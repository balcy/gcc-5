# DP: Changes for the Linaro 5-2015.11 release.

LANG=C git diff 3e5774f831e9eca881babb16108038af1d444690 4c4566ae0c0962f52ccb4270c9c111dd17c6ac1a \
 | egrep -v '^(diff|index) ' \
 | filterdiff --strip=1 --addoldprefix=a/src/  --addnewprefix=b/src/ \
 | sed 's,a/src//dev/null,/dev/null,'

--- a/src/fixincludes/mkfixinc.sh
+++ b/src/fixincludes/mkfixinc.sh
@@ -19,7 +19,8 @@ case $machine in
     powerpc-*-eabi*    | \
     powerpc-*-rtems*   | \
     powerpcle-*-eabisim* | \
-    powerpcle-*-eabi* )
+    powerpcle-*-eabi* | \
+    *-musl* )
 	#  IF there is no include fixing,
 	#  THEN create a no-op fixer and exit
 	(echo "#! /bin/sh" ; echo "exit 0" ) > ${target}
--- /dev/null
+++ b/src/gcc/LINARO-VERSION
@@ -0,0 +1 @@
+5.2-2015.11~dev
--- a/src/gcc/Makefile.in
+++ b/src/gcc/Makefile.in
@@ -527,10 +527,6 @@ xm_include_list=@xm_include_list@
 xm_defines=@xm_defines@
 lang_checks=
 lang_checks_parallelized=
-# Upper limit to which it is useful to parallelize this lang target.
-# It doesn't make sense to try e.g. 128 goals for small testsuites
-# like objc or go.
-check_gcc_parallelize=10000
 lang_opt_files=@lang_opt_files@ $(srcdir)/c-family/c.opt $(srcdir)/common.opt
 lang_specs_files=@lang_specs_files@
 lang_tree_files=@lang_tree_files@
@@ -814,10 +810,12 @@ BASEVER     := $(srcdir)/BASE-VER  # 4.x.y
 DEVPHASE    := $(srcdir)/DEV-PHASE # experimental, prerelease, ""
 DATESTAMP   := $(srcdir)/DATESTAMP # YYYYMMDD or empty
 REVISION    := $(srcdir)/REVISION  # [BRANCH revision XXXXXX]
+LINAROVER   := $(srcdir)/LINARO-VERSION # M.x-YYYY.MM[-S][~dev]
 
 BASEVER_c   := $(shell cat $(BASEVER))
 DEVPHASE_c  := $(shell cat $(DEVPHASE))
 DATESTAMP_c := $(shell cat $(DATESTAMP))
+LINAROVER_c := $(shell cat $(LINAROVER))
 
 ifeq (,$(wildcard $(REVISION)))
 REVISION_c  :=
@@ -844,6 +842,7 @@ DATESTAMP_s := \
   "\"$(if $(DEVPHASE_c)$(filter-out 0,$(PATCHLEVEL_c)), $(DATESTAMP_c))\""
 PKGVERSION_s:= "\"@PKGVERSION@\""
 BUGURL_s    := "\"@REPORT_BUGS_TO@\""
+LINAROVER_s := "\"$(LINAROVER_c)\""
 
 PKGVERSION  := @PKGVERSION@
 BUGURL_TEXI := @REPORT_BUGS_TEXI@
@@ -2623,8 +2622,9 @@ PREPROCESSOR_DEFINES = \
   -DSTANDARD_EXEC_PREFIX=\"$(libdir)/gcc/\" \
   @TARGET_SYSTEM_ROOT_DEFINE@
 
-CFLAGS-cppbuiltin.o += $(PREPROCESSOR_DEFINES) -DBASEVER=$(BASEVER_s)
-cppbuiltin.o: $(BASEVER)
+CFLAGS-cppbuiltin.o += $(PREPROCESSOR_DEFINES) -DBASEVER=$(BASEVER_s) \
+	-DLINAROVER=$(LINAROVER_s)
+cppbuiltin.o: $(BASEVER) $(LINAROVER)
 
 CFLAGS-cppdefault.o += $(PREPROCESSOR_DEFINES)
 
@@ -3736,7 +3736,9 @@ check_p_subdirs=$(wordlist 1,$(check_p_count),$(wordlist 1, \
 #
 # To parallelize some language check, add the corresponding check-$lang
 # to lang_checks_parallelized variable and define check_$lang_parallelize
-# variable (see above check_gcc_parallelize description).
+# variable.  This is the upper limit to which it is useful to parallelize the
+# check-$lang target.  It doesn't make sense to try e.g. 128 goals for small
+# testsuites like objc or go.
 $(lang_checks_parallelized): check-% : site.exp
 	-rm -rf $(TESTSUITEDIR)/$*-parallel
 	@if [ "$(filter -j, $(MFLAGS))" = "-j" ]; then \
--- a/src/gcc/ada/gcc-interface/Make-lang.in
+++ b/src/gcc/ada/gcc-interface/Make-lang.in
@@ -811,6 +811,7 @@ ada.mostlyclean:
 	-$(RM) ada/*$(coverageexts)
 	-$(RM) ada/sdefault.adb ada/stamp-sdefault ada/stamp-snames
 	-$(RMDIR) ada/tools
+	-$(RM) gnatbind$(exeext) gnat1$(exeext)
 ada.clean:
 ada.distclean:
 	-$(RM) ada/Makefile
--- a/src/gcc/builtins.c
+++ b/src/gcc/builtins.c
@@ -5477,7 +5477,8 @@ expand_builtin_atomic_compare_exchange (machine_mode mode, tree exp,
      the normal case where EXPECT is totally private, i.e. a register.  At
      which point the store can be unconditional.  */
   label = gen_label_rtx ();
-  emit_cmp_and_jump_insns (target, const0_rtx, NE, NULL, VOIDmode, 1, label);
+  emit_cmp_and_jump_insns (target, const0_rtx, NE, NULL,
+			   GET_MODE (target), 1, label);
   emit_move_insn (expect, oldval);
   emit_label (label);
 
--- a/src/gcc/c-family/c-common.h
+++ b/src/gcc/c-family/c-common.h
@@ -1084,6 +1084,8 @@ extern const unsigned char executable_checksum[16];
 /* In c-cppbuiltin.c  */
 extern void builtin_define_std (const char *macro);
 extern void builtin_define_with_value (const char *, const char *, int);
+extern void builtin_define_with_int_value (const char *, HOST_WIDE_INT);
+extern void builtin_define_type_sizeof (const char *, tree);
 extern void c_stddef_cpp_builtins (void);
 extern void fe_file_change (const struct line_map *);
 extern void c_parse_error (const char *, enum cpp_ttype, tree, unsigned char);
--- a/src/gcc/c-family/c-cppbuiltin.c
+++ b/src/gcc/c-family/c-cppbuiltin.c
@@ -58,8 +58,6 @@ along with GCC; see the file COPYING3.  If not see
 #endif
 
 /* Non-static as some targets don't use it.  */
-void builtin_define_std (const char *) ATTRIBUTE_UNUSED;
-static void builtin_define_with_int_value (const char *, HOST_WIDE_INT);
 static void builtin_define_with_hex_fp_value (const char *, tree,
 					      int, const char *,
 					      const char *,
@@ -68,7 +66,6 @@ static void builtin_define_stdint_macros (void);
 static void builtin_define_constants (const char *, tree);
 static void builtin_define_type_max (const char *, tree);
 static void builtin_define_type_minmax (const char *, const char *, tree);
-static void builtin_define_type_sizeof (const char *, tree);
 static void builtin_define_float_constants (const char *,
 					    const char *,
 					    const char *,
@@ -113,7 +110,7 @@ mode_has_fma (machine_mode mode)
 }
 
 /* Define NAME with value TYPE size_unit.  */
-static void
+void
 builtin_define_type_sizeof (const char *name, tree type)
 {
   builtin_define_with_int_value (name,
@@ -1372,7 +1369,7 @@ builtin_define_with_value (const char *macro, const char *expansion, int is_str)
 
 
 /* Pass an object-like macro and an integer value to define it to.  */
-static void
+void
 builtin_define_with_int_value (const char *macro, HOST_WIDE_INT value)
 {
   char *buf;
--- a/src/gcc/c/Make-lang.in
+++ b/src/gcc/c/Make-lang.in
@@ -95,6 +95,8 @@ c.srcman:
 # List of targets that can use the generic check- rule and its // variant.
 lang_checks += check-gcc
 lang_checks_parallelized += check-gcc
+# For description see the check_$lang_parallelize comment in gcc/Makefile.in.
+check_gcc_parallelize=10000
 
 # 'make check' in gcc/ looks for check-c.  Redirect it to check-gcc.
 check-c : check-gcc
--- a/src/gcc/c/c-decl.c
+++ b/src/gcc/c/c-decl.c
@@ -2632,6 +2632,12 @@ merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype)
   else if (DECL_PRESERVE_P (newdecl))
     DECL_PRESERVE_P (olddecl) = 1;
 
+  /* Merge DECL_COMMON */
+  if (VAR_P (olddecl) && VAR_P (newdecl)
+      && !lookup_attribute ("common", DECL_ATTRIBUTES (newdecl))
+      && !lookup_attribute ("nocommon", DECL_ATTRIBUTES (newdecl)))
+    DECL_COMMON (newdecl) = DECL_COMMON (newdecl) && DECL_COMMON (olddecl);
+
   /* Copy most of the decl-specific fields of NEWDECL into OLDDECL.
      But preserve OLDDECL's DECL_UID, DECL_CONTEXT and
      DECL_ARGUMENTS (if appropriate).  */
@@ -7524,12 +7530,23 @@ detect_field_duplicates (tree fieldlist)
 /* Finish up struct info used by -Wc++-compat.  */
 
 static void
-warn_cxx_compat_finish_struct (tree fieldlist)
+warn_cxx_compat_finish_struct (tree fieldlist, enum tree_code code,
+			       location_t record_loc)
 {
   unsigned int ix;
   tree x;
   struct c_binding *b;
 
+  if (fieldlist == NULL_TREE)
+    {
+      if (code == RECORD_TYPE)
+	warning_at (record_loc, OPT_Wc___compat,
+		    "empty struct has size 0 in C, size 1 in C++");
+      else
+	warning_at (record_loc, OPT_Wc___compat,
+		    "empty union has size 0 in C, size 1 in C++");
+    }
+
   /* Set the C_TYPE_DEFINED_IN_STRUCT flag for each type defined in
      the current struct.  We do this now at the end of the struct
      because the flag is used to issue visibility warnings, and we
@@ -7862,7 +7879,7 @@ finish_struct (location_t loc, tree t, tree fieldlist, tree attributes,
 			  DECL_EXPR, build_decl (loc, TYPE_DECL, NULL, t)));
 
   if (warn_cxx_compat)
-    warn_cxx_compat_finish_struct (fieldlist);
+    warn_cxx_compat_finish_struct (fieldlist, TREE_CODE (t), loc);
 
   struct_parse_info->struct_types.release ();
   struct_parse_info->fields.release ();
--- a/src/gcc/cfgexpand.c
+++ b/src/gcc/cfgexpand.c
@@ -1382,7 +1382,16 @@ expand_one_var (tree var, bool toplevel, bool really_expand)
   else
     {
       if (really_expand)
-        expand_one_stack_var (origvar);
+        {
+          if (lookup_attribute ("naked",
+                                DECL_ATTRIBUTES (current_function_decl)))
+            error ("cannot allocate stack for variable %q+D, naked function.",
+                   var);
+
+          expand_one_stack_var (origvar);
+        }
+
+
       return tree_to_uhwi (DECL_SIZE_UNIT (var));
     }
   return 0;
--- a/src/gcc/cfgloop.h
+++ b/src/gcc/cfgloop.h
@@ -116,6 +116,14 @@ enum loop_estimation
   EST_LAST
 };
 
+/* The structure describing non-overflow control induction variable for
+   loop's exit edge.  */
+struct GTY ((chain_next ("%h.next"))) control_iv {
+  tree base;
+  tree step;
+  struct control_iv *next;
+};
+
 /* Structure to hold information for each natural loop.  */
 struct GTY ((chain_next ("%h.next"))) loop {
   /* Index into loops array.  */
@@ -203,6 +211,9 @@ struct GTY ((chain_next ("%h.next"))) loop {
   /* Upper bound on number of iterations of a loop.  */
   struct nb_iter_bound *bounds;
 
+  /* Non-overflow control ivs of a loop.  */
+  struct control_iv *control_ivs;
+
   /* Head of the cyclic list of the exits of the loop.  */
   struct loop_exit *exits;
 
--- a/src/gcc/cgraphunit.c
+++ b/src/gcc/cgraphunit.c
@@ -2505,6 +2505,7 @@ cgraph_node::create_wrapper (cgraph_node *target)
   memset (&thunk, 0, sizeof (cgraph_thunk_info));
   thunk.thunk_p = true;
   create_edge (target, NULL, count, CGRAPH_FREQ_BASE);
+  callees->can_throw_external = !TREE_NOTHROW (target->decl);
 
   tree arguments = DECL_ARGUMENTS (decl);
 
--- a/src/gcc/combine.c
+++ b/src/gcc/combine.c
@@ -1650,6 +1650,73 @@ setup_incoming_promotions (rtx_insn *first)
     }
 }
 
+#ifdef SHORT_IMMEDIATES_SIGN_EXTEND
+/* If MODE has a precision lower than PREC and SRC is a non-negative constant
+   that would appear negative in MODE, sign-extend SRC for use in nonzero_bits
+   because some machines (maybe most) will actually do the sign-extension and
+   this is the conservative approach.
+
+   ??? For 2.5, try to tighten up the MD files in this regard instead of this
+   kludge.  */
+
+static rtx
+sign_extend_short_imm (rtx src, machine_mode mode, unsigned int prec)
+{
+  if (GET_MODE_PRECISION (mode) < prec
+      && CONST_INT_P (src)
+      && INTVAL (src) > 0
+      && val_signbit_known_set_p (mode, INTVAL (src)))
+    src = GEN_INT (INTVAL (src) | ~GET_MODE_MASK (mode));
+
+  return src;
+}
+#endif
+
+/* Update RSP for pseudo-register X from INSN's REG_EQUAL note (if one exists)
+   and SET.  */
+
+static void
+update_rsp_from_reg_equal (reg_stat_type *rsp, rtx_insn *insn, const_rtx set,
+			   rtx x)
+{
+  rtx reg_equal_note = insn ? find_reg_equal_equiv_note (insn) : NULL_RTX;
+  unsigned HOST_WIDE_INT bits = 0;
+  rtx reg_equal = NULL, src = SET_SRC (set);
+  unsigned int num = 0;
+
+  if (reg_equal_note)
+    reg_equal = XEXP (reg_equal_note, 0);
+
+#ifdef SHORT_IMMEDIATES_SIGN_EXTEND
+  src = sign_extend_short_imm (src, GET_MODE (x), BITS_PER_WORD);
+  if (reg_equal)
+    reg_equal = sign_extend_short_imm (reg_equal, GET_MODE (x), BITS_PER_WORD);
+#endif
+
+  /* Don't call nonzero_bits if it cannot change anything.  */
+  if (rsp->nonzero_bits != ~(unsigned HOST_WIDE_INT) 0)
+    {
+      bits = nonzero_bits (src, nonzero_bits_mode);
+      if (reg_equal && bits)
+	bits &= nonzero_bits (reg_equal, nonzero_bits_mode);
+      rsp->nonzero_bits |= bits;
+    }
+
+  /* Don't call num_sign_bit_copies if it cannot change anything.  */
+  if (rsp->sign_bit_copies != 1)
+    {
+      num = num_sign_bit_copies (SET_SRC (set), GET_MODE (x));
+      if (reg_equal && num != GET_MODE_PRECISION (GET_MODE (x)))
+	{
+	  unsigned int numeq = num_sign_bit_copies (reg_equal, GET_MODE (x));
+	  if (num == 0 || numeq > num)
+	    num = numeq;
+	}
+      if (rsp->sign_bit_copies == 0 || num < rsp->sign_bit_copies)
+	rsp->sign_bit_copies = num;
+    }
+}
+
 /* Called via note_stores.  If X is a pseudo that is narrower than
    HOST_BITS_PER_WIDE_INT and is being set, record what bits are known zero.
 
@@ -1665,7 +1732,6 @@ static void
 set_nonzero_bits_and_sign_copies (rtx x, const_rtx set, void *data)
 {
   rtx_insn *insn = (rtx_insn *) data;
-  unsigned int num;
 
   if (REG_P (x)
       && REGNO (x) >= FIRST_PSEUDO_REGISTER
@@ -1725,34 +1791,7 @@ set_nonzero_bits_and_sign_copies (rtx x, const_rtx set, void *data)
       if (SET_DEST (set) == x
 	  || (paradoxical_subreg_p (SET_DEST (set))
 	      && SUBREG_REG (SET_DEST (set)) == x))
-	{
-	  rtx src = SET_SRC (set);
-
-#ifdef SHORT_IMMEDIATES_SIGN_EXTEND
-	  /* If X is narrower than a word and SRC is a non-negative
-	     constant that would appear negative in the mode of X,
-	     sign-extend it for use in reg_stat[].nonzero_bits because some
-	     machines (maybe most) will actually do the sign-extension
-	     and this is the conservative approach.
-
-	     ??? For 2.5, try to tighten up the MD files in this regard
-	     instead of this kludge.  */
-
-	  if (GET_MODE_PRECISION (GET_MODE (x)) < BITS_PER_WORD
-	      && CONST_INT_P (src)
-	      && INTVAL (src) > 0
-	      && val_signbit_known_set_p (GET_MODE (x), INTVAL (src)))
-	    src = GEN_INT (INTVAL (src) | ~GET_MODE_MASK (GET_MODE (x)));
-#endif
-
-	  /* Don't call nonzero_bits if it cannot change anything.  */
-	  if (rsp->nonzero_bits != ~(unsigned HOST_WIDE_INT) 0)
-	    rsp->nonzero_bits |= nonzero_bits (src, nonzero_bits_mode);
-	  num = num_sign_bit_copies (SET_SRC (set), GET_MODE (x));
-	  if (rsp->sign_bit_copies == 0
-	      || rsp->sign_bit_copies > num)
-	    rsp->sign_bit_copies = num;
-	}
+	update_rsp_from_reg_equal (rsp, insn, set, x);
       else
 	{
 	  rsp->nonzero_bits = GET_MODE_MASK (GET_MODE (x));
@@ -1914,6 +1953,15 @@ can_combine_p (rtx_insn *insn, rtx_insn *i3, rtx_insn *pred ATTRIBUTE_UNUSED,
   set = expand_field_assignment (set);
   src = SET_SRC (set), dest = SET_DEST (set);
 
+  /* Do not eliminate user-specified register if it is in an
+     asm input because we may break the register asm usage defined
+     in GCC manual if allow to do so.
+     Be aware that this may cover more cases than we expect but this
+     should be harmless.  */
+  if (REG_P (dest) && REG_USERVAR_P (dest) && HARD_REGISTER_P (dest)
+      && extract_asm_operands (PATTERN (i3)))
+    return 0;
+
   /* Don't eliminate a store in the stack pointer.  */
   if (dest == stack_pointer_rtx
       /* Don't combine with an insn that sets a register to itself if it has
@@ -5463,6 +5511,51 @@ combine_simplify_rtx (rtx x, machine_mode op0_mode, int in_dest,
       SUBST (XEXP (x, 1), temp);
     }
 
+  /* Try to fold this expression in case we have constants that weren't
+     present before.  */
+  temp = 0;
+  switch (GET_RTX_CLASS (code))
+    {
+    case RTX_UNARY:
+      if (op0_mode == VOIDmode)
+	op0_mode = GET_MODE (XEXP (x, 0));
+      temp = simplify_unary_operation (code, mode, XEXP (x, 0), op0_mode);
+      break;
+    case RTX_COMPARE:
+    case RTX_COMM_COMPARE:
+      {
+	machine_mode cmp_mode = GET_MODE (XEXP (x, 0));
+	if (cmp_mode == VOIDmode)
+	  {
+	    cmp_mode = GET_MODE (XEXP (x, 1));
+	    if (cmp_mode == VOIDmode)
+	      cmp_mode = op0_mode;
+	  }
+	temp = simplify_relational_operation (code, mode, cmp_mode,
+					      XEXP (x, 0), XEXP (x, 1));
+      }
+      break;
+    case RTX_COMM_ARITH:
+    case RTX_BIN_ARITH:
+      temp = simplify_binary_operation (code, mode, XEXP (x, 0), XEXP (x, 1));
+      break;
+    case RTX_BITFIELD_OPS:
+    case RTX_TERNARY:
+      temp = simplify_ternary_operation (code, mode, op0_mode, XEXP (x, 0),
+					 XEXP (x, 1), XEXP (x, 2));
+      break;
+    default:
+      break;
+    }
+
+  if (temp)
+    {
+      x = temp;
+      code = GET_CODE (temp);
+      op0_mode = VOIDmode;
+      mode = GET_MODE (temp);
+    }
+
   /* If this is a simple operation applied to an IF_THEN_ELSE, try
      applying it to the arms of the IF_THEN_ELSE.  This often simplifies
      things.  Check for cases where both arms are testing the same
@@ -5562,51 +5655,6 @@ combine_simplify_rtx (rtx x, machine_mode op0_mode, int in_dest,
 	}
     }
 
-  /* Try to fold this expression in case we have constants that weren't
-     present before.  */
-  temp = 0;
-  switch (GET_RTX_CLASS (code))
-    {
-    case RTX_UNARY:
-      if (op0_mode == VOIDmode)
-	op0_mode = GET_MODE (XEXP (x, 0));
-      temp = simplify_unary_operation (code, mode, XEXP (x, 0), op0_mode);
-      break;
-    case RTX_COMPARE:
-    case RTX_COMM_COMPARE:
-      {
-	machine_mode cmp_mode = GET_MODE (XEXP (x, 0));
-	if (cmp_mode == VOIDmode)
-	  {
-	    cmp_mode = GET_MODE (XEXP (x, 1));
-	    if (cmp_mode == VOIDmode)
-	      cmp_mode = op0_mode;
-	  }
-	temp = simplify_relational_operation (code, mode, cmp_mode,
-					      XEXP (x, 0), XEXP (x, 1));
-      }
-      break;
-    case RTX_COMM_ARITH:
-    case RTX_BIN_ARITH:
-      temp = simplify_binary_operation (code, mode, XEXP (x, 0), XEXP (x, 1));
-      break;
-    case RTX_BITFIELD_OPS:
-    case RTX_TERNARY:
-      temp = simplify_ternary_operation (code, mode, op0_mode, XEXP (x, 0),
-					 XEXP (x, 1), XEXP (x, 2));
-      break;
-    default:
-      break;
-    }
-
-  if (temp)
-    {
-      x = temp;
-      code = GET_CODE (temp);
-      op0_mode = VOIDmode;
-      mode = GET_MODE (temp);
-    }
-
   /* First see if we can apply the inverse distributive law.  */
   if (code == PLUS || code == MINUS
       || code == AND || code == IOR || code == XOR)
@@ -7723,9 +7771,8 @@ extract_left_shift (rtx x, int count)
    We try, as much as possible, to re-use rtl expressions to save memory.
 
    IN_CODE says what kind of expression we are processing.  Normally, it is
-   SET.  In a memory address (inside a MEM, PLUS or minus, the latter two
-   being kludges), it is MEM.  When processing the arguments of a comparison
-   or a COMPARE against zero, it is COMPARE.  */
+   SET.  In a memory address it is MEM.  When processing the arguments of
+   a comparison or a COMPARE against zero, it is COMPARE.  */
 
 rtx
 make_compound_operation (rtx x, enum rtx_code in_code)
@@ -7745,8 +7792,6 @@ make_compound_operation (rtx x, enum rtx_code in_code)
      but once inside, go back to our default of SET.  */
 
   next_code = (code == MEM ? MEM
-	       : ((code == PLUS || code == MINUS)
-		  && SCALAR_INT_MODE_P (mode)) ? MEM
 	       : ((code == COMPARE || COMPARISON_P (x))
 		  && XEXP (x, 1) == const0_rtx) ? COMPARE
 	       : in_code == COMPARE ? SET : in_code);
@@ -9797,20 +9842,8 @@ reg_nonzero_bits_for_combine (const_rtx x, machine_mode mode,
   if (tem)
     {
 #ifdef SHORT_IMMEDIATES_SIGN_EXTEND
-      /* If X is narrower than MODE and TEM is a non-negative
-	 constant that would appear negative in the mode of X,
-	 sign-extend it for use in reg_nonzero_bits because some
-	 machines (maybe most) will actually do the sign-extension
-	 and this is the conservative approach.
-
-	 ??? For 2.5, try to tighten up the MD files in this regard
-	 instead of this kludge.  */
-
-      if (GET_MODE_PRECISION (GET_MODE (x)) < GET_MODE_PRECISION (mode)
-	  && CONST_INT_P (tem)
-	  && INTVAL (tem) > 0
-	  && val_signbit_known_set_p (GET_MODE (x), INTVAL (tem)))
-	tem = GEN_INT (INTVAL (tem) | ~GET_MODE_MASK (GET_MODE (x)));
+      tem = sign_extend_short_imm (tem, GET_MODE (x),
+				   GET_MODE_PRECISION (mode));
 #endif
       return tem;
     }
--- a/src/gcc/common/config/aarch64/aarch64-common.c
+++ b/src/gcc/common/config/aarch64/aarch64-common.c
@@ -27,7 +27,7 @@
 #include "common/common-target-def.h"
 #include "opts.h"
 #include "flags.h"
-#include "errors.h"
+#include "diagnostic.h"
 
 #ifdef  TARGET_BIG_ENDIAN_DEFAULT
 #undef  TARGET_DEFAULT_TARGET_FLAGS
@@ -60,7 +60,7 @@ static const struct default_options aarch_option_optimization_table[] =
    respective component of -mcpu.  This logic is implemented
    in config/aarch64/aarch64.c:aarch64_override_options.  */
 
-static bool
+bool
 aarch64_handle_option (struct gcc_options *opts,
 		       struct gcc_options *opts_set ATTRIBUTE_UNUSED,
 		       const struct cl_decoded_option *decoded,
@@ -68,6 +68,7 @@ aarch64_handle_option (struct gcc_options *opts,
 {
   size_t code = decoded->opt_index;
   const char *arg = decoded->arg;
+  int val = decoded->value;
 
   switch (code)
     {
@@ -83,6 +84,22 @@ aarch64_handle_option (struct gcc_options *opts,
       opts->x_aarch64_tune_string = arg;
       return true;
 
+    case OPT_mgeneral_regs_only:
+      opts->x_target_flags |= MASK_GENERAL_REGS_ONLY;
+      return true;
+
+    case OPT_mfix_cortex_a53_835769:
+      opts->x_aarch64_fix_a53_err835769 = val;
+      return true;
+
+    case OPT_mstrict_align:
+      opts->x_target_flags |= MASK_STRICT_ALIGN;
+      return true;
+
+    case OPT_momit_leaf_frame_pointer:
+      opts->x_flag_omit_frame_pointer = val;
+      return true;
+
     default:
       return true;
     }
@@ -90,36 +107,134 @@ aarch64_handle_option (struct gcc_options *opts,
 
 struct gcc_targetm_common targetm_common = TARGETM_COMMON_INITIALIZER;
 
-#define AARCH64_CPU_NAME_LENGTH 128
+/* An ISA extension in the co-processor and main instruction set space.  */
+struct aarch64_option_extension
+{
+  const char *const name;
+  const unsigned long flags_on;
+  const unsigned long flags_off;
+};
+
+/* ISA extensions in AArch64.  */
+static const struct aarch64_option_extension all_extensions[] =
+{
+#define AARCH64_OPT_EXTENSION(NAME, FLAGS_ON, FLAGS_OFF, FEATURE_STRING) \
+  {NAME, FLAGS_ON, FLAGS_OFF},
+#include "config/aarch64/aarch64-option-extensions.def"
+#undef AARCH64_OPT_EXTENSION
+  {NULL, 0, 0}
+};
+
+struct processor_name_to_arch
+{
+  const std::string processor_name;
+  const enum aarch64_arch arch;
+  const unsigned long flags;
+};
+
+struct arch_to_arch_name
+{
+  const enum aarch64_arch arch;
+  const std::string arch_name;
+};
+
+/* Map processor names to the architecture revision they implement and
+   the default set of architectural feature flags they support.  */
+static const struct processor_name_to_arch all_cores[] =
+{
+#define AARCH64_CORE(NAME, X, IDENT, ARCH_IDENT, FLAGS, COSTS, IMP, PART) \
+  {NAME, AARCH64_ARCH_##ARCH_IDENT, FLAGS},
+#include "config/aarch64/aarch64-cores.def"
+#undef AARCH64_CORE
+  {"generic", AARCH64_ARCH_8A, AARCH64_FL_FOR_ARCH8},
+  {"", aarch64_no_arch, 0}
+};
+
+/* Map architecture revisions to their string representation.  */
+static const struct arch_to_arch_name all_architectures[] =
+{
+#define AARCH64_ARCH(NAME, CORE, ARCH_IDENT, ARCH, FLAGS) \
+  {AARCH64_ARCH_##ARCH_IDENT, NAME},
+#include "config/aarch64/aarch64-arches.def"
+#undef AARCH64_ARCH
+  {aarch64_no_arch, ""}
+};
+
+/* Return a string representation of ISA_FLAGS.  */
+
+std::string
+aarch64_get_extension_string_for_isa_flags (unsigned long isa_flags)
+{
+  const struct aarch64_option_extension *opt = NULL;
+  std::string outstr = "";
+
+  for (opt = all_extensions; opt->name != NULL; opt++)
+    if ((isa_flags & opt->flags_on) == opt->flags_on)
+      {
+	outstr += "+";
+	outstr += opt->name;
+      }
+  return outstr;
+}
 
-/* Truncate NAME at the first '.' character seen up to the first '+'
-   or return NAME unmodified.  */
+/* Attempt to rewrite NAME, which has been passed on the command line
+   as a -mcpu option to an equivalent -march value.  If we can do so,
+   return the new string, otherwise return an error.  */
 
 const char *
 aarch64_rewrite_selected_cpu (const char *name)
 {
-  static char output_buf[AARCH64_CPU_NAME_LENGTH + 1] = {0};
-  const char *bL_sep;
-  const char *feats;
-  size_t pref_size;
-  size_t feat_size;
+  std::string original_string (name);
+  std::string extensions;
+  std::string processor;
+  size_t extension_pos = original_string.find_first_of ('+');
 
-  bL_sep = strchr (name, '.');
-  if (!bL_sep)
-    return name;
-
-  feats = strchr (name, '+');
-  feat_size = feats ? strnlen (feats, AARCH64_CPU_NAME_LENGTH) : 0;
-  pref_size = bL_sep - name;
+  /* Strip and save the extension string.  */
+  if (extension_pos != std::string::npos)
+    {
+      processor = original_string.substr (0, extension_pos);
+      extensions = original_string.substr (extension_pos,
+					std::string::npos);
+    }
+  else
+    {
+      /* No extensions.  */
+      processor = original_string;
+    }
 
-  if ((feat_size + pref_size) > AARCH64_CPU_NAME_LENGTH)
-    internal_error ("-mcpu string too large");
+  const struct processor_name_to_arch* p_to_a;
+  for (p_to_a = all_cores;
+       p_to_a->arch != aarch64_no_arch;
+       p_to_a++)
+    {
+      if (p_to_a->processor_name == processor)
+	break;
+    }
 
-  strncpy (output_buf, name, pref_size);
-  if (feats)
-    strncpy (output_buf + pref_size, feats, feat_size);
+  const struct arch_to_arch_name* a_to_an;
+  for (a_to_an = all_architectures;
+       a_to_an->arch != aarch64_no_arch;
+       a_to_an++)
+    {
+      if (a_to_an->arch == p_to_a->arch)
+	break;
+    }
 
-  return output_buf;
+  /* We couldn't find that proceesor name, or the processor name we
+     found does not map to an architecture we understand.  */
+  if (p_to_a->arch == aarch64_no_arch
+      || a_to_an->arch == aarch64_no_arch)
+    fatal_error (input_location, "unknown value %qs for -mcpu", name);
+
+  std::string outstr = a_to_an->arch_name
+	+ aarch64_get_extension_string_for_isa_flags (p_to_a->flags)
+	+ extensions;
+
+  /* We are going to memory leak here, nobody elsewhere
+     in the callchain is going to clean up after us.  The alternative is
+     to allocate a static buffer, and assert that it is big enough for our
+     modified string, which seems much worse!  */
+  return xstrdup (outstr.c_str ());
 }
 
 /* Called by the driver to rewrite a name passed to the -mcpu
--- a/src/gcc/config.gcc
+++ b/src/gcc/config.gcc
@@ -302,7 +302,9 @@ m32c*-*-*)
 aarch64*-*-*)
 	cpu_type=aarch64
 	extra_headers="arm_neon.h arm_acle.h"
-	extra_objs="aarch64-builtins.o aarch-common.o"
+	c_target_objs="aarch64-c.o"
+	cxx_target_objs="aarch64-c.o"
+	extra_objs="aarch64-builtins.o aarch-common.o cortex-a57-fma-steering.o"
 	target_gtfiles="\$(srcdir)/config/aarch64/aarch64-builtins.c"
 	target_has_targetm_common=yes
 	;;
@@ -575,7 +577,7 @@ case ${target} in
 esac
 
 # Common C libraries.
-tm_defines="$tm_defines LIBC_GLIBC=1 LIBC_UCLIBC=2 LIBC_BIONIC=3"
+tm_defines="$tm_defines LIBC_GLIBC=1 LIBC_UCLIBC=2 LIBC_BIONIC=3 LIBC_MUSL=4"
 
 # 32-bit x86 processors supported by --with-arch=.  Each processor
 # MUST be separated by exactly one space.
@@ -720,6 +722,9 @@ case ${target} in
     *-*-*uclibc*)
       tm_defines="$tm_defines DEFAULT_LIBC=LIBC_UCLIBC"
       ;;
+    *-*-*musl*)
+      tm_defines="$tm_defines DEFAULT_LIBC=LIBC_MUSL"
+      ;;
     *)
       tm_defines="$tm_defines DEFAULT_LIBC=LIBC_GLIBC"
       ;;
@@ -3484,7 +3489,7 @@ case "${target}" in
 
 			eval "val=\$with_$which"
 			base_val=`echo $val | sed -e 's/\+.*//'`
-			ext_val=`echo $val | sed -e 's/[a-z0-9\-]\+//'`
+			ext_val=`echo $val | sed -e 's/[a-z0-9.-]\+//'`
 
 			if [ $which = arch ]; then
 			  def=aarch64-arches.def
--- a/src/gcc/config.host
+++ b/src/gcc/config.host
@@ -99,6 +99,14 @@ case ${host} in
 esac
 
 case ${host} in
+  aarch64*-*-linux*)
+    case ${target} in
+      aarch64*-*-*)
+	host_extra_gcc_objs="driver-aarch64.o"
+	host_xmake_file="${host_xmake_file} aarch64/x-aarch64"
+	;;
+    esac
+    ;;
   arm*-*-freebsd* | arm*-*-linux*)
     case ${target} in
       arm*-*-*)
--- a/src/gcc/config/aarch64/aarch64-arches.def
+++ b/src/gcc/config/aarch64/aarch64-arches.def
@@ -19,11 +19,17 @@
 
 /* Before using #include to read this file, define a macro:
 
-      AARCH64_ARCH(NAME, CORE, ARCH, FLAGS)
+      AARCH64_ARCH(NAME, CORE, ARCH_IDENT, ARCH_REV, FLAGS)
 
    The NAME is the name of the architecture, represented as a string
    constant.  The CORE is the identifier for a core representative of
-   this architecture.  ARCH is the architecture revision.  FLAGS are
-   the flags implied by the architecture.  */
+   this architecture.  ARCH_IDENT is the architecture identifier.  It must be
+   unique and be syntactically valid to appear as part of an enum identifier.
+   ARCH_REV is an integer specifying the architecture major revision.
+   FLAGS are the flags implied by the architecture.
+   Due to the assumptions about the positions of these fields in config.gcc,
+   the NAME should be kept as the first argument and FLAGS as the last.  */
+
+AARCH64_ARCH("armv8-a",	      generic,	     8A,	8,  AARCH64_FL_FOR_ARCH8)
+AARCH64_ARCH("armv8.1-a",     generic,	     8_1A,	8,  AARCH64_FL_FOR_ARCH8_1)
 
-AARCH64_ARCH("armv8-a",	      generic,	     8,  AARCH64_FL_FOR_ARCH8)
--- a/src/gcc/config/aarch64/aarch64-builtins.c
+++ b/src/gcc/config/aarch64/aarch64-builtins.c
@@ -80,6 +80,7 @@
 
 #define v8qi_UP  V8QImode
 #define v4hi_UP  V4HImode
+#define v4hf_UP  V4HFmode
 #define v2si_UP  V2SImode
 #define v2sf_UP  V2SFmode
 #define v1df_UP  V1DFmode
@@ -87,12 +88,12 @@
 #define df_UP    DFmode
 #define v16qi_UP V16QImode
 #define v8hi_UP  V8HImode
+#define v8hf_UP  V8HFmode
 #define v4si_UP  V4SImode
 #define v4sf_UP  V4SFmode
 #define v2di_UP  V2DImode
 #define v2df_UP  V2DFmode
 #define ti_UP	 TImode
-#define ei_UP	 EImode
 #define oi_UP	 OImode
 #define ci_UP	 CImode
 #define xi_UP	 XImode
@@ -133,7 +134,9 @@ enum aarch64_type_qualifiers
   /* Polynomial types.  */
   qualifier_poly = 0x100,
   /* Lane indices - must be in range, and flipped for bigendian.  */
-  qualifier_lane_index = 0x200
+  qualifier_lane_index = 0x200,
+  /* Lane indices for single lane structure loads and stores.  */
+  qualifier_struct_load_store_lane_index = 0x400
 };
 
 typedef struct
@@ -235,7 +238,7 @@ aarch64_types_load1_qualifiers[SIMD_MAX_BUILTIN_ARGS]
 static enum aarch64_type_qualifiers
 aarch64_types_loadstruct_lane_qualifiers[SIMD_MAX_BUILTIN_ARGS]
   = { qualifier_none, qualifier_const_pointer_map_mode,
-      qualifier_none, qualifier_none };
+      qualifier_none, qualifier_struct_load_store_lane_index };
 #define TYPES_LOADSTRUCT_LANE (aarch64_types_loadstruct_lane_qualifiers)
 
 static enum aarch64_type_qualifiers
@@ -267,7 +270,7 @@ aarch64_types_store1_qualifiers[SIMD_MAX_BUILTIN_ARGS]
 static enum aarch64_type_qualifiers
 aarch64_types_storestruct_lane_qualifiers[SIMD_MAX_BUILTIN_ARGS]
   = { qualifier_void, qualifier_pointer_map_mode,
-      qualifier_none, qualifier_none };
+      qualifier_none, qualifier_struct_load_store_lane_index };
 #define TYPES_STORESTRUCT_LANE (aarch64_types_storestruct_lane_qualifiers)
 
 #define CF0(N, X) CODE_FOR_aarch64_##N##X
@@ -312,6 +315,12 @@ aarch64_types_storestruct_lane_qualifiers[SIMD_MAX_BUILTIN_ARGS]
 #define VAR12(T, N, MAP, A, B, C, D, E, F, G, H, I, J, K, L) \
   VAR11 (T, N, MAP, A, B, C, D, E, F, G, H, I, J, K) \
   VAR1 (T, N, MAP, L)
+#define VAR13(T, N, MAP, A, B, C, D, E, F, G, H, I, J, K, L, M) \
+  VAR12 (T, N, MAP, A, B, C, D, E, F, G, H, I, J, K, L) \
+  VAR1 (T, N, MAP, M)
+#define VAR14(T, X, MAP, A, B, C, D, E, F, G, H, I, J, K, L, M, N) \
+  VAR13 (T, X, MAP, A, B, C, D, E, F, G, H, I, J, K, L, M) \
+  VAR1 (T, X, MAP, N)
 
 #include "aarch64-builtin-iterators.h"
 
@@ -389,6 +398,7 @@ const char *aarch64_scalar_builtin_types[] = {
   "__builtin_aarch64_simd_qi",
   "__builtin_aarch64_simd_hi",
   "__builtin_aarch64_simd_si",
+  "__builtin_aarch64_simd_hf",
   "__builtin_aarch64_simd_sf",
   "__builtin_aarch64_simd_di",
   "__builtin_aarch64_simd_df",
@@ -453,8 +463,10 @@ static struct aarch64_simd_type_info aarch64_simd_types [] = {
 };
 #undef ENTRY
 
+/* This type is not SIMD-specific; it is the user-visible __fp16.  */
+static tree aarch64_fp16_type_node = NULL_TREE;
+
 static tree aarch64_simd_intOI_type_node = NULL_TREE;
-static tree aarch64_simd_intEI_type_node = NULL_TREE;
 static tree aarch64_simd_intCI_type_node = NULL_TREE;
 static tree aarch64_simd_intXI_type_node = NULL_TREE;
 
@@ -528,12 +540,12 @@ aarch64_simd_builtin_std_type (enum machine_mode mode,
       return QUAL_TYPE (TI);
     case OImode:
       return aarch64_simd_intOI_type_node;
-    case EImode:
-      return aarch64_simd_intEI_type_node;
     case CImode:
       return aarch64_simd_intCI_type_node;
     case XImode:
       return aarch64_simd_intXI_type_node;
+    case HFmode:
+      return aarch64_fp16_type_node;
     case SFmode:
       return float_type_node;
     case DFmode:
@@ -618,6 +630,8 @@ aarch64_init_simd_builtin_types (void)
   aarch64_simd_types[Poly64x2_t].eltype = aarch64_simd_types[Poly64_t].itype;
 
   /* Continue with standard types.  */
+  aarch64_simd_types[Float16x4_t].eltype = aarch64_fp16_type_node;
+  aarch64_simd_types[Float16x8_t].eltype = aarch64_fp16_type_node;
   aarch64_simd_types[Float32x2_t].eltype = float_type_node;
   aarch64_simd_types[Float32x4_t].eltype = float_type_node;
   aarch64_simd_types[Float64x1_t].eltype = double_type_node;
@@ -642,15 +656,11 @@ aarch64_init_simd_builtin_types (void)
 #define AARCH64_BUILD_SIGNED_TYPE(mode)  \
   make_signed_type (GET_MODE_PRECISION (mode));
   aarch64_simd_intOI_type_node = AARCH64_BUILD_SIGNED_TYPE (OImode);
-  aarch64_simd_intEI_type_node = AARCH64_BUILD_SIGNED_TYPE (EImode);
   aarch64_simd_intCI_type_node = AARCH64_BUILD_SIGNED_TYPE (CImode);
   aarch64_simd_intXI_type_node = AARCH64_BUILD_SIGNED_TYPE (XImode);
 #undef AARCH64_BUILD_SIGNED_TYPE
 
   tdecl = add_builtin_type
-	    ("__builtin_aarch64_simd_ei" , aarch64_simd_intEI_type_node);
-  TYPE_NAME (aarch64_simd_intEI_type_node) = tdecl;
-  tdecl = add_builtin_type
 	    ("__builtin_aarch64_simd_oi" , aarch64_simd_intOI_type_node);
   TYPE_NAME (aarch64_simd_intOI_type_node) = tdecl;
   tdecl = add_builtin_type
@@ -669,6 +679,8 @@ aarch64_init_simd_builtin_scalar_types (void)
 					     "__builtin_aarch64_simd_qi");
   (*lang_hooks.types.register_builtin_type) (intHI_type_node,
 					     "__builtin_aarch64_simd_hi");
+  (*lang_hooks.types.register_builtin_type) (aarch64_fp16_type_node,
+					     "__builtin_aarch64_simd_hf");
   (*lang_hooks.types.register_builtin_type) (intSI_type_node,
 					     "__builtin_aarch64_simd_si");
   (*lang_hooks.types.register_builtin_type) (float_type_node,
@@ -698,11 +710,18 @@ aarch64_init_simd_builtin_scalar_types (void)
 					     "__builtin_aarch64_simd_udi");
 }
 
-static void
+static bool aarch64_simd_builtins_initialized_p = false;
+
+void
 aarch64_init_simd_builtins (void)
 {
   unsigned int i, fcode = AARCH64_SIMD_PATTERN_START;
 
+  if (aarch64_simd_builtins_initialized_p)
+    return;
+
+  aarch64_simd_builtins_initialized_p = true;
+
   aarch64_init_simd_builtin_types ();
 
   /* Strong-typing hasn't been implemented for all AdvSIMD builtin intrinsics.
@@ -863,10 +882,16 @@ aarch64_init_builtins (void)
     = add_builtin_function ("__builtin_aarch64_set_fpsr", ftype_set_fpr,
 			    AARCH64_BUILTIN_SET_FPSR, BUILT_IN_MD, NULL, NULL_TREE);
 
+  aarch64_fp16_type_node = make_node (REAL_TYPE);
+  TYPE_PRECISION (aarch64_fp16_type_node) = 16;
+  layout_type (aarch64_fp16_type_node);
+
+  (*lang_hooks.types.register_builtin_type) (aarch64_fp16_type_node, "__fp16");
+
   if (TARGET_SIMD)
     aarch64_init_simd_builtins ();
-  if (TARGET_CRC32)
-    aarch64_init_crc32_builtins ();
+
+  aarch64_init_crc32_builtins ();
 }
 
 tree
@@ -883,12 +908,15 @@ typedef enum
   SIMD_ARG_COPY_TO_REG,
   SIMD_ARG_CONSTANT,
   SIMD_ARG_LANE_INDEX,
+  SIMD_ARG_STRUCT_LOAD_STORE_LANE_INDEX,
   SIMD_ARG_STOP
 } builtin_simd_arg;
 
+
 static rtx
 aarch64_simd_expand_args (rtx target, int icode, int have_retval,
-			  tree exp, builtin_simd_arg *args)
+			  tree exp, builtin_simd_arg *args,
+			  enum machine_mode builtin_mode)
 {
   rtx pat;
   rtx op[SIMD_MAX_BUILTIN_ARGS + 1]; /* First element for result operand.  */
@@ -927,6 +955,19 @@ aarch64_simd_expand_args (rtx target, int icode, int have_retval,
 		op[opc] = copy_to_mode_reg (mode, op[opc]);
 	      break;
 
+	    case SIMD_ARG_STRUCT_LOAD_STORE_LANE_INDEX:
+	      gcc_assert (opc > 1);
+	      if (CONST_INT_P (op[opc]))
+		{
+		  aarch64_simd_lane_bounds (op[opc], 0,
+					    GET_MODE_NUNITS (builtin_mode),
+					    exp);
+		  /* Keep to GCC-vector-extension lane indices in the RTL.  */
+		  op[opc] =
+		    GEN_INT (ENDIAN_LANE_N (builtin_mode, INTVAL (op[opc])));
+		}
+	      goto constant_arg;
+
 	    case SIMD_ARG_LANE_INDEX:
 	      /* Must be a previous operand into which this is an index.  */
 	      gcc_assert (opc > 0);
@@ -941,6 +982,7 @@ aarch64_simd_expand_args (rtx target, int icode, int have_retval,
 	      /* Fall through - if the lane index isn't a constant then
 		 the next case will error.  */
 	    case SIMD_ARG_CONSTANT:
+constant_arg:
 	      if (!(*insn_data[icode].operand[opc].predicate)
 		  (op[opc], mode))
 	      {
@@ -1049,6 +1091,8 @@ aarch64_simd_expand_builtin (int fcode, tree exp, rtx target)
 
       if (d->qualifiers[qualifiers_k] & qualifier_lane_index)
 	args[k] = SIMD_ARG_LANE_INDEX;
+      else if (d->qualifiers[qualifiers_k] & qualifier_struct_load_store_lane_index)
+	args[k] = SIMD_ARG_STRUCT_LOAD_STORE_LANE_INDEX;
       else if (d->qualifiers[qualifiers_k] & qualifier_immediate)
 	args[k] = SIMD_ARG_CONSTANT;
       else if (d->qualifiers[qualifiers_k] & qualifier_maybe_immediate)
@@ -1072,7 +1116,7 @@ aarch64_simd_expand_builtin (int fcode, tree exp, rtx target)
   /* The interface to aarch64_simd_expand_args expects a 0 if
      the function is void, and a 1 if it is not.  */
   return aarch64_simd_expand_args
-	  (target, icode, !is_void, exp, &args[1]);
+	  (target, icode, !is_void, exp, &args[1], d->mode);
 }
 
 rtx
@@ -1146,7 +1190,7 @@ aarch64_expand_builtin (tree exp,
 	  icode = (fcode == AARCH64_BUILTIN_SET_FPSR) ?
 	    CODE_FOR_set_fpsr : CODE_FOR_set_fpcr;
 	  arg0 = CALL_EXPR_ARG (exp, 0);
-	  op0 = expand_normal (arg0);
+	  op0 = force_reg (SImode, expand_normal (arg0));
 	  pat = GEN_FCN (icode) (op0);
 	}
       emit_insn (pat);
--- /dev/null
+++ b/src/gcc/config/aarch64/aarch64-c.c
@@ -0,0 +1,203 @@
+/* Target-specific code for C family languages.
+   Copyright (C) 2015 Free Software Foundation, Inc.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GCC is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+#include "input.h"
+#include "tm_p.h"
+#include "flags.h"
+#include "c-family/c-common.h"
+#include "cpplib.h"
+#include "c-family/c-pragma.h"
+#include "langhooks.h"
+#include "target.h"
+
+
+#define builtin_define(TXT) cpp_define (pfile, TXT)
+#define builtin_assert(TXT) cpp_assert (pfile, TXT)
+
+
+static void
+aarch64_def_or_undef (bool def_p, const char *macro, cpp_reader *pfile)
+{
+  if (def_p)
+    cpp_define (pfile, macro);
+  else
+    cpp_undef (pfile, macro);
+}
+
+/* Define the macros that we always expect to have on AArch64.  */
+
+static void
+aarch64_define_unconditional_macros (cpp_reader *pfile)
+{
+  builtin_define ("__aarch64__");
+  builtin_define ("__ARM_64BIT_STATE");
+
+  builtin_define ("__ARM_ARCH_ISA_A64");
+  builtin_define_with_int_value ("__ARM_ALIGN_MAX_PWR", 28);
+  builtin_define_with_int_value ("__ARM_ALIGN_MAX_STACK_PWR", 16);
+
+  /* __ARM_ARCH_8A is not mandated by ACLE but we define it unconditionally
+     as interoperability with the same arm macro.  */
+  builtin_define ("__ARM_ARCH_8A");
+
+  builtin_define_with_int_value ("__ARM_ARCH_PROFILE", 'A');
+  builtin_define ("__ARM_FEATURE_CLZ");
+  builtin_define ("__ARM_FEATURE_IDIV");
+  builtin_define ("__ARM_FEATURE_UNALIGNED");
+  builtin_define ("__ARM_PCS_AAPCS64");
+  builtin_define_with_int_value ("__ARM_SIZEOF_WCHAR_T", WCHAR_TYPE_SIZE / 8);
+}
+
+/* Undefine/redefine macros that depend on the current backend state and may
+   need to change when a target pragma modifies the backend state.  */
+
+static void
+aarch64_update_cpp_builtins (cpp_reader *pfile)
+{
+  aarch64_def_or_undef (flag_unsafe_math_optimizations, "__ARM_FP_FAST", pfile);
+
+  builtin_define_with_int_value ("__ARM_ARCH", aarch64_architecture_version);
+
+  builtin_define_with_int_value ("__ARM_SIZEOF_MINIMAL_ENUM",
+				 flag_short_enums ? 1 : 4);
+  aarch64_def_or_undef (TARGET_BIG_END, "__AARCH64EB__", pfile);
+  aarch64_def_or_undef (TARGET_BIG_END, "__ARM_BIG_ENDIAN", pfile);
+  aarch64_def_or_undef (!TARGET_BIG_END, "__AARCH64EL__", pfile);
+
+  aarch64_def_or_undef (TARGET_FLOAT, "__ARM_FEATURE_FMA", pfile);
+
+  if (TARGET_FLOAT || TARGET_SIMD)
+    {
+      builtin_define_with_int_value ("__ARM_FP", 0x0E);
+      builtin_define ("__ARM_FP16_FORMAT_IEEE");
+      builtin_define ("__ARM_FP16_ARGS");
+    }
+  else
+    cpp_undef (pfile, "__ARM_FP");
+
+  aarch64_def_or_undef (TARGET_SIMD, "__ARM_FEATURE_NUMERIC_MAXMIN", pfile);
+  aarch64_def_or_undef (TARGET_SIMD, "__ARM_NEON", pfile);
+
+
+  aarch64_def_or_undef (TARGET_CRC32, "__ARM_FEATURE_CRC32", pfile);
+
+  cpp_undef (pfile, "__AARCH64_CMODEL_TINY__");
+  cpp_undef (pfile, "__AARCH64_CMODEL_SMALL__");
+  cpp_undef (pfile, "__AARCH64_CMODEL_LARGE__");
+
+  switch (aarch64_cmodel)
+    {
+      case AARCH64_CMODEL_TINY:
+      case AARCH64_CMODEL_TINY_PIC:
+	builtin_define ("__AARCH64_CMODEL_TINY__");
+	break;
+      case AARCH64_CMODEL_SMALL:
+      case AARCH64_CMODEL_SMALL_PIC:
+	builtin_define ("__AARCH64_CMODEL_SMALL__");
+	break;
+      case AARCH64_CMODEL_LARGE:
+	builtin_define ("__AARCH64_CMODEL_LARGE__");
+	break;
+      default:
+	break;
+    }
+
+  aarch64_def_or_undef (TARGET_ILP32, "_ILP32", pfile);
+  aarch64_def_or_undef (TARGET_ILP32, "__ILP32__", pfile);
+
+  aarch64_def_or_undef (TARGET_CRYPTO, "__ARM_FEATURE_CRYPTO", pfile);
+}
+
+/* Implement TARGET_CPU_CPP_BUILTINS.  */
+
+void
+aarch64_cpu_cpp_builtins (cpp_reader *pfile)
+{
+  aarch64_define_unconditional_macros (pfile);
+  aarch64_update_cpp_builtins (pfile);
+}
+
+/* Hook to validate the current #pragma GCC target and set the state, and
+   update the macros based on what was changed.  If ARGS is NULL, then
+   POP_TARGET is used to reset the options.  */
+
+static bool
+aarch64_pragma_target_parse (tree args, tree pop_target)
+{
+  /* If args is not NULL then process it and setup the target-specific
+     information that it specifies.  */
+  if (args)
+    {
+      if (!aarch64_process_target_attr (args, "pragma"))
+	return false;
+
+      aarch64_override_options_internal (&global_options);
+    }
+
+  /* args is NULL, restore to the state described in pop_target.  */
+  else
+    {
+      pop_target = pop_target ? pop_target : target_option_default_node;
+      cl_target_option_restore (&global_options,
+				TREE_TARGET_OPTION (pop_target));
+    }
+
+  target_option_current_node
+    = build_target_option_node (&global_options);
+
+  aarch64_reset_previous_fndecl ();
+  /* For the definitions, ensure all newly defined macros are considered
+     as used for -Wunused-macros.  There is no point warning about the
+     compiler predefined macros.  */
+  cpp_options *cpp_opts = cpp_get_options (parse_in);
+  unsigned char saved_warn_unused_macros = cpp_opts->warn_unused_macros;
+  cpp_opts->warn_unused_macros = 0;
+
+  aarch64_update_cpp_builtins (parse_in);
+
+  cpp_opts->warn_unused_macros = saved_warn_unused_macros;
+
+  /* Initialize SIMD builtins if we haven't already.
+     Set current_target_pragma to NULL for the duration so that
+     the builtin initialization code doesn't try to tag the functions
+     being built with the attributes specified by any current pragma, thus
+     going into an infinite recursion.  */
+  if (TARGET_SIMD)
+    {
+      tree saved_current_target_pragma = current_target_pragma;
+      current_target_pragma = NULL;
+      aarch64_init_simd_builtins ();
+      current_target_pragma = saved_current_target_pragma;
+    }
+
+  return true;
+}
+
+/* Implement REGISTER_TARGET_PRAGMAS.  */
+
+void
+aarch64_register_pragmas (void)
+{
+  /* Update pragma hook to allow parsing #pragma GCC target.  */
+  targetm.target_option.pragma_parse = aarch64_pragma_target_parse;
+}
--- a/src/gcc/config/aarch64/aarch64-cores.def
+++ b/src/gcc/config/aarch64/aarch64-cores.def
@@ -21,27 +21,34 @@
 
    Before using #include to read this file, define a macro:
 
-      AARCH64_CORE(CORE_NAME, CORE_IDENT, SCHEDULER_IDENT, ARCH, FLAGS, COSTS)
+      AARCH64_CORE(CORE_NAME, CORE_IDENT, SCHEDULER_IDENT, ARCH_IDENT, FLAGS, COSTS, IMP, PART)
 
    The CORE_NAME is the name of the core, represented as a string constant.
    The CORE_IDENT is the name of the core, represented as an identifier.
    The SCHEDULER_IDENT is the name of the core for which scheduling decisions
    will be made, represented as an identifier.
-   ARCH is the architecture revision implemented by the chip.
+   ARCH_IDENT is the architecture implemented by the chip as specified in
+   aarch64-arches.def.
    FLAGS are the bitwise-or of the traits that apply to that core.
    This need not include flags implied by the architecture.
-   COSTS is the name of the rtx_costs routine to use.  */
+   COSTS is the name of the rtx_costs routine to use.
+   IMP is the implementer ID of the CPU vendor.  On a GNU/Linux system it can
+   be found in /proc/cpuinfo.
+   PART is the part number of the CPU.  On a GNU/Linux system it can be found
+   in /proc/cpuinfo.  For big.LITTLE systems this should have the form at of
+   "<big core part number>.<LITTLE core part number>".  */
 
 /* V8 Architecture Processors.  */
 
-AARCH64_CORE("cortex-a53",  cortexa53, cortexa53, 8,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa53)
-AARCH64_CORE("cortex-a57",  cortexa57, cortexa57, 8,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa57)
-AARCH64_CORE("cortex-a72",  cortexa72, cortexa57, 8,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa57)
-AARCH64_CORE("exynos-m1",   exynosm1,  cortexa57, 8,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC | AARCH64_FL_CRYPTO, cortexa57)
-AARCH64_CORE("thunderx",    thunderx,  thunderx, 8,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC | AARCH64_FL_CRYPTO, thunderx)
-AARCH64_CORE("xgene1",      xgene1,    xgene1,    8,  AARCH64_FL_FOR_ARCH8, xgene1)
+AARCH64_CORE("cortex-a53",  cortexa53, cortexa53, 8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa53, "0x41", "0xd03")
+AARCH64_CORE("cortex-a57",  cortexa57, cortexa57, 8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa57, "0x41", "0xd07")
+AARCH64_CORE("cortex-a72",  cortexa72, cortexa57, 8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa72, "0x41", "0xd08")
+AARCH64_CORE("exynos-m1",   exynosm1,  cortexa57, 8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC | AARCH64_FL_CRYPTO, cortexa72, "0x53", "0x001")
+AARCH64_CORE("thunderx",    thunderx,  thunderx,  8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC | AARCH64_FL_CRYPTO, thunderx,  "0x43", "0x0a1")
+AARCH64_CORE("xgene1",      xgene1,    xgene1,    8A,  AARCH64_FL_FOR_ARCH8, xgene1, "0x50", "0x000")
 
 /* V8 big.LITTLE implementations.  */
 
-AARCH64_CORE("cortex-a57.cortex-a53",  cortexa57cortexa53, cortexa53, 8,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa57)
-AARCH64_CORE("cortex-a72.cortex-a53",  cortexa72cortexa53, cortexa53, 8,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa57)
+AARCH64_CORE("cortex-a57.cortex-a53",  cortexa57cortexa53, cortexa53, 8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa57, "0x41", "0xd07.0xd03")
+AARCH64_CORE("cortex-a72.cortex-a53",  cortexa72cortexa53, cortexa53, 8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa72, "0x41", "0xd08.0xd03")
+
--- a/src/gcc/config/aarch64/aarch64-cost-tables.h
+++ b/src/gcc/config/aarch64/aarch64-cost-tables.h
@@ -83,7 +83,9 @@ const struct cpu_cost_table thunderx_extra_costs =
     0,			/* N/A: Stm_regs_per_insn_subsequent.  */
     0,			/* Storef.  */
     0,			/* Stored.  */
-    COSTS_N_INSNS (1)  /* Store_unaligned.  */
+    COSTS_N_INSNS (1),	/* Store_unaligned.  */
+    COSTS_N_INSNS (1),	/* Loadv.  */
+    COSTS_N_INSNS (1)	/* Storev.  */
   },
   {
     /* FP SFmode */
--- a/src/gcc/config/aarch64/aarch64-elf-raw.h
+++ b/src/gcc/config/aarch64/aarch64-elf-raw.h
@@ -27,7 +27,7 @@
   " crtend%O%s crtn%O%s " \
   "%{Ofast|ffast-math|funsafe-math-optimizations:crtfastmath.o%s}"
 
-#ifdef TARGET_FIX_ERR_A53_835769_DEFAULT
+#if TARGET_FIX_ERR_A53_835769_DEFAULT
 #define CA53_ERR_835769_SPEC \
   " %{!mno-fix-cortex-a53-835769:--fix-cortex-a53-835769}"
 #else
--- a/src/gcc/config/aarch64/aarch64-elf.h
+++ b/src/gcc/config/aarch64/aarch64-elf.h
@@ -132,7 +132,8 @@
 #undef DRIVER_SELF_SPECS
 #define DRIVER_SELF_SPECS \
   " %{!mbig-endian:%{!mlittle-endian:" ENDIAN_SPEC "}}" \
-  " %{!mabi=*:" ABI_SPEC "}"
+  " %{!mabi=*:" ABI_SPEC "}" \
+  MCPU_MTUNE_NATIVE_SPECS
 
 #ifdef HAVE_AS_MABI_OPTION
 #define ASM_MABI_SPEC	"%{mabi=*:-mabi=%*}"
@@ -152,9 +153,6 @@ ASM_MABI_SPEC
 #undef TYPE_OPERAND_FMT
 #define TYPE_OPERAND_FMT	"%%%s"
 
-#undef TARGET_ASM_NAMED_SECTION
-#define TARGET_ASM_NAMED_SECTION  aarch64_elf_asm_named_section
-
 /* Stabs debug not required.  */
 #undef DBX_DEBUGGING_INFO
 
--- /dev/null
+++ b/src/gcc/config/aarch64/aarch64-fusion-pairs.def
@@ -0,0 +1,36 @@
+/* Copyright (C) 2015 Free Software Foundation, Inc.
+   Contributed by ARM Ltd.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3, or (at your
+   option) any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Pairs of instructions which can be fused. before including this file,
+   define a macro:
+
+     AARCH64_FUSION_PAIR (name, internal_name)
+
+   Where:
+
+     NAME is a string giving a friendly name for the instructions to fuse.
+     INTERNAL_NAME gives the internal name suitable for appending to
+     AARCH64_FUSE_ to give an enum name. */
+
+AARCH64_FUSION_PAIR ("mov+movk", MOV_MOVK)
+AARCH64_FUSION_PAIR ("adrp+add", ADRP_ADD)
+AARCH64_FUSION_PAIR ("movk+movk", MOVK_MOVK)
+AARCH64_FUSION_PAIR ("adrp+ldr", ADRP_LDR)
+AARCH64_FUSION_PAIR ("cmp+branch", CMP_BRANCH)
+
--- a/src/gcc/config/aarch64/aarch64-ldpstp.md
+++ b/src/gcc/config/aarch64/aarch64-ldpstp.md
@@ -98,6 +98,47 @@
     }
 })
 
+(define_peephole2
+  [(set (match_operand:VD 0 "register_operand" "")
+	(match_operand:VD 1 "aarch64_mem_pair_operand" ""))
+   (set (match_operand:VD 2 "register_operand" "")
+	(match_operand:VD 3 "memory_operand" ""))]
+  "aarch64_operands_ok_for_ldpstp (operands, true, <MODE>mode)"
+  [(parallel [(set (match_dup 0) (match_dup 1))
+	      (set (match_dup 2) (match_dup 3))])]
+{
+  rtx base, offset_1, offset_2;
+
+  extract_base_offset_in_addr (operands[1], &base, &offset_1);
+  extract_base_offset_in_addr (operands[3], &base, &offset_2);
+  if (INTVAL (offset_1) > INTVAL (offset_2))
+    {
+      std::swap (operands[0], operands[2]);
+      std::swap (operands[1], operands[3]);
+    }
+})
+
+(define_peephole2
+  [(set (match_operand:VD 0 "aarch64_mem_pair_operand" "")
+	(match_operand:VD 1 "register_operand" ""))
+   (set (match_operand:VD 2 "memory_operand" "")
+	(match_operand:VD 3 "register_operand" ""))]
+  "TARGET_SIMD && aarch64_operands_ok_for_ldpstp (operands, false, <MODE>mode)"
+  [(parallel [(set (match_dup 0) (match_dup 1))
+	      (set (match_dup 2) (match_dup 3))])]
+{
+  rtx base, offset_1, offset_2;
+
+  extract_base_offset_in_addr (operands[0], &base, &offset_1);
+  extract_base_offset_in_addr (operands[2], &base, &offset_2);
+  if (INTVAL (offset_1) > INTVAL (offset_2))
+    {
+      std::swap (operands[0], operands[2]);
+      std::swap (operands[1], operands[3]);
+    }
+})
+
+
 ;; Handle sign/zero extended consecutive load/store.
 
 (define_peephole2
--- a/src/gcc/config/aarch64/aarch64-linux.h
+++ b/src/gcc/config/aarch64/aarch64-linux.h
@@ -23,6 +23,9 @@
 
 #define GLIBC_DYNAMIC_LINKER "/lib/ld-linux-aarch64%{mbig-endian:_be}%{mabi=ilp32:_ilp32}.so.1"
 
+#undef MUSL_DYNAMIC_LINKER
+#define MUSL_DYNAMIC_LINKER "/lib/ld-musl-aarch64%{mbig-endian:_be}%{mabi=ilp32:_ilp32}.so.1"
+
 #undef  ASAN_CC1_SPEC
 #define ASAN_CC1_SPEC "%{%:sanitize(address):-funwind-tables}"
 
@@ -42,7 +45,7 @@
    %{mbig-endian:-EB} %{mlittle-endian:-EL}     \
    -maarch64linux%{mabi=ilp32:32}%{mbig-endian:b}"
 
-#ifdef TARGET_FIX_ERR_A53_835769_DEFAULT
+#if TARGET_FIX_ERR_A53_835769_DEFAULT
 #define CA53_ERR_835769_SPEC \
   " %{!mno-fix-cortex-a53-835769:--fix-cortex-a53-835769}"
 #else
--- a/src/gcc/config/aarch64/aarch64-modes.def
+++ b/src/gcc/config/aarch64/aarch64-modes.def
@@ -36,6 +36,10 @@ CC_MODE (CC_DLTU);
 CC_MODE (CC_DGEU);
 CC_MODE (CC_DGTU);
 
+/* Half-precision floating point for __fp16.  */
+FLOAT_MODE (HF, 2, 0);
+ADJUST_FLOAT_FORMAT (HF, &ieee_half_format);
+
 /* Vector modes.  */
 VECTOR_MODES (INT, 8);        /*       V8QI V4HI V2SI.  */
 VECTOR_MODES (INT, 16);       /* V16QI V8HI V4SI V2DI.  */
@@ -46,9 +50,8 @@ VECTOR_MODE (FLOAT, DF, 1);   /*                 V1DF.  */
 /* Oct Int: 256-bit integer mode needed for 32-byte vector arguments.  */
 INT_MODE (OI, 32);
 
-/* Opaque integer modes for 3, 6 or 8 Neon double registers (2 is
-   TImode).  */
-INT_MODE (EI, 24);
+/* Opaque integer modes for 3 or 4 Neon q-registers / 6 or 8 Neon d-registers
+   (2 d-regs = 1 q-reg = TImode).  */
 INT_MODE (CI, 48);
 INT_MODE (XI, 64);
 
--- a/src/gcc/config/aarch64/aarch64-option-extensions.def
+++ b/src/gcc/config/aarch64/aarch64-option-extensions.def
@@ -21,18 +21,24 @@
 
    Before using #include to read this file, define a macro:
 
-      AARCH64_OPT_EXTENSION(EXT_NAME, FLAGS_ON, FLAGS_OFF)
+      AARCH64_OPT_EXTENSION(EXT_NAME, FLAGS_ON, FLAGS_OFF, FEATURE_STRING)
 
    EXT_NAME is the name of the extension, represented as a string constant.
    FLAGS_ON are the bitwise-or of the features that the extension adds.
-   FLAGS_OFF are the bitwise-or of the features that the extension removes.  */
-
-/* V8 Architecture Extensions.
-   This list currently contains example extensions for CPUs that implement
-   AArch64, and therefore serves as a template for adding more CPUs in the
-   future.  */
-
-AARCH64_OPT_EXTENSION("fp",	AARCH64_FL_FP,	AARCH64_FL_FPSIMD | AARCH64_FL_CRYPTO)
-AARCH64_OPT_EXTENSION("simd",	AARCH64_FL_FPSIMD,	AARCH64_FL_SIMD | AARCH64_FL_CRYPTO)
-AARCH64_OPT_EXTENSION("crypto",	AARCH64_FL_CRYPTO | AARCH64_FL_FPSIMD,	AARCH64_FL_CRYPTO)
-AARCH64_OPT_EXTENSION("crc",	AARCH64_FL_CRC,	AARCH64_FL_CRC)
+   FLAGS_OFF are the bitwise-or of the features that the extension removes.
+   FEAT_STRING is a string containing the entries in the 'Features' field of
+   /proc/cpuinfo on a GNU/Linux system that correspond to this architecture
+   extension being available.  Sometimes multiple entries are needed to enable
+   the extension (for example, the 'crypto' extension depends on four
+   entries: aes, pmull, sha1, sha2 being present).  In that case this field
+   should contain a whitespace-separated list of the strings in 'Features'
+   that are required.  Their order is not important.  */
+
+AARCH64_OPT_EXTENSION("fp",	AARCH64_FL_FP,                          AARCH64_FL_FPSIMD | AARCH64_FL_CRYPTO | AARCH64_FL_RDMA, "fp")
+AARCH64_OPT_EXTENSION("simd",	AARCH64_FL_FPSIMD,                      AARCH64_FL_SIMD | AARCH64_FL_CRYPTO | AARCH64_FL_RDMA,   "asimd")
+AARCH64_OPT_EXTENSION("crypto",	AARCH64_FL_CRYPTO | AARCH64_FL_FPSIMD,  AARCH64_FL_CRYPTO,   "aes pmull sha1 sha2")
+AARCH64_OPT_EXTENSION("crc",	AARCH64_FL_CRC,                         AARCH64_FL_CRC,                        "crc32")
+AARCH64_OPT_EXTENSION("lse",	AARCH64_FL_LSE,                         AARCH64_FL_LSE,                        "lse")
+AARCH64_OPT_EXTENSION("pan",	AARCH64_FL_PAN,		AARCH64_FL_PAN,		"pan")
+AARCH64_OPT_EXTENSION("lor",	AARCH64_FL_LOR,		AARCH64_FL_LOR,		"lor")
+AARCH64_OPT_EXTENSION("rdma",	AARCH64_FL_RDMA | AARCH64_FL_FPSIMD,	AARCH64_FL_RDMA,	"rdma")
--- a/src/gcc/config/aarch64/aarch64-opts.h
+++ b/src/gcc/config/aarch64/aarch64-opts.h
@@ -25,7 +25,7 @@
 /* The various cores that implement AArch64.  */
 enum aarch64_processor
 {
-#define AARCH64_CORE(NAME, INTERNAL_IDENT, SCHED, ARCH, FLAGS, COSTS) \
+#define AARCH64_CORE(NAME, INTERNAL_IDENT, SCHED, ARCH, FLAGS, COSTS, IMP, PART) \
   INTERNAL_IDENT,
 #include "aarch64-cores.def"
 #undef AARCH64_CORE
@@ -35,6 +35,15 @@ enum aarch64_processor
   aarch64_none
 };
 
+enum aarch64_arch
+{
+#define AARCH64_ARCH(NAME, CORE, ARCH_IDENT, ARCH_REV, FLAGS) \
+  AARCH64_ARCH_##ARCH_IDENT,
+#include "aarch64-arches.def"
+#undef AARCH64_ARCH
+  aarch64_no_arch
+};
+
 /* TLS types.  */
 enum aarch64_tls_type {
   TLS_TRADITIONAL,
--- a/src/gcc/config/aarch64/aarch64-protos.h
+++ b/src/gcc/config/aarch64/aarch64-protos.h
@@ -22,6 +22,8 @@
 #ifndef GCC_AARCH64_PROTOS_H
 #define GCC_AARCH64_PROTOS_H
 
+#include "input.h"
+
 /*
   SYMBOL_CONTEXT_ADR
   The symbol is used in a load-address operation.
@@ -64,7 +66,7 @@ enum aarch64_symbol_context
    SYMBOL_SMALL_TLSGD
    SYMBOL_SMALL_TLSDESC
    SYMBOL_SMALL_GOTTPREL
-   SYMBOL_SMALL_TPREL
+   SYMBOL_TLSLE
    Each of of these represents a thread-local symbol, and corresponds to the
    thread local storage relocation operator for the symbol being referred to.
 
@@ -98,9 +100,9 @@ enum aarch64_symbol_type
   SYMBOL_SMALL_TLSGD,
   SYMBOL_SMALL_TLSDESC,
   SYMBOL_SMALL_GOTTPREL,
-  SYMBOL_SMALL_TPREL,
   SYMBOL_TINY_ABSOLUTE,
   SYMBOL_TINY_GOT,
+  SYMBOL_TLSLE,
   SYMBOL_FORCE_TO_MEM
 };
 
@@ -162,26 +164,83 @@ struct cpu_vector_cost
   const int cond_not_taken_branch_cost;  /* Cost of not taken branch.  */
 };
 
+/* Branch costs.  */
+struct cpu_branch_cost
+{
+  const int predictable;    /* Predictable branch or optimizing for size.  */
+  const int unpredictable;  /* Unpredictable branch or optimizing for speed.  */
+};
+
 struct tune_params
 {
-  const struct cpu_cost_table *const insn_extra_cost;
-  const struct cpu_addrcost_table *const addr_cost;
-  const struct cpu_regmove_cost *const regmove_cost;
-  const struct cpu_vector_cost *const vec_costs;
-  const int memmov_cost;
-  const int issue_rate;
-  const unsigned int fuseable_ops;
-  const int function_align;
-  const int jump_align;
-  const int loop_align;
-  const int int_reassoc_width;
-  const int fp_reassoc_width;
-  const int vec_reassoc_width;
+  const struct cpu_cost_table *insn_extra_cost;
+  const struct cpu_addrcost_table *addr_cost;
+  const struct cpu_regmove_cost *regmove_cost;
+  const struct cpu_vector_cost *vec_costs;
+  const struct cpu_branch_cost *branch_costs;
+  int memmov_cost;
+  int issue_rate;
+  unsigned int fusible_ops;
+  int function_align;
+  int jump_align;
+  int loop_align;
+  int int_reassoc_width;
+  int fp_reassoc_width;
+  int vec_reassoc_width;
+  int min_div_recip_mul_sf;
+  int min_div_recip_mul_df;
+  unsigned int extra_tuning_flags;
+};
+
+#define AARCH64_FUSION_PAIR(x, name) \
+  AARCH64_FUSE_##name##_index, 
+/* Supported fusion operations.  */
+enum aarch64_fusion_pairs_index
+{
+#include "aarch64-fusion-pairs.def"
+  AARCH64_FUSE_index_END
+};
+#undef AARCH64_FUSION_PAIR
+
+#define AARCH64_FUSION_PAIR(x, name) \
+  AARCH64_FUSE_##name = (1u << AARCH64_FUSE_##name##_index),
+/* Supported fusion operations.  */
+enum aarch64_fusion_pairs
+{
+  AARCH64_FUSE_NOTHING = 0,
+#include "aarch64-fusion-pairs.def"
+  AARCH64_FUSE_ALL = (1u << AARCH64_FUSE_index_END) - 1
+};
+#undef AARCH64_FUSION_PAIR
+
+#define AARCH64_EXTRA_TUNING_OPTION(x, name) \
+  AARCH64_EXTRA_TUNE_##name##_index,
+/* Supported tuning flags indexes.  */
+enum aarch64_extra_tuning_flags_index
+{
+#include "aarch64-tuning-flags.def"
+  AARCH64_EXTRA_TUNE_index_END
+};
+#undef AARCH64_EXTRA_TUNING_OPTION
+
+
+#define AARCH64_EXTRA_TUNING_OPTION(x, name) \
+  AARCH64_EXTRA_TUNE_##name = (1u << AARCH64_EXTRA_TUNE_##name##_index),
+/* Supported tuning flags.  */
+enum aarch64_extra_tuning_flags
+{
+  AARCH64_EXTRA_TUNE_NONE = 0,
+#include "aarch64-tuning-flags.def"
+  AARCH64_EXTRA_TUNE_ALL = (1u << AARCH64_EXTRA_TUNE_index_END) - 1
 };
+#undef AARCH64_EXTRA_TUNING_OPTION
+
+extern struct tune_params aarch64_tune_params;
 
 HOST_WIDE_INT aarch64_initial_elimination_offset (unsigned, unsigned);
 int aarch64_get_condition_code (rtx);
 bool aarch64_bitmask_imm (HOST_WIDE_INT val, machine_mode);
+int aarch64_branch_cost (bool, bool);
 enum aarch64_symbol_type
 aarch64_classify_symbolic_expression (rtx, enum aarch64_symbol_context);
 bool aarch64_const_vec_all_same_int_p (rtx, HOST_WIDE_INT);
@@ -191,9 +250,12 @@ bool aarch64_float_const_zero_rtx_p (rtx);
 bool aarch64_function_arg_regno_p (unsigned);
 bool aarch64_gen_movmemqi (rtx *);
 bool aarch64_gimple_fold_builtin (gimple_stmt_iterator *);
+bool aarch64_handle_option (struct gcc_options *, struct gcc_options *,
+			     const struct cl_decoded_option *, location_t);
 bool aarch64_is_extend_from_extract (machine_mode, rtx, rtx);
 bool aarch64_is_long_call_p (rtx);
 bool aarch64_label_mentioned_p (rtx);
+void aarch64_declare_function_name (FILE *, const char*, tree);
 bool aarch64_legitimate_pic_operand_p (rtx);
 bool aarch64_modes_tieable_p (machine_mode mode1,
 			      machine_mode mode2);
@@ -243,11 +305,14 @@ rtx aarch64_simd_gen_const_vector_dup (machine_mode, int);
 bool aarch64_simd_mem_operand_p (rtx);
 rtx aarch64_simd_vect_par_cnst_half (machine_mode, bool);
 rtx aarch64_tls_get_addr (void);
+std::string aarch64_get_extension_string_for_isa_flags (unsigned long);
 tree aarch64_fold_builtin (tree, int, tree *, bool);
 unsigned aarch64_dbx_register_number (unsigned);
 unsigned aarch64_trampoline_size (void);
 void aarch64_asm_output_labelref (FILE *, const char *);
+void aarch64_cpu_cpp_builtins (cpp_reader *);
 void aarch64_elf_asm_named_section (const char *, unsigned, tree);
+void aarch64_err_no_fpadvsimd (machine_mode, const char *);
 void aarch64_expand_epilogue (bool);
 void aarch64_expand_mov_immediate (rtx, rtx);
 void aarch64_expand_prologue (void);
@@ -255,21 +320,19 @@ void aarch64_expand_vector_init (rtx, rtx);
 void aarch64_init_cumulative_args (CUMULATIVE_ARGS *, const_tree, rtx,
 				   const_tree, unsigned);
 void aarch64_init_expanders (void);
+void aarch64_init_simd_builtins (void);
 void aarch64_print_operand (FILE *, rtx, char);
 void aarch64_print_operand_address (FILE *, rtx);
 void aarch64_emit_call_insn (rtx);
+void aarch64_register_pragmas (void);
+void aarch64_relayout_simd_types (void);
+void aarch64_reset_previous_fndecl (void);
 
 /* Initialize builtins for SIMD intrinsics.  */
 void init_aarch64_simd_builtins (void);
 
 void aarch64_simd_emit_reg_reg_move (rtx *, enum machine_mode, unsigned int);
 
-/* Emit code to place a AdvSIMD pair result in memory locations (with equal
-   registers).  */
-void aarch64_simd_emit_pair_result_insn (machine_mode,
-					 rtx (*intfn) (rtx, rtx, rtx), rtx,
-					 rtx);
-
 /* Expand builtins for SIMD intrinsics.  */
 rtx aarch64_simd_expand_builtin (int, tree, rtx);
 
@@ -295,12 +358,20 @@ rtx aarch64_load_tp (rtx);
 
 void aarch64_expand_compare_and_swap (rtx op[]);
 void aarch64_split_compare_and_swap (rtx op[]);
+void aarch64_gen_atomic_cas (rtx, rtx, rtx, rtx, rtx);
+
+bool aarch64_atomic_ldop_supported_p (enum rtx_code);
+void aarch64_gen_atomic_ldop (enum rtx_code, rtx, rtx, rtx, rtx, rtx);
 void aarch64_split_atomic_op (enum rtx_code, rtx, rtx, rtx, rtx, rtx, rtx);
 
 bool aarch64_gen_adjusted_ldpstp (rtx *, bool, enum machine_mode, RTX_CODE);
 #endif /* RTX_CODE */
 
 void aarch64_init_builtins (void);
+
+bool aarch64_process_target_attr (tree, const char*);
+void aarch64_override_options_internal (struct gcc_options *);
+
 rtx aarch64_expand_builtin (tree exp,
 			    rtx target,
 			    rtx subtarget ATTRIBUTE_UNUSED,
--- a/src/gcc/config/aarch64/aarch64-simd-builtin-types.def
+++ b/src/gcc/config/aarch64/aarch64-simd-builtin-types.def
@@ -44,6 +44,8 @@
   ENTRY (Poly16x8_t, V8HI, poly, 12)
   ENTRY (Poly64x1_t, DI, poly, 12)
   ENTRY (Poly64x2_t, V2DI, poly, 12)
+  ENTRY (Float16x4_t, V4HF, none, 13)
+  ENTRY (Float16x8_t, V8HF, none, 13)
   ENTRY (Float32x2_t, V2SF, none, 13)
   ENTRY (Float32x4_t, V4SF, none, 13)
   ENTRY (Float64x1_t, V1DF, none, 13)
--- a/src/gcc/config/aarch64/aarch64-simd-builtins.def
+++ b/src/gcc/config/aarch64/aarch64-simd-builtins.def
@@ -88,9 +88,9 @@
   BUILTIN_VALLDIF (LOADSTRUCT, ld3r, 0)
   BUILTIN_VALLDIF (LOADSTRUCT, ld4r, 0)
   /* Implemented by aarch64_ld<VSTRUCT:nregs>_lane<VQ:mode>.  */
-  BUILTIN_VQ (LOADSTRUCT_LANE, ld2_lane, 0)
-  BUILTIN_VQ (LOADSTRUCT_LANE, ld3_lane, 0)
-  BUILTIN_VQ (LOADSTRUCT_LANE, ld4_lane, 0)
+  BUILTIN_VALLDIF (LOADSTRUCT_LANE, ld2_lane, 0)
+  BUILTIN_VALLDIF (LOADSTRUCT_LANE, ld3_lane, 0)
+  BUILTIN_VALLDIF (LOADSTRUCT_LANE, ld4_lane, 0)
   /* Implemented by aarch64_st<VSTRUCT:nregs><VDC:mode>.  */
   BUILTIN_VDC (STORESTRUCT, st2, 0)
   BUILTIN_VDC (STORESTRUCT, st3, 0)
@@ -100,9 +100,9 @@
   BUILTIN_VQ (STORESTRUCT, st3, 0)
   BUILTIN_VQ (STORESTRUCT, st4, 0)
 
-  BUILTIN_VQ (STORESTRUCT_LANE, st2_lane, 0)
-  BUILTIN_VQ (STORESTRUCT_LANE, st3_lane, 0)
-  BUILTIN_VQ (STORESTRUCT_LANE, st4_lane, 0)
+  BUILTIN_VALLDIF (STORESTRUCT_LANE, st2_lane, 0)
+  BUILTIN_VALLDIF (STORESTRUCT_LANE, st3_lane, 0)
+  BUILTIN_VALLDIF (STORESTRUCT_LANE, st4_lane, 0)
 
   BUILTIN_VQW (BINOP, saddl2, 0)
   BUILTIN_VQW (BINOP, uaddl2, 0)
@@ -361,17 +361,19 @@
   BUILTIN_VSDQ_I_DI (UNOP, abs, 0)
   BUILTIN_VDQF (UNOP, abs, 2)
 
-  VAR1 (UNOP, vec_unpacks_hi_, 10, v4sf)
+  BUILTIN_VQ_HSF (UNOP, vec_unpacks_hi_, 10)
   VAR1 (BINOP, float_truncate_hi_, 0, v4sf)
+  VAR1 (BINOP, float_truncate_hi_, 0, v8hf)
 
   VAR1 (UNOP, float_extend_lo_, 0, v2df)
-  VAR1 (UNOP, float_truncate_lo_, 0, v2sf)
+  VAR1 (UNOP, float_extend_lo_,  0, v4sf)
+  BUILTIN_VDF (UNOP, float_truncate_lo_, 0)
 
-  /* Implemented by aarch64_ld1<VALL:mode>.  */
-  BUILTIN_VALL (LOAD1, ld1, 0)
+  /* Implemented by aarch64_ld1<VALL_F16:mode>.  */
+  BUILTIN_VALL_F16 (LOAD1, ld1, 0)
 
-  /* Implemented by aarch64_st1<VALL:mode>.  */
-  BUILTIN_VALL (STORE1, st1, 0)
+  /* Implemented by aarch64_st1<VALL_F16:mode>.  */
+  BUILTIN_VALL_F16 (STORE1, st1, 0)
 
   /* Implemented by fma<mode>4.  */
   BUILTIN_VDQF (TERNOP, fma, 4)
@@ -405,3 +407,8 @@
   VAR1 (BINOPP, crypto_pmull, 0, di)
   VAR1 (BINOPP, crypto_pmull, 0, v2di)
 
+  /* Implemented by aarch64_tbl3v8qi.  */
+  VAR1 (BINOP, tbl3, 0, v8qi)
+
+  /* Implemented by aarch64_tbx4v8qi.  */
+  VAR1 (TERNOP, tbx4, 0, v8qi)
--- a/src/gcc/config/aarch64/aarch64-simd.md
+++ b/src/gcc/config/aarch64/aarch64-simd.md
@@ -19,8 +19,8 @@
 ;; <http://www.gnu.org/licenses/>.
 
 (define_expand "mov<mode>"
-  [(set (match_operand:VALL 0 "nonimmediate_operand" "")
-	(match_operand:VALL 1 "general_operand" ""))]
+  [(set (match_operand:VALL_F16 0 "nonimmediate_operand" "")
+	(match_operand:VALL_F16 1 "general_operand" ""))]
   "TARGET_SIMD"
   "
     if (GET_CODE (operands[0]) == MEM)
@@ -53,18 +53,19 @@
 )
 
 (define_insn "aarch64_simd_dup<mode>"
-  [(set (match_operand:VDQF 0 "register_operand" "=w")
-        (vec_duplicate:VDQF (match_operand:<VEL> 1 "register_operand" "w")))]
+  [(set (match_operand:VDQF_F16 0 "register_operand" "=w")
+	(vec_duplicate:VDQF_F16
+	  (match_operand:<VEL> 1 "register_operand" "w")))]
   "TARGET_SIMD"
   "dup\\t%0.<Vtype>, %1.<Vetype>[0]"
   [(set_attr "type" "neon_dup<q>")]
 )
 
 (define_insn "aarch64_dup_lane<mode>"
-  [(set (match_operand:VALL 0 "register_operand" "=w")
-	(vec_duplicate:VALL
+  [(set (match_operand:VALL_F16 0 "register_operand" "=w")
+	(vec_duplicate:VALL_F16
 	  (vec_select:<VEL>
-	    (match_operand:VALL 1 "register_operand" "w")
+	    (match_operand:VALL_F16 1 "register_operand" "w")
 	    (parallel [(match_operand:SI 2 "immediate_operand" "i")])
           )))]
   "TARGET_SIMD"
@@ -76,8 +77,8 @@
 )
 
 (define_insn "aarch64_dup_lane_<vswap_width_name><mode>"
-  [(set (match_operand:VALL 0 "register_operand" "=w")
-	(vec_duplicate:VALL
+  [(set (match_operand:VALL_F16 0 "register_operand" "=w")
+	(vec_duplicate:VALL_F16
 	  (vec_select:<VEL>
 	    (match_operand:<VSWAP_WIDTH> 1 "register_operand" "w")
 	    (parallel [(match_operand:SI 2 "immediate_operand" "i")])
@@ -152,6 +153,34 @@
    (set_attr "length" "4,4,4,8,8,8,4")]
 )
 
+(define_insn "load_pair<mode>"
+  [(set (match_operand:VD 0 "register_operand" "=w")
+	(match_operand:VD 1 "aarch64_mem_pair_operand" "Ump"))
+   (set (match_operand:VD 2 "register_operand" "=w")
+	(match_operand:VD 3 "memory_operand" "m"))]
+  "TARGET_SIMD
+   && rtx_equal_p (XEXP (operands[3], 0),
+		   plus_constant (Pmode,
+				  XEXP (operands[1], 0),
+				  GET_MODE_SIZE (<MODE>mode)))"
+  "ldp\\t%d0, %d2, %1"
+  [(set_attr "type" "neon_ldp")]
+)
+
+(define_insn "store_pair<mode>"
+  [(set (match_operand:VD 0 "aarch64_mem_pair_operand" "=Ump")
+	(match_operand:VD 1 "register_operand" "w"))
+   (set (match_operand:VD 2 "memory_operand" "=m")
+	(match_operand:VD 3 "register_operand" "w"))]
+  "TARGET_SIMD
+   && rtx_equal_p (XEXP (operands[2], 0),
+		   plus_constant (Pmode,
+				  XEXP (operands[0], 0),
+				  GET_MODE_SIZE (<MODE>mode)))"
+  "stp\\t%d1, %d3, %0"
+  [(set_attr "type" "neon_stp")]
+)
+
 (define_split
   [(set (match_operand:VQ 0 "register_operand" "")
       (match_operand:VQ 1 "register_operand" ""))]
@@ -834,11 +863,11 @@
 )
 
 (define_insn "aarch64_simd_vec_set<mode>"
-  [(set (match_operand:VDQF 0 "register_operand" "=w")
-        (vec_merge:VDQF
-	    (vec_duplicate:VDQF
+  [(set (match_operand:VDQF_F16 0 "register_operand" "=w")
+	(vec_merge:VDQF_F16
+	    (vec_duplicate:VDQF_F16
 		(match_operand:<VEL> 1 "register_operand" "w"))
-	    (match_operand:VDQF 3 "register_operand" "0")
+	    (match_operand:VDQF_F16 3 "register_operand" "0")
 	    (match_operand:SI 2 "immediate_operand" "i")))]
   "TARGET_SIMD"
   {
@@ -851,7 +880,7 @@
 )
 
 (define_expand "vec_set<mode>"
-  [(match_operand:VDQF 0 "register_operand" "+w")
+  [(match_operand:VDQF_F16 0 "register_operand" "+w")
    (match_operand:<VEL> 1 "register_operand" "w")
    (match_operand:SI 2 "immediate_operand" "")]
   "TARGET_SIMD"
@@ -1691,61 +1720,116 @@
 
 ;; Float widening operations.
 
-(define_insn "vec_unpacks_lo_v4sf"
-  [(set (match_operand:V2DF 0 "register_operand" "=w")
-	(float_extend:V2DF
-	  (vec_select:V2SF
-	    (match_operand:V4SF 1 "register_operand" "w")
-	    (parallel [(const_int 0) (const_int 1)])
-	  )))]
+(define_insn "aarch64_simd_vec_unpacks_lo_<mode>"
+  [(set (match_operand:<VWIDE> 0 "register_operand" "=w")
+        (float_extend:<VWIDE> (vec_select:<VHALF>
+			       (match_operand:VQ_HSF 1 "register_operand" "w")
+			       (match_operand:VQ_HSF 2 "vect_par_cnst_lo_half" "")
+			    )))]
   "TARGET_SIMD"
-  "fcvtl\\t%0.2d, %1.2s"
+  "fcvtl\\t%0.<Vwtype>, %1.<Vhalftype>"
   [(set_attr "type" "neon_fp_cvt_widen_s")]
 )
 
-(define_insn "aarch64_float_extend_lo_v2df"
-  [(set (match_operand:V2DF 0 "register_operand" "=w")
-	(float_extend:V2DF
-	  (match_operand:V2SF 1 "register_operand" "w")))]
+;; ??? Note that the vectorizer usage of the vec_unpacks_[lo/hi] patterns
+;; is inconsistent with vector ordering elsewhere in the compiler, in that
+;; the meaning of HI and LO changes depending on the target endianness.
+;; While elsewhere we map the higher numbered elements of a vector to
+;; the lower architectural lanes of the vector, for these patterns we want
+;; to always treat "hi" as referring to the higher architectural lanes.
+;; Consequently, while the patterns below look inconsistent with our
+;; other big-endian patterns their behaviour is as required.
+
+(define_expand "vec_unpacks_lo_<mode>"
+  [(match_operand:<VWIDE> 0 "register_operand" "")
+   (match_operand:VQ_HSF 1 "register_operand" "")]
   "TARGET_SIMD"
-  "fcvtl\\t%0.2d, %1.2s"
+  {
+    rtx p = aarch64_simd_vect_par_cnst_half (<MODE>mode, false);
+    emit_insn (gen_aarch64_simd_vec_unpacks_lo_<mode> (operands[0],
+						       operands[1], p));
+    DONE;
+  }
+)
+
+(define_insn "aarch64_simd_vec_unpacks_hi_<mode>"
+  [(set (match_operand:<VWIDE> 0 "register_operand" "=w")
+        (float_extend:<VWIDE> (vec_select:<VHALF>
+			       (match_operand:VQ_HSF 1 "register_operand" "w")
+			       (match_operand:VQ_HSF 2 "vect_par_cnst_hi_half" "")
+			    )))]
+  "TARGET_SIMD"
+  "fcvtl2\\t%0.<Vwtype>, %1.<Vtype>"
   [(set_attr "type" "neon_fp_cvt_widen_s")]
 )
 
-(define_insn "vec_unpacks_hi_v4sf"
-  [(set (match_operand:V2DF 0 "register_operand" "=w")
-	(float_extend:V2DF
-	  (vec_select:V2SF
-	    (match_operand:V4SF 1 "register_operand" "w")
-	    (parallel [(const_int 2) (const_int 3)])
-	  )))]
+(define_expand "vec_unpacks_hi_<mode>"
+  [(match_operand:<VWIDE> 0 "register_operand" "")
+   (match_operand:VQ_HSF 1 "register_operand" "")]
   "TARGET_SIMD"
-  "fcvtl2\\t%0.2d, %1.4s"
+  {
+    rtx p = aarch64_simd_vect_par_cnst_half (<MODE>mode, true);
+    emit_insn (gen_aarch64_simd_vec_unpacks_lo_<mode> (operands[0],
+						       operands[1], p));
+    DONE;
+  }
+)
+(define_insn "aarch64_float_extend_lo_<Vwide>"
+  [(set (match_operand:<VWIDE> 0 "register_operand" "=w")
+	(float_extend:<VWIDE>
+	  (match_operand:VDF 1 "register_operand" "w")))]
+  "TARGET_SIMD"
+  "fcvtl\\t%0<Vmwtype>, %1<Vmtype>"
   [(set_attr "type" "neon_fp_cvt_widen_s")]
 )
 
 ;; Float narrowing operations.
 
-(define_insn "aarch64_float_truncate_lo_v2sf"
-  [(set (match_operand:V2SF 0 "register_operand" "=w")
-      (float_truncate:V2SF
-	(match_operand:V2DF 1 "register_operand" "w")))]
+(define_insn "aarch64_float_truncate_lo_<mode>"
+  [(set (match_operand:VDF 0 "register_operand" "=w")
+      (float_truncate:VDF
+	(match_operand:<VWIDE> 1 "register_operand" "w")))]
   "TARGET_SIMD"
-  "fcvtn\\t%0.2s, %1.2d"
+  "fcvtn\\t%0.<Vtype>, %1<Vmwtype>"
   [(set_attr "type" "neon_fp_cvt_narrow_d_q")]
 )
 
-(define_insn "aarch64_float_truncate_hi_v4sf"
-  [(set (match_operand:V4SF 0 "register_operand" "=w")
-    (vec_concat:V4SF
-      (match_operand:V2SF 1 "register_operand" "0")
-      (float_truncate:V2SF
-	(match_operand:V2DF 2 "register_operand" "w"))))]
-  "TARGET_SIMD"
-  "fcvtn2\\t%0.4s, %2.2d"
+(define_insn "aarch64_float_truncate_hi_<Vdbl>_le"
+  [(set (match_operand:<VDBL> 0 "register_operand" "=w")
+    (vec_concat:<VDBL>
+      (match_operand:VDF 1 "register_operand" "0")
+      (float_truncate:VDF
+	(match_operand:<VWIDE> 2 "register_operand" "w"))))]
+  "TARGET_SIMD && !BYTES_BIG_ENDIAN"
+  "fcvtn2\\t%0.<Vdtype>, %2<Vmwtype>"
+  [(set_attr "type" "neon_fp_cvt_narrow_d_q")]
+)
+
+(define_insn "aarch64_float_truncate_hi_<Vdbl>_be"
+  [(set (match_operand:<VDBL> 0 "register_operand" "=w")
+    (vec_concat:<VDBL>
+      (float_truncate:VDF
+	(match_operand:<VWIDE> 2 "register_operand" "w"))
+      (match_operand:VDF 1 "register_operand" "0")))]
+  "TARGET_SIMD && BYTES_BIG_ENDIAN"
+  "fcvtn2\\t%0.<Vdtype>, %2<Vmwtype>"
   [(set_attr "type" "neon_fp_cvt_narrow_d_q")]
 )
 
+(define_expand "aarch64_float_truncate_hi_<Vdbl>"
+  [(match_operand:<VDBL> 0 "register_operand" "=w")
+   (match_operand:VDF 1 "register_operand" "0")
+   (match_operand:<VWIDE> 2 "register_operand" "w")]
+  "TARGET_SIMD"
+{
+  rtx (*gen) (rtx, rtx, rtx) = BYTES_BIG_ENDIAN
+			     ? gen_aarch64_float_truncate_hi_<Vdbl>_be
+			     : gen_aarch64_float_truncate_hi_<Vdbl>_le;
+  emit_insn (gen (operands[0], operands[1], operands[2]));
+  DONE;
+}
+)
+
 (define_expand "vec_pack_trunc_v2df"
   [(set (match_operand:V4SF 0 "register_operand")
       (vec_concat:V4SF
@@ -2057,13 +2141,13 @@
 })
 
 (define_expand "aarch64_vcond_internal<mode><mode>"
-  [(set (match_operand:VDQ_I 0 "register_operand")
-	(if_then_else:VDQ_I
+  [(set (match_operand:VSDQ_I_DI 0 "register_operand")
+	(if_then_else:VSDQ_I_DI
 	  (match_operator 3 "comparison_operator"
-	    [(match_operand:VDQ_I 4 "register_operand")
-	     (match_operand:VDQ_I 5 "nonmemory_operand")])
-	  (match_operand:VDQ_I 1 "nonmemory_operand")
-	  (match_operand:VDQ_I 2 "nonmemory_operand")))]
+	    [(match_operand:VSDQ_I_DI 4 "register_operand")
+	     (match_operand:VSDQ_I_DI 5 "nonmemory_operand")])
+	  (match_operand:VSDQ_I_DI 1 "nonmemory_operand")
+	  (match_operand:VSDQ_I_DI 2 "nonmemory_operand")))]
   "TARGET_SIMD"
 {
   rtx op1 = operands[1];
@@ -2365,13 +2449,13 @@
 })
 
 (define_expand "vcond<mode><mode>"
-  [(set (match_operand:VALL 0 "register_operand")
-	(if_then_else:VALL
+  [(set (match_operand:VALLDI 0 "register_operand")
+	(if_then_else:VALLDI
 	  (match_operator 3 "comparison_operator"
-	    [(match_operand:VALL 4 "register_operand")
-	     (match_operand:VALL 5 "nonmemory_operand")])
-	  (match_operand:VALL 1 "nonmemory_operand")
-	  (match_operand:VALL 2 "nonmemory_operand")))]
+	    [(match_operand:VALLDI 4 "register_operand")
+	     (match_operand:VALLDI 5 "nonmemory_operand")])
+	  (match_operand:VALLDI 1 "nonmemory_operand")
+	  (match_operand:VALLDI 2 "nonmemory_operand")))]
   "TARGET_SIMD"
 {
   emit_insn (gen_aarch64_vcond_internal<mode><mode> (operands[0], operands[1],
@@ -2398,13 +2482,13 @@
 })
 
 (define_expand "vcondu<mode><mode>"
-  [(set (match_operand:VDQ_I 0 "register_operand")
-	(if_then_else:VDQ_I
+  [(set (match_operand:VSDQ_I_DI 0 "register_operand")
+	(if_then_else:VSDQ_I_DI
 	  (match_operator 3 "comparison_operator"
-	    [(match_operand:VDQ_I 4 "register_operand")
-	     (match_operand:VDQ_I 5 "nonmemory_operand")])
-	  (match_operand:VDQ_I 1 "nonmemory_operand")
-	  (match_operand:VDQ_I 2 "nonmemory_operand")))]
+	    [(match_operand:VSDQ_I_DI 4 "register_operand")
+	     (match_operand:VSDQ_I_DI 5 "nonmemory_operand")])
+	  (match_operand:VSDQ_I_DI 1 "nonmemory_operand")
+	  (match_operand:VSDQ_I_DI 2 "nonmemory_operand")))]
   "TARGET_SIMD"
 {
   emit_insn (gen_aarch64_vcond_internal<mode><mode> (operands[0], operands[1],
@@ -2450,7 +2534,7 @@
 (define_insn "aarch64_get_lane<mode>"
   [(set (match_operand:<VEL> 0 "aarch64_simd_nonimmediate_operand" "=r, w, Utv")
 	(vec_select:<VEL>
-	  (match_operand:VALL 1 "register_operand" "w, w, w")
+	  (match_operand:VALL_F16 1 "register_operand" "w, w, w")
 	  (parallel [(match_operand:SI 2 "immediate_operand" "i, i, i")])))]
   "TARGET_SIMD"
   {
@@ -2474,23 +2558,33 @@
 ;; dest vector.
 
 (define_insn "*aarch64_combinez<mode>"
-  [(set (match_operand:<VDBL> 0 "register_operand" "=&w")
+  [(set (match_operand:<VDBL> 0 "register_operand" "=w,w,w")
         (vec_concat:<VDBL>
-	   (match_operand:VD_BHSI 1 "register_operand" "w")
-	   (match_operand:VD_BHSI 2 "aarch64_simd_imm_zero" "Dz")))]
+	   (match_operand:VD_BHSI 1 "general_operand" "w,r,m")
+	   (match_operand:VD_BHSI 2 "aarch64_simd_imm_zero" "Dz,Dz,Dz")))]
   "TARGET_SIMD && !BYTES_BIG_ENDIAN"
-  "mov\\t%0.8b, %1.8b"
-  [(set_attr "type" "neon_move<q>")]
+  "@
+   mov\\t%0.8b, %1.8b
+   fmov\t%d0, %1
+   ldr\\t%d0, %1"
+  [(set_attr "type" "neon_move<q>, neon_from_gp, neon_load1_1reg")
+   (set_attr "simd" "yes,*,yes")
+   (set_attr "fp" "*,yes,*")]
 )
 
 (define_insn "*aarch64_combinez_be<mode>"
-  [(set (match_operand:<VDBL> 0 "register_operand" "=&w")
+  [(set (match_operand:<VDBL> 0 "register_operand" "=w,w,w")
         (vec_concat:<VDBL>
-	   (match_operand:VD_BHSI 2 "aarch64_simd_imm_zero" "Dz")
-	   (match_operand:VD_BHSI 1 "register_operand" "w")))]
+	   (match_operand:VD_BHSI 2 "aarch64_simd_imm_zero" "Dz,Dz,Dz")
+	   (match_operand:VD_BHSI 1 "general_operand" "w,r,m")))]
   "TARGET_SIMD && BYTES_BIG_ENDIAN"
-  "mov\\t%0.8b, %1.8b"
-  [(set_attr "type" "neon_move<q>")]
+  "@
+   mov\\t%0.8b, %1.8b
+   fmov\t%d0, %1
+   ldr\\t%d0, %1"
+  [(set_attr "type" "neon_move<q>, neon_from_gp, neon_load1_1reg")
+   (set_attr "simd" "yes,*,yes")
+   (set_attr "fp" "*,yes,*")]
 )
 
 (define_expand "aarch64_combine<mode>"
@@ -3906,7 +4000,7 @@
 
 (define_insn "aarch64_simd_ld2r<mode>"
   [(set (match_operand:OI 0 "register_operand" "=w")
-       (unspec:OI [(match_operand:<V_TWO_ELEM> 1 "aarch64_simd_struct_operand" "Utv")
+       (unspec:OI [(match_operand:BLK 1 "aarch64_simd_struct_operand" "Utv")
                    (unspec:VALLDIF [(const_int 0)] UNSPEC_VSTRUCTDUMMY) ]
                   UNSPEC_LD2_DUP))]
   "TARGET_SIMD"
@@ -3916,13 +4010,16 @@
 
 (define_insn "aarch64_vec_load_lanesoi_lane<mode>"
   [(set (match_operand:OI 0 "register_operand" "=w")
-	(unspec:OI [(match_operand:<V_TWO_ELEM> 1 "aarch64_simd_struct_operand" "Utv")
+	(unspec:OI [(match_operand:BLK 1 "aarch64_simd_struct_operand" "Utv")
 		    (match_operand:OI 2 "register_operand" "0")
 		    (match_operand:SI 3 "immediate_operand" "i")
-		    (unspec:VQ [(const_int 0)] UNSPEC_VSTRUCTDUMMY) ]
+		    (unspec:VALLDIF [(const_int 0)] UNSPEC_VSTRUCTDUMMY) ]
 		   UNSPEC_LD2_LANE))]
   "TARGET_SIMD"
-  "ld2\\t{%S0.<Vetype> - %T0.<Vetype>}[%3], %1"
+  {
+    operands[3] = GEN_INT (ENDIAN_LANE_N (<MODE>mode, INTVAL (operands[3])));
+    return "ld2\\t{%S0.<Vetype> - %T0.<Vetype>}[%3], %1";
+  }
   [(set_attr "type" "neon_load2_one_lane")]
 )
 
@@ -3955,15 +4052,19 @@
   [(set_attr "type" "neon_store2_2reg<q>")]
 )
 
-(define_insn "vec_store_lanesoi_lane<mode>"
-  [(set (match_operand:<V_TWO_ELEM> 0 "aarch64_simd_struct_operand" "=Utv")
-	(unspec:<V_TWO_ELEM> [(match_operand:OI 1 "register_operand" "w")
-                    (unspec:VQ [(const_int 0)] UNSPEC_VSTRUCTDUMMY)
+;; RTL uses GCC vector extension indices, so flip only for assembly.
+(define_insn "aarch64_vec_store_lanesoi_lane<mode>"
+  [(set (match_operand:BLK 0 "aarch64_simd_struct_operand" "=Utv")
+	(unspec:BLK [(match_operand:OI 1 "register_operand" "w")
+		    (unspec:VALLDIF [(const_int 0)] UNSPEC_VSTRUCTDUMMY)
 		    (match_operand:SI 2 "immediate_operand" "i")]
-                   UNSPEC_ST2_LANE))]
+		   UNSPEC_ST2_LANE))]
   "TARGET_SIMD"
-  "st2\\t{%S1.<Vetype> - %T1.<Vetype>}[%2], %0"
-  [(set_attr "type" "neon_store3_one_lane<q>")]
+  {
+    operands[2] = GEN_INT (ENDIAN_LANE_N (<MODE>mode, INTVAL (operands[2])));
+    return "st2\\t{%S1.<Vetype> - %T1.<Vetype>}[%2], %0";
+  }
+  [(set_attr "type" "neon_store2_one_lane<q>")]
 )
 
 (define_expand "vec_store_lanesoi<mode>"
@@ -3997,7 +4098,7 @@
 
 (define_insn "aarch64_simd_ld3r<mode>"
   [(set (match_operand:CI 0 "register_operand" "=w")
-       (unspec:CI [(match_operand:<V_THREE_ELEM> 1 "aarch64_simd_struct_operand" "Utv")
+       (unspec:CI [(match_operand:BLK 1 "aarch64_simd_struct_operand" "Utv")
                    (unspec:VALLDIF [(const_int 0)] UNSPEC_VSTRUCTDUMMY) ]
                   UNSPEC_LD3_DUP))]
   "TARGET_SIMD"
@@ -4007,13 +4108,16 @@
 
 (define_insn "aarch64_vec_load_lanesci_lane<mode>"
   [(set (match_operand:CI 0 "register_operand" "=w")
-	(unspec:CI [(match_operand:<V_THREE_ELEM> 1 "aarch64_simd_struct_operand" "Utv")
+	(unspec:CI [(match_operand:BLK 1 "aarch64_simd_struct_operand" "Utv")
 		    (match_operand:CI 2 "register_operand" "0")
 		    (match_operand:SI 3 "immediate_operand" "i")
-		    (unspec:VQ [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
+		    (unspec:VALLDIF [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
 		   UNSPEC_LD3_LANE))]
   "TARGET_SIMD"
-  "ld3\\t{%S0.<Vetype> - %U0.<Vetype>}[%3], %1"
+{
+    operands[3] = GEN_INT (ENDIAN_LANE_N (<MODE>mode, INTVAL (operands[3])));
+    return "ld3\\t{%S0.<Vetype> - %U0.<Vetype>}[%3], %1";
+}
   [(set_attr "type" "neon_load3_one_lane")]
 )
 
@@ -4046,14 +4150,18 @@
   [(set_attr "type" "neon_store3_3reg<q>")]
 )
 
-(define_insn "vec_store_lanesci_lane<mode>"
-  [(set (match_operand:<V_THREE_ELEM> 0 "aarch64_simd_struct_operand" "=Utv")
-	(unspec:<V_THREE_ELEM> [(match_operand:CI 1 "register_operand" "w")
-                    (unspec:VQ [(const_int 0)] UNSPEC_VSTRUCTDUMMY)
-		    (match_operand:SI 2 "immediate_operand" "i")]
-                   UNSPEC_ST3_LANE))]
+;; RTL uses GCC vector extension indices, so flip only for assembly.
+(define_insn "aarch64_vec_store_lanesci_lane<mode>"
+  [(set (match_operand:BLK 0 "aarch64_simd_struct_operand" "=Utv")
+	(unspec:BLK [(match_operand:CI 1 "register_operand" "w")
+		     (unspec:VALLDIF [(const_int 0)] UNSPEC_VSTRUCTDUMMY)
+		     (match_operand:SI 2 "immediate_operand" "i")]
+		    UNSPEC_ST3_LANE))]
   "TARGET_SIMD"
-  "st3\\t{%S1.<Vetype> - %U1.<Vetype>}[%2], %0"
+  {
+    operands[2] = GEN_INT (ENDIAN_LANE_N (<MODE>mode, INTVAL (operands[2])));
+    return "st3\\t{%S1.<Vetype> - %U1.<Vetype>}[%2], %0";
+  }
   [(set_attr "type" "neon_store3_one_lane<q>")]
 )
 
@@ -4088,7 +4196,7 @@
 
 (define_insn "aarch64_simd_ld4r<mode>"
   [(set (match_operand:XI 0 "register_operand" "=w")
-       (unspec:XI [(match_operand:<V_FOUR_ELEM> 1 "aarch64_simd_struct_operand" "Utv")
+       (unspec:XI [(match_operand:BLK 1 "aarch64_simd_struct_operand" "Utv")
                    (unspec:VALLDIF [(const_int 0)] UNSPEC_VSTRUCTDUMMY) ]
                   UNSPEC_LD4_DUP))]
   "TARGET_SIMD"
@@ -4098,13 +4206,16 @@
 
 (define_insn "aarch64_vec_load_lanesxi_lane<mode>"
   [(set (match_operand:XI 0 "register_operand" "=w")
-	(unspec:XI [(match_operand:<V_FOUR_ELEM> 1 "aarch64_simd_struct_operand" "Utv")
+	(unspec:XI [(match_operand:BLK 1 "aarch64_simd_struct_operand" "Utv")
 		    (match_operand:XI 2 "register_operand" "0")
 		    (match_operand:SI 3 "immediate_operand" "i")
-		    (unspec:VQ [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
+		    (unspec:VALLDIF [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
 		   UNSPEC_LD4_LANE))]
   "TARGET_SIMD"
-  "ld4\\t{%S0.<Vetype> - %V0.<Vetype>}[%3], %1"
+{
+    operands[3] = GEN_INT (ENDIAN_LANE_N (<MODE>mode, INTVAL (operands[3])));
+    return "ld4\\t{%S0.<Vetype> - %V0.<Vetype>}[%3], %1";
+}
   [(set_attr "type" "neon_load4_one_lane")]
 )
 
@@ -4137,14 +4248,18 @@
   [(set_attr "type" "neon_store4_4reg<q>")]
 )
 
-(define_insn "vec_store_lanesxi_lane<mode>"
-  [(set (match_operand:<V_FOUR_ELEM> 0 "aarch64_simd_struct_operand" "=Utv")
-	(unspec:<V_FOUR_ELEM> [(match_operand:XI 1 "register_operand" "w")
-                    (unspec:VQ [(const_int 0)] UNSPEC_VSTRUCTDUMMY)
-		    (match_operand:SI 2 "immediate_operand" "i")]
-                   UNSPEC_ST4_LANE))]
+;; RTL uses GCC vector extension indices, so flip only for assembly.
+(define_insn "aarch64_vec_store_lanesxi_lane<mode>"
+  [(set (match_operand:BLK 0 "aarch64_simd_struct_operand" "=Utv")
+	(unspec:BLK [(match_operand:XI 1 "register_operand" "w")
+		     (unspec:VALLDIF [(const_int 0)] UNSPEC_VSTRUCTDUMMY)
+		     (match_operand:SI 2 "immediate_operand" "i")]
+		    UNSPEC_ST4_LANE))]
   "TARGET_SIMD"
-  "st4\\t{%S1.<Vetype> - %V1.<Vetype>}[%2], %0"
+  {
+    operands[2] = GEN_INT (ENDIAN_LANE_N (<MODE>mode, INTVAL (operands[2])));
+    return "st4\\t{%S1.<Vetype> - %V1.<Vetype>}[%2], %0";
+  }
   [(set_attr "type" "neon_store4_one_lane<q>")]
 )
 
@@ -4222,8 +4337,9 @@
 )
 
 (define_insn "aarch64_be_ld1<mode>"
-  [(set (match_operand:VALLDI 0	"register_operand" "=w")
-	(unspec:VALLDI [(match_operand:VALLDI 1 "aarch64_simd_struct_operand" "Utv")]
+  [(set (match_operand:VALLDI_F16 0	"register_operand" "=w")
+	(unspec:VALLDI_F16 [(match_operand:VALLDI_F16 1
+			     "aarch64_simd_struct_operand" "Utv")]
 	UNSPEC_LD1))]
   "TARGET_SIMD"
   "ld1\\t{%0<Vmtype>}, %1"
@@ -4231,8 +4347,8 @@
 )
 
 (define_insn "aarch64_be_st1<mode>"
-  [(set (match_operand:VALLDI 0 "aarch64_simd_struct_operand" "=Utv")
-	(unspec:VALLDI [(match_operand:VALLDI 1 "register_operand" "w")]
+  [(set (match_operand:VALLDI_F16 0 "aarch64_simd_struct_operand" "=Utv")
+	(unspec:VALLDI_F16 [(match_operand:VALLDI_F16 1 "register_operand" "w")]
 	UNSPEC_ST1))]
   "TARGET_SIMD"
   "st1\\t{%1<Vmtype>}, %0"
@@ -4249,7 +4365,7 @@
    #
    stp\\t%q1, %R1, %0
    ldp\\t%q0, %R0, %1"
-  [(set_attr "type" "multiple,neon_store2_2reg_q,neon_load2_2reg_q")
+  [(set_attr "type" "multiple,neon_stp_q,neon_ldp_q")
    (set (attr "length") (symbol_ref "aarch64_simd_attr_length_move (insn)"))]
 )
 
@@ -4337,42 +4453,18 @@
     FAIL;
 })
 
-(define_expand "aarch64_ld2r<mode>"
-  [(match_operand:OI 0 "register_operand" "=w")
+(define_expand "aarch64_ld<VSTRUCT:nregs>r<VALLDIF:mode>"
+  [(match_operand:VSTRUCT 0 "register_operand" "=w")
    (match_operand:DI 1 "register_operand" "w")
    (unspec:VALLDIF [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
   "TARGET_SIMD"
 {
-  machine_mode mode = <V_TWO_ELEM>mode;
-  rtx mem = gen_rtx_MEM (mode, operands[1]);
+  rtx mem = gen_rtx_MEM (BLKmode, operands[1]);
+  set_mem_size (mem, GET_MODE_SIZE (GET_MODE_INNER (<VALLDIF:MODE>mode))
+		     * <VSTRUCT:nregs>);
 
-  emit_insn (gen_aarch64_simd_ld2r<mode> (operands[0], mem));
-  DONE;
-})
-
-(define_expand "aarch64_ld3r<mode>"
-  [(match_operand:CI 0 "register_operand" "=w")
-   (match_operand:DI 1 "register_operand" "w")
-   (unspec:VALLDIF [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
-  "TARGET_SIMD"
-{
-  machine_mode mode = <V_THREE_ELEM>mode;
-  rtx mem = gen_rtx_MEM (mode, operands[1]);
-
-  emit_insn (gen_aarch64_simd_ld3r<mode> (operands[0], mem));
-  DONE;
-})
-
-(define_expand "aarch64_ld4r<mode>"
-  [(match_operand:XI 0 "register_operand" "=w")
-   (match_operand:DI 1 "register_operand" "w")
-   (unspec:VALLDIF [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
-  "TARGET_SIMD"
-{
-  machine_mode mode = <V_FOUR_ELEM>mode;
-  rtx mem = gen_rtx_MEM (mode, operands[1]);
-
-  emit_insn (gen_aarch64_simd_ld4r<mode> (operands[0],mem));
+  emit_insn (gen_aarch64_simd_ld<VSTRUCT:nregs>r<VALLDIF:mode> (operands[0],
+								mem));
   DONE;
 })
 
@@ -4381,8 +4473,9 @@
 	(subreg:OI
 	  (vec_concat:<VRL2>
 	    (vec_concat:<VDBL>
-	     (unspec:VD [(match_operand:TI 1 "aarch64_simd_struct_operand" "Utv")]
-			UNSPEC_LD2)
+	     (unspec:VD
+		[(match_operand:BLK 1 "aarch64_simd_struct_operand" "Utv")]
+		UNSPEC_LD2)
 	     (vec_duplicate:VD (const_int 0)))
 	    (vec_concat:<VDBL>
 	     (unspec:VD [(match_dup 1)]
@@ -4398,8 +4491,9 @@
 	(subreg:OI
 	  (vec_concat:<VRL2>
 	    (vec_concat:<VDBL>
-	     (unspec:DX [(match_operand:TI 1 "aarch64_simd_struct_operand" "Utv")]
-			UNSPEC_LD2)
+	     (unspec:DX
+		[(match_operand:BLK 1 "aarch64_simd_struct_operand" "Utv")]
+		UNSPEC_LD2)
 	     (const_int 0))
 	    (vec_concat:<VDBL>
 	     (unspec:DX [(match_dup 1)]
@@ -4416,8 +4510,9 @@
 	 (vec_concat:<VRL3>
 	  (vec_concat:<VRL2>
 	    (vec_concat:<VDBL>
-	     (unspec:VD [(match_operand:EI 1 "aarch64_simd_struct_operand" "Utv")]
-			UNSPEC_LD3)
+	     (unspec:VD
+		[(match_operand:BLK 1 "aarch64_simd_struct_operand" "Utv")]
+		UNSPEC_LD3)
 	     (vec_duplicate:VD (const_int 0)))
 	    (vec_concat:<VDBL>
 	     (unspec:VD [(match_dup 1)]
@@ -4438,8 +4533,9 @@
 	 (vec_concat:<VRL3>
 	  (vec_concat:<VRL2>
 	    (vec_concat:<VDBL>
-	     (unspec:DX [(match_operand:EI 1 "aarch64_simd_struct_operand" "Utv")]
-			UNSPEC_LD3)
+	     (unspec:DX
+		[(match_operand:BLK 1 "aarch64_simd_struct_operand" "Utv")]
+		UNSPEC_LD3)
 	     (const_int 0))
 	    (vec_concat:<VDBL>
 	     (unspec:DX [(match_dup 1)]
@@ -4460,8 +4556,9 @@
 	 (vec_concat:<VRL4>
 	   (vec_concat:<VRL2>
 	     (vec_concat:<VDBL>
-	       (unspec:VD [(match_operand:OI 1 "aarch64_simd_struct_operand" "Utv")]
-			  UNSPEC_LD4)
+	       (unspec:VD
+		[(match_operand:BLK 1 "aarch64_simd_struct_operand" "Utv")]
+		UNSPEC_LD4)
 	       (vec_duplicate:VD (const_int 0)))
 	      (vec_concat:<VDBL>
 	        (unspec:VD [(match_dup 1)]
@@ -4487,8 +4584,9 @@
 	 (vec_concat:<VRL4>
 	   (vec_concat:<VRL2>
 	     (vec_concat:<VDBL>
-	       (unspec:DX [(match_operand:OI 1 "aarch64_simd_struct_operand" "Utv")]
-			  UNSPEC_LD4)
+	       (unspec:DX
+		[(match_operand:BLK 1 "aarch64_simd_struct_operand" "Utv")]
+		UNSPEC_LD4)
 	       (const_int 0))
 	      (vec_concat:<VDBL>
 	        (unspec:DX [(match_dup 1)]
@@ -4514,23 +4612,23 @@
   (unspec:VDC [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
   "TARGET_SIMD"
 {
-  machine_mode mode = <VSTRUCT:VSTRUCT_DREG>mode;
-  rtx mem = gen_rtx_MEM (mode, operands[1]);
+  rtx mem = gen_rtx_MEM (BLKmode, operands[1]);
+  set_mem_size (mem, <VSTRUCT:nregs> * 8);
 
   emit_insn (gen_aarch64_ld<VSTRUCT:nregs><VDC:mode>_dreg (operands[0], mem));
   DONE;
 })
 
-(define_expand "aarch64_ld1<VALL:mode>"
- [(match_operand:VALL 0 "register_operand")
+(define_expand "aarch64_ld1<VALL_F16:mode>"
+ [(match_operand:VALL_F16 0 "register_operand")
   (match_operand:DI 1 "register_operand")]
   "TARGET_SIMD"
 {
-  machine_mode mode = <VALL:MODE>mode;
+  machine_mode mode = <VALL_F16:MODE>mode;
   rtx mem = gen_rtx_MEM (mode, operands[1]);
 
   if (BYTES_BIG_ENDIAN)
-    emit_insn (gen_aarch64_be_ld1<VALL:mode> (operands[0], mem));
+    emit_insn (gen_aarch64_be_ld1<VALL_F16:mode> (operands[0], mem));
   else
     emit_move_insn (operands[0], mem);
   DONE;
@@ -4545,72 +4643,30 @@
   machine_mode mode = <VSTRUCT:MODE>mode;
   rtx mem = gen_rtx_MEM (mode, operands[1]);
 
-  emit_insn (gen_vec_load_lanes<VSTRUCT:mode><VQ:mode> (operands[0], mem));
+  emit_insn (gen_aarch64_simd_ld<VSTRUCT:nregs><VQ:mode> (operands[0], mem));
   DONE;
 })
 
-(define_expand "aarch64_ld2_lane<mode>"
-  [(match_operand:OI 0 "register_operand" "=w")
+(define_expand "aarch64_ld<VSTRUCT:nregs>_lane<VALLDIF:mode>"
+  [(match_operand:VSTRUCT 0 "register_operand" "=w")
 	(match_operand:DI 1 "register_operand" "w")
-	(match_operand:OI 2 "register_operand" "0")
+	(match_operand:VSTRUCT 2 "register_operand" "0")
 	(match_operand:SI 3 "immediate_operand" "i")
-	(unspec:VQ [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
+	(unspec:VALLDIF [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
   "TARGET_SIMD"
 {
-  machine_mode mode = <V_TWO_ELEM>mode;
-  rtx mem = gen_rtx_MEM (mode, operands[1]);
+  rtx mem = gen_rtx_MEM (BLKmode, operands[1]);
+  set_mem_size (mem, GET_MODE_SIZE (GET_MODE_INNER (<VALLDIF:MODE>mode))
+		     * <VSTRUCT:nregs>);
 
-  aarch64_simd_lane_bounds (operands[3], 0, GET_MODE_NUNITS (<VCONQ>mode),
+  aarch64_simd_lane_bounds (operands[3], 0,
+			    GET_MODE_NUNITS (<VALLDIF:MODE>mode),
 			    NULL);
-  emit_insn (gen_aarch64_vec_load_lanesoi_lane<mode> (operands[0],
-						      mem,
-						      operands[2],
-						      operands[3]));
+  emit_insn (gen_aarch64_vec_load_lanes<VSTRUCT:mode>_lane<VALLDIF:mode> (
+	operands[0], mem, operands[2], operands[3]));
   DONE;
 })
 
-(define_expand "aarch64_ld3_lane<mode>"
-  [(match_operand:CI 0 "register_operand" "=w")
-	(match_operand:DI 1 "register_operand" "w")
-	(match_operand:CI 2 "register_operand" "0")
-	(match_operand:SI 3 "immediate_operand" "i")
-	(unspec:VQ [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
-  "TARGET_SIMD"
-{
-  machine_mode mode = <V_THREE_ELEM>mode;
-  rtx mem = gen_rtx_MEM (mode, operands[1]);
-
-  aarch64_simd_lane_bounds (operands[3], 0, GET_MODE_NUNITS (<VCONQ>mode),
-			    NULL);
-  emit_insn (gen_aarch64_vec_load_lanesci_lane<mode> (operands[0],
-						      mem,
-						      operands[2],
-						      operands[3]));
-  DONE;
-})
-
-(define_expand "aarch64_ld4_lane<mode>"
-  [(match_operand:XI 0 "register_operand" "=w")
-	(match_operand:DI 1 "register_operand" "w")
-	(match_operand:XI 2 "register_operand" "0")
-	(match_operand:SI 3 "immediate_operand" "i")
-	(unspec:VQ [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
-  "TARGET_SIMD"
-{
-  machine_mode mode = <V_FOUR_ELEM>mode;
-  rtx mem = gen_rtx_MEM (mode, operands[1]);
-
-  aarch64_simd_lane_bounds (operands[3], 0, GET_MODE_NUNITS (<VCONQ>mode),
-			    NULL);
-  emit_insn (gen_aarch64_vec_load_lanesxi_lane<mode> (operands[0],
-						      mem,
-						      operands[2],
-						      operands[3]));
-  DONE;
-})
-
-
-
 ;; Expanders for builtins to extract vector registers from large
 ;; opaque integer modes.
 
@@ -4654,9 +4710,9 @@
 ;; vec_perm support
 
 (define_expand "vec_perm_const<mode>"
-  [(match_operand:VALL 0 "register_operand")
-   (match_operand:VALL 1 "register_operand")
-   (match_operand:VALL 2 "register_operand")
+  [(match_operand:VALL_F16 0 "register_operand")
+   (match_operand:VALL_F16 1 "register_operand")
+   (match_operand:VALL_F16 2 "register_operand")
    (match_operand:<V_cmp_result> 3)]
   "TARGET_SIMD"
 {
@@ -4701,6 +4757,27 @@
   [(set_attr "type" "neon_tbl2_q")]
 )
 
+(define_insn "aarch64_tbl3v8qi"
+  [(set (match_operand:V8QI 0 "register_operand" "=w")
+	(unspec:V8QI [(match_operand:OI 1 "register_operand" "w")
+		      (match_operand:V8QI 2 "register_operand" "w")]
+		      UNSPEC_TBL))]
+  "TARGET_SIMD"
+  "tbl\\t%S0.8b, {%S1.16b - %T1.16b}, %S2.8b"
+  [(set_attr "type" "neon_tbl3")]
+)
+
+(define_insn "aarch64_tbx4v8qi"
+  [(set (match_operand:V8QI 0 "register_operand" "=w")
+	(unspec:V8QI [(match_operand:V8QI 1 "register_operand" "0")
+		      (match_operand:OI 2 "register_operand" "w")
+		      (match_operand:V8QI 3 "register_operand" "w")]
+		      UNSPEC_TBX))]
+  "TARGET_SIMD"
+  "tbx\\t%S0.8b, {%S2.16b - %T2.16b}, %S3.8b"
+  [(set_attr "type" "neon_tbl4")]
+)
+
 (define_insn_and_split "aarch64_combinev16qi"
   [(set (match_operand:OI 0 "register_operand" "=w")
 	(unspec:OI [(match_operand:V16QI 1 "register_operand" "w")
@@ -4753,8 +4830,8 @@
 )
 
 (define_insn "aarch64_st2<mode>_dreg"
-  [(set (match_operand:TI 0 "aarch64_simd_struct_operand" "=Utv")
-	(unspec:TI [(match_operand:OI 1 "register_operand" "w")
+  [(set (match_operand:BLK 0 "aarch64_simd_struct_operand" "=Utv")
+	(unspec:BLK [(match_operand:OI 1 "register_operand" "w")
                     (unspec:VD [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
                    UNSPEC_ST2))]
   "TARGET_SIMD"
@@ -4763,8 +4840,8 @@
 )
 
 (define_insn "aarch64_st2<mode>_dreg"
-  [(set (match_operand:TI 0 "aarch64_simd_struct_operand" "=Utv")
-	(unspec:TI [(match_operand:OI 1 "register_operand" "w")
+  [(set (match_operand:BLK 0 "aarch64_simd_struct_operand" "=Utv")
+	(unspec:BLK [(match_operand:OI 1 "register_operand" "w")
                     (unspec:DX [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
                    UNSPEC_ST2))]
   "TARGET_SIMD"
@@ -4773,8 +4850,8 @@
 )
 
 (define_insn "aarch64_st3<mode>_dreg"
-  [(set (match_operand:EI 0 "aarch64_simd_struct_operand" "=Utv")
-	(unspec:EI [(match_operand:CI 1 "register_operand" "w")
+  [(set (match_operand:BLK 0 "aarch64_simd_struct_operand" "=Utv")
+	(unspec:BLK [(match_operand:CI 1 "register_operand" "w")
                     (unspec:VD [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
                    UNSPEC_ST3))]
   "TARGET_SIMD"
@@ -4783,8 +4860,8 @@
 )
 
 (define_insn "aarch64_st3<mode>_dreg"
-  [(set (match_operand:EI 0 "aarch64_simd_struct_operand" "=Utv")
-	(unspec:EI [(match_operand:CI 1 "register_operand" "w")
+  [(set (match_operand:BLK 0 "aarch64_simd_struct_operand" "=Utv")
+	(unspec:BLK [(match_operand:CI 1 "register_operand" "w")
                     (unspec:DX [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
                    UNSPEC_ST3))]
   "TARGET_SIMD"
@@ -4793,8 +4870,8 @@
 )
 
 (define_insn "aarch64_st4<mode>_dreg"
-  [(set (match_operand:OI 0 "aarch64_simd_struct_operand" "=Utv")
-	(unspec:OI [(match_operand:XI 1 "register_operand" "w")
+  [(set (match_operand:BLK 0 "aarch64_simd_struct_operand" "=Utv")
+	(unspec:BLK [(match_operand:XI 1 "register_operand" "w")
                     (unspec:VD [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
                    UNSPEC_ST4))]
   "TARGET_SIMD"
@@ -4803,8 +4880,8 @@
 )
 
 (define_insn "aarch64_st4<mode>_dreg"
-  [(set (match_operand:OI 0 "aarch64_simd_struct_operand" "=Utv")
-	(unspec:OI [(match_operand:XI 1 "register_operand" "w")
+  [(set (match_operand:BLK 0 "aarch64_simd_struct_operand" "=Utv")
+	(unspec:BLK [(match_operand:XI 1 "register_operand" "w")
                     (unspec:DX [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
                    UNSPEC_ST4))]
   "TARGET_SIMD"
@@ -4818,8 +4895,8 @@
   (unspec:VDC [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
   "TARGET_SIMD"
 {
-  machine_mode mode = <VSTRUCT:VSTRUCT_DREG>mode;
-  rtx mem = gen_rtx_MEM (mode, operands[0]);
+  rtx mem = gen_rtx_MEM (BLKmode, operands[0]);
+  set_mem_size (mem, <VSTRUCT:nregs> * 8);
 
   emit_insn (gen_aarch64_st<VSTRUCT:nregs><VDC:mode>_dreg (mem, operands[1]));
   DONE;
@@ -4834,71 +4911,36 @@
   machine_mode mode = <VSTRUCT:MODE>mode;
   rtx mem = gen_rtx_MEM (mode, operands[0]);
 
-  emit_insn (gen_vec_store_lanes<VSTRUCT:mode><VQ:mode> (mem, operands[1]));
-  DONE;
-})
-
-(define_expand "aarch64_st2_lane<VQ:mode>"
- [(match_operand:DI 0 "register_operand" "r")
-  (match_operand:OI 1 "register_operand" "w")
-  (unspec:VQ [(const_int 0)] UNSPEC_VSTRUCTDUMMY)
-  (match_operand:SI 2 "immediate_operand")]
-  "TARGET_SIMD"
-{
-  machine_mode mode = <V_TWO_ELEM>mode;
-  rtx mem = gen_rtx_MEM (mode, operands[0]);
-  operands[2] = GEN_INT (ENDIAN_LANE_N (<MODE>mode, INTVAL (operands[2])));
-
-  emit_insn (gen_vec_store_lanesoi_lane<VQ:mode> (mem,
-						  operands[1],
-						  operands[2]));
+  emit_insn (gen_aarch64_simd_st<VSTRUCT:nregs><VQ:mode> (mem, operands[1]));
   DONE;
 })
 
-(define_expand "aarch64_st3_lane<VQ:mode>"
+(define_expand "aarch64_st<VSTRUCT:nregs>_lane<VALLDIF:mode>"
  [(match_operand:DI 0 "register_operand" "r")
-  (match_operand:CI 1 "register_operand" "w")
-  (unspec:VQ [(const_int 0)] UNSPEC_VSTRUCTDUMMY)
-  (match_operand:SI 2 "immediate_operand")]
-  "TARGET_SIMD"
-{
-  machine_mode mode = <V_THREE_ELEM>mode;
-  rtx mem = gen_rtx_MEM (mode, operands[0]);
-  operands[2] = GEN_INT (ENDIAN_LANE_N (<MODE>mode, INTVAL (operands[2])));
-
-  emit_insn (gen_vec_store_lanesci_lane<VQ:mode> (mem,
-						  operands[1],
-						  operands[2]));
-  DONE;
-})
-
-(define_expand "aarch64_st4_lane<VQ:mode>"
- [(match_operand:DI 0 "register_operand" "r")
-  (match_operand:XI 1 "register_operand" "w")
-  (unspec:VQ [(const_int 0)] UNSPEC_VSTRUCTDUMMY)
+  (match_operand:VSTRUCT 1 "register_operand" "w")
+  (unspec:VALLDIF [(const_int 0)] UNSPEC_VSTRUCTDUMMY)
   (match_operand:SI 2 "immediate_operand")]
   "TARGET_SIMD"
 {
-  machine_mode mode = <V_FOUR_ELEM>mode;
-  rtx mem = gen_rtx_MEM (mode, operands[0]);
-  operands[2] = GEN_INT (ENDIAN_LANE_N (<MODE>mode, INTVAL (operands[2])));
+  rtx mem = gen_rtx_MEM (BLKmode, operands[0]);
+  set_mem_size (mem, GET_MODE_SIZE (GET_MODE_INNER (<VALLDIF:MODE>mode))
+		     * <VSTRUCT:nregs>);
 
-  emit_insn (gen_vec_store_lanesxi_lane<VQ:mode> (mem,
-						  operands[1],
-						  operands[2]));
+  emit_insn (gen_aarch64_vec_store_lanes<VSTRUCT:mode>_lane<VALLDIF:mode> (
+		mem, operands[1], operands[2]));
   DONE;
 })
 
-(define_expand "aarch64_st1<VALL:mode>"
+(define_expand "aarch64_st1<VALL_F16:mode>"
  [(match_operand:DI 0 "register_operand")
-  (match_operand:VALL 1 "register_operand")]
+  (match_operand:VALL_F16 1 "register_operand")]
   "TARGET_SIMD"
 {
-  machine_mode mode = <VALL:MODE>mode;
+  machine_mode mode = <VALL_F16:MODE>mode;
   rtx mem = gen_rtx_MEM (mode, operands[0]);
 
   if (BYTES_BIG_ENDIAN)
-    emit_insn (gen_aarch64_be_st1<VALL:mode> (mem, operands[1]));
+    emit_insn (gen_aarch64_be_st1<VALL_F16:mode> (mem, operands[1]));
   else
     emit_move_insn (mem, operands[1]);
   DONE;
@@ -4929,7 +4971,7 @@
 ;; Standard pattern name vec_init<mode>.
 
 (define_expand "vec_init<mode>"
-  [(match_operand:VALL 0 "register_operand" "")
+  [(match_operand:VALL_F16 0 "register_operand" "")
    (match_operand 1 "" "")]
   "TARGET_SIMD"
 {
@@ -4938,8 +4980,8 @@
 })
 
 (define_insn "*aarch64_simd_ld1r<mode>"
-  [(set (match_operand:VALL 0 "register_operand" "=w")
-	(vec_duplicate:VALL
+  [(set (match_operand:VALL_F16 0 "register_operand" "=w")
+	(vec_duplicate:VALL_F16
 	  (match_operand:<VEL> 1 "aarch64_simd_struct_operand" "Utv")))]
   "TARGET_SIMD"
   "ld1r\\t{%0.<Vtype>}, %1"
@@ -4986,7 +5028,7 @@
 
 (define_expand "vec_extract<mode>"
   [(match_operand:<VEL> 0 "aarch64_simd_nonimmediate_operand" "")
-   (match_operand:VALL 1 "register_operand" "")
+   (match_operand:VALL_F16 1 "register_operand" "")
    (match_operand:SI 2 "immediate_operand" "")]
   "TARGET_SIMD"
 {
--- /dev/null
+++ b/src/gcc/config/aarch64/aarch64-tuning-flags.def
@@ -0,0 +1,32 @@
+/* Copyright (C) 2015 Free Software Foundation, Inc.
+   Contributed by ARM Ltd.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3, or (at your
+   option) any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Additional control over certain tuning parameters.  Before including
+   this file, define a macro:
+
+     AARCH64_EXTRA_TUNING_OPTION (name, internal_name)
+
+   Where:
+
+     NAME is a string giving a friendly name for the tuning flag.
+     INTERNAL_NAME gives the internal name suitable for appending to
+     AARCH64_TUNE_ to give an enum name. */
+
+AARCH64_EXTRA_TUNING_OPTION ("rename_fma_regs", RENAME_FMA_REGS)
+
--- a/src/gcc/config/aarch64/aarch64.c
+++ b/src/gcc/config/aarch64/aarch64.c
@@ -75,6 +75,8 @@
 #include "tm_p.h"
 #include "recog.h"
 #include "langhooks.h"
+#include "opts.h"
+#include "diagnostic.h"
 #include "diagnostic-core.h"
 #include "hash-table.h"
 #include "tree-ssa-alias.h"
@@ -95,6 +97,8 @@
 #include "rtl-iter.h"
 #include "tm-constrs.h"
 #include "sched-int.h"
+#include "cortex-a57-fma-steering.h"
+#include "target-globals.h"
 
 /* Defined for convenience.  */
 #define POINTER_BYTES (POINTER_SIZE / BITS_PER_UNIT)
@@ -166,7 +170,6 @@ static void aarch64_elf_asm_constructor (rtx, int) ATTRIBUTE_UNUSED;
 static void aarch64_elf_asm_destructor (rtx, int) ATTRIBUTE_UNUSED;
 static void aarch64_override_options_after_change (void);
 static bool aarch64_vector_mode_supported_p (machine_mode);
-static unsigned bit_count (unsigned HOST_WIDE_INT);
 static bool aarch64_vectorize_vec_perm_const_ok (machine_mode vmode,
 						 const unsigned char *sel);
 static int aarch64_address_cost (rtx, machine_mode, addr_space_t, bool);
@@ -177,15 +180,39 @@ unsigned aarch64_architecture_version;
 /* The processor for which instructions should be scheduled.  */
 enum aarch64_processor aarch64_tune = cortexa53;
 
-/* The current tuning set.  */
-const struct tune_params *aarch64_tune_params;
-
-/* Mask to specify which instructions we are allowed to generate.  */
-unsigned long aarch64_isa_flags = 0;
-
 /* Mask to specify which instruction scheduling options should be used.  */
 unsigned long aarch64_tune_flags = 0;
 
+/* Support for command line parsing of boolean flags in the tuning
+   structures.  */
+struct aarch64_flag_desc
+{
+  const char* name;
+  unsigned int flag;
+};
+
+#define AARCH64_FUSION_PAIR(name, internal_name) \
+  { name, AARCH64_FUSE_##internal_name },
+static const struct aarch64_flag_desc aarch64_fusible_pairs[] =
+{
+  { "none", AARCH64_FUSE_NOTHING },
+#include "aarch64-fusion-pairs.def"
+  { "all", AARCH64_FUSE_ALL },
+  { NULL, AARCH64_FUSE_NOTHING }
+};
+#undef AARCH64_FUION_PAIR
+
+#define AARCH64_EXTRA_TUNING_OPTION(name, internal_name) \
+  { name, AARCH64_EXTRA_TUNE_##internal_name },
+static const struct aarch64_flag_desc aarch64_tuning_flags[] =
+{
+  { "none", AARCH64_EXTRA_TUNE_NONE },
+#include "aarch64-tuning-flags.def"
+  { "all", AARCH64_EXTRA_TUNE_ALL },
+  { NULL, AARCH64_EXTRA_TUNE_NONE }
+};
+#undef AARCH64_EXTRA_TUNING_OPTION
+
 /* Tuning parameters.  */
 
 static const struct cpu_addrcost_table generic_addrcost_table =
@@ -332,12 +359,12 @@ static const struct cpu_vector_cost xgene1_vector_cost =
   1 /* cond_not_taken_branch_cost  */
 };
 
-#define AARCH64_FUSE_NOTHING	(0)
-#define AARCH64_FUSE_MOV_MOVK	(1 << 0)
-#define AARCH64_FUSE_ADRP_ADD	(1 << 1)
-#define AARCH64_FUSE_MOVK_MOVK	(1 << 2)
-#define AARCH64_FUSE_ADRP_LDR	(1 << 3)
-#define AARCH64_FUSE_CMP_BRANCH	(1 << 4)
+/* Generic costs for branch instructions.  */
+static const struct cpu_branch_cost generic_branch_cost =
+{
+  2,  /* Predictable.  */
+  2   /* Unpredictable.  */
+};
 
 static const struct tune_params generic_tunings =
 {
@@ -345,15 +372,19 @@ static const struct tune_params generic_tunings =
   &generic_addrcost_table,
   &generic_regmove_cost,
   &generic_vector_cost,
+  &generic_branch_cost,
   4, /* memmov_cost  */
   2, /* issue_rate  */
-  AARCH64_FUSE_NOTHING, /* fuseable_ops  */
+  AARCH64_FUSE_NOTHING, /* fusible_ops  */
   8,	/* function_align.  */
   8,	/* jump_align.  */
   4,	/* loop_align.  */
   2,	/* int_reassoc_width.  */
   4,	/* fp_reassoc_width.  */
-  1	/* vec_reassoc_width.  */
+  1,	/* vec_reassoc_width.  */
+  2,	/* min_div_recip_mul_sf.  */
+  2,	/* min_div_recip_mul_df.  */
+  (AARCH64_EXTRA_TUNE_NONE)	/* tune_flags.  */
 };
 
 static const struct tune_params cortexa53_tunings =
@@ -362,16 +393,20 @@ static const struct tune_params cortexa53_tunings =
   &generic_addrcost_table,
   &cortexa53_regmove_cost,
   &generic_vector_cost,
+  &generic_branch_cost,
   4, /* memmov_cost  */
   2, /* issue_rate  */
   (AARCH64_FUSE_MOV_MOVK | AARCH64_FUSE_ADRP_ADD
-   | AARCH64_FUSE_MOVK_MOVK | AARCH64_FUSE_ADRP_LDR), /* fuseable_ops  */
+   | AARCH64_FUSE_MOVK_MOVK | AARCH64_FUSE_ADRP_LDR), /* fusible_ops  */
   8,	/* function_align.  */
   8,	/* jump_align.  */
   4,	/* loop_align.  */
   2,	/* int_reassoc_width.  */
   4,	/* fp_reassoc_width.  */
-  1	/* vec_reassoc_width.  */
+  1,	/* vec_reassoc_width.  */
+  2,	/* min_div_recip_mul_sf.  */
+  2,	/* min_div_recip_mul_df.  */
+  (AARCH64_EXTRA_TUNE_NONE)	/* tune_flags.  */
 };
 
 static const struct tune_params cortexa57_tunings =
@@ -380,16 +415,42 @@ static const struct tune_params cortexa57_tunings =
   &cortexa57_addrcost_table,
   &cortexa57_regmove_cost,
   &cortexa57_vector_cost,
+  &generic_branch_cost,
+  4, /* memmov_cost  */
+  3, /* issue_rate  */
+  (AARCH64_FUSE_MOV_MOVK | AARCH64_FUSE_ADRP_ADD
+   | AARCH64_FUSE_MOVK_MOVK), /* fusible_ops  */
+  16,	/* function_align.  */
+  8,	/* jump_align.  */
+  4,	/* loop_align.  */
+  2,	/* int_reassoc_width.  */
+  4,	/* fp_reassoc_width.  */
+  1,	/* vec_reassoc_width.  */
+  2,	/* min_div_recip_mul_sf.  */
+  2,	/* min_div_recip_mul_df.  */
+  (AARCH64_EXTRA_TUNE_RENAME_FMA_REGS)	/* tune_flags.  */
+};
+
+static const struct tune_params cortexa72_tunings =
+{
+  &cortexa57_extra_costs,
+  &cortexa57_addrcost_table,
+  &cortexa57_regmove_cost,
+  &cortexa57_vector_cost,
+  &generic_branch_cost,
   4, /* memmov_cost  */
   3, /* issue_rate  */
   (AARCH64_FUSE_MOV_MOVK | AARCH64_FUSE_ADRP_ADD
-   | AARCH64_FUSE_MOVK_MOVK), /* fuseable_ops  */
+   | AARCH64_FUSE_MOVK_MOVK), /* fusible_ops  */
   16,	/* function_align.  */
   8,	/* jump_align.  */
   4,	/* loop_align.  */
   2,	/* int_reassoc_width.  */
   4,	/* fp_reassoc_width.  */
-  1	/* vec_reassoc_width.  */
+  1,	/* vec_reassoc_width.  */
+  2,	/* min_div_recip_mul_sf.  */
+  2,	/* min_div_recip_mul_df.  */
+  (AARCH64_EXTRA_TUNE_NONE)	/* tune_flags.  */
 };
 
 static const struct tune_params thunderx_tunings =
@@ -398,15 +459,19 @@ static const struct tune_params thunderx_tunings =
   &generic_addrcost_table,
   &thunderx_regmove_cost,
   &generic_vector_cost,
+  &generic_branch_cost,
   6, /* memmov_cost  */
   2, /* issue_rate  */
-  AARCH64_FUSE_CMP_BRANCH, /* fuseable_ops  */
+  AARCH64_FUSE_CMP_BRANCH, /* fusible_ops  */
   8,	/* function_align.  */
   8,	/* jump_align.  */
   8,	/* loop_align.  */
   2,	/* int_reassoc_width.  */
   4,	/* fp_reassoc_width.  */
-  1	/* vec_reassoc_width.  */
+  1,	/* vec_reassoc_width.  */
+  2,	/* min_div_recip_mul_sf.  */
+  2,	/* min_div_recip_mul_df.  */
+  (AARCH64_EXTRA_TUNE_NONE)	/* tune_flags.  */
 };
 
 static const struct tune_params xgene1_tunings =
@@ -415,55 +480,85 @@ static const struct tune_params xgene1_tunings =
   &xgene1_addrcost_table,
   &xgene1_regmove_cost,
   &xgene1_vector_cost,
+  &generic_branch_cost,
   6, /* memmov_cost  */
   4, /* issue_rate  */
-  AARCH64_FUSE_NOTHING, /* fuseable_ops  */
+  AARCH64_FUSE_NOTHING, /* fusible_ops  */
   16,	/* function_align.  */
   8,	/* jump_align.  */
   16,	/* loop_align.  */
   2,	/* int_reassoc_width.  */
   4,	/* fp_reassoc_width.  */
-  1	/* vec_reassoc_width.  */
+  1,	/* vec_reassoc_width.  */
+  2,	/* min_div_recip_mul_sf.  */
+  2,	/* min_div_recip_mul_df.  */
+  (AARCH64_EXTRA_TUNE_NONE)	/* tune_flags.  */
+};
+
+/* Support for fine-grained override of the tuning structures.  */
+struct aarch64_tuning_override_function
+{
+  const char* name;
+  void (*parse_override)(const char*, struct tune_params*);
+};
+
+static void aarch64_parse_fuse_string (const char*, struct tune_params*);
+static void aarch64_parse_tune_string (const char*, struct tune_params*);
+
+static const struct aarch64_tuning_override_function
+aarch64_tuning_override_functions[] =
+{
+  { "fuse", aarch64_parse_fuse_string },
+  { "tune", aarch64_parse_tune_string },
+  { NULL, NULL }
 };
 
 /* A processor implementing AArch64.  */
 struct processor
 {
   const char *const name;
-  enum aarch64_processor core;
-  const char *arch;
+  enum aarch64_processor ident;
+  enum aarch64_processor sched_core;
+  enum aarch64_arch arch;
   unsigned architecture_version;
   const unsigned long flags;
   const struct tune_params *const tune;
 };
 
+/* Architectures implementing AArch64.  */
+static const struct processor all_architectures[] =
+{
+#define AARCH64_ARCH(NAME, CORE, ARCH_IDENT, ARCH_REV, FLAGS) \
+  {NAME, CORE, CORE, AARCH64_ARCH_##ARCH_IDENT, ARCH_REV, FLAGS, NULL},
+#include "aarch64-arches.def"
+#undef AARCH64_ARCH
+  {NULL, aarch64_none, aarch64_none, aarch64_no_arch, 0, 0, NULL}
+};
+
 /* Processor cores implementing AArch64.  */
 static const struct processor all_cores[] =
 {
-#define AARCH64_CORE(NAME, IDENT, SCHED, ARCH, FLAGS, COSTS) \
-  {NAME, SCHED, #ARCH, ARCH, FLAGS, &COSTS##_tunings},
+#define AARCH64_CORE(NAME, IDENT, SCHED, ARCH, FLAGS, COSTS, IMP, PART) \
+  {NAME, IDENT, SCHED, AARCH64_ARCH_##ARCH,				\
+  all_architectures[AARCH64_ARCH_##ARCH].architecture_version,	\
+  FLAGS, &COSTS##_tunings},
 #include "aarch64-cores.def"
 #undef AARCH64_CORE
-  {"generic", cortexa53, "8", 8, AARCH64_FL_FOR_ARCH8, &generic_tunings},
-  {NULL, aarch64_none, NULL, 0, 0, NULL}
+  {"generic", generic, cortexa53, AARCH64_ARCH_8A, 8,
+    AARCH64_FL_FOR_ARCH8, &generic_tunings},
+  {NULL, aarch64_none, aarch64_none, aarch64_no_arch, 0, 0, NULL}
 };
 
-/* Architectures implementing AArch64.  */
-static const struct processor all_architectures[] =
-{
-#define AARCH64_ARCH(NAME, CORE, ARCH, FLAGS) \
-  {NAME, CORE, #ARCH, ARCH, FLAGS, NULL},
-#include "aarch64-arches.def"
-#undef AARCH64_ARCH
-  {NULL, aarch64_none, NULL, 0, 0, NULL}
-};
 
-/* Target specification.  These are populated as commandline arguments
-   are processed, or NULL if not specified.  */
+/* Target specification.  These are populated by the -march, -mtune, -mcpu
+   handling code or by target attributes.  */
 static const struct processor *selected_arch;
 static const struct processor *selected_cpu;
 static const struct processor *selected_tune;
 
+/* The current tuning set.  */
+struct tune_params aarch64_tune_params = generic_tunings;
+
 #define AARCH64_CPU_DEFAULT_FLAGS ((selected_cpu) ? selected_cpu->flags : 0)
 
 /* An ISA extension in the co-processor and main instruction set space.  */
@@ -477,7 +572,7 @@ struct aarch64_option_extension
 /* ISA extensions in AArch64.  */
 static const struct aarch64_option_extension all_extensions[] =
 {
-#define AARCH64_OPT_EXTENSION(NAME, FLAGS_ON, FLAGS_OFF) \
+#define AARCH64_OPT_EXTENSION(NAME, FLAGS_ON, FLAGS_OFF, FEATURE_STRING) \
   {NAME, FLAGS_ON, FLAGS_OFF},
 #include "aarch64-option-extensions.def"
 #undef AARCH64_OPT_EXTENSION
@@ -488,12 +583,6 @@ static const struct aarch64_option_extension all_extensions[] =
    increment address.  */
 static machine_mode aarch64_memory_reference_mode;
 
-/* A table of valid AArch64 "bitmask immediate" values for
-   logical instructions.  */
-
-#define AARCH64_NUM_BITMASKS  5334
-static unsigned HOST_WIDE_INT aarch64_bitmasks[AARCH64_NUM_BITMASKS];
-
 typedef enum aarch64_cond_code
 {
   AARCH64_EQ = 0, AARCH64_NE, AARCH64_CS, AARCH64_CC, AARCH64_MI, AARCH64_PL,
@@ -511,10 +600,22 @@ static const char * const aarch64_condition_codes[] =
   "hi", "ls", "ge", "lt", "gt", "le", "al", "nv"
 };
 
+void
+aarch64_err_no_fpadvsimd (machine_mode mode, const char *msg)
+{
+  const char *mc = FLOAT_MODE_P (mode) ? "floating-point" : "vector";
+  if (TARGET_GENERAL_REGS_ONLY)
+    error ("%qs is incompatible with %s %s", "-mgeneral-regs-only", mc, msg);
+  else
+    error ("%qs feature modifier is incompatible with %s %s", "+nofp", mc, msg);
+}
+
 static unsigned int
-aarch64_min_divisions_for_recip_mul (enum machine_mode mode ATTRIBUTE_UNUSED)
+aarch64_min_divisions_for_recip_mul (enum machine_mode mode)
 {
-  return 2;
+  if (GET_MODE_UNIT_SIZE (mode) == 4)
+    return aarch64_tune_params.min_div_recip_mul_sf;
+  return aarch64_tune_params.min_div_recip_mul_df;
 }
 
 static int
@@ -522,11 +623,11 @@ aarch64_reassociation_width (unsigned opc ATTRIBUTE_UNUSED,
 			     enum machine_mode mode)
 {
   if (VECTOR_MODE_P (mode))
-    return aarch64_tune_params->vec_reassoc_width;
+    return aarch64_tune_params.vec_reassoc_width;
   if (INTEGRAL_MODE_P (mode))
-    return aarch64_tune_params->int_reassoc_width;
+    return aarch64_tune_params.int_reassoc_width;
   if (FLOAT_MODE_P (mode))
-    return aarch64_tune_params->fp_reassoc_width;
+    return aarch64_tune_params.fp_reassoc_width;
   return 1;
 }
 
@@ -567,7 +668,8 @@ aarch64_array_mode_supported_p (machine_mode mode,
 				unsigned HOST_WIDE_INT nelems)
 {
   if (TARGET_SIMD
-      && AARCH64_VALID_SIMD_QREG_MODE (mode)
+      && (AARCH64_VALID_SIMD_QREG_MODE (mode)
+	  || AARCH64_VALID_SIMD_DREG_MODE (mode))
       && (nelems >= 2 && nelems <= 4))
     return true;
 
@@ -908,14 +1010,14 @@ aarch64_load_symref_appropriately (rtx dest, rtx imm,
 	return;
       }
 
-    case SYMBOL_SMALL_TPREL:
+    case SYMBOL_TLSLE:
       {
 	rtx tp = aarch64_load_tp (NULL);
 
 	if (GET_MODE (dest) != Pmode)
 	  tp = gen_lowpart (GET_MODE (dest), tp);
 
-	emit_insn (gen_tlsle_small (dest, tp, imm));
+	emit_insn (gen_tlsle (dest, tp, imm));
 	set_unique_reg_note (get_last_insn (), REG_EQUIV, imm);
 	return;
       }
@@ -1052,6 +1154,9 @@ aarch64_split_simd_combine (rtx dst, rtx src1, rtx src2)
 	case V2SImode:
 	  gen = gen_aarch64_simd_combinev2si;
 	  break;
+	case V4HFmode:
+	  gen = gen_aarch64_simd_combinev4hf;
+	  break;
 	case V2SFmode:
 	  gen = gen_aarch64_simd_combinev2sf;
 	  break;
@@ -1100,6 +1205,9 @@ aarch64_split_simd_move (rtx dst, rtx src)
 	case V2DImode:
 	  gen = gen_aarch64_split_simd_movv2di;
 	  break;
+	case V8HFmode:
+	  gen = gen_aarch64_split_simd_movv8hf;
+	  break;
 	case V4SFmode:
 	  gen = gen_aarch64_split_simd_movv4sf;
 	  break;
@@ -1149,268 +1257,95 @@ static int
 aarch64_internal_mov_immediate (rtx dest, rtx imm, bool generate,
 				machine_mode mode)
 {
-  unsigned HOST_WIDE_INT mask;
   int i;
-  bool first;
-  unsigned HOST_WIDE_INT val;
-  bool subtargets;
-  rtx subtarget;
-  int one_match, zero_match, first_not_ffff_match;
-  int num_insns = 0;
+  unsigned HOST_WIDE_INT val, val2, mask;
+  int one_match, zero_match;
+  int num_insns;
 
-  if (CONST_INT_P (imm) && aarch64_move_imm (INTVAL (imm), mode))
+  val = INTVAL (imm);
+
+  if (aarch64_move_imm (val, mode))
     {
       if (generate)
 	emit_insn (gen_rtx_SET (VOIDmode, dest, imm));
-      num_insns++;
-      return num_insns;
+      return 1;
     }
 
-  if (mode == SImode)
+  if ((val >> 32) == 0 || mode == SImode)
     {
-      /* We know we can't do this in 1 insn, and we must be able to do it
-	 in two; so don't mess around looking for sequences that don't buy
-	 us anything.  */
       if (generate)
 	{
-	  emit_insn (gen_rtx_SET (VOIDmode, dest,
-				  GEN_INT (INTVAL (imm) & 0xffff)));
-	  emit_insn (gen_insv_immsi (dest, GEN_INT (16),
-				     GEN_INT ((INTVAL (imm) >> 16) & 0xffff)));
+	  emit_insn (gen_rtx_SET (VOIDmode, dest, GEN_INT (val & 0xffff)));
+	  if (mode == SImode)
+	    emit_insn (gen_insv_immsi (dest, GEN_INT (16),
+				       GEN_INT ((val >> 16) & 0xffff)));
+	  else
+	    emit_insn (gen_insv_immdi (dest, GEN_INT (16),
+				       GEN_INT ((val >> 16) & 0xffff)));
 	}
-      num_insns += 2;
-      return num_insns;
+      return 2;
     }
 
   /* Remaining cases are all for DImode.  */
 
-  val = INTVAL (imm);
-  subtargets = optimize && can_create_pseudo_p ();
-
-  one_match = 0;
-  zero_match = 0;
   mask = 0xffff;
-  first_not_ffff_match = -1;
-
-  for (i = 0; i < 64; i += 16, mask <<= 16)
-    {
-      if ((val & mask) == mask)
-	one_match++;
-      else
-	{
-	  if (first_not_ffff_match < 0)
-	    first_not_ffff_match = i;
-	  if ((val & mask) == 0)
-	    zero_match++;
-	}
-    }
-
-  if (one_match == 2)
-    {
-      /* Set one of the quarters and then insert back into result.  */
-      mask = 0xffffll << first_not_ffff_match;
-      if (generate)
-	{
-	  emit_insn (gen_rtx_SET (VOIDmode, dest, GEN_INT (val | mask)));
-	  emit_insn (gen_insv_immdi (dest, GEN_INT (first_not_ffff_match),
-				     GEN_INT ((val >> first_not_ffff_match)
-					      & 0xffff)));
-	}
-      num_insns += 2;
-      return num_insns;
-    }
-
-  if (zero_match == 2)
-    goto simple_sequence;
+  zero_match = ((val & mask) == 0) + ((val & (mask << 16)) == 0) +
+    ((val & (mask << 32)) == 0) + ((val & (mask << 48)) == 0);
+  one_match = ((~val & mask) == 0) + ((~val & (mask << 16)) == 0) +
+    ((~val & (mask << 32)) == 0) + ((~val & (mask << 48)) == 0);
 
-  mask = 0x0ffff0000UL;
-  for (i = 16; i < 64; i += 16, mask <<= 16)
+  if (zero_match != 2 && one_match != 2)
     {
-      HOST_WIDE_INT comp = mask & ~(mask - 1);
+      /* Try emitting a bitmask immediate with a movk replacing 16 bits.
+	 For a 64-bit bitmask try whether changing 16 bits to all ones or
+	 zeroes creates a valid bitmask.  To check any repeated bitmask,
+	 try using 16 bits from the other 32-bit half of val.  */
 
-      if (aarch64_uimm12_shift (val - (val & mask)))
+      for (i = 0; i < 64; i += 16, mask <<= 16)
 	{
-	  if (generate)
-	    {
-	      subtarget = subtargets ? gen_reg_rtx (DImode) : dest;
-	      emit_insn (gen_rtx_SET (VOIDmode, subtarget,
-				      GEN_INT (val & mask)));
-	      emit_insn (gen_adddi3 (dest, subtarget,
-				     GEN_INT (val - (val & mask))));
-	    }
-	  num_insns += 2;
-	  return num_insns;
-	}
-      else if (aarch64_uimm12_shift (-(val - ((val + comp) & mask))))
-	{
-	  if (generate)
-	    {
-	      subtarget = subtargets ? gen_reg_rtx (DImode) : dest;
-	      emit_insn (gen_rtx_SET (VOIDmode, subtarget,
-				      GEN_INT ((val + comp) & mask)));
-	      emit_insn (gen_adddi3 (dest, subtarget,
-				     GEN_INT (val - ((val + comp) & mask))));
-	    }
-	  num_insns += 2;
-	  return num_insns;
-	}
-      else if (aarch64_uimm12_shift (val - ((val - comp) | ~mask)))
-	{
-	  if (generate)
-	    {
-	      subtarget = subtargets ? gen_reg_rtx (DImode) : dest;
-	      emit_insn (gen_rtx_SET (VOIDmode, subtarget,
-				      GEN_INT ((val - comp) | ~mask)));
-	      emit_insn (gen_adddi3 (dest, subtarget,
-				     GEN_INT (val - ((val - comp) | ~mask))));
-	    }
-	  num_insns += 2;
-	  return num_insns;
-	}
-      else if (aarch64_uimm12_shift (-(val - (val | ~mask))))
-	{
-	  if (generate)
-	    {
-	      subtarget = subtargets ? gen_reg_rtx (DImode) : dest;
-	      emit_insn (gen_rtx_SET (VOIDmode, subtarget,
-				      GEN_INT (val | ~mask)));
-	      emit_insn (gen_adddi3 (dest, subtarget,
-				     GEN_INT (val - (val | ~mask))));
-	    }
-	  num_insns += 2;
-	  return num_insns;
+	  val2 = val & ~mask;
+	  if (val2 != val && aarch64_bitmask_imm (val2, mode))
+	    break;
+	  val2 = val | mask;
+	  if (val2 != val && aarch64_bitmask_imm (val2, mode))
+	    break;
+	  val2 = val2 & ~mask;
+	  val2 = val2 | (((val2 >> 32) | (val2 << 32)) & mask);
+	  if (val2 != val && aarch64_bitmask_imm (val2, mode))
+	    break;
 	}
-    }
-
-  /* See if we can do it by arithmetically combining two
-     immediates.  */
-  for (i = 0; i < AARCH64_NUM_BITMASKS; i++)
-    {
-      int j;
-      mask = 0xffff;
-
-      if (aarch64_uimm12_shift (val - aarch64_bitmasks[i])
-	  || aarch64_uimm12_shift (-val + aarch64_bitmasks[i]))
+      if (i != 64)
 	{
 	  if (generate)
 	    {
-	      subtarget = subtargets ? gen_reg_rtx (DImode) : dest;
-	      emit_insn (gen_rtx_SET (VOIDmode, subtarget,
-				      GEN_INT (aarch64_bitmasks[i])));
-	      emit_insn (gen_adddi3 (dest, subtarget,
-				     GEN_INT (val - aarch64_bitmasks[i])));
-	    }
-	  num_insns += 2;
-	  return num_insns;
-	}
-
-      for (j = 0; j < 64; j += 16, mask <<= 16)
-	{
-	  if ((aarch64_bitmasks[i] & ~mask) == (val & ~mask))
-	    {
-	      if (generate)
-		{
-		  emit_insn (gen_rtx_SET (VOIDmode, dest,
-					  GEN_INT (aarch64_bitmasks[i])));
-		  emit_insn (gen_insv_immdi (dest, GEN_INT (j),
-					     GEN_INT ((val >> j) & 0xffff)));
-		}
-	      num_insns += 2;
-	      return num_insns;
+	      emit_insn (gen_rtx_SET (VOIDmode, dest, GEN_INT (val2)));
+	      emit_insn (gen_insv_immdi (dest, GEN_INT (i),
+					 GEN_INT ((val >> i) & 0xffff)));
 	    }
 	}
     }
 
-  /* See if we can do it by logically combining two immediates.  */
-  for (i = 0; i < AARCH64_NUM_BITMASKS; i++)
-    {
-      if ((aarch64_bitmasks[i] & val) == aarch64_bitmasks[i])
-	{
-	  int j;
-
-	  for (j = i + 1; j < AARCH64_NUM_BITMASKS; j++)
-	    if (val == (aarch64_bitmasks[i] | aarch64_bitmasks[j]))
-	      {
-		if (generate)
-		  {
-		    subtarget = subtargets ? gen_reg_rtx (mode) : dest;
-		    emit_insn (gen_rtx_SET (VOIDmode, subtarget,
-					    GEN_INT (aarch64_bitmasks[i])));
-		    emit_insn (gen_iordi3 (dest, subtarget,
-					   GEN_INT (aarch64_bitmasks[j])));
-		  }
-		num_insns += 2;
-		return num_insns;
-	      }
-	}
-      else if ((val & aarch64_bitmasks[i]) == val)
-	{
-	  int j;
+  /* Generate 2-4 instructions, skipping 16 bits of all zeroes or ones which
+     are emitted by the initial mov.  If one_match > zero_match, skip set bits,
+     otherwise skip zero bits.  */
 
-	  for (j = i + 1; j < AARCH64_NUM_BITMASKS; j++)
-	    if (val == (aarch64_bitmasks[j] & aarch64_bitmasks[i]))
-	      {
-		if (generate)
-		  {
-		    subtarget = subtargets ? gen_reg_rtx (mode) : dest;
-		    emit_insn (gen_rtx_SET (VOIDmode, subtarget,
-					    GEN_INT (aarch64_bitmasks[j])));
-		    emit_insn (gen_anddi3 (dest, subtarget,
-					   GEN_INT (aarch64_bitmasks[i])));
-		  }
-		num_insns += 2;
-		return num_insns;
-	      }
-	}
-    }
+  num_insns = 1;
+  mask = 0xffff;
+  val2 = one_match > zero_match ? ~val : val;
+  i = (val2 & mask) != 0 ? 0 : (val2 & (mask << 16)) != 0 ? 16 : 32;
 
-  if (one_match > zero_match)
+  if (generate)
+    emit_insn (gen_rtx_SET (VOIDmode, dest, GEN_INT (one_match > zero_match
+						    ? (val | ~(mask << i))
+						    : (val & (mask << i)))));
+  for (i += 16; i < 64; i += 16)
     {
-      /* Set either first three quarters or all but the third.	 */
-      mask = 0xffffll << (16 - first_not_ffff_match);
+      if ((val2 & (mask << i)) == 0)
+	continue;
       if (generate)
-	emit_insn (gen_rtx_SET (VOIDmode, dest,
-				GEN_INT (val | mask | 0xffffffff00000000ull)));
+	emit_insn (gen_insv_immdi (dest, GEN_INT (i),
+				   GEN_INT ((val >> i) & 0xffff)));
       num_insns ++;
-
-      /* Now insert other two quarters.	 */
-      for (i = first_not_ffff_match + 16, mask <<= (first_not_ffff_match << 1);
-	   i < 64; i += 16, mask <<= 16)
-	{
-	  if ((val & mask) != mask)
-	    {
-	      if (generate)
-		emit_insn (gen_insv_immdi (dest, GEN_INT (i),
-					   GEN_INT ((val >> i) & 0xffff)));
-	      num_insns ++;
-	    }
-	}
-      return num_insns;
-    }
-
- simple_sequence:
-  first = true;
-  mask = 0xffff;
-  for (i = 0; i < 64; i += 16, mask <<= 16)
-    {
-      if ((val & mask) != 0)
-	{
-	  if (first)
-	    {
-	      if (generate)
-		emit_insn (gen_rtx_SET (VOIDmode, dest,
-					GEN_INT (val & mask)));
-	      num_insns ++;
-	      first = false;
-	    }
-	  else
-	    {
-	      if (generate)
-		emit_insn (gen_insv_immdi (dest, GEN_INT (i),
-					   GEN_INT ((val >> i) & 0xffff)));
-	      num_insns ++;
-	    }
-	}
     }
 
   return num_insns;
@@ -1471,9 +1406,9 @@ aarch64_expand_mov_immediate (rtx dest, rtx imm)
 	    }
 	  /* FALLTHRU */
 
-        case SYMBOL_SMALL_TPREL:
 	case SYMBOL_SMALL_ABSOLUTE:
 	case SYMBOL_TINY_ABSOLUTE:
+	case SYMBOL_TLSLE:
 	  aarch64_load_symref_appropriately (dest, imm, sty);
 	  return;
 
@@ -1763,6 +1698,9 @@ aarch64_layout_arg (cumulative_args_t pcum_v, machine_mode mode,
      and homogenous short-vector aggregates (HVA).  */
   if (allocate_nvrn)
     {
+      if (!TARGET_FLOAT)
+	aarch64_err_no_fpadvsimd (mode, "argument");
+
       if (nvrn + nregs <= NUM_FP_ARG_REGS)
 	{
 	  pcum->aapcs_nextnvrn = nvrn + nregs;
@@ -1889,6 +1827,17 @@ aarch64_init_cumulative_args (CUMULATIVE_ARGS *pcum,
   pcum->aapcs_stack_words = 0;
   pcum->aapcs_stack_size = 0;
 
+  if (!TARGET_FLOAT
+      && fndecl && TREE_PUBLIC (fndecl)
+      && fntype && fntype != error_mark_node)
+    {
+      const_tree type = TREE_TYPE (fntype);
+      machine_mode mode ATTRIBUTE_UNUSED; /* To pass pointer as argument.  */
+      int nregs ATTRIBUTE_UNUSED; /* Likewise.  */
+      if (aarch64_vfp_is_call_or_return_candidate (TYPE_MODE (type), type,
+						   &mode, &nregs, NULL))
+	aarch64_err_no_fpadvsimd (TYPE_MODE (type), "return type");
+    }
   return;
 }
 
@@ -2992,67 +2941,6 @@ aarch64_tls_referenced_p (rtx x)
 }
 
 
-static int
-aarch64_bitmasks_cmp (const void *i1, const void *i2)
-{
-  const unsigned HOST_WIDE_INT *imm1 = (const unsigned HOST_WIDE_INT *) i1;
-  const unsigned HOST_WIDE_INT *imm2 = (const unsigned HOST_WIDE_INT *) i2;
-
-  if (*imm1 < *imm2)
-    return -1;
-  if (*imm1 > *imm2)
-    return +1;
-  return 0;
-}
-
-
-static void
-aarch64_build_bitmask_table (void)
-{
-  unsigned HOST_WIDE_INT mask, imm;
-  unsigned int log_e, e, s, r;
-  unsigned int nimms = 0;
-
-  for (log_e = 1; log_e <= 6; log_e++)
-    {
-      e = 1 << log_e;
-      if (e == 64)
-	mask = ~(HOST_WIDE_INT) 0;
-      else
-	mask = ((HOST_WIDE_INT) 1 << e) - 1;
-      for (s = 1; s < e; s++)
-	{
-	  for (r = 0; r < e; r++)
-	    {
-	      /* set s consecutive bits to 1 (s < 64) */
-	      imm = ((unsigned HOST_WIDE_INT)1 << s) - 1;
-	      /* rotate right by r */
-	      if (r != 0)
-		imm = ((imm >> r) | (imm << (e - r))) & mask;
-	      /* replicate the constant depending on SIMD size */
-	      switch (log_e) {
-	      case 1: imm |= (imm <<  2);
-	      case 2: imm |= (imm <<  4);
-	      case 3: imm |= (imm <<  8);
-	      case 4: imm |= (imm << 16);
-	      case 5: imm |= (imm << 32);
-	      case 6:
-		break;
-	      default:
-		gcc_unreachable ();
-	      }
-	      gcc_assert (nimms < AARCH64_NUM_BITMASKS);
-	      aarch64_bitmasks[nimms++] = imm;
-	    }
-	}
-    }
-
-  gcc_assert (nimms == AARCH64_NUM_BITMASKS);
-  qsort (aarch64_bitmasks, nimms, sizeof (aarch64_bitmasks[0]),
-	 aarch64_bitmasks_cmp);
-}
-
-
 /* Return true if val can be encoded as a 12-bit unsigned immediate with
    a left shift of 0 or 12 bits.  */
 bool
@@ -3084,19 +2972,63 @@ aarch64_movw_imm (HOST_WIDE_INT val, machine_mode mode)
 	  || (val & (((HOST_WIDE_INT) 0xffff) << 16)) == val);
 }
 
+/* Multipliers for repeating bitmasks of width 32, 16, 8, 4, and 2.  */
+
+static const unsigned HOST_WIDE_INT bitmask_imm_mul[] =
+  {
+    0x0000000100000001ull,
+    0x0001000100010001ull,
+    0x0101010101010101ull,
+    0x1111111111111111ull,
+    0x5555555555555555ull,
+  };
+
 
 /* Return true if val is a valid bitmask immediate.  */
+
 bool
-aarch64_bitmask_imm (HOST_WIDE_INT val, machine_mode mode)
+aarch64_bitmask_imm (HOST_WIDE_INT val_in, machine_mode mode)
 {
-  if (GET_MODE_SIZE (mode) < 8)
-    {
-      /* Replicate bit pattern.  */
-      val &= (HOST_WIDE_INT) 0xffffffff;
-      val |= val << 32;
-    }
-  return bsearch (&val, aarch64_bitmasks, AARCH64_NUM_BITMASKS,
-		  sizeof (aarch64_bitmasks[0]), aarch64_bitmasks_cmp) != NULL;
+  unsigned HOST_WIDE_INT val, tmp, mask, first_one, next_one;
+  int bits;
+
+  /* Check for a single sequence of one bits and return quickly if so.
+     The special cases of all ones and all zeroes returns false.  */
+  val = (unsigned HOST_WIDE_INT) val_in;
+  tmp = val + (val & -val);
+
+  if (tmp == (tmp & -tmp))
+    return (val + 1) > 1;
+
+  /* Replicate 32-bit immediates so we can treat them as 64-bit.  */
+  if (mode == SImode)
+    val = (val << 32) | (val & 0xffffffff);
+
+  /* Invert if the immediate doesn't start with a zero bit - this means we
+     only need to search for sequences of one bits.  */
+  if (val & 1)
+    val = ~val;
+
+  /* Find the first set bit and set tmp to val with the first sequence of one
+     bits removed.  Return success if there is a single sequence of ones.  */
+  first_one = val & -val;
+  tmp = val & (val + first_one);
+
+  if (tmp == 0)
+    return true;
+
+  /* Find the next set bit and compute the difference in bit position.  */
+  next_one = tmp & -tmp;
+  bits = clz_hwi (first_one) - clz_hwi (next_one);
+  mask = val ^ tmp;
+
+  /* Check the bit position difference is a power of 2, and that the first
+     sequence of one bits fits within 'bits' bits.  */
+  if ((mask >> bits) != 0 || bits != (bits & -bits))
+    return false;
+
+  /* Check the sequence of one bits is repeated 64/bits times.  */
+  return val == mask * bitmask_imm_mul[__builtin_clz (bits) - 26];
 }
 
 
@@ -3372,6 +3304,18 @@ offset_12bit_unsigned_scaled_p (machine_mode mode, HOST_WIDE_INT offset)
 	  && offset % GET_MODE_SIZE (mode) == 0);
 }
 
+/* Return true if MODE is one of the modes for which we
+   support LDP/STP operations.  */
+
+static bool
+aarch64_mode_valid_for_sched_fusion_p (machine_mode mode)
+{
+  return mode == SImode || mode == DImode
+	 || mode == SFmode || mode == DFmode
+	 || (aarch64_vector_mode_supported_p (mode)
+	     && GET_MODE_SIZE (mode) == 8);
+}
+
 /* Return true if X is a valid address for machine mode MODE.  If it is,
    fill in INFO appropriately.  STRICT_P is true if REG_OK_STRICT is in
    effect.  OUTER_CODE is PARALLEL for a load/store pair.  */
@@ -3945,19 +3889,6 @@ aarch64_const_vec_all_same_int_p (rtx x, HOST_WIDE_INT val)
   return aarch64_const_vec_all_same_in_range_p (x, val, val);
 }
 
-static unsigned
-bit_count (unsigned HOST_WIDE_INT value)
-{
-  unsigned count = 0;
-
-  while (value)
-    {
-      count++;
-      value &= value - 1;
-    }
-
-  return count;
-}
 
 /* N Z C V.  */
 #define AARCH64_CC_V 1
@@ -4112,7 +4043,7 @@ aarch64_print_operand (FILE *f, rtx x, char code)
 	  return;
 	}
 
-      asm_fprintf (f, "%u", bit_count (INTVAL (x)));
+      asm_fprintf (f, "%u", popcount_hwi (INTVAL (x)));
       break;
 
     case 'H':
@@ -4263,6 +4194,7 @@ aarch64_print_operand (FILE *f, rtx x, char code)
 	  output_address (XEXP (x, 0));
 	  break;
 
+	case CONST:
 	case LABEL_REF:
 	case SYMBOL_REF:
 	  output_addr_const (asm_out_file, x);
@@ -4342,7 +4274,7 @@ aarch64_print_operand (FILE *f, rtx x, char code)
 	  asm_fprintf (asm_out_file, ":gottprel:");
 	  break;
 
-	case SYMBOL_SMALL_TPREL:
+	case SYMBOL_TLSLE:
 	  asm_fprintf (asm_out_file, ":tprel:");
 	  break;
 
@@ -4375,7 +4307,7 @@ aarch64_print_operand (FILE *f, rtx x, char code)
 	  asm_fprintf (asm_out_file, ":gottprel_lo12:");
 	  break;
 
-	case SYMBOL_SMALL_TPREL:
+	case SYMBOL_TLSLE:
 	  asm_fprintf (asm_out_file, ":tprel_lo12_nc:");
 	  break;
 
@@ -4393,7 +4325,7 @@ aarch64_print_operand (FILE *f, rtx x, char code)
 
       switch (aarch64_classify_symbolic_expression (x, SYMBOL_CONTEXT_ADR))
 	{
-	case SYMBOL_SMALL_TPREL:
+	case SYMBOL_TLSLE:
 	  asm_fprintf (asm_out_file, ":tprel_hi12:");
 	  break;
 	default:
@@ -4901,8 +4833,9 @@ aarch64_class_max_nregs (reg_class_t regclass, machine_mode mode)
     case FP_REGS:
     case FP_LO_REGS:
       return
-	aarch64_vector_mode_p (mode) ? (GET_MODE_SIZE (mode) + 15) / 16 :
-				       (GET_MODE_SIZE (mode) + 7) / 8;
+	aarch64_vector_mode_p (mode)
+	  ? (GET_MODE_SIZE (mode) + UNITS_PER_VREG - 1) / UNITS_PER_VREG
+	  : (GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;
     case STACK_REG:
       return 1;
 
@@ -5157,9 +5090,18 @@ aarch64_strip_extend (rtx x)
   return x;
 }
 
+/* Return true iff CODE is a shift supported in combination
+   with arithmetic instructions.  */
+
+static bool
+aarch64_shift_p (enum rtx_code code)
+{
+  return code == ASHIFT || code == ASHIFTRT || code == LSHIFTRT;
+}
+
 /* Helper function for rtx cost calculation.  Calculate the cost of
-   a MULT, which may be part of a multiply-accumulate rtx.  Return
-   the calculated cost of the expression, recursing manually in to
+   a MULT or ASHIFT, which may be part of a compound PLUS/MINUS rtx.
+   Return the calculated cost of the expression, recursing manually in to
    operands where needed.  */
 
 static int
@@ -5167,9 +5109,9 @@ aarch64_rtx_mult_cost (rtx x, int code, int outer, bool speed)
 {
   rtx op0, op1;
   const struct cpu_cost_table *extra_cost
-    = aarch64_tune_params->insn_extra_cost;
+    = aarch64_tune_params.insn_extra_cost;
   int cost = 0;
-  bool maybe_fma = (outer == PLUS || outer == MINUS);
+  bool compound_p = (outer == PLUS || outer == MINUS);
   machine_mode mode = GET_MODE (x);
 
   gcc_checking_assert (code == MULT);
@@ -5184,24 +5126,50 @@ aarch64_rtx_mult_cost (rtx x, int code, int outer, bool speed)
   if (GET_MODE_CLASS (mode) == MODE_INT)
     {
       /* The multiply will be canonicalized as a shift, cost it as such.  */
-      if (CONST_INT_P (op1)
-	  && exact_log2 (INTVAL (op1)) > 0)
+      if (aarch64_shift_p (GET_CODE (x))
+	  || (CONST_INT_P (op1)
+	      && exact_log2 (INTVAL (op1)) > 0))
 	{
+	  bool is_extend = GET_CODE (op0) == ZERO_EXTEND
+	                   || GET_CODE (op0) == SIGN_EXTEND;
 	  if (speed)
 	    {
-	      if (maybe_fma)
-		/* ADD (shifted register).  */
-		cost += extra_cost->alu.arith_shift;
+	      if (compound_p)
+	        {
+	          if (REG_P (op1))
+		    /* ARITH + shift-by-register.  */
+		    cost += extra_cost->alu.arith_shift_reg;
+		  else if (is_extend)
+		    /* ARITH + extended register.  We don't have a cost field
+		       for ARITH+EXTEND+SHIFT, so use extend_arith here.  */
+		    cost += extra_cost->alu.extend_arith;
+		  else
+		    /* ARITH + shift-by-immediate.  */
+		    cost += extra_cost->alu.arith_shift;
+		}
 	      else
 		/* LSL (immediate).  */
-		cost += extra_cost->alu.shift;
+	        cost += extra_cost->alu.shift;
+
 	    }
+	  /* Strip extends as we will have costed them in the case above.  */
+	  if (is_extend)
+	    op0 = aarch64_strip_extend (op0);
 
 	  cost += rtx_cost (op0, GET_CODE (op0), 0, speed);
 
 	  return cost;
 	}
 
+      /* MNEG or [US]MNEGL.  Extract the NEG operand and indicate that it's a
+	 compound and let the below cases handle it.  After all, MNEG is a
+	 special-case alias of MSUB.  */
+      if (GET_CODE (op0) == NEG)
+	{
+	  op0 = XEXP (op0, 0);
+	  compound_p = true;
+	}
+
       /* Integer multiplies or FMAs have zero/sign extending variants.  */
       if ((GET_CODE (op0) == ZERO_EXTEND
 	   && GET_CODE (op1) == ZERO_EXTEND)
@@ -5213,8 +5181,8 @@ aarch64_rtx_mult_cost (rtx x, int code, int outer, bool speed)
 
 	  if (speed)
 	    {
-	      if (maybe_fma)
-		/* MADD/SMADDL/UMADDL.  */
+	      if (compound_p)
+		/* SMADDL/UMADDL/UMSUBL/SMSUBL.  */
 		cost += extra_cost->mult[0].extend_add;
 	      else
 		/* MUL/SMULL/UMULL.  */
@@ -5224,15 +5192,15 @@ aarch64_rtx_mult_cost (rtx x, int code, int outer, bool speed)
 	  return cost;
 	}
 
-      /* This is either an integer multiply or an FMA.  In both cases
+      /* This is either an integer multiply or a MADD.  In both cases
 	 we want to recurse and cost the operands.  */
       cost += rtx_cost (op0, MULT, 0, speed)
 	      + rtx_cost (op1, MULT, 1, speed);
 
       if (speed)
 	{
-	  if (maybe_fma)
-	    /* MADD.  */
+	  if (compound_p)
+	    /* MADD/MSUB.  */
 	    cost += extra_cost->mult[mode == DImode].add;
 	  else
 	    /* MUL.  */
@@ -5250,7 +5218,7 @@ aarch64_rtx_mult_cost (rtx x, int code, int outer, bool speed)
 	     which case FNMUL is different than FMUL with operand negation.  */
 	  bool neg0 = GET_CODE (op0) == NEG;
 	  bool neg1 = GET_CODE (op1) == NEG;
-	  if (maybe_fma || !flag_rounding_math || (neg0 && neg1))
+	  if (compound_p || !flag_rounding_math || (neg0 && neg1))
 	    {
 	      if (neg0)
 		op0 = XEXP (op0, 0);
@@ -5258,7 +5226,7 @@ aarch64_rtx_mult_cost (rtx x, int code, int outer, bool speed)
 		op1 = XEXP (op1, 0);
 	    }
 
-	  if (maybe_fma)
+	  if (compound_p)
 	    /* FMADD/FNMADD/FNMSUB/FMSUB.  */
 	    cost += extra_cost->fp[mode == DFmode].fma;
 	  else
@@ -5279,7 +5247,7 @@ aarch64_address_cost (rtx x,
 		      bool speed)
 {
   enum rtx_code c = GET_CODE (x);
-  const struct cpu_addrcost_table *addr_cost = aarch64_tune_params->addr_cost;
+  const struct cpu_addrcost_table *addr_cost = aarch64_tune_params.addr_cost;
   struct aarch64_address_info info;
   int cost = 0;
   info.shift = 0;
@@ -5367,6 +5335,23 @@ aarch64_address_cost (rtx x,
   return cost;
 }
 
+/* Return the cost of a branch.  If SPEED_P is true then the compiler is
+   optimizing for speed.  If PREDICTABLE_P is true then the branch is predicted
+   to be taken.  */
+
+int
+aarch64_branch_cost (bool speed_p, bool predictable_p)
+{
+  /* When optimizing for speed, use the cost of unpredictable branches.  */
+  const struct cpu_branch_cost *branch_costs =
+    aarch64_tune_params.branch_costs;
+
+  if (!speed_p || predictable_p)
+    return branch_costs->predictable;
+  else
+    return branch_costs->unpredictable;
+}
+
 /* Return true if the RTX X in mode MODE is a zero or sign extract
    usable in an ADD or SUB (extended register) instruction.  */
 static bool
@@ -5415,6 +5400,51 @@ aarch64_frint_unspec_p (unsigned int u)
     }
 }
 
+/* Return true iff X is an rtx that will match an extr instruction
+   i.e. as described in the *extr<mode>5_insn family of patterns.
+   OP0 and OP1 will be set to the operands of the shifts involved
+   on success and will be NULL_RTX otherwise.  */
+
+static bool
+aarch64_extr_rtx_p (rtx x, rtx *res_op0, rtx *res_op1)
+{
+  rtx op0, op1;
+  machine_mode mode = GET_MODE (x);
+
+  *res_op0 = NULL_RTX;
+  *res_op1 = NULL_RTX;
+
+  if (GET_CODE (x) != IOR)
+    return false;
+
+  op0 = XEXP (x, 0);
+  op1 = XEXP (x, 1);
+
+  if ((GET_CODE (op0) == ASHIFT && GET_CODE (op1) == LSHIFTRT)
+      || (GET_CODE (op1) == ASHIFT && GET_CODE (op0) == LSHIFTRT))
+    {
+     /* Canonicalise locally to ashift in op0, lshiftrt in op1.  */
+      if (GET_CODE (op1) == ASHIFT)
+        std::swap (op0, op1);
+
+      if (!CONST_INT_P (XEXP (op0, 1)) || !CONST_INT_P (XEXP (op1, 1)))
+        return false;
+
+      unsigned HOST_WIDE_INT shft_amnt_0 = UINTVAL (XEXP (op0, 1));
+      unsigned HOST_WIDE_INT shft_amnt_1 = UINTVAL (XEXP (op1, 1));
+
+      if (shft_amnt_0 < GET_MODE_BITSIZE (mode)
+          && shft_amnt_0 + shft_amnt_1 == GET_MODE_BITSIZE (mode))
+        {
+          *res_op0 = XEXP (op0, 0);
+          *res_op1 = XEXP (op1, 0);
+          return true;
+        }
+    }
+
+  return false;
+}
+
 /* Calculate the cost of calculating (if_then_else (OP0) (OP1) (OP2)),
    storing it in *COST.  Result is true if the total cost of the operation
    has now been calculated.  */
@@ -5497,7 +5527,7 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,
 {
   rtx op0, op1, op2;
   const struct cpu_cost_table *extra_cost
-    = aarch64_tune_params->insn_extra_cost;
+    = aarch64_tune_params.insn_extra_cost;
   machine_mode mode = GET_MODE (x);
 
   /* By default, assume that everything has equivalent cost to the
@@ -5505,16 +5535,6 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,
      above this default.  */
   *cost = COSTS_N_INSNS (1);
 
-  /* TODO: The cost infrastructure currently does not handle
-     vector operations.  Assume that all vector operations
-     are equally expensive.  */
-  if (VECTOR_MODE_P (mode))
-    {
-      if (speed)
-	*cost += extra_cost->vect.alu;
-      return true;
-    }
-
   switch (code)
     {
     case SET:
@@ -5529,7 +5549,9 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,
 	  if (speed)
 	    {
 	      rtx address = XEXP (op0, 0);
-	      if (GET_MODE_CLASS (mode) == MODE_INT)
+	      if (VECTOR_MODE_P (mode))
+		*cost += extra_cost->ldst.storev;
+	      else if (GET_MODE_CLASS (mode) == MODE_INT)
 		*cost += extra_cost->ldst.store;
 	      else if (mode == SFmode)
 		*cost += extra_cost->ldst.storef;
@@ -5550,15 +5572,22 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,
 
 	  /* Fall through.  */
 	case REG:
+	  /* The cost is one per vector-register copied.  */
+	  if (VECTOR_MODE_P (GET_MODE (op0)) && REG_P (op1))
+	    {
+	      int n_minus_1 = (GET_MODE_SIZE (GET_MODE (op0)) - 1)
+			      / GET_MODE_SIZE (V4SImode);
+	      *cost = COSTS_N_INSNS (n_minus_1 + 1);
+	    }
 	  /* const0_rtx is in general free, but we will use an
 	     instruction to set a register to 0.  */
-          if (REG_P (op1) || op1 == const0_rtx)
-            {
-              /* The cost is 1 per register copied.  */
-              int n_minus_1 = (GET_MODE_SIZE (GET_MODE (op0)) - 1)
+	  else if (REG_P (op1) || op1 == const0_rtx)
+	    {
+	      /* The cost is 1 per register copied.  */
+	      int n_minus_1 = (GET_MODE_SIZE (GET_MODE (op0)) - 1)
 			      / UNITS_PER_WORD;
-              *cost = COSTS_N_INSNS (n_minus_1 + 1);
-            }
+	      *cost = COSTS_N_INSNS (n_minus_1 + 1);
+	    }
           else
 	    /* Cost is just the cost of the RHS of the set.  */
 	    *cost += rtx_cost (op1, SET, 1, speed);
@@ -5656,7 +5685,9 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,
 	     approximation for the additional cost of the addressing
 	     mode.  */
 	  rtx address = XEXP (x, 0);
-	  if (GET_MODE_CLASS (mode) == MODE_INT)
+	  if (VECTOR_MODE_P (mode))
+	    *cost += extra_cost->ldst.loadv;
+	  else if (GET_MODE_CLASS (mode) == MODE_INT)
 	    *cost += extra_cost->ldst.load;
 	  else if (mode == SFmode)
 	    *cost += extra_cost->ldst.loadf;
@@ -5673,6 +5704,16 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,
     case NEG:
       op0 = XEXP (x, 0);
 
+      if (VECTOR_MODE_P (mode))
+	{
+	  if (speed)
+	    {
+	      /* FNEG.  */
+	      *cost += extra_cost->vect.alu;
+	    }
+	  return false;
+	}
+
       if (GET_MODE_CLASS (GET_MODE (x)) == MODE_INT)
        {
           if (GET_RTX_CLASS (GET_CODE (op0)) == RTX_COMPARE
@@ -5717,7 +5758,12 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,
     case CLRSB:
     case CLZ:
       if (speed)
-        *cost += extra_cost->alu.clz;
+	{
+	  if (VECTOR_MODE_P (mode))
+	    *cost += extra_cost->vect.alu;
+	  else
+	    *cost += extra_cost->alu.clz;
+	}
 
       return false;
 
@@ -5796,12 +5842,27 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,
 
           if (CONST_DOUBLE_P (op1) && aarch64_float_const_zero_rtx_p (op1))
             {
+              *cost += rtx_cost (op0, COMPARE, 0, speed);
               /* FCMP supports constant 0.0 for no extra cost. */
               return true;
             }
           return false;
         }
 
+      if (VECTOR_MODE_P (mode))
+	{
+	  /* Vector compare.  */
+	  if (speed)
+	    *cost += extra_cost->vect.alu;
+
+	  if (aarch64_float_const_zero_rtx_p (op1))
+	    {
+	      /* Vector cm (eq|ge|gt|lt|le) supports constant 0.0 for no extra
+		 cost.  */
+	      return true;
+	    }
+	  return false;
+	}
       return false;
 
     case MINUS:
@@ -5810,6 +5871,8 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,
 	op1 = XEXP (x, 1);
 
 cost_minus:
+	*cost += rtx_cost (op0, MINUS, 0, speed);
+
 	/* Detect valid immediates.  */
 	if ((GET_MODE_CLASS (mode) == MODE_INT
 	     || (GET_MODE_CLASS (mode) == MODE_CC
@@ -5817,20 +5880,17 @@ cost_minus:
 	    && CONST_INT_P (op1)
 	    && aarch64_uimm12_shift (INTVAL (op1)))
 	  {
-	    *cost += rtx_cost (op0, MINUS, 0, speed);
-
 	    if (speed)
 	      /* SUB(S) (immediate).  */
 	      *cost += extra_cost->alu.arith;
 	    return true;
-
 	  }
 
 	/* Look for SUB (extended register).  */
         if (aarch64_rtx_arith_op_extract_p (op1, mode))
 	  {
 	    if (speed)
-	      *cost += extra_cost->alu.arith_shift;
+	      *cost += extra_cost->alu.extend_arith;
 
 	    *cost += rtx_cost (XEXP (XEXP (op1, 0), 0),
 			       (enum rtx_code) GET_CODE (op1),
@@ -5842,13 +5902,12 @@ cost_minus:
 
 	/* Cost this as an FMA-alike operation.  */
 	if ((GET_CODE (new_op1) == MULT
-	     || GET_CODE (new_op1) == ASHIFT)
+	     || aarch64_shift_p (GET_CODE (new_op1)))
 	    && code != COMPARE)
 	  {
 	    *cost += aarch64_rtx_mult_cost (new_op1, MULT,
 					    (enum rtx_code) code,
 					    speed);
-	    *cost += rtx_cost (op0, MINUS, 0, speed);
 	    return true;
 	  }
 
@@ -5856,12 +5915,21 @@ cost_minus:
 
 	if (speed)
 	  {
-	    if (GET_MODE_CLASS (mode) == MODE_INT)
-	      /* SUB(S).  */
-	      *cost += extra_cost->alu.arith;
+	    if (VECTOR_MODE_P (mode))
+	      {
+		/* Vector SUB.  */
+		*cost += extra_cost->vect.alu;
+	      }
+	    else if (GET_MODE_CLASS (mode) == MODE_INT)
+	      {
+		/* SUB(S).  */
+		*cost += extra_cost->alu.arith;
+	      }
 	    else if (GET_MODE_CLASS (mode) == MODE_FLOAT)
-	      /* FSUB.  */
-	      *cost += extra_cost->fp[mode == DFmode].addsub;
+	      {
+		/* FSUB.  */
+		*cost += extra_cost->fp[mode == DFmode].addsub;
+	      }
 	  }
 	return true;
       }
@@ -5895,11 +5963,13 @@ cost_plus:
 	    return true;
 	  }
 
+	*cost += rtx_cost (op1, PLUS, 1, speed);
+
 	/* Look for ADD (extended register).  */
         if (aarch64_rtx_arith_op_extract_p (op0, mode))
 	  {
 	    if (speed)
-	      *cost += extra_cost->alu.arith_shift;
+	      *cost += extra_cost->alu.extend_arith;
 
 	    *cost += rtx_cost (XEXP (XEXP (op0, 0), 0),
 			       (enum rtx_code) GET_CODE (op0),
@@ -5912,25 +5982,32 @@ cost_plus:
 	new_op0 = aarch64_strip_extend (op0);
 
 	if (GET_CODE (new_op0) == MULT
-	    || GET_CODE (new_op0) == ASHIFT)
+	    || aarch64_shift_p (GET_CODE (new_op0)))
 	  {
 	    *cost += aarch64_rtx_mult_cost (new_op0, MULT, PLUS,
 					    speed);
-	    *cost += rtx_cost (op1, PLUS, 1, speed);
 	    return true;
 	  }
 
-	*cost += (rtx_cost (new_op0, PLUS, 0, speed)
-		  + rtx_cost (op1, PLUS, 1, speed));
+	*cost += rtx_cost (new_op0, PLUS, 0, speed);
 
 	if (speed)
 	  {
-	    if (GET_MODE_CLASS (mode) == MODE_INT)
-	      /* ADD.  */
-	      *cost += extra_cost->alu.arith;
+	    if (VECTOR_MODE_P (mode))
+	      {
+		/* Vector ADD.  */
+		*cost += extra_cost->vect.alu;
+	      }
+	    else if (GET_MODE_CLASS (mode) == MODE_INT)
+	      {
+		/* ADD.  */
+		*cost += extra_cost->alu.arith;
+	      }
 	    else if (GET_MODE_CLASS (mode) == MODE_FLOAT)
-	      /* FADD.  */
-	      *cost += extra_cost->fp[mode == DFmode].addsub;
+	      {
+		/* FADD.  */
+		*cost += extra_cost->fp[mode == DFmode].addsub;
+	      }
 	  }
 	return true;
       }
@@ -5939,8 +6016,12 @@ cost_plus:
       *cost = COSTS_N_INSNS (1);
 
       if (speed)
-        *cost += extra_cost->alu.rev;
-
+	{
+	  if (VECTOR_MODE_P (mode))
+	    *cost += extra_cost->vect.alu;
+	  else
+	    *cost += extra_cost->alu.rev;
+	}
       return false;
 
     case IOR:
@@ -5948,8 +6029,22 @@ cost_plus:
         {
           *cost = COSTS_N_INSNS (1);
 
+	  if (speed)
+	    {
+	      if (VECTOR_MODE_P (mode))
+		*cost += extra_cost->vect.alu;
+	      else
+		*cost += extra_cost->alu.rev;
+	    }
+	  return true;
+        }
+
+      if (aarch64_extr_rtx_p (x, &op0, &op1))
+        {
+          *cost += rtx_cost (op0, IOR, 0, speed)
+                   + rtx_cost (op1, IOR, 1, speed);
           if (speed)
-            *cost += extra_cost->alu.rev;
+            *cost += extra_cost->alu.shift;
 
           return true;
         }
@@ -5960,6 +6055,13 @@ cost_plus:
       op0 = XEXP (x, 0);
       op1 = XEXP (x, 1);
 
+      if (VECTOR_MODE_P (mode))
+	{
+	  if (speed)
+	    *cost += extra_cost->vect.alu;
+	  return true;
+	}
+
       if (code == AND
           && GET_CODE (op0) == MULT
           && CONST_INT_P (XEXP (op0, 1))
@@ -6025,13 +6127,52 @@ cost_plus:
       return false;
 
     case NOT:
+      x = XEXP (x, 0);
+      op0 = aarch64_strip_shift (x);
+
+      if (VECTOR_MODE_P (mode))
+	{
+	  /* Vector NOT.  */
+	  *cost += extra_cost->vect.alu;
+	  return false;
+	}
+
+      /* MVN-shifted-reg.  */
+      if (op0 != x)
+        {
+          *cost += rtx_cost (op0, (enum rtx_code) code, 0, speed);
+
+          if (speed)
+            *cost += extra_cost->alu.log_shift;
+
+          return true;
+        }
+      /* EON can have two forms: (xor (not a) b) but also (not (xor a b)).
+         Handle the second form here taking care that 'a' in the above can
+         be a shift.  */
+      else if (GET_CODE (op0) == XOR)
+        {
+          rtx newop0 = XEXP (op0, 0);
+          rtx newop1 = XEXP (op0, 1);
+          rtx op0_stripped = aarch64_strip_shift (newop0);
+
+          *cost += rtx_cost (newop1, (enum rtx_code) code, 1, speed)
+                   + rtx_cost (op0_stripped, XOR, 0, speed);
+
+          if (speed)
+            {
+              if (op0_stripped != newop0)
+                *cost += extra_cost->alu.log_shift;
+              else
+                *cost += extra_cost->alu.logical;
+            }
+
+          return true;
+        }
       /* MVN.  */
       if (speed)
 	*cost += extra_cost->alu.logical;
 
-      /* The logical instruction could have the shifted register form,
-         but the cost is the same if the shift is processed as a separate
-         instruction, so we don't bother with it here.  */
       return false;
 
     case ZERO_EXTEND:
@@ -6067,10 +6208,19 @@ cost_plus:
 	  return true;
 	}
 
-      /* UXTB/UXTH.  */
       if (speed)
-	*cost += extra_cost->alu.extend;
-
+	{
+	  if (VECTOR_MODE_P (mode))
+	    {
+	      /* UMOV.  */
+	      *cost += extra_cost->vect.alu;
+	    }
+	  else
+	    {
+	      /* UXTB/UXTH.  */
+	      *cost += extra_cost->alu.extend;
+	    }
+	}
       return false;
 
     case SIGN_EXTEND:
@@ -6090,7 +6240,12 @@ cost_plus:
 	}
 
       if (speed)
-	*cost += extra_cost->alu.extend;
+	{
+	  if (VECTOR_MODE_P (mode))
+	    *cost += extra_cost->vect.alu;
+	  else
+	    *cost += extra_cost->alu.extend;
+	}
       return false;
 
     case ASHIFT:
@@ -6099,10 +6254,20 @@ cost_plus:
 
       if (CONST_INT_P (op1))
         {
-	  /* LSL (immediate), UBMF, UBFIZ and friends.  These are all
-	     aliases.  */
 	  if (speed)
-	    *cost += extra_cost->alu.shift;
+	    {
+	      if (VECTOR_MODE_P (mode))
+		{
+		  /* Vector shift (immediate).  */
+		  *cost += extra_cost->vect.alu;
+		}
+	      else
+		{
+		  /* LSL (immediate), UBMF, UBFIZ and friends.  These are all
+		     aliases.  */
+		  *cost += extra_cost->alu.shift;
+		}
+	    }
 
           /* We can incorporate zero/sign extend for free.  */
           if (GET_CODE (op0) == ZERO_EXTEND
@@ -6114,10 +6279,19 @@ cost_plus:
         }
       else
         {
-	  /* LSLV.  */
 	  if (speed)
-	    *cost += extra_cost->alu.shift_reg;
-
+	    {
+	      if (VECTOR_MODE_P (mode))
+		{
+		  /* Vector shift (register).  */
+		  *cost += extra_cost->vect.alu;
+		}
+	      else
+		{
+		  /* LSLV.  */
+		  *cost += extra_cost->alu.shift_reg;
+		}
+	    }
 	  return false;  /* All arguments need to be in registers.  */
         }
 
@@ -6132,7 +6306,12 @@ cost_plus:
 	{
 	  /* ASR (immediate) and friends.  */
 	  if (speed)
-	    *cost += extra_cost->alu.shift;
+	    {
+	      if (VECTOR_MODE_P (mode))
+		*cost += extra_cost->vect.alu;
+	      else
+		*cost += extra_cost->alu.shift;
+	    }
 
 	  *cost += rtx_cost (op0, (enum rtx_code) code, 0, speed);
 	  return true;
@@ -6142,8 +6321,12 @@ cost_plus:
 
 	  /* ASR (register) and friends.  */
 	  if (speed)
-	    *cost += extra_cost->alu.shift_reg;
-
+	    {
+	      if (VECTOR_MODE_P (mode))
+		*cost += extra_cost->vect.alu;
+	      else
+		*cost += extra_cost->alu.shift_reg;
+	    }
 	  return false;  /* All arguments need to be in registers.  */
 	}
 
@@ -6191,7 +6374,12 @@ cost_plus:
     case SIGN_EXTRACT:
       /* UBFX/SBFX.  */
       if (speed)
-	*cost += extra_cost->alu.bfx;
+	{
+	  if (VECTOR_MODE_P (mode))
+	    *cost += extra_cost->vect.alu;
+	  else
+	    *cost += extra_cost->alu.bfx;
+	}
 
       /* We can trust that the immediates used will be correct (there
 	 are no by-register forms), so we need only cost op0.  */
@@ -6208,7 +6396,9 @@ cost_plus:
     case UMOD:
       if (speed)
 	{
-	  if (GET_MODE_CLASS (GET_MODE (x)) == MODE_INT)
+	  if (VECTOR_MODE_P (mode))
+	    *cost += extra_cost->vect.alu;
+	  else if (GET_MODE_CLASS (GET_MODE (x)) == MODE_INT)
 	    *cost += (extra_cost->mult[GET_MODE (x) == DImode].add
 		      + extra_cost->mult[GET_MODE (x) == DImode].idiv);
 	  else if (GET_MODE (x) == DFmode)
@@ -6225,7 +6415,9 @@ cost_plus:
     case SQRT:
       if (speed)
 	{
-	  if (GET_MODE_CLASS (mode) == MODE_INT)
+	  if (VECTOR_MODE_P (mode))
+	    *cost += extra_cost->vect.alu;
+	  else if (GET_MODE_CLASS (mode) == MODE_INT)
 	    /* There is no integer SQRT, so only DIV and UDIV can get
 	       here.  */
 	    *cost += extra_cost->mult[mode == DImode].idiv;
@@ -6257,7 +6449,12 @@ cost_plus:
       op2 = XEXP (x, 2);
 
       if (speed)
-	*cost += extra_cost->fp[mode == DFmode].fma;
+	{
+	  if (VECTOR_MODE_P (mode))
+	    *cost += extra_cost->vect.alu;
+	  else
+	    *cost += extra_cost->fp[mode == DFmode].fma;
+	}
 
       /* FMSUB, FNMADD, and FNMSUB are free.  */
       if (GET_CODE (op0) == NEG)
@@ -6295,14 +6492,36 @@ cost_plus:
       *cost += rtx_cost (op2, FMA, 2, speed);
       return true;
 
+    case FLOAT:
+    case UNSIGNED_FLOAT:
+      if (speed)
+	*cost += extra_cost->fp[mode == DFmode].fromint;
+      return false;
+
     case FLOAT_EXTEND:
       if (speed)
-	*cost += extra_cost->fp[mode == DFmode].widen;
+	{
+	  if (VECTOR_MODE_P (mode))
+	    {
+	      /*Vector truncate.  */
+	      *cost += extra_cost->vect.alu;
+	    }
+	  else
+	    *cost += extra_cost->fp[mode == DFmode].widen;
+	}
       return false;
 
     case FLOAT_TRUNCATE:
       if (speed)
-	*cost += extra_cost->fp[mode == DFmode].narrow;
+	{
+	  if (VECTOR_MODE_P (mode))
+	    {
+	      /*Vector conversion.  */
+	      *cost += extra_cost->vect.alu;
+	    }
+	  else
+	    *cost += extra_cost->fp[mode == DFmode].narrow;
+	}
       return false;
 
     case FIX:
@@ -6323,15 +6542,37 @@ cost_plus:
         }
 
       if (speed)
-        *cost += extra_cost->fp[GET_MODE (x) == DFmode].toint;
-
+	{
+	  if (VECTOR_MODE_P (mode))
+	    *cost += extra_cost->vect.alu;
+	  else
+	    *cost += extra_cost->fp[GET_MODE (x) == DFmode].toint;
+	}
       *cost += rtx_cost (x, (enum rtx_code) code, 0, speed);
       return true;
 
     case ABS:
-      if (GET_MODE_CLASS (mode) == MODE_FLOAT)
+      if (VECTOR_MODE_P (mode))
+	{
+	  /* ABS (vector).  */
+	  if (speed)
+	    *cost += extra_cost->vect.alu;
+	}
+      else if (GET_MODE_CLASS (mode) == MODE_FLOAT)
 	{
-	  /* FABS and FNEG are analogous.  */
+	  op0 = XEXP (x, 0);
+
+	  /* FABD, which is analogous to FADD.  */
+	  if (GET_CODE (op0) == MINUS)
+	    {
+	      *cost += rtx_cost (XEXP (op0, 0), MINUS, 0, speed);
+			+ rtx_cost (XEXP (op0, 1), MINUS, 1, speed);
+	      if (speed)
+		*cost += extra_cost->fp[mode == DFmode].addsub;
+
+	      return true;
+	    }
+	  /* Simple FABS is analogous to FNEG.  */
 	  if (speed)
 	    *cost += extra_cost->fp[mode == DFmode].neg;
 	}
@@ -6350,10 +6591,15 @@ cost_plus:
     case SMIN:
       if (speed)
 	{
-	  /* FMAXNM/FMINNM/FMAX/FMIN.
-	     TODO: This may not be accurate for all implementations, but
-	     we do not model this in the cost tables.  */
-	  *cost += extra_cost->fp[mode == DFmode].addsub;
+	  if (VECTOR_MODE_P (mode))
+	    *cost += extra_cost->vect.alu;
+	  else
+	    {
+	      /* FMAXNM/FMINNM/FMAX/FMIN.
+	         TODO: This may not be accurate for all implementations, but
+	         we do not model this in the cost tables.  */
+	      *cost += extra_cost->fp[mode == DFmode].addsub;
+	    }
 	}
       return false;
 
@@ -6447,7 +6693,7 @@ aarch64_register_move_cost (machine_mode mode,
   enum reg_class from = (enum reg_class) from_i;
   enum reg_class to = (enum reg_class) to_i;
   const struct cpu_regmove_cost *regmove_cost
-    = aarch64_tune_params->regmove_cost;
+    = aarch64_tune_params.regmove_cost;
 
   /* Caller save and pointer regs are equivalent to GENERAL_REGS.  */
   if (to == CALLER_SAVE_REGS || to == POINTER_REGS)
@@ -6502,14 +6748,14 @@ aarch64_memory_move_cost (machine_mode mode ATTRIBUTE_UNUSED,
 			  reg_class_t rclass ATTRIBUTE_UNUSED,
 			  bool in ATTRIBUTE_UNUSED)
 {
-  return aarch64_tune_params->memmov_cost;
+  return aarch64_tune_params.memmov_cost;
 }
 
 /* Return the number of instructions that can be issued per cycle.  */
 static int
 aarch64_sched_issue_rate (void)
 {
-  return aarch64_tune_params->issue_rate;
+  return aarch64_tune_params.issue_rate;
 }
 
 static int
@@ -6533,44 +6779,44 @@ aarch64_builtin_vectorization_cost (enum vect_cost_for_stmt type_of_cost,
   switch (type_of_cost)
     {
       case scalar_stmt:
-	return aarch64_tune_params->vec_costs->scalar_stmt_cost;
+	return aarch64_tune_params.vec_costs->scalar_stmt_cost;
 
       case scalar_load:
-	return aarch64_tune_params->vec_costs->scalar_load_cost;
+	return aarch64_tune_params.vec_costs->scalar_load_cost;
 
       case scalar_store:
-	return aarch64_tune_params->vec_costs->scalar_store_cost;
+	return aarch64_tune_params.vec_costs->scalar_store_cost;
 
       case vector_stmt:
-	return aarch64_tune_params->vec_costs->vec_stmt_cost;
+	return aarch64_tune_params.vec_costs->vec_stmt_cost;
 
       case vector_load:
-	return aarch64_tune_params->vec_costs->vec_align_load_cost;
+	return aarch64_tune_params.vec_costs->vec_align_load_cost;
 
       case vector_store:
-	return aarch64_tune_params->vec_costs->vec_store_cost;
+	return aarch64_tune_params.vec_costs->vec_store_cost;
 
       case vec_to_scalar:
-	return aarch64_tune_params->vec_costs->vec_to_scalar_cost;
+	return aarch64_tune_params.vec_costs->vec_to_scalar_cost;
 
       case scalar_to_vec:
-	return aarch64_tune_params->vec_costs->scalar_to_vec_cost;
+	return aarch64_tune_params.vec_costs->scalar_to_vec_cost;
 
       case unaligned_load:
-	return aarch64_tune_params->vec_costs->vec_unalign_load_cost;
+	return aarch64_tune_params.vec_costs->vec_unalign_load_cost;
 
       case unaligned_store:
-	return aarch64_tune_params->vec_costs->vec_unalign_store_cost;
+	return aarch64_tune_params.vec_costs->vec_unalign_store_cost;
 
       case cond_branch_taken:
-	return aarch64_tune_params->vec_costs->cond_taken_branch_cost;
+	return aarch64_tune_params.vec_costs->cond_taken_branch_cost;
 
       case cond_branch_not_taken:
-	return aarch64_tune_params->vec_costs->cond_not_taken_branch_cost;
+	return aarch64_tune_params.vec_costs->cond_not_taken_branch_cost;
 
       case vec_perm:
       case vec_promote_demote:
-	return aarch64_tune_params->vec_costs->vec_stmt_cost;
+	return aarch64_tune_params.vec_costs->vec_stmt_cost;
 
       case vec_construct:
         elements = TYPE_VECTOR_SUBPARTS (vectype);
@@ -6615,12 +6861,26 @@ aarch64_add_stmt_cost (void *data, int count, enum vect_cost_for_stmt kind,
   return retval;
 }
 
-static void initialize_aarch64_code_model (void);
+static void initialize_aarch64_code_model (struct gcc_options *);
 
-/* Parse the architecture extension string.  */
+/* Enum describing the various ways that the
+   aarch64_parse_{arch,tune,cpu,extension} functions can fail.
+   This way their callers can choose what kind of error to give.  */
 
-static void
-aarch64_parse_extension (char *str)
+enum aarch64_parse_opt_result
+{
+  AARCH64_PARSE_OK,			/* Parsing was successful.  */
+  AARCH64_PARSE_MISSING_ARG,		/* Missing argument.  */
+  AARCH64_PARSE_INVALID_FEATURE,	/* Invalid feature modifier.  */
+  AARCH64_PARSE_INVALID_ARG		/* Invalid arch, tune, cpu arg.  */
+};
+
+/* Parse the architecture extension string STR and update ISA_FLAGS
+   with the architecture features turned on or off.  Return a
+   aarch64_parse_opt_result describing the result.  */
+
+static enum aarch64_parse_opt_result
+aarch64_parse_extension (char *str, unsigned long *isa_flags)
 {
   /* The extension string is parsed left to right.  */
   const struct aarch64_option_extension *opt = NULL;
@@ -6651,11 +6911,8 @@ aarch64_parse_extension (char *str)
 	adding_ext = 1;
 
       if (len == 0)
-	{
-	  error ("missing feature modifier after %qs", adding_ext ? "+"
-	                                                          : "+no");
-	  return;
-	}
+	return AARCH64_PARSE_MISSING_ARG;
+
 
       /* Scan over the extensions table trying to find an exact match.  */
       for (opt = all_extensions; opt->name != NULL; opt++)
@@ -6664,9 +6921,9 @@ aarch64_parse_extension (char *str)
 	    {
 	      /* Add or remove the extension.  */
 	      if (adding_ext)
-		aarch64_isa_flags |= opt->flags_on;
+		*isa_flags |= opt->flags_on;
 	      else
-		aarch64_isa_flags &= ~(opt->flags_off);
+		*isa_flags &= ~(opt->flags_off);
 	      break;
 	    }
 	}
@@ -6674,27 +6931,30 @@ aarch64_parse_extension (char *str)
       if (opt->name == NULL)
 	{
 	  /* Extension not found in list.  */
-	  error ("unknown feature modifier %qs", str);
-	  return;
+	  return AARCH64_PARSE_INVALID_FEATURE;
 	}
 
       str = ext;
     };
 
-  return;
+  return AARCH64_PARSE_OK;
 }
 
-/* Parse the ARCH string.  */
+/* Parse the TO_PARSE string and put the architecture struct that it
+   selects into RES and the architectural features into ISA_FLAGS.
+   Return an aarch64_parse_opt_result describing the parse result.
+   If there is an error parsing, RES and ISA_FLAGS are left unchanged.  */
 
-static void
-aarch64_parse_arch (void)
+static enum aarch64_parse_opt_result
+aarch64_parse_arch (const char *to_parse, const struct processor **res,
+		    unsigned long *isa_flags)
 {
   char *ext;
   const struct processor *arch;
-  char *str = (char *) alloca (strlen (aarch64_arch_string) + 1);
+  char *str = (char *) alloca (strlen (to_parse) + 1);
   size_t len;
 
-  strcpy (str, aarch64_arch_string);
+  strcpy (str, to_parse);
 
   ext = strchr (str, '+');
 
@@ -6704,54 +6964,52 @@ aarch64_parse_arch (void)
     len = strlen (str);
 
   if (len == 0)
-    {
-      error ("missing arch name in -march=%qs", str);
-      return;
-    }
+    return AARCH64_PARSE_MISSING_ARG;
+
 
-  /* Loop through the list of supported ARCHs to find a match.  */
+  /* Loop through the list of supported ARCHes to find a match.  */
   for (arch = all_architectures; arch->name != NULL; arch++)
     {
       if (strlen (arch->name) == len && strncmp (arch->name, str, len) == 0)
 	{
-	  selected_arch = arch;
-	  aarch64_isa_flags = selected_arch->flags;
-
-	  if (!selected_cpu)
-	    selected_cpu = &all_cores[selected_arch->core];
+	  unsigned long isa_temp = arch->flags;
 
 	  if (ext != NULL)
 	    {
-	      /* ARCH string contains at least one extension.  */
-	      aarch64_parse_extension (ext);
-	    }
+	      /* TO_PARSE string contains at least one extension.  */
+	      enum aarch64_parse_opt_result ext_res
+		= aarch64_parse_extension (ext, &isa_temp);
 
-	  if (strcmp (selected_arch->arch, selected_cpu->arch))
-	    {
-	      warning (0, "switch -mcpu=%s conflicts with -march=%s switch",
-		       selected_cpu->name, selected_arch->name);
+	      if (ext_res != AARCH64_PARSE_OK)
+		return ext_res;
 	    }
-
-	  return;
+	  /* Extension parsing was successful.  Confirm the result
+	     arch and ISA flags.  */
+	  *res = arch;
+	  *isa_flags = isa_temp;
+	  return AARCH64_PARSE_OK;
 	}
     }
 
   /* ARCH name not found in list.  */
-  error ("unknown value %qs for -march", str);
-  return;
+  return AARCH64_PARSE_INVALID_ARG;
 }
 
-/* Parse the CPU string.  */
+/* Parse the TO_PARSE string and put the result tuning in RES and the
+   architecture flags in ISA_FLAGS.  Return an aarch64_parse_opt_result
+   describing the parse result.  If there is an error parsing, RES and
+   ISA_FLAGS are left unchanged.  */
 
-static void
-aarch64_parse_cpu (void)
+static enum aarch64_parse_opt_result
+aarch64_parse_cpu (const char *to_parse, const struct processor **res,
+		   unsigned long *isa_flags)
 {
   char *ext;
   const struct processor *cpu;
-  char *str = (char *) alloca (strlen (aarch64_cpu_string) + 1);
+  char *str = (char *) alloca (strlen (to_parse) + 1);
   size_t len;
 
-  strcpy (str, aarch64_cpu_string);
+  strcpy (str, to_parse);
 
   ext = strchr (str, '+');
 
@@ -6761,157 +7019,556 @@ aarch64_parse_cpu (void)
     len = strlen (str);
 
   if (len == 0)
-    {
-      error ("missing cpu name in -mcpu=%qs", str);
-      return;
-    }
+    return AARCH64_PARSE_MISSING_ARG;
+
 
   /* Loop through the list of supported CPUs to find a match.  */
   for (cpu = all_cores; cpu->name != NULL; cpu++)
     {
       if (strlen (cpu->name) == len && strncmp (cpu->name, str, len) == 0)
 	{
-	  selected_cpu = cpu;
-	  aarch64_isa_flags = selected_cpu->flags;
+	  unsigned long isa_temp = cpu->flags;
+
 
 	  if (ext != NULL)
 	    {
-	      /* CPU string contains at least one extension.  */
-	      aarch64_parse_extension (ext);
-	    }
+	      /* TO_PARSE string contains at least one extension.  */
+	      enum aarch64_parse_opt_result ext_res
+		= aarch64_parse_extension (ext, &isa_temp);
 
-	  return;
+	      if (ext_res != AARCH64_PARSE_OK)
+		return ext_res;
+	    }
+	  /* Extension parsing was successfull.  Confirm the result
+	     cpu and ISA flags.  */
+	  *res = cpu;
+	  *isa_flags = isa_temp;
+	  return AARCH64_PARSE_OK;
 	}
     }
 
   /* CPU name not found in list.  */
-  error ("unknown value %qs for -mcpu", str);
-  return;
+  return AARCH64_PARSE_INVALID_ARG;
 }
 
-/* Parse the TUNE string.  */
+/* Parse the TO_PARSE string and put the cpu it selects into RES.
+   Return an aarch64_parse_opt_result describing the parse result.
+   If the parsing fails the RES does not change.  */
 
-static void
-aarch64_parse_tune (void)
+static enum aarch64_parse_opt_result
+aarch64_parse_tune (const char *to_parse, const struct processor **res)
 {
   const struct processor *cpu;
-  char *str = (char *) alloca (strlen (aarch64_tune_string) + 1);
-  strcpy (str, aarch64_tune_string);
+  char *str = (char *) alloca (strlen (to_parse) + 1);
+
+  strcpy (str, to_parse);
 
   /* Loop through the list of supported CPUs to find a match.  */
   for (cpu = all_cores; cpu->name != NULL; cpu++)
     {
       if (strcmp (cpu->name, str) == 0)
 	{
-	  selected_tune = cpu;
-	  return;
+	  *res = cpu;
+	  return AARCH64_PARSE_OK;
 	}
     }
 
   /* CPU name not found in list.  */
-  error ("unknown value %qs for -mtune", str);
-  return;
+  return AARCH64_PARSE_INVALID_ARG;
 }
 
+/* Parse TOKEN, which has length LENGTH to see if it is an option
+   described in FLAG.  If it is, return the index bit for that fusion type.
+   If not, error (printing OPTION_NAME) and return zero.  */
 
-/* Implement TARGET_OPTION_OVERRIDE.  */
-
-static void
-aarch64_override_options (void)
+static unsigned int
+aarch64_parse_one_option_token (const char *token,
+				size_t length,
+				const struct aarch64_flag_desc *flag,
+				const char *option_name)
 {
-  /* -mcpu=CPU is shorthand for -march=ARCH_FOR_CPU, -mtune=CPU.
-     If either of -march or -mtune is given, they override their
-     respective component of -mcpu.
-
-     So, first parse AARCH64_CPU_STRING, then the others, be careful
-     with -march as, if -mcpu is not present on the command line, march
-     must set a sensible default CPU.  */
-  if (aarch64_cpu_string)
+  for (; flag->name != NULL; flag++)
     {
-      aarch64_parse_cpu ();
+      if (length == strlen (flag->name)
+	  && !strncmp (flag->name, token, length))
+	return flag->flag;
     }
 
-  if (aarch64_arch_string)
+  error ("unknown flag passed in -moverride=%s (%s)", option_name, token);
+  return 0;
+}
+
+/* Parse OPTION which is a comma-separated list of flags to enable.
+   FLAGS gives the list of flags we understand, INITIAL_STATE gives any
+   default state we inherit from the CPU tuning structures.  OPTION_NAME
+   gives the top-level option we are parsing in the -moverride string,
+   for use in error messages.  */
+
+static unsigned int
+aarch64_parse_boolean_options (const char *option,
+			       const struct aarch64_flag_desc *flags,
+			       unsigned int initial_state,
+			       const char *option_name)
+{
+  const char separator = '.';
+  const char* specs = option;
+  const char* ntoken = option;
+  unsigned int found_flags = initial_state;
+
+  while ((ntoken = strchr (specs, separator)))
     {
-      aarch64_parse_arch ();
+      size_t token_length = ntoken - specs;
+      unsigned token_ops = aarch64_parse_one_option_token (specs,
+							   token_length,
+							   flags,
+							   option_name);
+      /* If we find "none" (or, for simplicity's sake, an error) anywhere
+	 in the token stream, reset the supported operations.  So:
+
+	   adrp+add.cmp+branch.none.adrp+add
+
+	   would have the result of turning on only adrp+add fusion.  */
+      if (!token_ops)
+	found_flags = 0;
+
+      found_flags |= token_ops;
+      specs = ++ntoken;
     }
 
-  if (aarch64_tune_string)
+  /* We ended with a comma, print something.  */
+  if (!(*specs))
     {
-      aarch64_parse_tune ();
+      error ("%s string ill-formed\n", option_name);
+      return 0;
     }
 
-#ifndef HAVE_AS_MABI_OPTION
-  /* The compiler may have been configured with 2.23.* binutils, which does
-     not have support for ILP32.  */
-  if (TARGET_ILP32)
-    error ("Assembler does not support -mabi=ilp32");
-#endif
+  /* We still have one more token to parse.  */
+  size_t token_length = strlen (specs);
+  unsigned token_ops = aarch64_parse_one_option_token (specs,
+						       token_length,
+						       flags,
+						       option_name);
+   if (!token_ops)
+     found_flags = 0;
 
-  initialize_aarch64_code_model ();
+  found_flags |= token_ops;
+  return found_flags;
+}
 
-  aarch64_build_bitmask_table ();
+/* Support for overriding instruction fusion.  */
 
-  /* This target defaults to strict volatile bitfields.  */
-  if (flag_strict_volatile_bitfields < 0 && abi_version_at_least (2))
-    flag_strict_volatile_bitfields = 1;
+static void
+aarch64_parse_fuse_string (const char *fuse_string,
+			    struct tune_params *tune)
+{
+  tune->fusible_ops = aarch64_parse_boolean_options (fuse_string,
+						     aarch64_fusible_pairs,
+						     tune->fusible_ops,
+						     "fuse=");
+}
 
-  /* If the user did not specify a processor, choose the default
-     one for them.  This will be the CPU set during configuration using
-     --with-cpu, otherwise it is "generic".  */
-  if (!selected_cpu)
-    {
-      selected_cpu = &all_cores[TARGET_CPU_DEFAULT & 0x3f];
-      aarch64_isa_flags = TARGET_CPU_DEFAULT >> 6;
-    }
+/* Support for overriding other tuning flags.  */
 
-  gcc_assert (selected_cpu);
+static void
+aarch64_parse_tune_string (const char *tune_string,
+			    struct tune_params *tune)
+{
+  tune->extra_tuning_flags
+    = aarch64_parse_boolean_options (tune_string,
+				     aarch64_tuning_flags,
+				     tune->extra_tuning_flags,
+				     "tune=");
+}
 
-  if (!selected_tune)
-    selected_tune = selected_cpu;
+/* Parse TOKEN, which has length LENGTH to see if it is a tuning option
+   we understand.  If it is, extract the option string and handoff to
+   the appropriate function.  */
 
-  aarch64_tune_flags = selected_tune->flags;
-  aarch64_tune = selected_tune->core;
-  aarch64_tune_params = selected_tune->tune;
-  aarch64_architecture_version = selected_cpu->architecture_version;
+void
+aarch64_parse_one_override_token (const char* token,
+				  size_t length,
+				  struct tune_params *tune)
+{
+  const struct aarch64_tuning_override_function *fn
+    = aarch64_tuning_override_functions;
 
-  if (aarch64_fix_a53_err835769 == 2)
+  const char *option_part = strchr (token, '=');
+  if (!option_part)
     {
-#ifdef TARGET_FIX_ERR_A53_835769_DEFAULT
-      aarch64_fix_a53_err835769 = 1;
-#else
-      aarch64_fix_a53_err835769 = 0;
-#endif
+      error ("tuning string missing in option (%s)", token);
+      return;
+    }
+
+  /* Get the length of the option name.  */
+  length = option_part - token;
+  /* Skip the '=' to get to the option string.  */
+  option_part++;
+
+  for (; fn->name != NULL; fn++)
+    {
+      if (!strncmp (fn->name, token, length))
+	{
+	  fn->parse_override (option_part, tune);
+	  return;
+	}
     }
 
-  aarch64_override_options_after_change ();
+  error ("unknown tuning option (%s)",token);
+  return;
 }
 
-/* Implement targetm.override_options_after_change.  */
+/* Parse STRING looking for options in the format:
+     string	:: option:string
+     option	:: name=substring
+     name	:: {a-z}
+     substring	:: defined by option.  */
 
 static void
-aarch64_override_options_after_change (void)
+aarch64_parse_override_string (const char* input_string,
+			       struct tune_params* tune)
 {
-  if (flag_omit_frame_pointer)
-    flag_omit_leaf_frame_pointer = false;
-  else if (flag_omit_leaf_frame_pointer)
-    flag_omit_frame_pointer = true;
+  const char separator = ':';
+  size_t string_length = strlen (input_string) + 1;
+  char *string_root = (char *) xmalloc (sizeof (*string_root) * string_length);
+  char *string = string_root;
+  strncpy (string, input_string, string_length);
+  string[string_length - 1] = '\0';
 
-  /* If not optimizing for size, set the default
-     alignment to what the target wants */
-  if (!optimize_size)
+  char* ntoken = string;
+
+  while ((ntoken = strchr (string, separator)))
     {
-      if (align_loops <= 0)
-	align_loops = aarch64_tune_params->loop_align;
-      if (align_jumps <= 0)
-	align_jumps = aarch64_tune_params->jump_align;
-      if (align_functions <= 0)
-	align_functions = aarch64_tune_params->function_align;
+      size_t token_length = ntoken - string;
+      /* Make this substring look like a string.  */
+      *ntoken = '\0';
+      aarch64_parse_one_override_token (string, token_length, tune);
+      string = ++ntoken;
     }
+
+  /* One last option to parse.  */
+  aarch64_parse_one_override_token (string, strlen (string), tune);
+  free (string_root);
 }
 
-static struct machine_function *
-aarch64_init_machine_status (void)
+
+static void
+aarch64_override_options_after_change_1 (struct gcc_options *opts)
+{
+  if (opts->x_flag_omit_frame_pointer)
+    opts->x_flag_omit_leaf_frame_pointer = false;
+  else if (opts->x_flag_omit_leaf_frame_pointer)
+    opts->x_flag_omit_frame_pointer = true;
+
+  /* If not opzimizing for size, set the default
+     alignment to what the target wants.  */
+  if (!opts->x_optimize_size)
+    {
+      if (opts->x_align_loops <= 0)
+	opts->x_align_loops = aarch64_tune_params.loop_align;
+      if (opts->x_align_jumps <= 0)
+	opts->x_align_jumps = aarch64_tune_params.jump_align;
+      if (opts->x_align_functions <= 0)
+	opts->x_align_functions = aarch64_tune_params.function_align;
+    }
+}
+
+/* 'Unpack' up the internal tuning structs and update the options
+    in OPTS.  The caller must have set up selected_tune and selected_arch
+    as all the other target-specific codegen decisions are
+    derived from them.  */
+
+void
+aarch64_override_options_internal (struct gcc_options *opts)
+{
+  aarch64_tune_flags = selected_tune->flags;
+  aarch64_tune = selected_tune->sched_core;
+  /* Make a copy of the tuning parameters attached to the core, which
+     we may later overwrite.  */
+  aarch64_tune_params = *(selected_tune->tune);
+  aarch64_architecture_version = selected_arch->architecture_version;
+
+  if (opts->x_aarch64_override_tune_string)
+    aarch64_parse_override_string (opts->x_aarch64_override_tune_string,
+				  &aarch64_tune_params);
+
+  /* This target defaults to strict volatile bitfields.  */
+  if (opts->x_flag_strict_volatile_bitfields < 0 && abi_version_at_least (2))
+    opts->x_flag_strict_volatile_bitfields = 1;
+
+  /* -mgeneral-regs-only sets a mask in target_flags, make sure that
+     aarch64_isa_flags does not contain the FP/SIMD/Crypto feature flags
+     in case some code tries reading aarch64_isa_flags directly to check if
+     FP is available.  Reuse the aarch64_parse_extension machinery since it
+     knows how to disable any other flags that fp implies.  */
+  if (TARGET_GENERAL_REGS_ONLY_P (opts->x_target_flags))
+    {
+      /* aarch64_parse_extension takes char* rather than const char* because
+	 it is usually called from within other parsing functions.  */
+      char tmp_str[] = "+nofp";
+      aarch64_parse_extension (tmp_str, &opts->x_aarch64_isa_flags);
+    }
+
+  initialize_aarch64_code_model (opts);
+
+  aarch64_override_options_after_change_1 (opts);
+}
+
+/* Validate a command-line -mcpu option.  Parse the cpu and extensions (if any)
+   specified in STR and throw errors if appropriate.  Put the results if
+   they are valid in RES and ISA_FLAGS.  Return whether the option is
+   valid.  */
+
+static bool
+aarch64_validate_mcpu (const char *str, const struct processor **res,
+		       unsigned long *isa_flags)
+{
+  enum aarch64_parse_opt_result parse_res
+    = aarch64_parse_cpu (str, res, isa_flags);
+
+  if (parse_res == AARCH64_PARSE_OK)
+    return true;
+
+  switch (parse_res)
+    {
+      case AARCH64_PARSE_MISSING_ARG:
+	error ("missing cpu name in -mcpu=%qs", str);
+	break;
+      case AARCH64_PARSE_INVALID_ARG:
+	error ("unknown value %qs for -mcpu", str);
+	break;
+      case AARCH64_PARSE_INVALID_FEATURE:
+	error ("invalid feature modifier in -mcpu=%qs", str);
+	break;
+      default:
+	gcc_unreachable ();
+    }
+
+  return false;
+}
+
+/* Validate a command-line -march option.  Parse the arch and extensions
+   (if any) specified in STR and throw errors if appropriate.  Put the
+   results, if they are valid, in RES and ISA_FLAGS.  Return whether the
+   option is valid.  */
+
+static bool
+aarch64_validate_march (const char *str, const struct processor **res,
+		       unsigned long *isa_flags)
+{
+  enum aarch64_parse_opt_result parse_res
+    = aarch64_parse_arch (str, res, isa_flags);
+
+  if (parse_res == AARCH64_PARSE_OK)
+    return true;
+
+  switch (parse_res)
+    {
+      case AARCH64_PARSE_MISSING_ARG:
+	error ("missing arch name in -march=%qs", str);
+	break;
+      case AARCH64_PARSE_INVALID_ARG:
+	error ("unknown value %qs for -march", str);
+	break;
+      case AARCH64_PARSE_INVALID_FEATURE:
+	error ("invalid feature modifier in -march=%qs", str);
+	break;
+      default:
+	gcc_unreachable ();
+    }
+
+  return false;
+}
+
+/* Validate a command-line -mtune option.  Parse the cpu
+   specified in STR and throw errors if appropriate.  Put the
+   result, if it is valid, in RES.  Return whether the option is
+   valid.  */
+
+static bool
+aarch64_validate_mtune (const char *str, const struct processor **res)
+{
+  enum aarch64_parse_opt_result parse_res
+    = aarch64_parse_tune (str, res);
+
+  if (parse_res == AARCH64_PARSE_OK)
+    return true;
+
+  switch (parse_res)
+    {
+      case AARCH64_PARSE_MISSING_ARG:
+	error ("missing cpu name in -mtune=%qs", str);
+	break;
+      case AARCH64_PARSE_INVALID_ARG:
+	error ("unknown value %qs for -mtune", str);
+	break;
+      default:
+	gcc_unreachable ();
+    }
+  return false;
+}
+
+/* Return the CPU corresponding to the enum CPU.
+   If it doesn't specify a cpu, return the default.  */
+
+static const struct processor *
+aarch64_get_tune_cpu (enum aarch64_processor cpu)
+{
+  if (cpu != aarch64_none)
+    return &all_cores[cpu];
+
+  /* The & 0x3f is to extract the bottom 6 bits that encode the
+     default cpu as selected by the --with-cpu GCC configure option
+     in config.gcc.
+     ???: The whole TARGET_CPU_DEFAULT and AARCH64_CPU_DEFAULT_FLAGS
+     flags mechanism should be reworked to make it more sane.  */
+  return &all_cores[TARGET_CPU_DEFAULT & 0x3f];
+}
+
+/* Return the architecture corresponding to the enum ARCH.
+   If it doesn't specify a valid architecture, return the default.  */
+
+static const struct processor *
+aarch64_get_arch (enum aarch64_arch arch)
+{
+  if (arch != aarch64_no_arch)
+    return &all_architectures[arch];
+
+  const struct processor *cpu = &all_cores[TARGET_CPU_DEFAULT & 0x3f];
+
+  return &all_architectures[cpu->arch];
+}
+
+/* Implement TARGET_OPTION_OVERRIDE.  This is called once in the beginning
+   and is used to parse the -m{cpu,tune,arch} strings and setup the initial
+   tuning structs.  In particular it must set selected_tune and
+   aarch64_isa_flags that define the available ISA features and tuning
+   decisions.  It must also set selected_arch as this will be used to
+   output the .arch asm tags for each function.  */
+
+static void
+aarch64_override_options (void)
+{
+  unsigned long cpu_isa = 0;
+  unsigned long arch_isa = 0;
+  aarch64_isa_flags = 0;
+
+  bool valid_cpu = true;
+  bool valid_tune = true;
+  bool valid_arch = true;
+
+  selected_cpu = NULL;
+  selected_arch = NULL;
+  selected_tune = NULL;
+
+  /* -mcpu=CPU is shorthand for -march=ARCH_FOR_CPU, -mtune=CPU.
+     If either of -march or -mtune is given, they override their
+     respective component of -mcpu.  */
+  if (aarch64_cpu_string)
+    valid_cpu = aarch64_validate_mcpu (aarch64_cpu_string, &selected_cpu,
+					&cpu_isa);
+
+  if (aarch64_arch_string)
+    valid_arch = aarch64_validate_march (aarch64_arch_string, &selected_arch,
+					  &arch_isa);
+
+  if (aarch64_tune_string)
+    valid_tune = aarch64_validate_mtune (aarch64_tune_string, &selected_tune);
+
+  /* If the user did not specify a processor, choose the default
+     one for them.  This will be the CPU set during configuration using
+     --with-cpu, otherwise it is "generic".  */
+  if (!selected_cpu)
+    {
+      if (selected_arch)
+	{
+	  selected_cpu = &all_cores[selected_arch->ident];
+	  aarch64_isa_flags = arch_isa;
+	  explicit_arch = selected_arch->arch;
+	}
+      else
+	{
+	  /* Get default configure-time CPU.  */
+	  selected_cpu = aarch64_get_tune_cpu (aarch64_none);
+	  aarch64_isa_flags = TARGET_CPU_DEFAULT >> 6;
+	}
+
+      if (selected_tune)
+	explicit_tune_core = selected_tune->ident;
+    }
+  /* If both -mcpu and -march are specified check that they are architecturally
+     compatible, warn if they're not and prefer the -march ISA flags.  */
+  else if (selected_arch)
+    {
+      if (selected_arch->arch != selected_cpu->arch)
+	{
+	  warning (0, "switch -mcpu=%s conflicts with -march=%s switch",
+		       all_architectures[selected_cpu->arch].name,
+		       selected_arch->name);
+	}
+      aarch64_isa_flags = arch_isa;
+      explicit_arch = selected_arch->arch;
+      explicit_tune_core = selected_tune ? selected_tune->ident
+					  : selected_cpu->ident;
+    }
+  else
+    {
+      /* -mcpu but no -march.  */
+      aarch64_isa_flags = cpu_isa;
+      explicit_tune_core = selected_tune ? selected_tune->ident
+					  : selected_cpu->ident;
+      gcc_assert (selected_cpu);
+      selected_arch = &all_architectures[selected_cpu->arch];
+      explicit_arch = selected_arch->arch;
+    }
+
+  /* Set the arch as well as we will need it when outputing
+     the .arch directive in assembly.  */
+  if (!selected_arch)
+    {
+      gcc_assert (selected_cpu);
+      selected_arch = &all_architectures[selected_cpu->arch];
+    }
+
+  if (!selected_tune)
+    selected_tune = selected_cpu;
+
+#ifndef HAVE_AS_MABI_OPTION
+  /* The compiler may have been configured with 2.23.* binutils, which does
+     not have support for ILP32.  */
+  if (TARGET_ILP32)
+    error ("Assembler does not support -mabi=ilp32");
+#endif
+
+  /* Make sure we properly set up the explicit options.  */
+  if ((aarch64_cpu_string && valid_cpu)
+       || (aarch64_tune_string && valid_tune))
+    gcc_assert (explicit_tune_core != aarch64_none);
+
+  if ((aarch64_cpu_string && valid_cpu)
+       || (aarch64_arch_string && valid_arch))
+    gcc_assert (explicit_arch != aarch64_no_arch);
+
+  aarch64_override_options_internal (&global_options);
+
+  /* Save these options as the default ones in case we push and pop them later
+     while processing functions with potential target attributes.  */
+  target_option_default_node = target_option_current_node
+      = build_target_option_node (&global_options);
+
+  aarch64_register_fma_steering ();
+
+}
+
+/* Implement targetm.override_options_after_change.  */
+
+static void
+aarch64_override_options_after_change (void)
+{
+  aarch64_override_options_after_change_1 (&global_options);
+}
+
+static struct machine_function *
+aarch64_init_machine_status (void)
 {
   struct machine_function *machine;
   machine = ggc_cleared_alloc<machine_function> ();
@@ -6926,11 +7583,11 @@ aarch64_init_expanders (void)
 
 /* A checking mechanism for the implementation of the various code models.  */
 static void
-initialize_aarch64_code_model (void)
+initialize_aarch64_code_model (struct gcc_options *opts)
 {
-   if (flag_pic)
+   if (opts->x_flag_pic)
      {
-       switch (aarch64_cmodel_var)
+       switch (opts->x_aarch64_cmodel_var)
 	 {
 	 case AARCH64_CMODEL_TINY:
 	   aarch64_cmodel = AARCH64_CMODEL_TINY_PIC;
@@ -6940,13 +7597,761 @@ initialize_aarch64_code_model (void)
 	   break;
 	 case AARCH64_CMODEL_LARGE:
 	   sorry ("code model %qs with -f%s", "large",
-		  flag_pic > 1 ? "PIC" : "pic");
+		  opts->x_flag_pic > 1 ? "PIC" : "pic");
 	 default:
 	   gcc_unreachable ();
 	 }
      }
    else
-     aarch64_cmodel = aarch64_cmodel_var;
+     aarch64_cmodel = opts->x_aarch64_cmodel_var;
+}
+
+/* Implement TARGET_OPTION_SAVE.  */
+
+static void
+aarch64_option_save (struct cl_target_option *ptr, struct gcc_options *opts)
+{
+  ptr->x_aarch64_override_tune_string = opts->x_aarch64_override_tune_string;
+}
+
+/* Implements TARGET_OPTION_RESTORE.  Restore the backend codegen decisions
+   using the information saved in PTR.  */
+
+static void
+aarch64_option_restore (struct gcc_options *opts, struct cl_target_option *ptr)
+{
+  opts->x_explicit_tune_core = ptr->x_explicit_tune_core;
+  selected_tune = aarch64_get_tune_cpu (ptr->x_explicit_tune_core);
+  opts->x_explicit_arch = ptr->x_explicit_arch;
+  selected_arch = aarch64_get_arch (ptr->x_explicit_arch);
+  opts->x_aarch64_override_tune_string = ptr->x_aarch64_override_tune_string;
+
+  aarch64_override_options_internal (opts);
+}
+
+/* Implement TARGET_OPTION_PRINT.  */
+
+static void
+aarch64_option_print (FILE *file, int indent, struct cl_target_option *ptr)
+{
+  const struct processor *cpu
+    = aarch64_get_tune_cpu (ptr->x_explicit_tune_core);
+  unsigned long isa_flags = ptr->x_aarch64_isa_flags;
+  const struct processor *arch = aarch64_get_arch (ptr->x_explicit_arch);
+  std::string extension
+    = aarch64_get_extension_string_for_isa_flags (isa_flags);
+
+  fprintf (file, "%*sselected tune = %s\n", indent, "", cpu->name);
+  fprintf (file, "%*sselected arch = %s%s\n", indent, "",
+	   arch->name, extension.c_str ());
+}
+
+static GTY(()) tree aarch64_previous_fndecl;
+
+void
+aarch64_reset_previous_fndecl (void)
+{
+  aarch64_previous_fndecl = NULL;
+}
+
+/* Implement TARGET_SET_CURRENT_FUNCTION.  Unpack the codegen decisions
+   like tuning and ISA features from the DECL_FUNCTION_SPECIFIC_TARGET
+   of the function, if such exists.  This function may be called multiple
+   times on a single function so use aarch64_previous_fndecl to avoid
+   setting up identical state.  */
+
+static void
+aarch64_set_current_function (tree fndecl)
+{
+  tree old_tree = (aarch64_previous_fndecl
+		   ? DECL_FUNCTION_SPECIFIC_TARGET (aarch64_previous_fndecl)
+		   : NULL_TREE);
+
+  tree new_tree = (fndecl
+		   ? DECL_FUNCTION_SPECIFIC_TARGET (fndecl)
+		   : NULL_TREE);
+
+
+  if (fndecl && fndecl != aarch64_previous_fndecl)
+    {
+      aarch64_previous_fndecl = fndecl;
+      if (old_tree == new_tree)
+	;
+
+      else if (new_tree && new_tree != target_option_default_node)
+	{
+	  cl_target_option_restore (&global_options,
+				    TREE_TARGET_OPTION (new_tree));
+	  if (TREE_TARGET_GLOBALS (new_tree))
+	    restore_target_globals (TREE_TARGET_GLOBALS (new_tree));
+	  else
+	    TREE_TARGET_GLOBALS (new_tree)
+	      = save_target_globals_default_opts ();
+	}
+
+      else if (old_tree && old_tree != target_option_default_node)
+	{
+	  new_tree = target_option_current_node;
+	  cl_target_option_restore (&global_options,
+				    TREE_TARGET_OPTION (new_tree));
+	  if (TREE_TARGET_GLOBALS (new_tree))
+	    restore_target_globals (TREE_TARGET_GLOBALS (new_tree));
+	  else if (new_tree == target_option_default_node)
+	    restore_target_globals (&default_target_globals);
+	  else
+	    TREE_TARGET_GLOBALS (new_tree)
+	      = save_target_globals_default_opts ();
+	}
+    }
+
+  if (!fndecl)
+    return;
+
+  /* If we turned on SIMD make sure that any vector parameters are re-laid out
+     so that they use proper vector modes.  */
+  if (TARGET_SIMD)
+    {
+      tree parms = DECL_ARGUMENTS (fndecl);
+      for (; parms && parms != void_list_node; parms = TREE_CHAIN (parms))
+	{
+	  if (TREE_CODE (parms) == PARM_DECL
+	      && VECTOR_TYPE_P (TREE_TYPE (parms))
+	      && DECL_MODE (parms) != TYPE_MODE (TREE_TYPE (parms)))
+	    relayout_decl (parms);
+	}
+    }
+}
+
+/* Enum describing the various ways we can handle attributes.
+   In many cases we can reuse the generic option handling machinery.  */
+
+enum aarch64_attr_opt_type
+{
+  aarch64_attr_mask,	/* Attribute should set a bit in target_flags.  */
+  aarch64_attr_bool,	/* Attribute sets or unsets a boolean variable.  */
+  aarch64_attr_enum,	/* Attribute sets an enum variable.  */
+  aarch64_attr_custom	/* Attribute requires a custom handling function.  */
+};
+
+/* All the information needed to handle a target attribute.
+   NAME is the name of the attribute.
+   ATTR_TYPE specifies the type of behaviour of the attribute as described
+   in the definition of enum aarch64_attr_opt_type.
+   ALLOW_NEG is true if the attribute supports a "no-" form.
+   HANDLER is the function that takes the attribute string and whether
+   it is a pragma or attribute and handles the option.  It is needed only
+   when the ATTR_TYPE is aarch64_attr_custom.
+   OPT_NUM is the enum specifying the option that the attribute modifies.
+   This is needed for attributes that mirror the behaviour of a command-line
+   option, that is it has ATTR_TYPE aarch64_attr_mask, aarch64_attr_bool or
+   aarch64_attr_enum.  */
+
+struct aarch64_attribute_info
+{
+  const char *name;
+  enum aarch64_attr_opt_type attr_type;
+  bool allow_neg;
+  bool (*handler) (const char *, const char *);
+  enum opt_code opt_num;
+};
+
+/* Handle the ARCH_STR argument to the arch= target attribute.
+   PRAGMA_OR_ATTR is used in potential error messages.  */
+
+static bool
+aarch64_handle_attr_arch (const char *str, const char *pragma_or_attr)
+{
+  const struct processor *tmp_arch = NULL;
+  enum aarch64_parse_opt_result parse_res
+    = aarch64_parse_arch (str, &tmp_arch, &aarch64_isa_flags);
+
+  if (parse_res == AARCH64_PARSE_OK)
+    {
+      gcc_assert (tmp_arch);
+      selected_arch = tmp_arch;
+      explicit_arch = selected_arch->arch;
+      return true;
+    }
+
+  switch (parse_res)
+    {
+      case AARCH64_PARSE_MISSING_ARG:
+	error ("missing architecture name in 'arch' target %s", pragma_or_attr);
+	break;
+      case AARCH64_PARSE_INVALID_ARG:
+	error ("unknown value %qs for 'arch' target %s", str, pragma_or_attr);
+	break;
+      case AARCH64_PARSE_INVALID_FEATURE:
+	error ("invalid feature modifier %qs for 'arch' target %s",
+	       str, pragma_or_attr);
+	break;
+      default:
+	gcc_unreachable ();
+    }
+
+  return false;
+}
+
+/* Handle the argument CPU_STR to the cpu= target attribute.
+   PRAGMA_OR_ATTR is used in potential error messages.  */
+
+static bool
+aarch64_handle_attr_cpu (const char *str, const char *pragma_or_attr)
+{
+  const struct processor *tmp_cpu = NULL;
+  enum aarch64_parse_opt_result parse_res
+    = aarch64_parse_cpu (str, &tmp_cpu, &aarch64_isa_flags);
+
+  if (parse_res == AARCH64_PARSE_OK)
+    {
+      gcc_assert (tmp_cpu);
+      selected_tune = tmp_cpu;
+      explicit_tune_core = selected_tune->ident;
+
+      selected_arch = &all_architectures[tmp_cpu->arch];
+      explicit_arch = selected_arch->arch;
+      return true;
+    }
+
+  switch (parse_res)
+    {
+      case AARCH64_PARSE_MISSING_ARG:
+	error ("missing cpu name in 'cpu' target %s", pragma_or_attr);
+	break;
+      case AARCH64_PARSE_INVALID_ARG:
+	error ("unknown value %qs for 'cpu' target %s", str, pragma_or_attr);
+	break;
+      case AARCH64_PARSE_INVALID_FEATURE:
+	error ("invalid feature modifier %qs for 'cpu' target %s",
+	       str, pragma_or_attr);
+	break;
+      default:
+	gcc_unreachable ();
+    }
+
+  return false;
+}
+
+/* Handle the argument STR to the tune= target attribute.
+   PRAGMA_OR_ATTR is used in potential error messages.  */
+
+static bool
+aarch64_handle_attr_tune (const char *str, const char *pragma_or_attr)
+{
+  const struct processor *tmp_tune = NULL;
+  enum aarch64_parse_opt_result parse_res
+    = aarch64_parse_tune (str, &tmp_tune);
+
+  if (parse_res == AARCH64_PARSE_OK)
+    {
+      gcc_assert (tmp_tune);
+      selected_tune = tmp_tune;
+      explicit_tune_core = selected_tune->ident;
+      return true;
+    }
+
+  switch (parse_res)
+    {
+      case AARCH64_PARSE_INVALID_ARG:
+	error ("unknown value %qs for 'tune' target %s", str, pragma_or_attr);
+	break;
+      default:
+	gcc_unreachable ();
+    }
+
+  return false;
+}
+
+/* Parse an architecture extensions target attribute string specified in STR.
+   For example "+fp+nosimd".  Show any errors if needed.  Return TRUE
+   if successful.  Update aarch64_isa_flags to reflect the ISA features
+   modified.
+   PRAGMA_OR_ATTR is used in potential error messages.  */
+
+static bool
+aarch64_handle_attr_isa_flags (char *str, const char *pragma_or_attr)
+{
+  enum aarch64_parse_opt_result parse_res;
+  unsigned long isa_flags = aarch64_isa_flags;
+
+  /* We allow "+nothing" in the beginning to clear out all architectural
+     features if the user wants to handpick specific features.  */
+  if (strncmp ("+nothing", str, 8) == 0)
+    {
+      isa_flags = 0;
+      str += 8;
+    }
+
+  parse_res = aarch64_parse_extension (str, &isa_flags);
+
+  if (parse_res == AARCH64_PARSE_OK)
+    {
+      aarch64_isa_flags = isa_flags;
+      return true;
+    }
+
+  switch (parse_res)
+    {
+      case AARCH64_PARSE_MISSING_ARG:
+	error ("missing feature modifier in target %s %qs",
+	       pragma_or_attr, str);
+	break;
+
+      case AARCH64_PARSE_INVALID_FEATURE:
+	error ("invalid feature modifier in target %s %qs",
+	       pragma_or_attr, str);
+	break;
+
+      default:
+	gcc_unreachable ();
+    }
+
+ return false;
+}
+
+/* The target attributes that we support.  On top of these we also support just
+   ISA extensions, like  __attribute__ ((target ("+crc"))), but that case is
+   handled explicitly in aarch64_process_one_target_attr.  */
+
+static const struct aarch64_attribute_info aarch64_attributes[] =
+{
+  { "general-regs-only", aarch64_attr_mask, false, NULL,
+     OPT_mgeneral_regs_only },
+  { "fix-cortex-a53-835769", aarch64_attr_bool, true, NULL,
+     OPT_mfix_cortex_a53_835769 },
+  { "cmodel", aarch64_attr_enum, false, NULL, OPT_mcmodel_ },
+  { "strict-align", aarch64_attr_mask, false, NULL, OPT_mstrict_align },
+  { "omit-leaf-frame-pointer", aarch64_attr_bool, true, NULL,
+     OPT_momit_leaf_frame_pointer },
+  { "tls-dialect", aarch64_attr_enum, false, NULL, OPT_mtls_dialect_ },
+  { "arch", aarch64_attr_custom, false, aarch64_handle_attr_arch,
+     OPT_march_ },
+  { "cpu", aarch64_attr_custom, false, aarch64_handle_attr_cpu, OPT_mcpu_ },
+  { "tune", aarch64_attr_custom, false, aarch64_handle_attr_tune,
+     OPT_mtune_ },
+  { NULL, aarch64_attr_custom, false, NULL, OPT____ }
+};
+
+/* Parse ARG_STR which contains the definition of one target attribute.
+   Show appropriate errors if any or return true if the attribute is valid.
+   PRAGMA_OR_ATTR holds the string to use in error messages about whether
+   we're processing a target attribute or pragma.  */
+
+static bool
+aarch64_process_one_target_attr (char *arg_str, const char* pragma_or_attr)
+{
+  bool invert = false;
+
+  size_t len = strlen (arg_str);
+
+  if (len == 0)
+    {
+      error ("malformed target %s", pragma_or_attr);
+      return false;
+    }
+
+  char *str_to_check = (char *) alloca (len + 1);
+  strcpy (str_to_check, arg_str);
+
+  /* Skip leading whitespace.  */
+  while (*str_to_check == ' ' || *str_to_check == '\t')
+    str_to_check++;
+
+  /* We have something like __attribute__ ((target ("+fp+nosimd"))).
+     It is easier to detect and handle it explicitly here rather than going
+     through the machinery for the rest of the target attributes in this
+     function.  */
+  if (*str_to_check == '+')
+    return aarch64_handle_attr_isa_flags (str_to_check, pragma_or_attr);
+
+  if (len > 3 && strncmp (str_to_check, "no-", 3) == 0)
+    {
+      invert = true;
+      str_to_check += 3;
+    }
+  char *arg = strchr (str_to_check, '=');
+
+  /* If we found opt=foo then terminate STR_TO_CHECK at the '='
+     and point ARG to "foo".  */
+  if (arg)
+    {
+      *arg = '\0';
+      arg++;
+    }
+  const struct aarch64_attribute_info *p_attr;
+  for (p_attr = aarch64_attributes; p_attr->name; p_attr++)
+    {
+      /* If the names don't match up, or the user has given an argument
+	 to an attribute that doesn't accept one, or didn't give an argument
+	 to an attribute that expects one, fail to match.  */
+      if (strcmp (str_to_check, p_attr->name) != 0)
+	continue;
+
+      bool attr_need_arg_p = p_attr->attr_type == aarch64_attr_custom
+			      || p_attr->attr_type == aarch64_attr_enum;
+
+      if (attr_need_arg_p ^ (arg != NULL))
+	{
+	  error ("target %s %qs does not accept an argument",
+		  pragma_or_attr, str_to_check);
+	  return false;
+	}
+
+      /* If the name matches but the attribute does not allow "no-" versions
+	 then we can't match.  */
+      if (invert && !p_attr->allow_neg)
+	{
+	  error ("target %s %qs does not allow a negated form",
+		  pragma_or_attr, str_to_check);
+	  return false;
+	}
+
+      switch (p_attr->attr_type)
+	{
+	/* Has a custom handler registered.
+	   For example, cpu=, arch=, tune=.  */
+	  case aarch64_attr_custom:
+	    gcc_assert (p_attr->handler);
+	    if (!p_attr->handler (arg, pragma_or_attr))
+	      return false;
+	    break;
+
+	  /* Either set or unset a boolean option.  */
+	  case aarch64_attr_bool:
+	    {
+	      struct cl_decoded_option decoded;
+
+	      generate_option (p_attr->opt_num, NULL, !invert,
+			       CL_TARGET, &decoded);
+	      aarch64_handle_option (&global_options, &global_options_set,
+				      &decoded, input_location);
+	      break;
+	    }
+	  /* Set or unset a bit in the target_flags.  aarch64_handle_option
+	     should know what mask to apply given the option number.  */
+	  case aarch64_attr_mask:
+	    {
+	      struct cl_decoded_option decoded;
+	      /* We only need to specify the option number.
+		 aarch64_handle_option will know which mask to apply.  */
+	      decoded.opt_index = p_attr->opt_num;
+	      decoded.value = !invert;
+	      aarch64_handle_option (&global_options, &global_options_set,
+				      &decoded, input_location);
+	      break;
+	    }
+	  /* Use the option setting machinery to set an option to an enum.  */
+	  case aarch64_attr_enum:
+	    {
+	      gcc_assert (arg);
+	      bool valid;
+	      int value;
+	      valid = opt_enum_arg_to_value (p_attr->opt_num, arg,
+					      &value, CL_TARGET);
+	      if (valid)
+		{
+		  set_option (&global_options, NULL, p_attr->opt_num, value,
+			      NULL, DK_UNSPECIFIED, input_location,
+			      global_dc);
+		}
+	      else
+		{
+		  error ("target %s %s=%s is not valid",
+			 pragma_or_attr, str_to_check, arg);
+		}
+	      break;
+	    }
+	  default:
+	    gcc_unreachable ();
+	}
+    }
+
+  return true;
+}
+
+/* Count how many times the character C appears in
+   NULL-terminated string STR.  */
+
+static unsigned int
+num_occurences_in_str (char c, char *str)
+{
+  unsigned int res = 0;
+  while (*str != '\0')
+    {
+      if (*str == c)
+	res++;
+
+      str++;
+    }
+
+  return res;
+}
+
+/* Parse the tree in ARGS that contains the target attribute information
+   and update the global target options space.  PRAGMA_OR_ATTR is a string
+   to be used in error messages, specifying whether this is processing
+   a target attribute or a target pragma.  */
+
+bool
+aarch64_process_target_attr (tree args, const char* pragma_or_attr)
+{
+  if (TREE_CODE (args) == TREE_LIST)
+    {
+      do
+	{
+	  tree head = TREE_VALUE (args);
+	  if (head)
+	    {
+	      if (!aarch64_process_target_attr (head, pragma_or_attr))
+		return false;
+	    }
+	  args = TREE_CHAIN (args);
+	} while (args);
+
+      return true;
+    }
+  /* We expect to find a string to parse.  */
+  gcc_assert (TREE_CODE (args) == STRING_CST);
+
+  size_t len = strlen (TREE_STRING_POINTER (args));
+  char *str_to_check = (char *) alloca (len + 1);
+  strcpy (str_to_check, TREE_STRING_POINTER (args));
+
+  if (len == 0)
+    {
+      error ("malformed target %s value", pragma_or_attr);
+      return false;
+    }
+
+  /* Used to catch empty spaces between commas i.e.
+     attribute ((target ("attr1,,attr2"))).  */
+  unsigned int num_commas = num_occurences_in_str (',', str_to_check);
+
+  /* Handle multiple target attributes separated by ','.  */
+  char *token = strtok (str_to_check, ",");
+
+  unsigned int num_attrs = 0;
+  while (token)
+    {
+      num_attrs++;
+      if (!aarch64_process_one_target_attr (token, pragma_or_attr))
+	{
+	  error ("target %s %qs is invalid", pragma_or_attr, token);
+	  return false;
+	}
+
+      token = strtok (NULL, ",");
+    }
+
+  if (num_attrs != num_commas + 1)
+    {
+      error ("malformed target %s list %qs",
+	      pragma_or_attr, TREE_STRING_POINTER (args));
+      return false;
+    }
+
+  return true;
+}
+
+/* Implement TARGET_OPTION_VALID_ATTRIBUTE_P.  This is used to
+   process attribute ((target ("..."))).  */
+
+static bool
+aarch64_option_valid_attribute_p (tree fndecl, tree, tree args, int)
+{
+  struct cl_target_option cur_target;
+  bool ret;
+  tree old_optimize;
+  tree new_target, new_optimize;
+  tree existing_target = DECL_FUNCTION_SPECIFIC_TARGET (fndecl);
+
+  /* If what we're processing is the current pragma string then the
+     target option node is already stored in target_option_current_node
+     by aarch64_pragma_target_parse in aarch64-c.c.  Use that to avoid
+     having to re-parse the string.  This is especially useful to keep
+     arm_neon.h compile times down since that header contains a lot
+     of intrinsics enclosed in pragmas.  */
+  if (!existing_target && args == current_target_pragma)
+    {
+      DECL_FUNCTION_SPECIFIC_TARGET (fndecl) = target_option_current_node;
+      return true;
+    }
+  tree func_optimize = DECL_FUNCTION_SPECIFIC_OPTIMIZATION (fndecl);
+
+  old_optimize = build_optimization_node (&global_options);
+  func_optimize = DECL_FUNCTION_SPECIFIC_OPTIMIZATION (fndecl);
+
+  /* If the function changed the optimization levels as well as setting
+     target options, start with the optimizations specified.  */
+  if (func_optimize && func_optimize != old_optimize)
+    cl_optimization_restore (&global_options,
+			     TREE_OPTIMIZATION (func_optimize));
+
+  /* Save the current target options to restore at the end.  */
+  cl_target_option_save (&cur_target, &global_options);
+
+  /* If fndecl already has some target attributes applied to it, unpack
+     them so that we add this attribute on top of them, rather than
+     overwriting them.  */
+  if (existing_target)
+    {
+      struct cl_target_option *existing_options
+	= TREE_TARGET_OPTION (existing_target);
+
+      if (existing_options)
+	cl_target_option_restore (&global_options, existing_options);
+    }
+  else
+    cl_target_option_restore (&global_options,
+			TREE_TARGET_OPTION (target_option_current_node));
+
+
+  ret = aarch64_process_target_attr (args, "attribute");
+
+  /* Set up any additional state.  */
+  if (ret)
+    {
+      aarch64_override_options_internal (&global_options);
+      /* Initialize SIMD builtins if we haven't already.
+	 Set current_target_pragma to NULL for the duration so that
+	 the builtin initialization code doesn't try to tag the functions
+	 being built with the attributes specified by any current pragma, thus
+	 going into an infinite recursion.  */
+      if (TARGET_SIMD)
+	{
+	  tree saved_current_target_pragma = current_target_pragma;
+	  current_target_pragma = NULL;
+	  aarch64_init_simd_builtins ();
+	  current_target_pragma = saved_current_target_pragma;
+	}
+      new_target = build_target_option_node (&global_options);
+    }
+  else
+    new_target = NULL;
+
+  new_optimize = build_optimization_node (&global_options);
+
+  if (fndecl && ret)
+    {
+      DECL_FUNCTION_SPECIFIC_TARGET (fndecl) = new_target;
+
+      if (old_optimize != new_optimize)
+	DECL_FUNCTION_SPECIFIC_OPTIMIZATION (fndecl) = new_optimize;
+    }
+
+  cl_target_option_restore (&global_options, &cur_target);
+
+  if (old_optimize != new_optimize)
+    cl_optimization_restore (&global_options,
+			     TREE_OPTIMIZATION (old_optimize));
+  return ret;
+}
+
+/* Helper for aarch64_can_inline_p.  In the case where CALLER and CALLEE are
+   tri-bool options (yes, no, don't care) and the default value is
+   DEF, determine whether to reject inlining.  */
+
+static bool
+aarch64_tribools_ok_for_inlining_p (int caller, int callee,
+				     int dont_care, int def)
+{
+  /* If the callee doesn't care, always allow inlining.  */
+  if (callee == dont_care)
+    return true;
+
+  /* If the caller doesn't care, always allow inlining.  */
+  if (caller == dont_care)
+    return true;
+
+  /* Otherwise, allow inlining if either the callee and caller values
+     agree, or if the callee is using the default value.  */
+  return (callee == caller || callee == def);
+}
+
+/* Implement TARGET_CAN_INLINE_P.  Decide whether it is valid
+   to inline CALLEE into CALLER based on target-specific info.
+   Make sure that the caller and callee have compatible architectural
+   features.  Then go through the other possible target attributes
+   and see if they can block inlining.  Try not to reject always_inline
+   callees unless they are incompatible architecturally.  */
+
+static bool
+aarch64_can_inline_p (tree caller, tree callee)
+{
+  tree caller_tree = DECL_FUNCTION_SPECIFIC_TARGET (caller);
+  tree callee_tree = DECL_FUNCTION_SPECIFIC_TARGET (callee);
+
+  /* If callee has no option attributes, then it is ok to inline.  */
+  if (!callee_tree)
+    return true;
+
+  struct cl_target_option *caller_opts
+	= TREE_TARGET_OPTION (caller_tree ? caller_tree
+					   : target_option_default_node);
+
+  struct cl_target_option *callee_opts = TREE_TARGET_OPTION (callee_tree);
+
+
+  /* Callee's ISA flags should be a subset of the caller's.  */
+  if ((caller_opts->x_aarch64_isa_flags & callee_opts->x_aarch64_isa_flags)
+       != callee_opts->x_aarch64_isa_flags)
+    return false;
+
+  /* Allow non-strict aligned functions inlining into strict
+     aligned ones.  */
+  if ((TARGET_STRICT_ALIGN_P (caller_opts->x_target_flags)
+       != TARGET_STRICT_ALIGN_P (callee_opts->x_target_flags))
+      && !(!TARGET_STRICT_ALIGN_P (callee_opts->x_target_flags)
+	   && TARGET_STRICT_ALIGN_P (caller_opts->x_target_flags)))
+    return false;
+
+  bool always_inline = lookup_attribute ("always_inline",
+					  DECL_ATTRIBUTES (callee));
+
+  /* If the architectural features match up and the callee is always_inline
+     then the other attributes don't matter.  */
+  if (always_inline)
+    return true;
+
+  if (caller_opts->x_aarch64_cmodel_var
+      != callee_opts->x_aarch64_cmodel_var)
+    return false;
+
+  if (caller_opts->x_aarch64_tls_dialect
+      != callee_opts->x_aarch64_tls_dialect)
+    return false;
+
+  /* Honour explicit requests to workaround errata.  */
+  if (!aarch64_tribools_ok_for_inlining_p (
+	  caller_opts->x_aarch64_fix_a53_err835769,
+	  callee_opts->x_aarch64_fix_a53_err835769,
+	  2, TARGET_FIX_ERR_A53_835769_DEFAULT))
+    return false;
+
+  /* If the user explicitly specified -momit-leaf-frame-pointer for the
+     caller and calle and they don't match up, reject inlining.  */
+  if (!aarch64_tribools_ok_for_inlining_p (
+	  caller_opts->x_flag_omit_leaf_frame_pointer,
+	  callee_opts->x_flag_omit_leaf_frame_pointer,
+	  2, 1))
+    return false;
+
+  /* If the callee has specific tuning overrides, respect them.  */
+  if (callee_opts->x_aarch64_override_tune_string != NULL
+      && caller_opts->x_aarch64_override_tune_string == NULL)
+    return false;
+
+  /* If the user specified tuning override strings for the
+     caller and callee and they don't match up, reject inlining.
+     We just do a string compare here, we don't analyze the meaning
+     of the string, as it would be too costly for little gain.  */
+  if (callee_opts->x_aarch64_override_tune_string
+      && caller_opts->x_aarch64_override_tune_string
+      && (strcmp (callee_opts->x_aarch64_override_tune_string,
+		  caller_opts->x_aarch64_override_tune_string) != 0))
+    return false;
+
+  return true;
 }
 
 /* Return true if SYMBOL_REF X binds locally.  */
@@ -6988,7 +8393,7 @@ aarch64_classify_tls_symbol (rtx x)
       return SYMBOL_SMALL_GOTTPREL;
 
     case TLS_MODEL_LOCAL_EXEC:
-      return SYMBOL_SMALL_TPREL;
+      return SYMBOL_TLSLE;
 
     case TLS_MODEL_EMULATED:
     case TLS_MODEL_NONE:
@@ -7104,16 +8509,13 @@ aarch64_valid_floating_const (machine_mode mode, rtx x)
   if (!CONST_DOUBLE_P (x))
     return false;
 
-  /* TODO: We could handle moving 0.0 to a TFmode register,
-     but first we would like to refactor the movtf_aarch64
-     to be more amicable to split moves properly and
-     correctly gate on TARGET_SIMD.  For now - reject all
-     constants which are not to SFmode or DFmode registers.  */
+  if (aarch64_float_const_zero_rtx_p (x))
+    return true;
+
+  /* We only handle moving 0.0 to a TFmode register.  */
   if (!(mode == SFmode || mode == DFmode))
     return false;
 
-  if (aarch64_float_const_zero_rtx_p (x))
-    return true;
   return aarch64_float_const_representable_p (x);
 }
 
@@ -7247,9 +8649,7 @@ aarch64_expand_builtin_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)
 
   if (!TARGET_FLOAT)
     {
-      if (cum->aapcs_nvrn > 0)
-	sorry ("%qs and floating point or vector arguments",
-	       "-mgeneral-regs-only");
+      gcc_assert (cum->aapcs_nvrn == 0);
       vr_save_area_size = 0;
     }
 
@@ -7356,8 +8756,7 @@ aarch64_gimplify_va_arg_expr (tree valist, tree type, gimple_seq *pre_p,
     {
       /* TYPE passed in fp/simd registers.  */
       if (!TARGET_FLOAT)
-	sorry ("%qs and floating point or vector arguments",
-	       "-mgeneral-regs-only");
+	aarch64_err_no_fpadvsimd (mode, "varargs");
 
       f_top = build3 (COMPONENT_REF, TREE_TYPE (f_vrtop),
 		      unshare_expr (valist), f_vrtop, NULL_TREE);
@@ -7594,9 +8993,7 @@ aarch64_setup_incoming_varargs (cumulative_args_t cum_v, machine_mode mode,
 
   if (!TARGET_FLOAT)
     {
-      if (local_cum.aapcs_nvrn > 0)
-	sorry ("%qs and floating point or vector arguments",
-	       "-mgeneral-regs-only");
+      gcc_assert (local_cum.aapcs_nvrn == 0);
       vr_saved = 0;
     }
 
@@ -7830,6 +9227,26 @@ aapcs_vfp_sub_candidate (const_tree type, machine_mode *modep)
   return -1;
 }
 
+/* Return TRUE if the type, as described by TYPE and MODE, is a short vector
+   type as described in AAPCS64 \S 4.1.2.
+
+   See the comment above aarch64_composite_type_p for the notes on MODE.  */
+
+static bool
+aarch64_short_vector_p (const_tree type,
+			machine_mode mode)
+{
+  HOST_WIDE_INT size = -1;
+
+  if (type && TREE_CODE (type) == VECTOR_TYPE)
+    size = int_size_in_bytes (type);
+  else if (GET_MODE_CLASS (mode) == MODE_VECTOR_INT
+	    || GET_MODE_CLASS (mode) == MODE_VECTOR_FLOAT)
+    size = GET_MODE_SIZE (mode);
+
+  return (size == 8 || size == 16);
+}
+
 /* Return TRUE if the type, as described by TYPE and MODE, is a composite
    type as described in AAPCS64 \S 4.3.  This includes aggregate, union and
    array types.  The C99 floating-point complex types are also considered
@@ -7851,36 +9268,18 @@ static bool
 aarch64_composite_type_p (const_tree type,
 			  machine_mode mode)
 {
-  if (type && (AGGREGATE_TYPE_P (type) || TREE_CODE (type) == COMPLEX_TYPE))
-    return true;
+  if (aarch64_short_vector_p (type, mode))
+    return false;
 
-  if (mode == BLKmode
-      || GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT
-      || GET_MODE_CLASS (mode) == MODE_COMPLEX_INT)
+  if (type && (AGGREGATE_TYPE_P (type) || TREE_CODE (type) == COMPLEX_TYPE))
     return true;
 
-  return false;
-}
-
-/* Return TRUE if the type, as described by TYPE and MODE, is a short vector
-   type as described in AAPCS64 \S 4.1.2.
-
-   See the comment above aarch64_composite_type_p for the notes on MODE.  */
-
-static bool
-aarch64_short_vector_p (const_tree type,
-			machine_mode mode)
-{
-  HOST_WIDE_INT size = -1;
-
-  if (type && TREE_CODE (type) == VECTOR_TYPE)
-    size = int_size_in_bytes (type);
-  else if (!aarch64_composite_type_p (type, mode)
-	   && (GET_MODE_CLASS (mode) == MODE_VECTOR_INT
-	       || GET_MODE_CLASS (mode) == MODE_VECTOR_FLOAT))
-    size = GET_MODE_SIZE (mode);
+  if (mode == BLKmode
+      || GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT
+      || GET_MODE_CLASS (mode) == MODE_COMPLEX_INT)
+    return true;
 
-  return (size == 8 || size == 16) ? true : false;
+  return false;
 }
 
 /* Return TRUE if an argument, whose type is described by TYPE and MODE,
@@ -7954,6 +9353,7 @@ aarch64_vector_mode_supported_p (machine_mode mode)
 	  || mode == V2SImode  || mode == V4HImode
 	  || mode == V8QImode || mode == V2SFmode
 	  || mode == V4SFmode || mode == V2DFmode
+	  || mode == V4HFmode || mode == V8HFmode
 	  || mode == V1DFmode))
     return true;
 
@@ -8029,6 +9429,10 @@ aarch64_mangle_type (const_tree type)
   if (lang_hooks.types_compatible_p (CONST_CAST_TREE (type), va_list_type))
     return "St9__va_list";
 
+  /* Half-precision float.  */
+  if (TREE_CODE (type) == REAL_TYPE && TYPE_PRECISION (type) == 16)
+    return "Dh";
+
   /* Mangle AArch64-specific internal types.  TYPE_NAME is non-NULL_TREE for
      builtin types.  */
   if (TYPE_NAME (type) != NULL)
@@ -8130,7 +9534,7 @@ aarch64_madd_needs_nop (rtx_insn* insn)
   rtx_insn *prev;
   rtx body;
 
-  if (!aarch64_fix_a53_err835769)
+  if (!TARGET_FIX_ERR_A53_835769)
     return false;
 
   if (recog_memoized (insn) < 0)
@@ -8575,30 +9979,12 @@ aarch64_simd_lane_bounds (rtx operand, HOST_WIDE_INT low, HOST_WIDE_INT high,
   if (lane < low || lane >= high)
   {
     if (exp)
-      error ("%Klane %ld out of range %ld - %ld", exp, lane, low, high - 1);
+      error ("%Klane %wd out of range %wd - %wd", exp, lane, low, high - 1);
     else
-      error ("lane %ld out of range %ld - %ld", lane, low, high - 1);
+      error ("lane %wd out of range %wd - %wd", lane, low, high - 1);
   }
 }
 
-/* Emit code to place a AdvSIMD pair result in memory locations (with equal
-   registers).  */
-void
-aarch64_simd_emit_pair_result_insn (machine_mode mode,
-			    rtx (*intfn) (rtx, rtx, rtx), rtx destaddr,
-                            rtx op1)
-{
-  rtx mem = gen_rtx_MEM (mode, destaddr);
-  rtx tmp1 = gen_reg_rtx (mode);
-  rtx tmp2 = gen_reg_rtx (mode);
-
-  emit_insn (intfn (tmp1, op1, tmp2));
-
-  emit_move_insn (mem, tmp1);
-  mem = adjust_address (mem, mode, GET_MODE_SIZE (mode));
-  emit_move_insn (mem, tmp2);
-}
-
 /* Return TRUE if OP is a valid vector addressing mode.  */
 bool
 aarch64_simd_mem_operand_p (rtx op)
@@ -8659,7 +10045,7 @@ aarch64_simd_attr_length_move (rtx_insn *insn)
 }
 
 /* Compute and return the length of aarch64_simd_reglist<mode>, where <mode> is
-   one of VSTRUCT modes: OI, CI, EI, or XI.  */
+   one of VSTRUCT modes: OI, CI, or XI.  */
 int
 aarch64_simd_attr_length_rglist (enum machine_mode mode)
 {
@@ -8781,22 +10167,19 @@ aarch64_expand_vector_init (rtx target, rtx vals)
   machine_mode mode = GET_MODE (target);
   machine_mode inner_mode = GET_MODE_INNER (mode);
   int n_elts = GET_MODE_NUNITS (mode);
-  int n_var = 0, one_var = -1;
+  int n_var = 0;
+  rtx any_const = NULL_RTX;
   bool all_same = true;
-  rtx x, mem;
-  int i;
 
-  x = XVECEXP (vals, 0, 0);
-  if (!CONST_INT_P (x) && !CONST_DOUBLE_P (x))
-    n_var = 1, one_var = 0;
-  
-  for (i = 1; i < n_elts; ++i)
+  for (int i = 0; i < n_elts; ++i)
     {
-      x = XVECEXP (vals, 0, i);
+      rtx x = XVECEXP (vals, 0, i);
       if (!CONST_INT_P (x) && !CONST_DOUBLE_P (x))
-	++n_var, one_var = i;
+	++n_var;
+      else
+	any_const = x;
 
-      if (!rtx_equal_p (x, XVECEXP (vals, 0, 0)))
+      if (i > 0 && !rtx_equal_p (x, XVECEXP (vals, 0, 0)))
 	all_same = false;
     }
 
@@ -8813,36 +10196,60 @@ aarch64_expand_vector_init (rtx target, rtx vals)
   /* Splat a single non-constant element if we can.  */
   if (all_same)
     {
-      x = copy_to_mode_reg (inner_mode, XVECEXP (vals, 0, 0));
+      rtx x = copy_to_mode_reg (inner_mode, XVECEXP (vals, 0, 0));
       aarch64_emit_move (target, gen_rtx_VEC_DUPLICATE (mode, x));
       return;
     }
 
-  /* One field is non-constant.  Load constant then overwrite varying
-     field.  This is more efficient than using the stack.  */
-  if (n_var == 1)
+  /* Half the fields (or less) are non-constant.  Load constant then overwrite
+     varying fields.  Hope that this is more efficient than using the stack.  */
+  if (n_var <= n_elts/2)
     {
       rtx copy = copy_rtx (vals);
-      rtx index = GEN_INT (one_var);
-      enum insn_code icode;
 
-      /* Load constant part of vector, substitute neighboring value for
-	 varying element.  */
-      XVECEXP (copy, 0, one_var) = XVECEXP (vals, 0, one_var ^ 1);
+      /* Load constant part of vector.  We really don't care what goes into the
+	 parts we will overwrite, but we're more likely to be able to load the
+	 constant efficiently if it has fewer, larger, repeating parts
+	 (see aarch64_simd_valid_immediate).  */
+      for (int i = 0; i < n_elts; i++)
+	{
+	  rtx x = XVECEXP (vals, 0, i);
+	  if (CONST_INT_P (x) || CONST_DOUBLE_P (x))
+	    continue;
+	  rtx subst = any_const;
+	  for (int bit = n_elts / 2; bit > 0; bit /= 2)
+	    {
+	      /* Look in the copied vector, as more elements are const.  */
+	      rtx test = XVECEXP (copy, 0, i ^ bit);
+	      if (CONST_INT_P (test) || CONST_DOUBLE_P (test))
+		{
+		  subst = test;
+		  break;
+		}
+	    }
+	  XVECEXP (copy, 0, i) = subst;
+	}
       aarch64_expand_vector_init (target, copy);
 
-      /* Insert variable.  */
-      x = copy_to_mode_reg (inner_mode, XVECEXP (vals, 0, one_var));
-      icode = optab_handler (vec_set_optab, mode);
+      /* Insert variables.  */
+      enum insn_code icode = optab_handler (vec_set_optab, mode);
       gcc_assert (icode != CODE_FOR_nothing);
-      emit_insn (GEN_FCN (icode) (target, x, index));
+
+      for (int i = 0; i < n_elts; i++)
+	{
+	  rtx x = XVECEXP (vals, 0, i);
+	  if (CONST_INT_P (x) || CONST_DOUBLE_P (x))
+	    continue;
+	  x = copy_to_mode_reg (inner_mode, x);
+	  emit_insn (GEN_FCN (icode) (target, x, GEN_INT (i)));
+	}
       return;
     }
 
   /* Construct the vector in memory one field at a time
      and load the whole vector.  */
-  mem = assign_stack_temp (mode, GET_MODE_SIZE (mode));
-  for (i = 0; i < n_elts; i++)
+  rtx mem = assign_stack_temp (mode, GET_MODE_SIZE (mode));
+  for (int i = 0; i < n_elts; i++)
     emit_move_insn (adjust_address_nv (mem, inner_mode,
 				    i * GET_MODE_SIZE (inner_mode)),
 		    XVECEXP (vals, 0, i));
@@ -8858,80 +10265,6 @@ aarch64_shift_truncation_mask (machine_mode mode)
      || aarch64_vect_struct_mode_p (mode)) ? 0 : (GET_MODE_BITSIZE (mode) - 1);
 }
 
-#ifndef TLS_SECTION_ASM_FLAG
-#define TLS_SECTION_ASM_FLAG 'T'
-#endif
-
-void
-aarch64_elf_asm_named_section (const char *name, unsigned int flags,
-			       tree decl ATTRIBUTE_UNUSED)
-{
-  char flagchars[10], *f = flagchars;
-
-  /* If we have already declared this section, we can use an
-     abbreviated form to switch back to it -- unless this section is
-     part of a COMDAT groups, in which case GAS requires the full
-     declaration every time.  */
-  if (!(HAVE_COMDAT_GROUP && (flags & SECTION_LINKONCE))
-      && (flags & SECTION_DECLARED))
-    {
-      fprintf (asm_out_file, "\t.section\t%s\n", name);
-      return;
-    }
-
-  if (!(flags & SECTION_DEBUG))
-    *f++ = 'a';
-  if (flags & SECTION_WRITE)
-    *f++ = 'w';
-  if (flags & SECTION_CODE)
-    *f++ = 'x';
-  if (flags & SECTION_SMALL)
-    *f++ = 's';
-  if (flags & SECTION_MERGE)
-    *f++ = 'M';
-  if (flags & SECTION_STRINGS)
-    *f++ = 'S';
-  if (flags & SECTION_TLS)
-    *f++ = TLS_SECTION_ASM_FLAG;
-  if (HAVE_COMDAT_GROUP && (flags & SECTION_LINKONCE))
-    *f++ = 'G';
-  *f = '\0';
-
-  fprintf (asm_out_file, "\t.section\t%s,\"%s\"", name, flagchars);
-
-  if (!(flags & SECTION_NOTYPE))
-    {
-      const char *type;
-      const char *format;
-
-      if (flags & SECTION_BSS)
-	type = "nobits";
-      else
-	type = "progbits";
-
-#ifdef TYPE_OPERAND_FMT
-      format = "," TYPE_OPERAND_FMT;
-#else
-      format = ",@%s";
-#endif
-
-      fprintf (asm_out_file, format, type);
-
-      if (flags & SECTION_ENTSIZE)
-	fprintf (asm_out_file, ",%d", flags & SECTION_ENTSIZE);
-      if (HAVE_COMDAT_GROUP && (flags & SECTION_LINKONCE))
-	{
-	  if (TREE_CODE (decl) == IDENTIFIER_NODE)
-	    fprintf (asm_out_file, ",%s,comdat", IDENTIFIER_POINTER (decl));
-	  else
-	    fprintf (asm_out_file, ",%s,comdat",
-		     IDENTIFIER_POINTER (DECL_COMDAT_GROUP (decl)));
-	}
-    }
-
-  putc ('\n', asm_out_file);
-}
-
 /* Select a format to encode pointers in exception handling data.  */
 int
 aarch64_asm_preferred_eh_data_format (int code ATTRIBUTE_UNUSED, int global)
@@ -8955,6 +10288,45 @@ aarch64_asm_preferred_eh_data_format (int code ATTRIBUTE_UNUSED, int global)
    return (global ? DW_EH_PE_indirect : 0) | DW_EH_PE_pcrel | type;
 }
 
+/* Implement ASM_DECLARE_FUNCTION_NAME.  Output the ISA features used
+   by the function fndecl.  */
+
+void
+aarch64_declare_function_name (FILE *stream, const char* name,
+				tree fndecl)
+{
+  tree target_parts = DECL_FUNCTION_SPECIFIC_TARGET (fndecl);
+
+  struct cl_target_option *targ_options;
+  if (target_parts)
+    targ_options = TREE_TARGET_OPTION (target_parts);
+  else
+    targ_options = TREE_TARGET_OPTION (target_option_current_node);
+  gcc_assert (targ_options);
+
+  const struct processor *this_arch
+    = aarch64_get_arch (targ_options->x_explicit_arch);
+
+  unsigned long isa_flags = targ_options->x_aarch64_isa_flags;
+  std::string extension
+    = aarch64_get_extension_string_for_isa_flags (isa_flags);
+  asm_fprintf (asm_out_file, "\t.arch %s%s\n",
+	       this_arch->name, extension.c_str ());
+
+  /* Print the cpu name we're tuning for in the comments, might be
+     useful to readers of the generated asm.  */
+
+  const struct processor *this_tune
+    = aarch64_get_tune_cpu (targ_options->x_explicit_tune_core);
+
+  asm_fprintf (asm_out_file, "\t" ASM_COMMENT_START ".tune %s\n",
+	       this_tune->name);
+
+  /* Don't forget the type directive for ELF.  */
+  ASM_OUTPUT_TYPE_DIRECTIVE (stream, name, "function");
+  ASM_OUTPUT_LABEL (stream, name);
+}
+
 /* Emit load exclusive.  */
 
 static void
@@ -9015,7 +10387,23 @@ aarch64_expand_compare_and_swap (rtx operands[])
 {
   rtx bval, rval, mem, oldval, newval, is_weak, mod_s, mod_f, x;
   machine_mode mode, cmp_mode;
-  rtx (*gen) (rtx, rtx, rtx, rtx, rtx, rtx, rtx);
+  typedef rtx (*gen_cas_fn) (rtx, rtx, rtx, rtx, rtx, rtx, rtx);
+  int idx;
+  gen_cas_fn gen;
+  const gen_cas_fn split_cas[] =
+  {
+    gen_aarch64_compare_and_swapqi,
+    gen_aarch64_compare_and_swaphi,
+    gen_aarch64_compare_and_swapsi,
+    gen_aarch64_compare_and_swapdi
+  };
+  const gen_cas_fn atomic_cas[] =
+  {
+    gen_aarch64_compare_and_swapqi_lse,
+    gen_aarch64_compare_and_swaphi_lse,
+    gen_aarch64_compare_and_swapsi_lse,
+    gen_aarch64_compare_and_swapdi_lse
+  };
 
   bval = operands[0];
   rval = operands[1];
@@ -9060,13 +10448,17 @@ aarch64_expand_compare_and_swap (rtx operands[])
 
   switch (mode)
     {
-    case QImode: gen = gen_atomic_compare_and_swapqi_1; break;
-    case HImode: gen = gen_atomic_compare_and_swaphi_1; break;
-    case SImode: gen = gen_atomic_compare_and_swapsi_1; break;
-    case DImode: gen = gen_atomic_compare_and_swapdi_1; break;
+    case QImode: idx = 0; break;
+    case HImode: idx = 1; break;
+    case SImode: idx = 2; break;
+    case DImode: idx = 3; break;
     default:
       gcc_unreachable ();
     }
+  if (TARGET_LSE)
+    gen = atomic_cas[idx];
+  else
+    gen = split_cas[idx];
 
   emit_insn (gen (rval, mem, oldval, newval, is_weak, mod_s, mod_f));
 
@@ -9078,6 +10470,32 @@ aarch64_expand_compare_and_swap (rtx operands[])
   emit_insn (gen_rtx_SET (VOIDmode, bval, x));
 }
 
+/* Test whether the target supports using a atomic load-operate instruction.
+   CODE is the operation and AFTER is TRUE if the data in memory after the
+   operation should be returned and FALSE if the data before the operation
+   should be returned.  Returns FALSE if the operation isn't supported by the
+   architecture.  */
+
+bool
+aarch64_atomic_ldop_supported_p (enum rtx_code code)
+{
+  if (!TARGET_LSE)
+    return false;
+
+  switch (code)
+    {
+    case SET:
+    case AND:
+    case IOR:
+    case XOR:
+    case MINUS:
+    case PLUS:
+      return true;
+    default:
+      return false;
+    }
+}
+
 /* Emit a barrier, that is appropriate for memory model MODEL, at the end of a
    sequence implementing an atomic operation.  */
 
@@ -9095,6 +10513,42 @@ aarch64_emit_post_barrier (enum memmodel model)
     }
 }
 
+/* Emit an atomic compare-and-swap operation.  RVAL is the destination register
+   for the data in memory.  EXPECTED is the value expected to be in memory.
+   DESIRED is the value to store to memory.  MEM is the memory location.  MODEL
+   is the memory ordering to use.  */
+
+void
+aarch64_gen_atomic_cas (rtx rval, rtx mem,
+			rtx expected, rtx desired,
+			rtx model)
+{
+  rtx (*gen) (rtx, rtx, rtx, rtx);
+  machine_mode mode;
+
+  mode = GET_MODE (mem);
+
+  switch (mode)
+    {
+    case QImode: gen = gen_aarch64_atomic_casqi; break;
+    case HImode: gen = gen_aarch64_atomic_cashi; break;
+    case SImode: gen = gen_aarch64_atomic_cassi; break;
+    case DImode: gen = gen_aarch64_atomic_casdi; break;
+    default:
+      gcc_unreachable ();
+    }
+
+  /* Move the expected value into the CAS destination register.  */
+  emit_insn (gen_rtx_SET (VOIDmode, rval, expected));
+
+  /* Emit the CAS.  */
+  emit_insn (gen (rval, mem, desired, model));
+
+  /* Compare the expected value with the value loaded by the CAS, to establish
+     whether the swap was made.  */
+  aarch64_gen_compare_reg (EQ, rval, expected);
+}
+
 /* Split a compare and swap pattern.  */
 
 void
@@ -9163,11 +10617,257 @@ aarch64_split_compare_and_swap (rtx operands[])
     aarch64_emit_post_barrier (model);
 }
 
+/* Emit a BIC instruction.  */
+
+static void
+aarch64_emit_bic (machine_mode mode, rtx dst, rtx s1, rtx s2, int shift)
+{
+  rtx shift_rtx = GEN_INT (shift);
+  rtx (*gen) (rtx, rtx, rtx, rtx);
+
+  switch (mode)
+    {
+    case SImode: gen = gen_and_one_cmpl_lshrsi3; break;
+    case DImode: gen = gen_and_one_cmpl_lshrdi3; break;
+    default:
+      gcc_unreachable ();
+    }
+
+  emit_insn (gen (dst, s2, shift_rtx, s1));
+}
+
+/* Emit an atomic swap.  */
+
+static void
+aarch64_emit_atomic_swap (machine_mode mode, rtx dst, rtx value,
+			  rtx mem, rtx model)
+{
+  rtx (*gen) (rtx, rtx, rtx, rtx);
+
+  switch (mode)
+    {
+    case QImode: gen = gen_aarch64_atomic_swpqi; break;
+    case HImode: gen = gen_aarch64_atomic_swphi; break;
+    case SImode: gen = gen_aarch64_atomic_swpsi; break;
+    case DImode: gen = gen_aarch64_atomic_swpdi; break;
+    default:
+      gcc_unreachable ();
+    }
+
+  emit_insn (gen (dst, mem, value, model));
+}
+
+/* Operations supported by aarch64_emit_atomic_load_op.  */
+
+enum aarch64_atomic_load_op_code
+{
+  AARCH64_LDOP_PLUS,	/* A + B  */
+  AARCH64_LDOP_XOR,	/* A ^ B  */
+  AARCH64_LDOP_OR,	/* A | B  */
+  AARCH64_LDOP_BIC	/* A & ~B  */
+};
+
+/* Emit an atomic load-operate.  */
+
+static void
+aarch64_emit_atomic_load_op (enum aarch64_atomic_load_op_code code,
+			     machine_mode mode, rtx dst, rtx src,
+			     rtx mem, rtx model)
+{
+  typedef rtx (*aarch64_atomic_load_op_fn) (rtx, rtx, rtx, rtx);
+  const aarch64_atomic_load_op_fn plus[] =
+  {
+    gen_aarch64_atomic_loadaddqi,
+    gen_aarch64_atomic_loadaddhi,
+    gen_aarch64_atomic_loadaddsi,
+    gen_aarch64_atomic_loadadddi
+  };
+  const aarch64_atomic_load_op_fn eor[] =
+  {
+    gen_aarch64_atomic_loadeorqi,
+    gen_aarch64_atomic_loadeorhi,
+    gen_aarch64_atomic_loadeorsi,
+    gen_aarch64_atomic_loadeordi
+  };
+  const aarch64_atomic_load_op_fn ior[] =
+  {
+    gen_aarch64_atomic_loadsetqi,
+    gen_aarch64_atomic_loadsethi,
+    gen_aarch64_atomic_loadsetsi,
+    gen_aarch64_atomic_loadsetdi
+  };
+  const aarch64_atomic_load_op_fn bic[] =
+  {
+    gen_aarch64_atomic_loadclrqi,
+    gen_aarch64_atomic_loadclrhi,
+    gen_aarch64_atomic_loadclrsi,
+    gen_aarch64_atomic_loadclrdi
+  };
+  aarch64_atomic_load_op_fn gen;
+  int idx = 0;
+
+  switch (mode)
+    {
+    case QImode: idx = 0; break;
+    case HImode: idx = 1; break;
+    case SImode: idx = 2; break;
+    case DImode: idx = 3; break;
+    default:
+      gcc_unreachable ();
+    }
+
+  switch (code)
+    {
+    case AARCH64_LDOP_PLUS: gen = plus[idx]; break;
+    case AARCH64_LDOP_XOR: gen = eor[idx]; break;
+    case AARCH64_LDOP_OR: gen = ior[idx]; break;
+    case AARCH64_LDOP_BIC: gen = bic[idx]; break;
+    default:
+      gcc_unreachable ();
+    }
+
+  emit_insn (gen (dst, mem, src, model));
+}
+
+/* Emit an atomic load+operate.  CODE is the operation.  OUT_DATA is the
+   location to store the data read from memory.  OUT_RESULT is the location to
+   store the result of the operation.  MEM is the memory location to read and
+   modify.  MODEL_RTX is the memory ordering to use.  VALUE is the second
+   operand for the operation.  Either OUT_DATA or OUT_RESULT, but not both, can
+   be NULL.  */
+
+void
+aarch64_gen_atomic_ldop (enum rtx_code code, rtx out_data, rtx out_result,
+			 rtx mem, rtx value, rtx model_rtx)
+{
+  machine_mode mode = GET_MODE (mem);
+  machine_mode wmode = (mode == DImode ? DImode : SImode);
+  const bool short_mode = (mode < SImode);
+  aarch64_atomic_load_op_code ldop_code;
+  rtx src;
+  rtx x;
+
+  if (out_data)
+    out_data = gen_lowpart (mode, out_data);
+
+  if (out_result)
+    out_result = gen_lowpart (mode, out_result);
+
+  /* Make sure the value is in a register, putting it into a destination
+     register if it needs to be manipulated.  */
+  if (!register_operand (value, mode)
+      || code == AND || code == MINUS)
+    {
+      src = out_result ? out_result : out_data;
+      emit_move_insn (src, gen_lowpart (mode, value));
+    }
+  else
+    src = value;
+  gcc_assert (register_operand (src, mode));
+
+  /* Preprocess the data for the operation as necessary.  If the operation is
+     a SET then emit a swap instruction and finish.  */
+  switch (code)
+    {
+    case SET:
+      aarch64_emit_atomic_swap (mode, out_data, src, mem, model_rtx);
+      return;
+
+    case MINUS:
+      /* Negate the value and treat it as a PLUS.  */
+      {
+	rtx neg_src;
+
+	/* Resize the value if necessary.  */
+	if (short_mode)
+	  src = gen_lowpart (wmode, src);
+
+	neg_src = gen_rtx_NEG (wmode, src);
+	emit_insn (gen_rtx_SET (VOIDmode, src, neg_src));
+
+	if (short_mode)
+	  src = gen_lowpart (mode, src);
+      }
+      /* Fall-through.  */
+    case PLUS:
+      ldop_code = AARCH64_LDOP_PLUS;
+      break;
+
+    case IOR:
+      ldop_code = AARCH64_LDOP_OR;
+      break;
+
+    case XOR:
+      ldop_code = AARCH64_LDOP_XOR;
+      break;
+
+    case AND:
+      {
+	rtx not_src;
+
+	/* Resize the value if necessary.  */
+	if (short_mode)
+	  src = gen_lowpart (wmode, src);
+
+	not_src = gen_rtx_NOT (wmode, src);
+	emit_insn (gen_rtx_SET (VOIDmode, src, not_src));
+
+	if (short_mode)
+	  src = gen_lowpart (mode, src);
+      }
+      ldop_code = AARCH64_LDOP_BIC;
+      break;
+
+    default:
+      /* The operation can't be done with atomic instructions.  */
+      gcc_unreachable ();
+    }
+
+  aarch64_emit_atomic_load_op (ldop_code, mode, out_data, src, mem, model_rtx);
+
+  /* If necessary, calculate the data in memory after the update by redoing the
+     operation from values in registers.  */
+  if (!out_result)
+    return;
+
+  if (short_mode)
+    {
+      src = gen_lowpart (wmode, src);
+      out_data = gen_lowpart (wmode, out_data);
+      out_result = gen_lowpart (wmode, out_result);
+    }
+
+  x = NULL_RTX;
+
+  switch (code)
+    {
+    case MINUS:
+    case PLUS:
+      x = gen_rtx_PLUS (wmode, out_data, src);
+      break;
+    case IOR:
+      x = gen_rtx_IOR (wmode, out_data, src);
+      break;
+    case XOR:
+      x = gen_rtx_XOR (wmode, out_data, src);
+      break;
+    case AND:
+      aarch64_emit_bic (wmode, out_result, out_data, src, 0);
+      return;
+    default:
+      gcc_unreachable ();
+    }
+
+  emit_set_insn (out_result, x);
+
+  return;
+}
+
 /* Split an atomic operation.  */
 
 void
 aarch64_split_atomic_op (enum rtx_code code, rtx old_out, rtx new_out, rtx mem,
-		     rtx value, rtx model_rtx, rtx cond)
+			 rtx value, rtx model_rtx, rtx cond)
 {
   machine_mode mode = GET_MODE (mem);
   machine_mode wmode = (mode == DImode ? DImode : SImode);
@@ -9176,6 +10876,7 @@ aarch64_split_atomic_op (enum rtx_code code, rtx old_out, rtx new_out, rtx mem,
   rtx_code_label *label;
   rtx x;
 
+  /* Split the atomic operation into a sequence.  */
   label = gen_label_rtx ();
   emit_label (label);
 
@@ -9236,33 +10937,30 @@ aarch64_split_atomic_op (enum rtx_code code, rtx old_out, rtx new_out, rtx mem,
 }
 
 static void
-aarch64_print_extension (void)
+aarch64_init_libfuncs (void)
 {
-  const struct aarch64_option_extension *opt = NULL;
+   /* Half-precision float operations.  The compiler handles all operations
+     with NULL libfuncs by converting to SFmode.  */
 
-  for (opt = all_extensions; opt->name != NULL; opt++)
-    if ((aarch64_isa_flags & opt->flags_on) == opt->flags_on)
-      asm_fprintf (asm_out_file, "+%s", opt->name);
+  /* Conversions.  */
+  set_conv_libfunc (trunc_optab, HFmode, SFmode, "__gnu_f2h_ieee");
+  set_conv_libfunc (sext_optab, SFmode, HFmode, "__gnu_h2f_ieee");
 
-  asm_fprintf (asm_out_file, "\n");
-}
+  /* Arithmetic.  */
+  set_optab_libfunc (add_optab, HFmode, NULL);
+  set_optab_libfunc (sdiv_optab, HFmode, NULL);
+  set_optab_libfunc (smul_optab, HFmode, NULL);
+  set_optab_libfunc (neg_optab, HFmode, NULL);
+  set_optab_libfunc (sub_optab, HFmode, NULL);
 
-static void
-aarch64_start_file (void)
-{
-  if (selected_arch)
-    {
-      asm_fprintf (asm_out_file, "\t.arch %s", selected_arch->name);
-      aarch64_print_extension ();
-    }
-  else if (selected_cpu)
-    {
-      const char *truncated_name
-	    = aarch64_rewrite_selected_cpu (selected_cpu->name);
-      asm_fprintf (asm_out_file, "\t.cpu %s", truncated_name);
-      aarch64_print_extension ();
-    }
-  default_file_start();
+  /* Comparisons.  */
+  set_optab_libfunc (eq_optab, HFmode, NULL);
+  set_optab_libfunc (ne_optab, HFmode, NULL);
+  set_optab_libfunc (lt_optab, HFmode, NULL);
+  set_optab_libfunc (le_optab, HFmode, NULL);
+  set_optab_libfunc (ge_optab, HFmode, NULL);
+  set_optab_libfunc (gt_optab, HFmode, NULL);
+  set_optab_libfunc (unord_optab, HFmode, NULL);
 }
 
 /* Target hook for c_mode_for_suffix.  */
@@ -9303,7 +11001,8 @@ aarch64_float_const_representable_p (rtx x)
   if (!CONST_DOUBLE_P (x))
     return false;
 
-  if (GET_MODE (x) == VOIDmode)
+  /* We don't support HFmode constants yet.  */
+  if (GET_MODE (x) == VOIDmode || GET_MODE (x) == HFmode)
     return false;
 
   REAL_VALUE_FROM_CONST_DOUBLE (r, x);
@@ -10006,6 +11705,8 @@ aarch64_evpc_dup (struct expand_vec_perm_d *d)
     case V4SImode: gen = gen_aarch64_dup_lanev4si; break;
     case V2SImode: gen = gen_aarch64_dup_lanev2si; break;
     case V2DImode: gen = gen_aarch64_dup_lanev2di; break;
+    case V8HFmode: gen = gen_aarch64_dup_lanev8hf; break;
+    case V4HFmode: gen = gen_aarch64_dup_lanev4hf; break;
     case V4SFmode: gen = gen_aarch64_dup_lanev4sf; break;
     case V2SFmode: gen = gen_aarch64_dup_lanev2sf; break;
     case V2DFmode: gen = gen_aarch64_dup_lanev2df; break;
@@ -10604,7 +12305,7 @@ aarch64_gen_ccmp_next (rtx *prep_seq, rtx *gen_seq, rtx prev, int cmp_code,
 static bool
 aarch64_macro_fusion_p (void)
 {
-  return aarch64_tune_params->fuseable_ops != AARCH64_FUSE_NOTHING;
+  return aarch64_tune_params.fusible_ops != AARCH64_FUSE_NOTHING;
 }
 
 
@@ -10624,7 +12325,7 @@ aarch_macro_fusion_pair_p (rtx_insn *prev, rtx_insn *curr)
     return false;
 
   if (simple_sets_p
-      && (aarch64_tune_params->fuseable_ops & AARCH64_FUSE_MOV_MOVK))
+      && (aarch64_tune_params.fusible_ops & AARCH64_FUSE_MOV_MOVK))
     {
       /* We are trying to match:
          prev (mov)  == (set (reg r0) (const_int imm16))
@@ -10649,7 +12350,7 @@ aarch_macro_fusion_pair_p (rtx_insn *prev, rtx_insn *curr)
     }
 
   if (simple_sets_p
-      && (aarch64_tune_params->fuseable_ops & AARCH64_FUSE_ADRP_ADD))
+      && (aarch64_tune_params.fusible_ops & AARCH64_FUSE_ADRP_ADD))
     {
 
       /*  We're trying to match:
@@ -10675,7 +12376,7 @@ aarch_macro_fusion_pair_p (rtx_insn *prev, rtx_insn *curr)
     }
 
   if (simple_sets_p
-      && (aarch64_tune_params->fuseable_ops & AARCH64_FUSE_MOVK_MOVK))
+      && (aarch64_tune_params.fusible_ops & AARCH64_FUSE_MOVK_MOVK))
     {
 
       /* We're trying to match:
@@ -10704,7 +12405,7 @@ aarch_macro_fusion_pair_p (rtx_insn *prev, rtx_insn *curr)
 
     }
   if (simple_sets_p
-      && (aarch64_tune_params->fuseable_ops & AARCH64_FUSE_ADRP_LDR))
+      && (aarch64_tune_params.fusible_ops & AARCH64_FUSE_ADRP_LDR))
     {
       /* We're trying to match:
           prev (adrp) == (set (reg r0)
@@ -10735,7 +12436,7 @@ aarch_macro_fusion_pair_p (rtx_insn *prev, rtx_insn *curr)
         }
     }
 
-  if ((aarch64_tune_params->fuseable_ops & AARCH64_FUSE_CMP_BRANCH)
+  if ((aarch64_tune_params.fusible_ops & AARCH64_FUSE_CMP_BRANCH)
       && any_condjump_p (curr))
     {
       enum attr_type prev_type = get_attr_type (prev);
@@ -10815,8 +12516,9 @@ fusion_load_store (rtx_insn *insn, rtx *base, rtx *offset)
   src = SET_SRC (x);
   dest = SET_DEST (x);
 
-  if (GET_MODE (dest) != SImode && GET_MODE (dest) != DImode
-      && GET_MODE (dest) != SFmode && GET_MODE (dest) != DFmode)
+  machine_mode dest_mode = GET_MODE (dest);
+
+  if (!aarch64_mode_valid_for_sched_fusion_p (dest_mode))
     return SCHED_FUSION_NONE;
 
   if (GET_CODE (src) == SIGN_EXTEND)
@@ -11239,6 +12941,14 @@ aarch64_gen_adjusted_ldpstp (rtx *operands, bool load,
   return true;
 }
 
+/* Implement TARGET_PROMOTED_TYPE to promote __fp16 to float.  */
+static tree
+aarch64_promoted_type (const_tree t)
+{
+  if (SCALAR_FLOAT_TYPE_P (t) && TYPE_PRECISION (t) == 16)
+    return float_type_node;
+  return NULL_TREE;
+}
 #undef TARGET_ADDRESS_COST
 #define TARGET_ADDRESS_COST aarch64_address_cost
 
@@ -11262,9 +12972,6 @@ aarch64_gen_adjusted_ldpstp (rtx *operands, bool load,
 #define TARGET_ASM_CAN_OUTPUT_MI_THUNK \
   hook_bool_const_tree_hwi_hwi_const_tree_true
 
-#undef TARGET_ASM_FILE_START
-#define TARGET_ASM_FILE_START aarch64_start_file
-
 #undef TARGET_ASM_OUTPUT_MI_THUNK
 #define TARGET_ASM_OUTPUT_MI_THUNK aarch64_output_mi_thunk
 
@@ -11283,6 +12990,9 @@ aarch64_gen_adjusted_ldpstp (rtx *operands, bool load,
 #undef TARGET_CAN_ELIMINATE
 #define TARGET_CAN_ELIMINATE aarch64_can_eliminate
 
+#undef TARGET_CAN_INLINE_P
+#define TARGET_CAN_INLINE_P aarch64_can_inline_p
+
 #undef TARGET_CANNOT_FORCE_CONST_MEM
 #define TARGET_CANNOT_FORCE_CONST_MEM aarch64_cannot_force_const_mem
 
@@ -11384,6 +13094,21 @@ aarch64_gen_adjusted_ldpstp (rtx *operands, bool load,
 #define TARGET_OVERRIDE_OPTIONS_AFTER_CHANGE \
   aarch64_override_options_after_change
 
+#undef TARGET_OPTION_SAVE
+#define TARGET_OPTION_SAVE aarch64_option_save
+
+#undef TARGET_OPTION_RESTORE
+#define TARGET_OPTION_RESTORE aarch64_option_restore
+
+#undef TARGET_OPTION_PRINT
+#define TARGET_OPTION_PRINT aarch64_option_print
+
+#undef TARGET_OPTION_VALID_ATTRIBUTE_P
+#define TARGET_OPTION_VALID_ATTRIBUTE_P aarch64_option_valid_attribute_p
+
+#undef TARGET_SET_CURRENT_FUNCTION
+#define TARGET_SET_CURRENT_FUNCTION aarch64_set_current_function
+
 #undef TARGET_PASS_BY_REFERENCE
 #define TARGET_PASS_BY_REFERENCE aarch64_pass_by_reference
 
@@ -11393,6 +13118,9 @@ aarch64_gen_adjusted_ldpstp (rtx *operands, bool load,
 #undef TARGET_SCHED_REASSOCIATION_WIDTH
 #define TARGET_SCHED_REASSOCIATION_WIDTH aarch64_reassociation_width
 
+#undef TARGET_PROMOTED_TYPE
+#define TARGET_PROMOTED_TYPE aarch64_promoted_type
+
 #undef TARGET_SECONDARY_RELOAD
 #define TARGET_SECONDARY_RELOAD aarch64_secondary_reload
 
@@ -11485,6 +13213,8 @@ aarch64_gen_adjusted_ldpstp (rtx *operands, bool load,
 #define TARGET_VECTORIZE_VEC_PERM_CONST_OK \
   aarch64_vectorize_vec_perm_const_ok
 
+#undef TARGET_INIT_LIBFUNCS
+#define TARGET_INIT_LIBFUNCS aarch64_init_libfuncs
 
 #undef TARGET_FIXED_CONDITION_CODE_REGS
 #define TARGET_FIXED_CONDITION_CODE_REGS aarch64_fixed_condition_code_regs
--- a/src/gcc/config/aarch64/aarch64.h
+++ b/src/gcc/config/aarch64/aarch64.h
@@ -23,80 +23,13 @@
 #define GCC_AARCH64_H
 
 /* Target CPU builtins.  */
-#define TARGET_CPU_CPP_BUILTINS()			\
-  do							\
-    {							\
-      builtin_define ("__aarch64__");                   \
-      builtin_define ("__ARM_64BIT_STATE");             \
-      builtin_define_with_int_value                     \
-        ("__ARM_ARCH", aarch64_architecture_version);   \
-      cpp_define_formatted                                              \
-        (parse_in, "__ARM_ARCH_%dA", aarch64_architecture_version);     \
-      builtin_define ("__ARM_ARCH_ISA_A64");            \
-      builtin_define_with_int_value                     \
-        ("__ARM_ARCH_PROFILE", 'A');                    \
-      builtin_define ("__ARM_FEATURE_CLZ");             \
-      builtin_define ("__ARM_FEATURE_IDIV");            \
-      builtin_define ("__ARM_FEATURE_UNALIGNED");       \
-      if (flag_unsafe_math_optimizations)               \
-        builtin_define ("__ARM_FP_FAST");               \
-      builtin_define ("__ARM_PCS_AAPCS64");             \
-      builtin_define_with_int_value                     \
-        ("__ARM_SIZEOF_WCHAR_T", WCHAR_TYPE_SIZE / 8);  \
-      builtin_define_with_int_value                     \
-        ("__ARM_SIZEOF_MINIMAL_ENUM",                   \
-         flag_short_enums? 1 : 4);                      \
-      if (TARGET_BIG_END)				\
-        {                                               \
-          builtin_define ("__AARCH64EB__");             \
-          builtin_define ("__ARM_BIG_ENDIAN");          \
-        }                                               \
-      else						\
-	builtin_define ("__AARCH64EL__");		\
-							\
-      if (TARGET_FLOAT)                                         \
-        {                                                       \
-          builtin_define ("__ARM_FEATURE_FMA");                 \
-          builtin_define_with_int_value ("__ARM_FP", 0x0C);     \
-        }                                                       \
-      if (TARGET_SIMD)                                          \
-        {                                                       \
-          builtin_define ("__ARM_FEATURE_NUMERIC_MAXMIN");      \
-          builtin_define ("__ARM_NEON");			\
-          builtin_define_with_int_value ("__ARM_NEON_FP", 0x0C);\
-        }                                                       \
-							        \
-      if (TARGET_CRC32)				        \
-	builtin_define ("__ARM_FEATURE_CRC32");		\
-							\
-      switch (aarch64_cmodel)				\
-	{						\
-	  case AARCH64_CMODEL_TINY:			\
-	  case AARCH64_CMODEL_TINY_PIC:			\
-	    builtin_define ("__AARCH64_CMODEL_TINY__");	\
-	    break;					\
-	  case AARCH64_CMODEL_SMALL:			\
-	  case AARCH64_CMODEL_SMALL_PIC:		\
-	    builtin_define ("__AARCH64_CMODEL_SMALL__");\
-	    break;					\
-	  case AARCH64_CMODEL_LARGE:			\
-	    builtin_define ("__AARCH64_CMODEL_LARGE__");	\
-	    break;					\
-	  default:					\
-	    break;					\
-	}						\
-							\
-      if (TARGET_ILP32)					\
-	{						\
-	  cpp_define (parse_in, "_ILP32");		\
-	  cpp_define (parse_in, "__ILP32__");		\
-	}						\
-      if (TARGET_CRYPTO)				\
-	builtin_define ("__ARM_FEATURE_CRYPTO");	\
-    } while (0)
+#define TARGET_CPU_CPP_BUILTINS()	\
+  aarch64_cpu_cpp_builtins (pfile)
 
 
 
+#define REGISTER_TARGET_PRAGMAS() aarch64_register_pragmas ()
+
 /* Target machine storage layout.  */
 
 #define PROMOTE_MODE(MODE, UNSIGNEDP, TYPE)	\
@@ -198,8 +131,12 @@ extern unsigned aarch64_architecture_version;
 #define AARCH64_FL_SIMD       (1 << 0)	/* Has SIMD instructions.  */
 #define AARCH64_FL_FP         (1 << 1)	/* Has FP.  */
 #define AARCH64_FL_CRYPTO     (1 << 2)	/* Has crypto.  */
-#define AARCH64_FL_SLOWMUL    (1 << 3)	/* A slow multiply core.  */
-#define AARCH64_FL_CRC        (1 << 4)	/* Has CRC.  */
+#define AARCH64_FL_CRC        (1 << 3)	/* Has CRC.  */
+/* ARMv8.1 architecture extensions.  */
+#define AARCH64_FL_LSE	      (1 << 4)  /* Has Large System Extensions.  */
+#define AARCH64_FL_PAN	      (1 << 5)  /* Has Privileged Access Never.  */
+#define AARCH64_FL_LOR	      (1 << 6)  /* Has Limited Ordering regions.  */
+#define AARCH64_FL_RDMA	      (1 << 7)  /* Has ARMv8.1 Adv.SIMD.  */
 
 /* Has FP and SIMD.  */
 #define AARCH64_FL_FPSIMD     (AARCH64_FL_FP | AARCH64_FL_SIMD)
@@ -209,17 +146,17 @@ extern unsigned aarch64_architecture_version;
 
 /* Architecture flags that effect instruction selection.  */
 #define AARCH64_FL_FOR_ARCH8       (AARCH64_FL_FPSIMD)
+#define AARCH64_FL_FOR_ARCH8_1			       \
+  (AARCH64_FL_FOR_ARCH8 | AARCH64_FL_LSE | AARCH64_FL_PAN \
+   | AARCH64_FL_LOR | AARCH64_FL_RDMA)
 
 /* Macros to test ISA flags.  */
-extern unsigned long aarch64_isa_flags;
+
 #define AARCH64_ISA_CRC            (aarch64_isa_flags & AARCH64_FL_CRC)
 #define AARCH64_ISA_CRYPTO         (aarch64_isa_flags & AARCH64_FL_CRYPTO)
 #define AARCH64_ISA_FP             (aarch64_isa_flags & AARCH64_FL_FP)
 #define AARCH64_ISA_SIMD           (aarch64_isa_flags & AARCH64_FL_SIMD)
-
-/* Macros to test tuning flags.  */
-extern unsigned long aarch64_tune_flags;
-#define AARCH64_TUNE_SLOWMUL       (aarch64_tune_flags & AARCH64_FL_SLOWMUL)
+#define AARCH64_ISA_LSE		   (aarch64_isa_flags & AARCH64_FL_LSE)
 
 /* Crypto is an optional extension to AdvSIMD.  */
 #define TARGET_CRYPTO (TARGET_SIMD && AARCH64_ISA_CRYPTO)
@@ -227,6 +164,23 @@ extern unsigned long aarch64_tune_flags;
 /* CRC instructions that can be enabled through +crc arch extension.  */
 #define TARGET_CRC32 (AARCH64_ISA_CRC)
 
+/* Atomic instructions that can be enabled through the +lse extension.  */
+#define TARGET_LSE (AARCH64_ISA_LSE)
+
+/* Make sure this is always defined so we don't have to check for ifdefs
+   but rather use normal ifs.  */
+#ifndef TARGET_FIX_ERR_A53_835769_DEFAULT
+#define TARGET_FIX_ERR_A53_835769_DEFAULT 0
+#else
+#undef TARGET_FIX_ERR_A53_835769_DEFAULT
+#define TARGET_FIX_ERR_A53_835769_DEFAULT 1
+#endif
+
+/* Apply the workaround for Cortex-A53 erratum 835769.  */
+#define TARGET_FIX_ERR_A53_835769	\
+  ((aarch64_fix_a53_err835769 == 2)	\
+  ? TARGET_FIX_ERR_A53_835769_DEFAULT : aarch64_fix_a53_err835769)
+
 /* Standard register usage.  */
 
 /* 31 64-bit general purpose registers R0-R30:
@@ -416,6 +370,10 @@ extern unsigned long aarch64_tune_flags;
 #define ASM_PREFERRED_EH_DATA_FORMAT(CODE, GLOBAL) \
   aarch64_asm_preferred_eh_data_format ((CODE), (GLOBAL))
 
+/* Output the assembly strings we want to add to a function definition.  */
+#define ASM_DECLARE_FUNCTION_NAME(STR, NAME, DECL)	\
+  aarch64_declare_function_name (STR, NAME, DECL)
+
 /* The register that holds the return address in exception handlers.  */
 #define AARCH64_EH_STACKADJ_REGNUM	(R0_REGNUM + 4)
 #define EH_RETURN_STACKADJ_RTX	gen_rtx_REG (Pmode, AARCH64_EH_STACKADJ_REGNUM)
@@ -506,7 +464,7 @@ enum reg_class
 
 enum target_cpus
 {
-#define AARCH64_CORE(NAME, INTERNAL_IDENT, SCHED, ARCH, FLAGS, COSTS) \
+#define AARCH64_CORE(NAME, INTERNAL_IDENT, SCHED, ARCH, FLAGS, COSTS, IMP, PART) \
   TARGET_CPU_##INTERNAL_IDENT,
 #include "aarch64-cores.def"
 #undef AARCH64_CORE
@@ -823,7 +781,8 @@ do {									     \
 #define TRAMPOLINE_SECTION text_section
 
 /* To start with.  */
-#define BRANCH_COST(SPEED_P, PREDICTABLE_P) 2
+#define BRANCH_COST(SPEED_P, PREDICTABLE_P) \
+  (aarch64_branch_cost (SPEED_P, PREDICTABLE_P))
 
 
 /* Assembly output.  */
@@ -892,6 +851,9 @@ do {									     \
 #define HARD_REGNO_CALL_PART_CLOBBERED(REGNO, MODE) \
 		(FP_REGNUM_P (REGNO) && GET_MODE_SIZE (MODE) > 8)
 
+#undef SWITCHABLE_TARGET
+#define SWITCHABLE_TARGET 1
+
 /* Check TLS Descriptors mechanism is selected.  */
 #define TARGET_TLS_DESC (aarch64_tls_dialect == TLS_DESCRIPTORS)
 
@@ -907,10 +869,17 @@ extern enum aarch64_code_model aarch64_cmodel;
   (aarch64_cmodel == AARCH64_CMODEL_TINY		\
    || aarch64_cmodel == AARCH64_CMODEL_TINY_PIC)
 
+/* Modes valid for AdvSIMD D registers, i.e. that fit in half a Q register.  */
+#define AARCH64_VALID_SIMD_DREG_MODE(MODE) \
+  ((MODE) == V2SImode || (MODE) == V4HImode || (MODE) == V8QImode \
+   || (MODE) == V2SFmode || (MODE) == V4HFmode || (MODE) == DImode \
+   || (MODE) == DFmode)
+
 /* Modes valid for AdvSIMD Q registers.  */
 #define AARCH64_VALID_SIMD_QREG_MODE(MODE) \
   ((MODE) == V4SImode || (MODE) == V8HImode || (MODE) == V16QImode \
-   || (MODE) == V4SFmode || (MODE) == V2DImode || mode == V2DFmode)
+   || (MODE) == V4SFmode || (MODE) == V8HFmode || (MODE) == V2DImode \
+   || (MODE) == V2DFmode)
 
 #define ENDIAN_LANE_N(mode, n)  \
   (BYTES_BIG_ENDIAN ? GET_MODE_NUNITS (mode) - 1 - n : n)
@@ -922,17 +891,30 @@ extern enum aarch64_code_model aarch64_cmodel;
   {"arch", "%{!march=*:%{!mcpu=*:-march=%(VALUE)}}" },	\
   {"cpu",  "%{!march=*:%{!mcpu=*:-mcpu=%(VALUE)}}" },
 
-#define BIG_LITTLE_SPEC \
-   " %{mcpu=*:-mcpu=%:rewrite_mcpu(%{mcpu=*:%*})}"
+#define MCPU_TO_MARCH_SPEC \
+   " %{mcpu=*:-march=%:rewrite_mcpu(%{mcpu=*:%*})}"
 
 extern const char *aarch64_rewrite_mcpu (int argc, const char **argv);
-#define BIG_LITTLE_CPU_SPEC_FUNCTIONS \
+#define MCPU_TO_MARCH_SPEC_FUNCTIONS \
   { "rewrite_mcpu", aarch64_rewrite_mcpu },
 
-#define ASM_CPU_SPEC \
-   BIG_LITTLE_SPEC
+#if defined(__aarch64__)
+extern const char *host_detect_local_cpu (int argc, const char **argv);
+# define EXTRA_SPEC_FUNCTIONS						\
+  { "local_cpu_detect", host_detect_local_cpu },			\
+  MCPU_TO_MARCH_SPEC_FUNCTIONS
 
-#define EXTRA_SPEC_FUNCTIONS BIG_LITTLE_CPU_SPEC_FUNCTIONS
+# define MCPU_MTUNE_NATIVE_SPECS					\
+   " %{march=native:%<march=native %:local_cpu_detect(arch)}"		\
+   " %{mcpu=native:%<mcpu=native %:local_cpu_detect(cpu)}"		\
+   " %{mtune=native:%<mtune=native %:local_cpu_detect(tune)}"
+#else
+# define MCPU_MTUNE_NATIVE_SPECS ""
+# define EXTRA_SPEC_FUNCTIONS MCPU_TO_MARCH_SPEC_FUNCTIONS
+#endif
+
+#define ASM_CPU_SPEC \
+   MCPU_TO_MARCH_SPEC
 
 #define EXTRA_SPECS						\
   { "asm_cpu_spec",		ASM_CPU_SPEC }
--- a/src/gcc/config/aarch64/aarch64.md
+++ b/src/gcc/config/aarch64/aarch64.md
@@ -116,6 +116,7 @@
     UNSPEC_ST4_LANE
     UNSPEC_TLS
     UNSPEC_TLSDESC
+    UNSPEC_TLSLE
     UNSPEC_USHL_2S
     UNSPEC_VSTRUCTDUMMY
     UNSPEC_SP_SET
@@ -827,7 +828,7 @@
        gcc_unreachable ();
      }
 }
-  [(set_attr "type" "mov_reg,mov_imm,mov_imm,load1,load1,store1,store1,\
+  [(set_attr "type" "mov_reg,mov_imm,neon_move,load1,load1,store1,store1,\
                      neon_to_gp<q>,neon_from_gp<q>,neon_dup")
    (set_attr "simd" "*,*,yes,*,*,*,*,yes,yes,yes")]
 )
@@ -912,7 +913,7 @@
        DONE;
     }"
   [(set_attr "type" "mov_reg,mov_reg,mov_reg,mov_imm,mov_imm,load1,load1,store1,store1,\
-                     adr,adr,f_mcr,f_mrc,fmov,fmov")
+                     adr,adr,f_mcr,f_mrc,fmov,neon_move")
    (set_attr "fp" "*,*,*,*,*,*,yes,*,yes,*,*,yes,yes,yes,*")
    (set_attr "simd" "*,*,*,*,*,*,*,*,*,*,*,*,*,*,yes")]
 )
@@ -976,26 +977,48 @@
 })
 
 (define_expand "mov<mode>"
-  [(set (match_operand:GPF 0 "nonimmediate_operand" "")
-	(match_operand:GPF 1 "general_operand" ""))]
+  [(set (match_operand:GPF_TF_F16 0 "nonimmediate_operand" "")
+	(match_operand:GPF_TF_F16 1 "general_operand" ""))]
   ""
-  "
+  {
     if (!TARGET_FLOAT)
-     {
-	sorry (\"%qs and floating point code\", \"-mgeneral-regs-only\");
+      {
+	aarch64_err_no_fpadvsimd (<MODE>mode, "code");
 	FAIL;
-     }
+      }
 
-    if (GET_CODE (operands[0]) == MEM)
+    if (GET_CODE (operands[0]) == MEM
+        && ! (GET_CODE (operands[1]) == CONST_DOUBLE
+	      && aarch64_float_const_zero_rtx_p (operands[1])))
       operands[1] = force_reg (<MODE>mode, operands[1]);
-  "
+  }
+)
+
+(define_insn "*movhf_aarch64"
+  [(set (match_operand:HF 0 "nonimmediate_operand" "=w, ?r,w,w,m,r,m ,r")
+	(match_operand:HF 1 "general_operand"      "?rY, w,w,m,w,m,rY,r"))]
+  "TARGET_FLOAT && (register_operand (operands[0], HFmode)
+    || register_operand (operands[1], HFmode))"
+  "@
+   mov\\t%0.h[0], %w1
+   umov\\t%w0, %1.h[0]
+   mov\\t%0.h[0], %1.h[0]
+   ldr\\t%h0, %1
+   str\\t%h1, %0
+   ldrh\\t%w0, %1
+   strh\\t%w1, %0
+   mov\\t%w0, %w1"
+  [(set_attr "type" "neon_from_gp,neon_to_gp,fmov,\
+                     f_loads,f_stores,load1,store1,mov_reg")
+   (set_attr "simd" "yes,yes,yes,*,*,*,*,*")
+   (set_attr "fp"   "*,*,*,yes,yes,*,*,*")]
 )
 
 (define_insn "*movsf_aarch64"
   [(set (match_operand:SF 0 "nonimmediate_operand" "=w, ?r,w,w  ,w,m,r,m ,r")
 	(match_operand:SF 1 "general_operand"      "?rY, w,w,Ufc,m,w,m,rY,r"))]
   "TARGET_FLOAT && (register_operand (operands[0], SFmode)
-    || register_operand (operands[1], SFmode))"
+    || aarch64_reg_or_fp_zero (operands[1], SFmode))"
   "@
    fmov\\t%s0, %w1
    fmov\\t%w0, %s1
@@ -1007,14 +1030,14 @@
    str\\t%w1, %0
    mov\\t%w0, %w1"
   [(set_attr "type" "f_mcr,f_mrc,fmov,fconsts,\
-                     f_loads,f_stores,f_loads,f_stores,mov_reg")]
+                     f_loads,f_stores,load1,store1,mov_reg")]
 )
 
 (define_insn "*movdf_aarch64"
   [(set (match_operand:DF 0 "nonimmediate_operand" "=w, ?r,w,w  ,w,m,r,m ,r")
 	(match_operand:DF 1 "general_operand"      "?rY, w,w,Ufc,m,w,m,rY,r"))]
   "TARGET_FLOAT && (register_operand (operands[0], DFmode)
-    || register_operand (operands[1], DFmode))"
+    || aarch64_reg_or_fp_zero (operands[1], DFmode))"
   "@
    fmov\\t%d0, %x1
    fmov\\t%x0, %d1
@@ -1026,32 +1049,16 @@
    str\\t%x1, %0
    mov\\t%x0, %x1"
   [(set_attr "type" "f_mcr,f_mrc,fmov,fconstd,\
-                     f_loadd,f_stored,f_loadd,f_stored,mov_reg")]
-)
-
-(define_expand "movtf"
-  [(set (match_operand:TF 0 "nonimmediate_operand" "")
-	(match_operand:TF 1 "general_operand" ""))]
-  ""
-  "
-    if (!TARGET_FLOAT)
-     {
-	sorry (\"%qs and floating point code\", \"-mgeneral-regs-only\");
-	FAIL;
-     }
-
-    if (GET_CODE (operands[0]) == MEM)
-      operands[1] = force_reg (TFmode, operands[1]);
-  "
+                     f_loadd,f_stored,load1,store1,mov_reg")]
 )
 
 (define_insn "*movtf_aarch64"
   [(set (match_operand:TF 0
-	 "nonimmediate_operand" "=w,?&r,w ,?r,w,?w,w,m,?r ,Ump")
+	 "nonimmediate_operand" "=w,?&r,w ,?r,w,?w,w,m,?r ,Ump,Ump")
 	(match_operand:TF 1
-	 "general_operand"      " w,?r, ?r,w ,Y,Y ,m,w,Ump,?rY"))]
+	 "general_operand"      " w,?r, ?r,w ,Y,Y ,m,w,Ump,?r ,Y"))]
   "TARGET_FLOAT && (register_operand (operands[0], TFmode)
-    || register_operand (operands[1], TFmode))"
+    || aarch64_reg_or_fp_zero (operands[1], TFmode))"
   "@
    orr\\t%0.16b, %1.16b, %1.16b
    #
@@ -1062,12 +1069,13 @@
    ldr\\t%q0, %1
    str\\t%q1, %0
    ldp\\t%0, %H0, %1
-   stp\\t%1, %H1, %0"
-  [(set_attr "type" "logic_reg,multiple,f_mcr,f_mrc,fconstd,fconstd,\
-                     f_loadd,f_stored,neon_load1_2reg,neon_store1_2reg")
-   (set_attr "length" "4,8,8,8,4,4,4,4,4,4")
-   (set_attr "fp" "*,*,yes,yes,*,yes,yes,yes,*,*")
-   (set_attr "simd" "yes,*,*,*,yes,*,*,*,*,*")]
+   stp\\t%1, %H1, %0
+   stp\\txzr, xzr, %0"
+  [(set_attr "type" "logic_reg,multiple,f_mcr,f_mrc,neon_move_q,fconstd,\
+                     f_loadd,f_stored,load2,store2,store2")
+   (set_attr "length" "4,8,8,8,4,4,4,4,4,4,4")
+   (set_attr "fp" "*,*,yes,yes,*,yes,yes,yes,*,*,*")
+   (set_attr "simd" "yes,*,*,*,yes,*,*,*,*,*,*")]
 )
 
 (define_split
@@ -1414,18 +1422,28 @@
   "
   if (! aarch64_plus_operand (operands[2], VOIDmode))
     {
-      rtx subtarget = ((optimize && can_create_pseudo_p ())
-		       ? gen_reg_rtx (<MODE>mode) : operands[0]);
       HOST_WIDE_INT imm = INTVAL (operands[2]);
 
-      if (imm < 0)
-	imm = -(-imm & ~0xfff);
+      if (aarch64_move_imm (imm, <MODE>mode) && can_create_pseudo_p ())
+        {
+	  rtx tmp = gen_reg_rtx (<MODE>mode);
+	  emit_move_insn (tmp, operands[2]);
+	  operands[2] = tmp;
+        }
       else
-        imm &= ~0xfff;
-
-      emit_insn (gen_add<mode>3 (subtarget, operands[1], GEN_INT (imm)));
-      operands[1] = subtarget;
-      operands[2] = GEN_INT (INTVAL (operands[2]) - imm);
+        {
+	  rtx subtarget = ((optimize && can_create_pseudo_p ())
+			   ? gen_reg_rtx (<MODE>mode) : operands[0]);
+
+	  if (imm < 0)
+	    imm = -(-imm & ~0xfff);
+	  else
+	    imm &= ~0xfff;
+
+	  emit_insn (gen_add<mode>3 (subtarget, operands[1], GEN_INT (imm)));
+	  operands[1] = subtarget;
+	  operands[2] = GEN_INT (INTVAL (operands[2]) - imm);
+        }
     }
   "
 )
@@ -1529,6 +1547,38 @@
   [(set_attr "type" "alus_sreg,alus_imm,alus_imm")]
 )
 
+(define_insn "*adds_shift_imm_<mode>"
+  [(set (reg:CC_NZ CC_REGNUM)
+	(compare:CC_NZ
+	 (plus:GPI (ASHIFT:GPI 
+		    (match_operand:GPI 1 "register_operand" "r")
+		    (match_operand:QI 2 "aarch64_shift_imm_<mode>" "n"))
+		   (match_operand:GPI 3 "register_operand" "r"))
+	 (const_int 0)))
+   (set (match_operand:GPI 0 "register_operand" "=r")
+	(plus:GPI (ASHIFT:GPI (match_dup 1) (match_dup 2))
+		  (match_dup 3)))]
+  ""
+  "adds\\t%<w>0, %<w>3, %<w>1, <shift> %2"
+  [(set_attr "type" "alus_shift_imm")]
+)
+
+(define_insn "*subs_shift_imm_<mode>"
+  [(set (reg:CC_NZ CC_REGNUM)
+	(compare:CC_NZ
+	 (minus:GPI (match_operand:GPI 1 "register_operand" "r")
+		    (ASHIFT:GPI
+		     (match_operand:GPI 2 "register_operand" "r")
+		     (match_operand:QI 3 "aarch64_shift_imm_<mode>" "n")))
+	 (const_int 0)))
+   (set (match_operand:GPI 0 "register_operand" "=r")
+	(minus:GPI (match_dup 1)
+		   (ASHIFT:GPI (match_dup 2) (match_dup 3))))]
+  ""
+  "subs\\t%<w>0, %<w>1, %<w>2, <shift> %3"
+  [(set_attr "type" "alus_shift_imm")]
+)
+
 (define_insn "*adds_mul_imm_<mode>"
   [(set (reg:CC_NZ CC_REGNUM)
 	(compare:CC_NZ
@@ -1589,6 +1639,42 @@
   [(set_attr "type" "alus_ext")]
 )
 
+(define_insn "*adds_<optab><ALLX:mode>_shift_<GPI:mode>"
+  [(set (reg:CC_NZ CC_REGNUM)
+	(compare:CC_NZ
+	 (plus:GPI (ashift:GPI 
+		    (ANY_EXTEND:GPI 
+		     (match_operand:ALLX 1 "register_operand" "r"))
+		    (match_operand 2 "aarch64_imm3" "Ui3"))
+		   (match_operand:GPI 3 "register_operand" "r"))
+	 (const_int 0)))
+   (set (match_operand:GPI 0 "register_operand" "=rk")
+	(plus:GPI (ashift:GPI (ANY_EXTEND:GPI (match_dup 1))
+			      (match_dup 2))
+		  (match_dup 3)))]
+  ""
+  "adds\\t%<GPI:w>0, %<GPI:w>3, %<GPI:w>1, <su>xt<ALLX:size> %2"
+  [(set_attr "type" "alus_ext")]
+)
+
+(define_insn "*subs_<optab><ALLX:mode>_shift_<GPI:mode>"
+  [(set (reg:CC_NZ CC_REGNUM)
+	(compare:CC_NZ
+	 (minus:GPI (match_operand:GPI 1 "register_operand" "r")
+		    (ashift:GPI 
+		     (ANY_EXTEND:GPI
+		      (match_operand:ALLX 2 "register_operand" "r"))
+		     (match_operand 3 "aarch64_imm3" "Ui3")))
+	 (const_int 0)))
+   (set (match_operand:GPI 0 "register_operand" "=rk")
+	(minus:GPI (match_dup 1)
+		   (ashift:GPI (ANY_EXTEND:GPI (match_dup 2))
+			       (match_dup 3))))]
+  ""
+  "subs\\t%<GPI:w>0, %<GPI:w>1, %<GPI:w>2, <su>xt<ALLX:size> %3"
+  [(set_attr "type" "alus_ext")]
+)
+
 (define_insn "*adds_<optab><mode>_multp2"
   [(set (reg:CC_NZ CC_REGNUM)
 	(compare:CC_NZ
@@ -1884,6 +1970,38 @@
   [(set_attr "type" "adc_reg")]
 )
 
+(define_insn "*add_uxt<mode>_shift2"
+  [(set (match_operand:GPI 0 "register_operand" "=rk")
+	(plus:GPI (and:GPI
+		   (ashift:GPI (match_operand:GPI 1 "register_operand" "r")
+			       (match_operand 2 "aarch64_imm3" "Ui3"))
+		   (match_operand 3 "const_int_operand" "n"))
+		  (match_operand:GPI 4 "register_operand" "r")))]
+  "aarch64_uxt_size (INTVAL (operands[2]), INTVAL (operands[3])) != 0"
+  "*
+  operands[3] = GEN_INT (aarch64_uxt_size (INTVAL(operands[2]),
+					   INTVAL (operands[3])));
+  return \"add\t%<w>0, %<w>4, %<w>1, uxt%e3 %2\";"
+  [(set_attr "type" "alu_ext")]
+)
+
+;; zero_extend version of above
+(define_insn "*add_uxtsi_shift2_uxtw"
+  [(set (match_operand:DI 0 "register_operand" "=rk")
+	(zero_extend:DI
+	 (plus:SI (and:SI
+		   (ashift:SI (match_operand:SI 1 "register_operand" "r")
+			      (match_operand 2 "aarch64_imm3" "Ui3"))
+		   (match_operand 3 "const_int_operand" "n"))
+		  (match_operand:SI 4 "register_operand" "r"))))]
+  "aarch64_uxt_size (INTVAL (operands[2]), INTVAL (operands[3])) != 0"
+  "*
+  operands[3] = GEN_INT (aarch64_uxt_size (INTVAL (operands[2]),
+					   INTVAL (operands[3])));
+  return \"add\t%w0, %w4, %w1, uxt%e3 %2\";"
+  [(set_attr "type" "alu_ext")]
+)
+
 (define_insn "*add_uxt<mode>_multp2"
   [(set (match_operand:GPI 0 "register_operand" "=rk")
 	(plus:GPI (and:GPI
@@ -2140,6 +2258,38 @@
   [(set_attr "type" "adc_reg")]
 )
 
+(define_insn "*sub_uxt<mode>_shift2"
+  [(set (match_operand:GPI 0 "register_operand" "=rk")
+	(minus:GPI (match_operand:GPI 4 "register_operand" "rk")
+		   (and:GPI
+		    (ashift:GPI (match_operand:GPI 1 "register_operand" "r")
+				(match_operand 2 "aarch64_imm3" "Ui3"))
+		    (match_operand 3 "const_int_operand" "n"))))]
+  "aarch64_uxt_size (INTVAL (operands[2]),INTVAL (operands[3])) != 0"
+  "*
+  operands[3] = GEN_INT (aarch64_uxt_size (INTVAL (operands[2]),
+					   INTVAL (operands[3])));
+  return \"sub\t%<w>0, %<w>4, %<w>1, uxt%e3 %2\";"
+  [(set_attr "type" "alu_ext")]
+)
+
+;; zero_extend version of above
+(define_insn "*sub_uxtsi_shift2_uxtw"
+  [(set (match_operand:DI 0 "register_operand" "=rk")
+	(zero_extend:DI
+	 (minus:SI (match_operand:SI 4 "register_operand" "rk")
+		   (and:SI
+		    (ashift:SI (match_operand:SI 1 "register_operand" "r")
+			       (match_operand 2 "aarch64_imm3" "Ui3"))
+		    (match_operand 3 "const_int_operand" "n")))))]
+  "aarch64_uxt_size (INTVAL (operands[2]),INTVAL (operands[3])) != 0"
+  "*
+  operands[3] = GEN_INT (aarch64_uxt_size (INTVAL (operands[2]),
+					   INTVAL (operands[3])));
+  return \"sub\t%w0, %w4, %w1, uxt%e3 %2\";"
+  [(set_attr "type" "alu_ext")]
+)
+
 (define_insn "*sub_uxt<mode>_multp2"
   [(set (match_operand:GPI 0 "register_operand" "=rk")
 	(minus:GPI (match_operand:GPI 4 "register_operand" "rk")
@@ -2172,35 +2322,16 @@
   [(set_attr "type" "alu_ext")]
 )
 
-(define_insn_and_split "absdi2"
-  [(set (match_operand:DI 0 "register_operand" "=&r,w")
-	(abs:DI (match_operand:DI 1 "register_operand" "r,w")))]
+(define_expand "abs<mode>2"
+  [(match_operand:GPI 0 "register_operand" "")
+   (match_operand:GPI 1 "register_operand" "")]
   ""
-  "@
-   #
-   abs\\t%d0, %d1"
-  "reload_completed
-   && GP_REGNUM_P (REGNO (operands[0]))
-   && GP_REGNUM_P (REGNO (operands[1]))"
-  [(const_int 0)]
   {
-    emit_insn (gen_rtx_SET (VOIDmode, operands[0],
-			    gen_rtx_XOR (DImode,
-					 gen_rtx_ASHIFTRT (DImode,
-							   operands[1],
-							   GEN_INT (63)),
-					 operands[1])));
-    emit_insn (gen_rtx_SET (VOIDmode,
-			    operands[0],
-			    gen_rtx_MINUS (DImode,
-					   operands[0],
-					   gen_rtx_ASHIFTRT (DImode,
-							     operands[1],
-							     GEN_INT (63)))));
+    rtx ccreg = aarch64_gen_compare_reg (LT, operands[1], const0_rtx);
+    rtx x = gen_rtx_LT (VOIDmode, ccreg, const0_rtx);
+    emit_insn (gen_csneg3<mode>_insn (operands[0], x, operands[1], operands[1]));
     DONE;
   }
-  [(set_attr "type" "alu_sreg")
-   (set_attr "simd" "no,yes")]
 )
 
 (define_insn "neg<mode>2"
@@ -2757,6 +2888,18 @@
   [(set_attr "type" "csel")]
 )
 
+(define_insn "*cmovdi_insn_uxtw"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(if_then_else:DI
+	 (match_operator 1 "aarch64_comparison_operator"
+	  [(match_operand 2 "cc_register" "") (const_int 0)])
+	 (zero_extend:DI (match_operand:SI 3 "register_operand" "r"))
+	 (zero_extend:DI (match_operand:SI 4 "register_operand" "r"))))]
+  ""
+  "csel\\t%w0, %w3, %w4, %m1"
+  [(set_attr "type" "csel")]
+)
+
 (define_insn "*cmov<mode>_insn"
   [(set (match_operand:GPF 0 "register_operand" "=w")
 	(if_then_else:GPF
@@ -2852,7 +2995,7 @@
         (plus:GPI (match_operand 2 "aarch64_comparison_operation" "")
                   (match_operand:GPI 1 "register_operand" "r")))]
   ""
-  "csinc\\t%<w>0, %<w>1, %<w>1, %M2"
+  "cinc\\t%<w>0, %<w>1, %m2"
   [(set_attr "type" "csel")]
 )
 
@@ -2879,7 +3022,19 @@
   [(set_attr "type" "csel")]
 )
 
-(define_insn "*csneg3<mode>_insn"
+(define_insn "csneg3_uxtw_insn"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(zero_extend:DI
+	  (if_then_else:SI
+	    (match_operand 1 "aarch64_comparison_operation" "")
+	    (neg:SI (match_operand:SI 2 "register_operand" "r"))
+	    (match_operand:SI 3 "aarch64_reg_or_zero" "rZ"))))]
+  ""
+  "csneg\\t%w0, %w3, %w2, %M1"
+  [(set_attr "type" "csel")]
+)
+
+(define_insn "csneg3<mode>_insn"
   [(set (match_operand:GPI 0 "register_operand" "=r")
         (if_then_else:GPI
 	  (match_operand 1 "aarch64_comparison_operation" "")
@@ -3058,6 +3213,26 @@
    (set_attr "simd" "*,yes")]
 )
 
+(define_insn "*<NLOGICAL:optab>_one_cmplsidi3_ze"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(zero_extend:DI
+	  (NLOGICAL:SI (not:SI (match_operand:SI 1 "register_operand" "r"))
+	               (match_operand:SI 2 "register_operand" "r"))))]
+  ""
+  "<NLOGICAL:nlogical>\\t%w0, %w2, %w1"
+  [(set_attr "type" "logic_reg")]
+)
+
+(define_insn "*xor_one_cmplsidi3_ze"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+        (zero_extend:DI
+          (not:SI (xor:SI (match_operand:SI 1 "register_operand" "r")
+                          (match_operand:SI 2 "register_operand" "r")))))]
+  ""
+  "eon\\t%w0, %w1, %w2"
+  [(set_attr "type" "logic_reg")]
+)
+
 ;; (xor (not a) b) is simplify_rtx-ed down to (not (xor a b)).
 ;; eon does not operate on SIMD registers so the vector variant must be split.
 (define_insn_and_split "*xor_one_cmpl<mode>3"
@@ -3119,7 +3294,7 @@
   [(set_attr "type" "logics_reg")]
 )
 
-(define_insn "*<LOGICAL:optab>_one_cmpl_<SHIFT:optab><mode>3"
+(define_insn "<LOGICAL:optab>_one_cmpl_<SHIFT:optab><mode>3"
   [(set (match_operand:GPI 0 "register_operand" "=r")
 	(LOGICAL:GPI (not:GPI
 		      (SHIFT:GPI
@@ -3128,7 +3303,33 @@
 		     (match_operand:GPI 3 "register_operand" "r")))]
   ""
   "<LOGICAL:nlogical>\\t%<w>0, %<w>3, %<w>1, <SHIFT:shift> %2"
-  [(set_attr "type" "logics_shift_imm")]
+  [(set_attr "type" "logic_shift_imm")]
+)
+
+(define_insn "*eor_one_cmpl_<SHIFT:optab><mode>3_alt"
+  [(set (match_operand:GPI 0 "register_operand" "=r")
+	(not:GPI (xor:GPI
+		      (SHIFT:GPI
+		       (match_operand:GPI 1 "register_operand" "r")
+		       (match_operand:QI 2 "aarch64_shift_imm_<mode>" "n"))
+		     (match_operand:GPI 3 "register_operand" "r"))))]
+  ""
+  "eon\\t%<w>0, %<w>3, %<w>1, <SHIFT:shift> %2"
+  [(set_attr "type" "logic_shift_imm")]
+)
+
+;; Zero-extend version of the above.
+(define_insn "*eor_one_cmpl_<SHIFT:optab>sidi3_alt_ze"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(zero_extend:DI
+	  (not:SI (xor:SI
+		    (SHIFT:SI
+		      (match_operand:SI 1 "register_operand" "r")
+		      (match_operand:QI 2 "aarch64_shift_imm_si" "n"))
+		    (match_operand:SI 3 "register_operand" "r")))))]
+  ""
+  "eon\\t%w0, %w3, %w1, <SHIFT:shift> %2"
+  [(set_attr "type" "logic_shift_imm")]
 )
 
 (define_insn "*and_one_cmpl_<SHIFT:optab><mode>3_compare0"
@@ -3240,7 +3441,7 @@
 	 (const_int 0)))]
   ""
   "tst\\t%<w>0, %<w>1"
-  [(set_attr "type" "logics_reg")]
+  [(set_attr "type" "logics_reg,logics_imm")]
 )
 
 (define_insn "*and_<SHIFT:optab><mode>3nr_compare0"
@@ -3347,32 +3548,33 @@
 
 ;; Logical left shift using SISD or Integer instruction
 (define_insn "*aarch64_ashl_sisd_or_int_<mode>3"
-  [(set (match_operand:GPI 0 "register_operand" "=w,w,r")
+  [(set (match_operand:GPI 0 "register_operand" "=r,w,w")
         (ashift:GPI
-          (match_operand:GPI 1 "register_operand" "w,w,r")
-          (match_operand:QI 2 "aarch64_reg_or_shift_imm_<mode>" "Us<cmode>,w,rUs<cmode>")))]
+          (match_operand:GPI 1 "register_operand" "r,w,w")
+          (match_operand:QI 2 "aarch64_reg_or_shift_imm_<mode>" "rUs<cmode>,Us<cmode>,w")))]
   ""
   "@
+   lsl\t%<w>0, %<w>1, %<w>2
    shl\t%<rtn>0<vas>, %<rtn>1<vas>, %2
-   ushl\t%<rtn>0<vas>, %<rtn>1<vas>, %<rtn>2<vas>
-   lsl\t%<w>0, %<w>1, %<w>2"
-  [(set_attr "simd" "yes,yes,no")
-   (set_attr "type" "neon_shift_imm<q>, neon_shift_reg<q>,shift_reg")]
+   ushl\t%<rtn>0<vas>, %<rtn>1<vas>, %<rtn>2<vas>"
+  [(set_attr "simd" "no,yes,yes")
+   (set_attr "type" "shift_reg,neon_shift_imm<q>, neon_shift_reg<q>")]
 )
 
 ;; Logical right shift using SISD or Integer instruction
 (define_insn "*aarch64_lshr_sisd_or_int_<mode>3"
-  [(set (match_operand:GPI 0 "register_operand" "=w,&w,r")
+  [(set (match_operand:GPI 0 "register_operand" "=r,w,&w,&w")
         (lshiftrt:GPI
-          (match_operand:GPI 1 "register_operand" "w,w,r")
-          (match_operand:QI 2 "aarch64_reg_or_shift_imm_<mode>" "Us<cmode>,w,rUs<cmode>")))]
+          (match_operand:GPI 1 "register_operand" "r,w,w,w")
+          (match_operand:QI 2 "aarch64_reg_or_shift_imm_<mode>" "rUs<cmode>,Us<cmode>,w,0")))]
   ""
   "@
+   lsr\t%<w>0, %<w>1, %<w>2
    ushr\t%<rtn>0<vas>, %<rtn>1<vas>, %2
    #
-   lsr\t%<w>0, %<w>1, %<w>2"
-  [(set_attr "simd" "yes,yes,no")
-   (set_attr "type" "neon_shift_imm<q>,neon_shift_reg<q>,shift_reg")]
+   #"
+  [(set_attr "simd" "no,yes,yes,yes")
+   (set_attr "type" "shift_reg,neon_shift_imm<q>,neon_shift_reg<q>,neon_shift_reg<q>")]
 )
 
 (define_split
@@ -3407,18 +3609,18 @@
 
 ;; Arithmetic right shift using SISD or Integer instruction
 (define_insn "*aarch64_ashr_sisd_or_int_<mode>3"
-  [(set (match_operand:GPI 0 "register_operand" "=w,&w,&w,r")
+  [(set (match_operand:GPI 0 "register_operand" "=r,w,&w,&w")
         (ashiftrt:GPI
-          (match_operand:GPI 1 "register_operand" "w,w,w,r")
-          (match_operand:QI 2 "aarch64_reg_or_shift_imm_di" "Us<cmode>,w,0,rUs<cmode>")))]
+          (match_operand:GPI 1 "register_operand" "r,w,w,w")
+          (match_operand:QI 2 "aarch64_reg_or_shift_imm_di" "rUs<cmode>,Us<cmode>,w,0")))]
   ""
   "@
+   asr\t%<w>0, %<w>1, %<w>2
    sshr\t%<rtn>0<vas>, %<rtn>1<vas>, %2
    #
-   #
-   asr\t%<w>0, %<w>1, %<w>2"
-  [(set_attr "simd" "yes,yes,yes,no")
-   (set_attr "type" "neon_shift_imm<q>,neon_shift_reg<q>,neon_shift_reg<q>,shift_reg")]
+   #"
+  [(set_attr "simd" "no,yes,yes,yes")
+   (set_attr "type" "shift_reg,neon_shift_imm<q>,neon_shift_reg<q>,neon_shift_reg<q>")]
 )
 
 (define_split
@@ -3551,6 +3753,21 @@
   [(set_attr "type" "shift_imm")]
 )
 
+;; There are no canonicalisation rules for ashift and lshiftrt inside an ior
+;; so we have to match both orderings.
+(define_insn "*extr<mode>5_insn_alt"
+  [(set (match_operand:GPI 0 "register_operand" "=r")
+	(ior:GPI  (lshiftrt:GPI (match_operand:GPI 2 "register_operand" "r")
+			        (match_operand 4 "const_int_operand" "n"))
+		  (ashift:GPI (match_operand:GPI 1 "register_operand" "r")
+			      (match_operand 3 "const_int_operand" "n"))))]
+  "UINTVAL (operands[3]) < GET_MODE_BITSIZE (<MODE>mode)
+   && (UINTVAL (operands[3]) + UINTVAL (operands[4])
+       == GET_MODE_BITSIZE (<MODE>mode))"
+  "extr\\t%<w>0, %<w>1, %<w>2, %4"
+  [(set_attr "type" "shift_imm")]
+)
+
 ;; zero_extend version of the above
 (define_insn "*extrsi5_insn_uxtw"
   [(set (match_operand:DI 0 "register_operand" "=r")
@@ -3565,6 +3782,19 @@
   [(set_attr "type" "shift_imm")]
 )
 
+(define_insn "*extrsi5_insn_uxtw_alt"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(zero_extend:DI
+	 (ior:SI (lshiftrt:SI (match_operand:SI 2 "register_operand" "r")
+			       (match_operand 4 "const_int_operand" "n"))
+		 (ashift:SI (match_operand:SI 1 "register_operand" "r")
+			    (match_operand 3 "const_int_operand" "n")))))]
+  "UINTVAL (operands[3]) < 32 &&
+   (UINTVAL (operands[3]) + UINTVAL (operands[4]) == 32)"
+  "extr\\t%w0, %w1, %w2, %4"
+  [(set_attr "type" "shift_imm")]
+)
+
 (define_insn "*ror<mode>3_insn"
   [(set (match_operand:GPI 0 "register_operand" "=r")
 	(rotate:GPI (match_operand:GPI 1 "register_operand" "r")
@@ -3696,6 +3926,16 @@
   [(set_attr "type" "bfm")]
 )
 
+(define_insn "*aarch64_bfi<GPI:mode><ALLX:mode>4"
+  [(set (zero_extract:GPI (match_operand:GPI 0 "register_operand" "+r")
+			  (match_operand 1 "const_int_operand" "n")
+			  (match_operand 2 "const_int_operand" "n"))
+	(zero_extend:GPI (match_operand:ALLX 3  "register_operand" "r")))]
+  "UINTVAL (operands[1]) <= <ALLX:sizen>"
+  "bfi\\t%<GPI:w>0, %<GPI:w>3, %2, %1"
+  [(set_attr "type" "bfm")]
+)
+
 (define_insn "*extr_insv_lower_reg<mode>"
   [(set (zero_extract:GPI (match_operand:GPI 0 "register_operand" "+r")
 			  (match_operand 1 "const_int_operand" "n")
@@ -3888,6 +4128,22 @@
   [(set_attr "type" "f_cvt")]
 )
 
+(define_insn "extendhfsf2"
+  [(set (match_operand:SF 0 "register_operand" "=w")
+        (float_extend:SF (match_operand:HF 1 "register_operand" "w")))]
+  "TARGET_FLOAT"
+  "fcvt\\t%s0, %h1"
+  [(set_attr "type" "f_cvt")]
+)
+
+(define_insn "extendhfdf2"
+  [(set (match_operand:DF 0 "register_operand" "=w")
+        (float_extend:DF (match_operand:HF 1 "register_operand" "w")))]
+  "TARGET_FLOAT"
+  "fcvt\\t%d0, %h1"
+  [(set_attr "type" "f_cvt")]
+)
+
 (define_insn "truncdfsf2"
   [(set (match_operand:SF 0 "register_operand" "=w")
         (float_truncate:SF (match_operand:DF 1 "register_operand" "w")))]
@@ -3896,6 +4152,22 @@
   [(set_attr "type" "f_cvt")]
 )
 
+(define_insn "truncsfhf2"
+  [(set (match_operand:HF 0 "register_operand" "=w")
+        (float_truncate:HF (match_operand:SF 1 "register_operand" "w")))]
+  "TARGET_FLOAT"
+  "fcvt\\t%h0, %s1"
+  [(set_attr "type" "f_cvt")]
+)
+
+(define_insn "truncdfhf2"
+  [(set (match_operand:HF 0 "register_operand" "=w")
+        (float_truncate:HF (match_operand:DF 1 "register_operand" "w")))]
+  "TARGET_FLOAT"
+  "fcvt\\t%h0, %d1"
+  [(set_attr "type" "f_cvt")]
+)
+
 (define_insn "fix_trunc<GPF:mode><GPI:mode>2"
   [(set (match_operand:GPI 0 "register_operand" "=r")
         (fix:GPI (match_operand:GPF 1 "register_operand" "w")))]
@@ -3915,7 +4187,7 @@
 (define_insn "<optab><fcvt_target><GPF:mode>2"
   [(set (match_operand:GPF 0 "register_operand" "=w,w")
         (FLOATUORS:GPF (match_operand:<FCVT_TARGET> 1 "register_operand" "w,r")))]
-  ""
+  "TARGET_FLOAT"
   "@
    <su_optab>cvtf\t%<GPF:s>0, %<s>1
    <su_optab>cvtf\t%<GPF:s>0, %<w1>1"
@@ -4042,6 +4314,52 @@
   [(set_attr "type" "f_minmax<s>")]
 )
 
+;; For copysign (x, y), we want to generate:
+;;
+;;   LDR d2, #(1 << 63)
+;;   BSL v2.8b, [y], [x]
+;;
+;; or another, equivalent, sequence using one of BSL/BIT/BIF.
+;; aarch64_simd_bsldf will select the best suited of these instructions
+;; to generate based on register allocation, and knows how to partially
+;; constant fold based on the values of X and Y, so expand through that.
+
+(define_expand "copysigndf3"
+  [(match_operand:DF 0 "register_operand")
+   (match_operand:DF 1 "register_operand")
+   (match_operand:DF 2 "register_operand")]
+  "TARGET_FLOAT && TARGET_SIMD"
+{
+  rtx mask = gen_reg_rtx (DImode);
+  emit_move_insn (mask, GEN_INT (HOST_WIDE_INT_1U << 63));
+  emit_insn (gen_aarch64_simd_bsldf (operands[0], mask,
+				     operands[2], operands[1]));
+  DONE;
+}
+)
+
+;; As above, but we must first get to a 64-bit value if we wish to use
+;; aarch64_simd_bslv2sf.
+
+(define_expand "copysignsf3"
+  [(match_operand:SF 0 "register_operand")
+   (match_operand:SF 1 "register_operand")
+   (match_operand:SF 2 "register_operand")]
+  "TARGET_FLOAT && TARGET_SIMD"
+{
+  rtx mask = gen_reg_rtx (DImode);
+
+  /* Juggle modes to get us in to a vector mode for BSL.  */
+  rtx op1 = lowpart_subreg (V2SFmode, operands[1], SFmode);
+  rtx op2 = lowpart_subreg (V2SFmode, operands[2], SFmode);
+  rtx tmp = gen_reg_rtx (V2SFmode);
+  emit_move_insn (mask, GEN_INT (HOST_WIDE_INT_1U << 31));
+  emit_insn (gen_aarch64_simd_bslv2sf (tmp, mask, op2, op1));
+  emit_move_insn (operands[0], lowpart_subreg (SFmode, tmp, V2SFmode));
+  DONE;
+}
+)
+
 ;; -------------------------------------------------------------------
 ;; Reload support
 ;; -------------------------------------------------------------------
@@ -4230,27 +4548,25 @@
    (set_attr "length" "8")]
 )
 
-(define_expand "tlsle_small"
+(define_expand "tlsle"
   [(set (match_operand 0 "register_operand" "=r")
         (unspec [(match_operand 1 "register_operand" "r")
                    (match_operand 2 "aarch64_tls_le_symref" "S")]
-                   UNSPEC_GOTSMALLTLS))]
+                   UNSPEC_TLSLE))]
   ""
 {
   machine_mode mode = GET_MODE (operands[0]);
   emit_insn ((mode == DImode
-	      ? gen_tlsle_small_di
-	      : gen_tlsle_small_si) (operands[0],
-				     operands[1],
-				     operands[2]));
+	      ? gen_tlsle_di
+	      : gen_tlsle_si) (operands[0], operands[1], operands[2]));
   DONE;
 })
 
-(define_insn "tlsle_small_<mode>"
+(define_insn "tlsle_<mode>"
   [(set (match_operand:P 0 "register_operand" "=r")
         (unspec:P [(match_operand:P 1 "register_operand" "r")
                    (match_operand 2 "aarch64_tls_le_symref" "S")]
-		   UNSPEC_GOTSMALLTLS))]
+		   UNSPEC_TLSLE))]
   ""
   "add\\t%<w>0, %<w>1, #%G2, lsl #12\;add\\t%<w>0, %<w>0, #%L2"
   [(set_attr "type" "alu_sreg")
--- a/src/gcc/config/aarch64/aarch64.opt
+++ b/src/gcc/config/aarch64/aarch64.opt
@@ -21,6 +21,18 @@
 HeaderInclude
 config/aarch64/aarch64-opts.h
 
+TargetVariable
+enum aarch64_processor explicit_tune_core = aarch64_none
+
+TargetVariable
+enum aarch64_arch explicit_arch = aarch64_no_arch
+
+TargetSave
+const char *x_aarch64_override_tune_string
+
+TargetVariable
+unsigned long aarch64_isa_flags = 0
+
 ; The TLS dialect names to use with -mtls-dialect.
 
 Enum
@@ -48,27 +60,16 @@ Enum(cmodel) String(small) Value(AARCH64_CMODEL_SMALL)
 EnumValue
 Enum(cmodel) String(large) Value(AARCH64_CMODEL_LARGE)
 
-; The cpu/arch option names to use in cpu/arch selection.
-
-Variable
-const char *aarch64_arch_string
-
-Variable
-const char *aarch64_cpu_string
-
-Variable
-const char *aarch64_tune_string
-
 mbig-endian
 Target Report RejectNegative Mask(BIG_END)
 Assume target CPU is configured as big endian
 
 mgeneral-regs-only
-Target Report RejectNegative Mask(GENERAL_REGS_ONLY)
+Target Report RejectNegative Mask(GENERAL_REGS_ONLY) Save
 Generate code which uses only the general registers
 
 mfix-cortex-a53-835769
-Target Report Var(aarch64_fix_a53_err835769) Init(2)
+Target Report Var(aarch64_fix_a53_err835769) Init(2) Save
 Workaround for ARM Cortex-A53 Erratum number 835769
 
 mfix-cortex-a53-843419
@@ -80,19 +81,19 @@ Target Report RejectNegative InverseMask(BIG_END)
 Assume target CPU is configured as little endian
 
 mcmodel=
-Target RejectNegative Joined Enum(cmodel) Var(aarch64_cmodel_var) Init(AARCH64_CMODEL_SMALL)
+Target RejectNegative Joined Enum(cmodel) Var(aarch64_cmodel_var) Init(AARCH64_CMODEL_SMALL) Save
 Specify the code model
 
 mstrict-align
-Target Report RejectNegative Mask(STRICT_ALIGN)
+Target Report RejectNegative Mask(STRICT_ALIGN) Save
 Don't assume that unaligned accesses are handled by the system
 
 momit-leaf-frame-pointer
-Target Report Save Var(flag_omit_leaf_frame_pointer) Init(1)
+Target Report Var(flag_omit_leaf_frame_pointer) Init(2) Save
 Omit the frame pointer in leaf functions
 
 mtls-dialect=
-Target RejectNegative Joined Enum(tls_type) Var(aarch64_tls_dialect) Init(TLS_DESCRIPTORS)
+Target RejectNegative Joined Enum(tls_type) Var(aarch64_tls_dialect) Init(TLS_DESCRIPTORS) Save
 Specify TLS dialect
 
 march=
@@ -111,6 +112,10 @@ mabi=
 Target RejectNegative Joined Enum(aarch64_abi) Var(aarch64_abi) Init(AARCH64_ABI_DEFAULT)
 -mabi=ABI	Generate code that conforms to the specified ABI
 
+moverride=
+Target RejectNegative ToLower Joined Var(aarch64_override_tune_string)
+-moverride=STRING	Power users only! Override CPU optimization parameters
+
 Enum
 Name(aarch64_abi) Type(int)
 Known AArch64 ABIs (for use with the -mabi= option):
--- a/src/gcc/config/aarch64/arm_acle.h
+++ b/src/gcc/config/aarch64/arm_acle.h
@@ -28,11 +28,15 @@
 #define _GCC_ARM_ACLE_H
 
 #include <stdint.h>
+
+#pragma GCC push_options
+
+#pragma GCC target ("+nothing+crc")
+
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-#ifdef __ARM_FEATURE_CRC32
 __extension__ static __inline uint32_t __attribute__ ((__always_inline__))
 __crc32b (uint32_t __a, uint8_t __b)
 {
@@ -81,10 +85,10 @@ __crc32d (uint32_t __a, uint64_t __b)
   return __builtin_aarch64_crc32x (__a, __b);
 }
 
-#endif
-
 #ifdef __cplusplus
 }
 #endif
 
+#pragma GCC pop_options
+
 #endif
--- a/src/gcc/config/aarch64/arm_neon.h
+++ b/src/gcc/config/aarch64/arm_neon.h
@@ -27,9 +27,8 @@
 #ifndef _AARCH64_NEON_H_
 #define _AARCH64_NEON_H_
 
-#ifndef __ARM_NEON
-#error You must enable AdvancedSIMD instructions to use arm_neon.h
-#else
+#pragma GCC push_options
+#pragma GCC target ("+nothing+simd")
 
 #include <stdint.h>
 
@@ -40,6 +39,7 @@ typedef __Int8x8_t int8x8_t;
 typedef __Int16x4_t int16x4_t;
 typedef __Int32x2_t int32x2_t;
 typedef __Int64x1_t int64x1_t;
+typedef __Float16x4_t float16x4_t;
 typedef __Float32x2_t float32x2_t;
 typedef __Poly8x8_t poly8x8_t;
 typedef __Poly16x4_t poly16x4_t;
@@ -52,6 +52,7 @@ typedef __Int8x16_t int8x16_t;
 typedef __Int16x8_t int16x8_t;
 typedef __Int32x4_t int32x4_t;
 typedef __Int64x2_t int64x2_t;
+typedef __Float16x8_t float16x8_t;
 typedef __Float32x4_t float32x4_t;
 typedef __Float64x2_t float64x2_t;
 typedef __Poly8x16_t poly8x16_t;
@@ -67,6 +68,7 @@ typedef __Poly16_t poly16_t;
 typedef __Poly64_t poly64_t;
 typedef __Poly128_t poly128_t;
 
+typedef __fp16 float16_t;
 typedef float float32_t;
 typedef double float64_t;
 
@@ -150,6 +152,16 @@ typedef struct uint64x2x2_t
   uint64x2_t val[2];
 } uint64x2x2_t;
 
+typedef struct float16x4x2_t
+{
+  float16x4_t val[2];
+} float16x4x2_t;
+
+typedef struct float16x8x2_t
+{
+  float16x8_t val[2];
+} float16x8x2_t;
+
 typedef struct float32x2x2_t
 {
   float32x2_t val[2];
@@ -270,6 +282,16 @@ typedef struct uint64x2x3_t
   uint64x2_t val[3];
 } uint64x2x3_t;
 
+typedef struct float16x4x3_t
+{
+  float16x4_t val[3];
+} float16x4x3_t;
+
+typedef struct float16x8x3_t
+{
+  float16x8_t val[3];
+} float16x8x3_t;
+
 typedef struct float32x2x3_t
 {
   float32x2_t val[3];
@@ -390,6 +412,16 @@ typedef struct uint64x2x4_t
   uint64x2_t val[4];
 } uint64x2x4_t;
 
+typedef struct float16x4x4_t
+{
+  float16x4_t val[4];
+} float16x4x4_t;
+
+typedef struct float16x8x4_t
+{
+  float16x8_t val[4];
+} float16x8x4_t;
+
 typedef struct float32x2x4_t
 {
   float32x2_t val[4];
@@ -2641,6 +2673,12 @@ vcreate_s64 (uint64_t __a)
   return (int64x1_t) {__a};
 }
 
+__extension__ static __inline float16x4_t __attribute__ ((__always_inline__))
+vcreate_f16 (uint64_t __a)
+{
+  return (float16x4_t) __a;
+}
+
 __extension__ static __inline float32x2_t __attribute__ ((__always_inline__))
 vcreate_f32 (uint64_t __a)
 {
@@ -2691,6 +2729,12 @@ vcreate_p16 (uint64_t __a)
 
 /* vget_lane  */
 
+__extension__ static __inline float16_t __attribute__ ((__always_inline__))
+vget_lane_f16 (float16x4_t __a, const int __b)
+{
+  return __aarch64_vget_lane_any (__a, __b);
+}
+
 __extension__ static __inline float32_t __attribute__ ((__always_inline__))
 vget_lane_f32 (float32x2_t __a, const int __b)
 {
@@ -2765,6 +2809,12 @@ vget_lane_u64 (uint64x1_t __a, const int __b)
 
 /* vgetq_lane  */
 
+__extension__ static __inline float16_t __attribute__ ((__always_inline__))
+vgetq_lane_f16 (float16x8_t __a, const int __b)
+{
+  return __aarch64_vget_lane_any (__a, __b);
+}
+
 __extension__ static __inline float32_t __attribute__ ((__always_inline__))
 vgetq_lane_f32 (float32x4_t __a, const int __b)
 {
@@ -2840,6 +2890,12 @@ vgetq_lane_u64 (uint64x2_t __a, const int __b)
 /* vreinterpret  */
 
 __extension__ static __inline poly8x8_t __attribute__ ((__always_inline__))
+vreinterpret_p8_f16 (float16x4_t __a)
+{
+  return (poly8x8_t) __a;
+}
+
+__extension__ static __inline poly8x8_t __attribute__ ((__always_inline__))
 vreinterpret_p8_f64 (float64x1_t __a)
 {
   return (poly8x8_t) __a;
@@ -2936,6 +2992,12 @@ vreinterpretq_p8_s64 (int64x2_t __a)
 }
 
 __extension__ static __inline poly8x16_t __attribute__ ((__always_inline__))
+vreinterpretq_p8_f16 (float16x8_t __a)
+{
+  return (poly8x16_t) __a;
+}
+
+__extension__ static __inline poly8x16_t __attribute__ ((__always_inline__))
 vreinterpretq_p8_f32 (float32x4_t __a)
 {
   return (poly8x16_t) __a;
@@ -2972,6 +3034,12 @@ vreinterpretq_p8_p16 (poly16x8_t __a)
 }
 
 __extension__ static __inline poly16x4_t __attribute__ ((__always_inline__))
+vreinterpret_p16_f16 (float16x4_t __a)
+{
+  return (poly16x4_t) __a;
+}
+
+__extension__ static __inline poly16x4_t __attribute__ ((__always_inline__))
 vreinterpret_p16_f64 (float64x1_t __a)
 {
   return (poly16x4_t) __a;
@@ -3068,6 +3136,12 @@ vreinterpretq_p16_s64 (int64x2_t __a)
 }
 
 __extension__ static __inline poly16x8_t __attribute__ ((__always_inline__))
+vreinterpretq_p16_f16 (float16x8_t __a)
+{
+  return (poly16x8_t) __a;
+}
+
+__extension__ static __inline poly16x8_t __attribute__ ((__always_inline__))
 vreinterpretq_p16_f32 (float32x4_t __a)
 {
   return (poly16x8_t) __a;
@@ -3103,6 +3177,156 @@ vreinterpretq_p16_p8 (poly8x16_t __a)
   return (poly16x8_t) __a;
 }
 
+__extension__ static __inline float16x4_t __attribute__ ((__always_inline__))
+vreinterpret_f16_f64 (float64x1_t __a)
+{
+  return (float16x4_t) __a;
+}
+
+__extension__ static __inline float16x4_t __attribute__ ((__always_inline__))
+vreinterpret_f16_s8 (int8x8_t __a)
+{
+  return (float16x4_t) __a;
+}
+
+__extension__ static __inline float16x4_t __attribute__ ((__always_inline__))
+vreinterpret_f16_s16 (int16x4_t __a)
+{
+  return (float16x4_t) __a;
+}
+
+__extension__ static __inline float16x4_t __attribute__ ((__always_inline__))
+vreinterpret_f16_s32 (int32x2_t __a)
+{
+  return (float16x4_t) __a;
+}
+
+__extension__ static __inline float16x4_t __attribute__ ((__always_inline__))
+vreinterpret_f16_s64 (int64x1_t __a)
+{
+  return (float16x4_t) __a;
+}
+
+__extension__ static __inline float16x4_t __attribute__ ((__always_inline__))
+vreinterpret_f16_f32 (float32x2_t __a)
+{
+  return (float16x4_t) __a;
+}
+
+__extension__ static __inline float16x4_t __attribute__ ((__always_inline__))
+vreinterpret_f16_u8 (uint8x8_t __a)
+{
+  return (float16x4_t) __a;
+}
+
+__extension__ static __inline float16x4_t __attribute__ ((__always_inline__))
+vreinterpret_f16_u16 (uint16x4_t __a)
+{
+  return (float16x4_t) __a;
+}
+
+__extension__ static __inline float16x4_t __attribute__ ((__always_inline__))
+vreinterpret_f16_u32 (uint32x2_t __a)
+{
+  return (float16x4_t) __a;
+}
+
+__extension__ static __inline float16x4_t __attribute__ ((__always_inline__))
+vreinterpret_f16_u64 (uint64x1_t __a)
+{
+  return (float16x4_t) __a;
+}
+
+__extension__ static __inline float16x4_t __attribute__ ((__always_inline__))
+vreinterpret_f16_p8 (poly8x8_t __a)
+{
+  return (float16x4_t) __a;
+}
+
+__extension__ static __inline float16x4_t __attribute__ ((__always_inline__))
+vreinterpret_f16_p16 (poly16x4_t __a)
+{
+  return (float16x4_t) __a;
+}
+
+__extension__ static __inline float16x8_t __attribute__ ((__always_inline__))
+vreinterpretq_f16_f64 (float64x2_t __a)
+{
+  return (float16x8_t) __a;
+}
+
+__extension__ static __inline float16x8_t __attribute__ ((__always_inline__))
+vreinterpretq_f16_s8 (int8x16_t __a)
+{
+  return (float16x8_t) __a;
+}
+
+__extension__ static __inline float16x8_t __attribute__ ((__always_inline__))
+vreinterpretq_f16_s16 (int16x8_t __a)
+{
+  return (float16x8_t) __a;
+}
+
+__extension__ static __inline float16x8_t __attribute__ ((__always_inline__))
+vreinterpretq_f16_s32 (int32x4_t __a)
+{
+  return (float16x8_t) __a;
+}
+
+__extension__ static __inline float16x8_t __attribute__ ((__always_inline__))
+vreinterpretq_f16_s64 (int64x2_t __a)
+{
+  return (float16x8_t) __a;
+}
+
+__extension__ static __inline float16x8_t __attribute__ ((__always_inline__))
+vreinterpretq_f16_f32 (float32x4_t __a)
+{
+  return (float16x8_t) __a;
+}
+
+__extension__ static __inline float16x8_t __attribute__ ((__always_inline__))
+vreinterpretq_f16_u8 (uint8x16_t __a)
+{
+  return (float16x8_t) __a;
+}
+
+__extension__ static __inline float16x8_t __attribute__ ((__always_inline__))
+vreinterpretq_f16_u16 (uint16x8_t __a)
+{
+  return (float16x8_t) __a;
+}
+
+__extension__ static __inline float16x8_t __attribute__ ((__always_inline__))
+vreinterpretq_f16_u32 (uint32x4_t __a)
+{
+  return (float16x8_t) __a;
+}
+
+__extension__ static __inline float16x8_t __attribute__ ((__always_inline__))
+vreinterpretq_f16_u64 (uint64x2_t __a)
+{
+  return (float16x8_t) __a;
+}
+
+__extension__ static __inline float16x8_t __attribute__ ((__always_inline__))
+vreinterpretq_f16_p8 (poly8x16_t __a)
+{
+  return (float16x8_t) __a;
+}
+
+__extension__ static __inline float16x8_t __attribute__ ((__always_inline__))
+vreinterpretq_f16_p16 (poly16x8_t __a)
+{
+  return (float16x8_t) __a;
+}
+
+__extension__ static __inline float32x2_t __attribute__ ((__always_inline__))
+vreinterpret_f32_f16 (float16x4_t __a)
+{
+  return (float32x2_t) __a;
+}
+
 __extension__ static __inline float32x2_t __attribute__ ((__always_inline__))
 vreinterpret_f32_f64 (float64x1_t __a)
 {
@@ -3170,6 +3394,12 @@ vreinterpret_f32_p16 (poly16x4_t __a)
 }
 
 __extension__ static __inline float32x4_t __attribute__ ((__always_inline__))
+vreinterpretq_f32_f16 (float16x8_t __a)
+{
+  return (float32x4_t) __a;
+}
+
+__extension__ static __inline float32x4_t __attribute__ ((__always_inline__))
 vreinterpretq_f32_f64 (float64x2_t __a)
 {
   return (float32x4_t) __a;
@@ -3236,6 +3466,12 @@ vreinterpretq_f32_p16 (poly16x8_t __a)
 }
 
 __extension__ static __inline float64x1_t __attribute__((__always_inline__))
+vreinterpret_f64_f16 (float16x4_t __a)
+{
+  return (float64x1_t) __a;
+}
+
+__extension__ static __inline float64x1_t __attribute__((__always_inline__))
 vreinterpret_f64_f32 (float32x2_t __a)
 {
   return (float64x1_t) __a;
@@ -3302,6 +3538,12 @@ vreinterpret_f64_u64 (uint64x1_t __a)
 }
 
 __extension__ static __inline float64x2_t __attribute__((__always_inline__))
+vreinterpretq_f64_f16 (float16x8_t __a)
+{
+  return (float64x2_t) __a;
+}
+
+__extension__ static __inline float64x2_t __attribute__((__always_inline__))
 vreinterpretq_f64_f32 (float32x4_t __a)
 {
   return (float64x2_t) __a;
@@ -3368,6 +3610,12 @@ vreinterpretq_f64_u64 (uint64x2_t __a)
 }
 
 __extension__ static __inline int64x1_t __attribute__ ((__always_inline__))
+vreinterpret_s64_f16 (float16x4_t __a)
+{
+  return (int64x1_t) __a;
+}
+
+__extension__ static __inline int64x1_t __attribute__ ((__always_inline__))
 vreinterpret_s64_f64 (float64x1_t __a)
 {
   return (int64x1_t) __a;
@@ -3458,6 +3706,12 @@ vreinterpretq_s64_s32 (int32x4_t __a)
 }
 
 __extension__ static __inline int64x2_t __attribute__ ((__always_inline__))
+vreinterpretq_s64_f16 (float16x8_t __a)
+{
+  return (int64x2_t) __a;
+}
+
+__extension__ static __inline int64x2_t __attribute__ ((__always_inline__))
 vreinterpretq_s64_f32 (float32x4_t __a)
 {
   return (int64x2_t) __a;
@@ -3500,6 +3754,12 @@ vreinterpretq_s64_p16 (poly16x8_t __a)
 }
 
 __extension__ static __inline uint64x1_t __attribute__ ((__always_inline__))
+vreinterpret_u64_f16 (float16x4_t __a)
+{
+  return (uint64x1_t) __a;
+}
+
+__extension__ static __inline uint64x1_t __attribute__ ((__always_inline__))
 vreinterpret_u64_f64 (float64x1_t __a)
 {
   return (uint64x1_t) __a;
@@ -3596,6 +3856,12 @@ vreinterpretq_u64_s64 (int64x2_t __a)
 }
 
 __extension__ static __inline uint64x2_t __attribute__ ((__always_inline__))
+vreinterpretq_u64_f16 (float16x8_t __a)
+{
+  return (uint64x2_t) __a;
+}
+
+__extension__ static __inline uint64x2_t __attribute__ ((__always_inline__))
 vreinterpretq_u64_f32 (float32x4_t __a)
 {
   return (uint64x2_t) __a;
@@ -3632,6 +3898,12 @@ vreinterpretq_u64_p16 (poly16x8_t __a)
 }
 
 __extension__ static __inline int8x8_t __attribute__ ((__always_inline__))
+vreinterpret_s8_f16 (float16x4_t __a)
+{
+  return (int8x8_t) __a;
+}
+
+__extension__ static __inline int8x8_t __attribute__ ((__always_inline__))
 vreinterpret_s8_f64 (float64x1_t __a)
 {
   return (int8x8_t) __a;
@@ -3722,6 +3994,12 @@ vreinterpretq_s8_s64 (int64x2_t __a)
 }
 
 __extension__ static __inline int8x16_t __attribute__ ((__always_inline__))
+vreinterpretq_s8_f16 (float16x8_t __a)
+{
+  return (int8x16_t) __a;
+}
+
+__extension__ static __inline int8x16_t __attribute__ ((__always_inline__))
 vreinterpretq_s8_f32 (float32x4_t __a)
 {
   return (int8x16_t) __a;
@@ -3764,6 +4042,12 @@ vreinterpretq_s8_p16 (poly16x8_t __a)
 }
 
 __extension__ static __inline int16x4_t __attribute__ ((__always_inline__))
+vreinterpret_s16_f16 (float16x4_t __a)
+{
+  return (int16x4_t) __a;
+}
+
+__extension__ static __inline int16x4_t __attribute__ ((__always_inline__))
 vreinterpret_s16_f64 (float64x1_t __a)
 {
   return (int16x4_t) __a;
@@ -3854,6 +4138,12 @@ vreinterpretq_s16_s64 (int64x2_t __a)
 }
 
 __extension__ static __inline int16x8_t __attribute__ ((__always_inline__))
+vreinterpretq_s16_f16 (float16x8_t __a)
+{
+  return (int16x8_t) __a;
+}
+
+__extension__ static __inline int16x8_t __attribute__ ((__always_inline__))
 vreinterpretq_s16_f32 (float32x4_t __a)
 {
   return (int16x8_t) __a;
@@ -3896,6 +4186,12 @@ vreinterpretq_s16_p16 (poly16x8_t __a)
 }
 
 __extension__ static __inline int32x2_t __attribute__ ((__always_inline__))
+vreinterpret_s32_f16 (float16x4_t __a)
+{
+  return (int32x2_t) __a;
+}
+
+__extension__ static __inline int32x2_t __attribute__ ((__always_inline__))
 vreinterpret_s32_f64 (float64x1_t __a)
 {
   return (int32x2_t) __a;
@@ -3986,6 +4282,12 @@ vreinterpretq_s32_s64 (int64x2_t __a)
 }
 
 __extension__ static __inline int32x4_t __attribute__ ((__always_inline__))
+vreinterpretq_s32_f16 (float16x8_t __a)
+{
+  return (int32x4_t) __a;
+}
+
+__extension__ static __inline int32x4_t __attribute__ ((__always_inline__))
 vreinterpretq_s32_f32 (float32x4_t __a)
 {
   return (int32x4_t) __a;
@@ -4028,6 +4330,12 @@ vreinterpretq_s32_p16 (poly16x8_t __a)
 }
 
 __extension__ static __inline uint8x8_t __attribute__ ((__always_inline__))
+vreinterpret_u8_f16 (float16x4_t __a)
+{
+  return (uint8x8_t) __a;
+}
+
+__extension__ static __inline uint8x8_t __attribute__ ((__always_inline__))
 vreinterpret_u8_f64 (float64x1_t __a)
 {
   return (uint8x8_t) __a;
@@ -4124,6 +4432,12 @@ vreinterpretq_u8_s64 (int64x2_t __a)
 }
 
 __extension__ static __inline uint8x16_t __attribute__ ((__always_inline__))
+vreinterpretq_u8_f16 (float16x8_t __a)
+{
+  return (uint8x16_t) __a;
+}
+
+__extension__ static __inline uint8x16_t __attribute__ ((__always_inline__))
 vreinterpretq_u8_f32 (float32x4_t __a)
 {
   return (uint8x16_t) __a;
@@ -4160,6 +4474,12 @@ vreinterpretq_u8_p16 (poly16x8_t __a)
 }
 
 __extension__ static __inline uint16x4_t __attribute__ ((__always_inline__))
+vreinterpret_u16_f16 (float16x4_t __a)
+{
+  return (uint16x4_t) __a;
+}
+
+__extension__ static __inline uint16x4_t __attribute__ ((__always_inline__))
 vreinterpret_u16_f64 (float64x1_t __a)
 {
   return (uint16x4_t) __a;
@@ -4256,6 +4576,12 @@ vreinterpretq_u16_s64 (int64x2_t __a)
 }
 
 __extension__ static __inline uint16x8_t __attribute__ ((__always_inline__))
+vreinterpretq_u16_f16 (float16x8_t __a)
+{
+  return (uint16x8_t) __a;
+}
+
+__extension__ static __inline uint16x8_t __attribute__ ((__always_inline__))
 vreinterpretq_u16_f32 (float32x4_t __a)
 {
   return (uint16x8_t) __a;
@@ -4292,6 +4618,12 @@ vreinterpretq_u16_p16 (poly16x8_t __a)
 }
 
 __extension__ static __inline uint32x2_t __attribute__ ((__always_inline__))
+vreinterpret_u32_f16 (float16x4_t __a)
+{
+  return (uint32x2_t) __a;
+}
+
+__extension__ static __inline uint32x2_t __attribute__ ((__always_inline__))
 vreinterpret_u32_f64 (float64x1_t __a)
 {
   return (uint32x2_t) __a;
@@ -4388,6 +4720,12 @@ vreinterpretq_u32_s64 (int64x2_t __a)
 }
 
 __extension__ static __inline uint32x4_t __attribute__ ((__always_inline__))
+vreinterpretq_u32_f16 (float16x8_t __a)
+{
+  return (uint32x4_t) __a;
+}
+
+__extension__ static __inline uint32x4_t __attribute__ ((__always_inline__))
 vreinterpretq_u32_f32 (float32x4_t __a)
 {
   return (uint32x4_t) __a;
@@ -4425,6 +4763,12 @@ vreinterpretq_u32_p16 (poly16x8_t __a)
 
 /* vset_lane  */
 
+__extension__ static __inline float16x4_t __attribute__ ((__always_inline__))
+vset_lane_f16 (float16_t __elem, float16x4_t __vec, const int __index)
+{
+  return __aarch64_vset_lane_any (__elem, __vec, __index);
+}
+
 __extension__ static __inline float32x2_t __attribute__ ((__always_inline__))
 vset_lane_f32 (float32_t __elem, float32x2_t __vec, const int __index)
 {
@@ -4499,6 +4843,12 @@ vset_lane_u64 (uint64_t __elem, uint64x1_t __vec, const int __index)
 
 /* vsetq_lane  */
 
+__extension__ static __inline float16x8_t __attribute__ ((__always_inline__))
+vsetq_lane_f16 (float16_t __elem, float16x8_t __vec, const int __index)
+{
+  return __aarch64_vset_lane_any (__elem, __vec, __index);
+}
+
 __extension__ static __inline float32x4_t __attribute__ ((__always_inline__))
 vsetq_lane_f32 (float32_t __elem, float32x4_t __vec, const int __index)
 {
@@ -4576,6 +4926,12 @@ vsetq_lane_u64 (uint64_t __elem, uint64x2_t __vec, const int __index)
   uint64x1_t lo = vcreate_u64 (vgetq_lane_u64 (tmp, 0));  \
   return vreinterpret_##__TYPE##_u64 (lo);
 
+__extension__ static __inline float16x4_t __attribute__ ((__always_inline__))
+vget_low_f16 (float16x8_t __a)
+{
+  __GET_LOW (f16);
+}
+
 __extension__ static __inline float32x2_t __attribute__ ((__always_inline__))
 vget_low_f32 (float32x4_t __a)
 {
@@ -4655,6 +5011,12 @@ vget_low_u64 (uint64x2_t __a)
   uint64x1_t hi = vcreate_u64 (vgetq_lane_u64 (tmp, 1));	\
   return vreinterpret_##__TYPE##_u64 (hi);
 
+__extension__ static __inline float16x4_t __attribute__ ((__always_inline__))
+vget_high_f16 (float16x8_t __a)
+{
+  __GET_HIGH (f16);
+}
+
 __extension__ static __inline float32x2_t __attribute__ ((__always_inline__))
 vget_high_f32 (float32x4_t __a)
 {
@@ -4753,6 +5115,12 @@ vcombine_s64 (int64x1_t __a, int64x1_t __b)
   return __builtin_aarch64_combinedi (__a[0], __b[0]);
 }
 
+__extension__ static __inline float16x8_t __attribute__ ((__always_inline__))
+vcombine_f16 (float16x4_t __a, float16x4_t __b)
+{
+  return __builtin_aarch64_combinev4hf (__a, __b);
+}
+
 __extension__ static __inline float32x4_t __attribute__ ((__always_inline__))
 vcombine_f32 (float32x2_t __a, float32x2_t __b)
 {
@@ -5657,16 +6025,6 @@ vaddlvq_u32 (uint32x4_t a)
        result;                                                          \
      })
 
-/* vcvt_f16_f32 not supported */
-
-/* vcvt_f32_f16 not supported */
-
-/* vcvt_high_f16_f32 not supported */
-
-/* vcvt_high_f32_f16 not supported */
-
-static float32x2_t vdup_n_f32 (float32_t);
-
 #define vcvt_n_f32_s32(a, b)                                            \
   __extension__                                                         \
     ({                                                                  \
@@ -9824,272 +10182,6 @@ vrsqrtss_f32 (float32_t a, float32_t b)
        result;                                                          \
      })
 
-#define vst1_lane_f32(a, b, c)                                          \
-  __extension__                                                         \
-    ({                                                                  \
-       float32x2_t b_ = (b);                                            \
-       float32_t * a_ = (a);                                            \
-       __asm__ ("st1 {%1.s}[%2],[%0]"                                   \
-                :                                                       \
-                : "r"(a_), "w"(b_), "i"(c)                              \
-                : "memory");                                            \
-     })
-
-#define vst1_lane_f64(a, b, c)                                          \
-  __extension__                                                         \
-    ({                                                                  \
-       float64x1_t b_ = (b);                                            \
-       float64_t * a_ = (a);                                            \
-       __asm__ ("st1 {%1.d}[%2],[%0]"                                   \
-                :                                                       \
-                : "r"(a_), "w"(b_), "i"(c)                              \
-                : "memory");                                            \
-     })
-
-#define vst1_lane_p8(a, b, c)                                           \
-  __extension__                                                         \
-    ({                                                                  \
-       poly8x8_t b_ = (b);                                              \
-       poly8_t * a_ = (a);                                              \
-       __asm__ ("st1 {%1.b}[%2],[%0]"                                   \
-                :                                                       \
-                : "r"(a_), "w"(b_), "i"(c)                              \
-                : "memory");                                            \
-     })
-
-#define vst1_lane_p16(a, b, c)                                          \
-  __extension__                                                         \
-    ({                                                                  \
-       poly16x4_t b_ = (b);                                             \
-       poly16_t * a_ = (a);                                             \
-       __asm__ ("st1 {%1.h}[%2],[%0]"                                   \
-                :                                                       \
-                : "r"(a_), "w"(b_), "i"(c)                              \
-                : "memory");                                            \
-     })
-
-#define vst1_lane_s8(a, b, c)                                           \
-  __extension__                                                         \
-    ({                                                                  \
-       int8x8_t b_ = (b);                                               \
-       int8_t * a_ = (a);                                               \
-       __asm__ ("st1 {%1.b}[%2],[%0]"                                   \
-                :                                                       \
-                : "r"(a_), "w"(b_), "i"(c)                              \
-                : "memory");                                            \
-     })
-
-#define vst1_lane_s16(a, b, c)                                          \
-  __extension__                                                         \
-    ({                                                                  \
-       int16x4_t b_ = (b);                                              \
-       int16_t * a_ = (a);                                              \
-       __asm__ ("st1 {%1.h}[%2],[%0]"                                   \
-                :                                                       \
-                : "r"(a_), "w"(b_), "i"(c)                              \
-                : "memory");                                            \
-     })
-
-#define vst1_lane_s32(a, b, c)                                          \
-  __extension__                                                         \
-    ({                                                                  \
-       int32x2_t b_ = (b);                                              \
-       int32_t * a_ = (a);                                              \
-       __asm__ ("st1 {%1.s}[%2],[%0]"                                   \
-                :                                                       \
-                : "r"(a_), "w"(b_), "i"(c)                              \
-                : "memory");                                            \
-     })
-
-#define vst1_lane_s64(a, b, c)                                          \
-  __extension__                                                         \
-    ({                                                                  \
-       int64x1_t b_ = (b);                                              \
-       int64_t * a_ = (a);                                              \
-       __asm__ ("st1 {%1.d}[%2],[%0]"                                   \
-                :                                                       \
-                : "r"(a_), "w"(b_), "i"(c)                              \
-                : "memory");                                            \
-     })
-
-#define vst1_lane_u8(a, b, c)                                           \
-  __extension__                                                         \
-    ({                                                                  \
-       uint8x8_t b_ = (b);                                              \
-       uint8_t * a_ = (a);                                              \
-       __asm__ ("st1 {%1.b}[%2],[%0]"                                   \
-                :                                                       \
-                : "r"(a_), "w"(b_), "i"(c)                              \
-                : "memory");                                            \
-     })
-
-#define vst1_lane_u16(a, b, c)                                          \
-  __extension__                                                         \
-    ({                                                                  \
-       uint16x4_t b_ = (b);                                             \
-       uint16_t * a_ = (a);                                             \
-       __asm__ ("st1 {%1.h}[%2],[%0]"                                   \
-                :                                                       \
-                : "r"(a_), "w"(b_), "i"(c)                              \
-                : "memory");                                            \
-     })
-
-#define vst1_lane_u32(a, b, c)                                          \
-  __extension__                                                         \
-    ({                                                                  \
-       uint32x2_t b_ = (b);                                             \
-       uint32_t * a_ = (a);                                             \
-       __asm__ ("st1 {%1.s}[%2],[%0]"                                   \
-                :                                                       \
-                : "r"(a_), "w"(b_), "i"(c)                              \
-                : "memory");                                            \
-     })
-
-#define vst1_lane_u64(a, b, c)                                          \
-  __extension__                                                         \
-    ({                                                                  \
-       uint64x1_t b_ = (b);                                             \
-       uint64_t * a_ = (a);                                             \
-       __asm__ ("st1 {%1.d}[%2],[%0]"                                   \
-                :                                                       \
-                : "r"(a_), "w"(b_), "i"(c)                              \
-                : "memory");                                            \
-     })
-
-
-#define vst1q_lane_f32(a, b, c)                                         \
-  __extension__                                                         \
-    ({                                                                  \
-       float32x4_t b_ = (b);                                            \
-       float32_t * a_ = (a);                                            \
-       __asm__ ("st1 {%1.s}[%2],[%0]"                                   \
-                :                                                       \
-                : "r"(a_), "w"(b_), "i"(c)                              \
-                : "memory");                                            \
-     })
-
-#define vst1q_lane_f64(a, b, c)                                         \
-  __extension__                                                         \
-    ({                                                                  \
-       float64x2_t b_ = (b);                                            \
-       float64_t * a_ = (a);                                            \
-       __asm__ ("st1 {%1.d}[%2],[%0]"                                   \
-                :                                                       \
-                : "r"(a_), "w"(b_), "i"(c)                              \
-                : "memory");                                            \
-     })
-
-#define vst1q_lane_p8(a, b, c)                                          \
-  __extension__                                                         \
-    ({                                                                  \
-       poly8x16_t b_ = (b);                                             \
-       poly8_t * a_ = (a);                                              \
-       __asm__ ("st1 {%1.b}[%2],[%0]"                                   \
-                :                                                       \
-                : "r"(a_), "w"(b_), "i"(c)                              \
-                : "memory");                                            \
-     })
-
-#define vst1q_lane_p16(a, b, c)                                         \
-  __extension__                                                         \
-    ({                                                                  \
-       poly16x8_t b_ = (b);                                             \
-       poly16_t * a_ = (a);                                             \
-       __asm__ ("st1 {%1.h}[%2],[%0]"                                   \
-                :                                                       \
-                : "r"(a_), "w"(b_), "i"(c)                              \
-                : "memory");                                            \
-     })
-
-#define vst1q_lane_s8(a, b, c)                                          \
-  __extension__                                                         \
-    ({                                                                  \
-       int8x16_t b_ = (b);                                              \
-       int8_t * a_ = (a);                                               \
-       __asm__ ("st1 {%1.b}[%2],[%0]"                                   \
-                :                                                       \
-                : "r"(a_), "w"(b_), "i"(c)                              \
-                : "memory");                                            \
-     })
-
-#define vst1q_lane_s16(a, b, c)                                         \
-  __extension__                                                         \
-    ({                                                                  \
-       int16x8_t b_ = (b);                                              \
-       int16_t * a_ = (a);                                              \
-       __asm__ ("st1 {%1.h}[%2],[%0]"                                   \
-                :                                                       \
-                : "r"(a_), "w"(b_), "i"(c)                              \
-                : "memory");                                            \
-     })
-
-#define vst1q_lane_s32(a, b, c)                                         \
-  __extension__                                                         \
-    ({                                                                  \
-       int32x4_t b_ = (b);                                              \
-       int32_t * a_ = (a);                                              \
-       __asm__ ("st1 {%1.s}[%2],[%0]"                                   \
-                :                                                       \
-                : "r"(a_), "w"(b_), "i"(c)                              \
-                : "memory");                                            \
-     })
-
-#define vst1q_lane_s64(a, b, c)                                         \
-  __extension__                                                         \
-    ({                                                                  \
-       int64x2_t b_ = (b);                                              \
-       int64_t * a_ = (a);                                              \
-       __asm__ ("st1 {%1.d}[%2],[%0]"                                   \
-                :                                                       \
-                : "r"(a_), "w"(b_), "i"(c)                              \
-                : "memory");                                            \
-     })
-
-#define vst1q_lane_u8(a, b, c)                                          \
-  __extension__                                                         \
-    ({                                                                  \
-       uint8x16_t b_ = (b);                                             \
-       uint8_t * a_ = (a);                                              \
-       __asm__ ("st1 {%1.b}[%2],[%0]"                                   \
-                :                                                       \
-                : "r"(a_), "w"(b_), "i"(c)                              \
-                : "memory");                                            \
-     })
-
-#define vst1q_lane_u16(a, b, c)                                         \
-  __extension__                                                         \
-    ({                                                                  \
-       uint16x8_t b_ = (b);                                             \
-       uint16_t * a_ = (a);                                             \
-       __asm__ ("st1 {%1.h}[%2],[%0]"                                   \
-                :                                                       \
-                : "r"(a_), "w"(b_), "i"(c)                              \
-                : "memory");                                            \
-     })
-
-#define vst1q_lane_u32(a, b, c)                                         \
-  __extension__                                                         \
-    ({                                                                  \
-       uint32x4_t b_ = (b);                                             \
-       uint32_t * a_ = (a);                                             \
-       __asm__ ("st1 {%1.s}[%2],[%0]"                                   \
-                :                                                       \
-                : "r"(a_), "w"(b_), "i"(c)                              \
-                : "memory");                                            \
-     })
-
-#define vst1q_lane_u64(a, b, c)                                         \
-  __extension__                                                         \
-    ({                                                                  \
-       uint64x2_t b_ = (b);                                             \
-       uint64_t * a_ = (a);                                             \
-       __asm__ ("st1 {%1.d}[%2],[%0]"                                   \
-                :                                                       \
-                : "r"(a_), "w"(b_), "i"(c)                              \
-                : "memory");                                            \
-     })
-
-
 __extension__ static __inline uint8x8_t __attribute__ ((__always_inline__))
 vtst_p8 (poly8x8_t a, poly8x8_t b)
 {
@@ -10149,7 +10241,7 @@ vtstq_p16 (poly16x8_t a, poly16x8_t b)
    +------+----+----+----+----+
    |uint  | Y  | Y  | N  | N  |
    +------+----+----+----+----+
-   |float | -  | -  | N  | N  |
+   |float | -  | Y  | N  | N  |
    +------+----+----+----+----+
    |poly  | Y  | Y  | -  | -  |
    +------+----+----+----+----+
@@ -10163,7 +10255,7 @@ vtstq_p16 (poly16x8_t a, poly16x8_t b)
    +------+----+----+----+----+
    |uint  | Y  | Y  | Y  | Y  |
    +------+----+----+----+----+
-   |float | -  | -  | Y  | Y  |
+   |float | -  | Y  | Y  | Y  |
    +------+----+----+----+----+
    |poly  | Y  | Y  | -  | -  |
    +------+----+----+----+----+
@@ -10177,7 +10269,7 @@ vtstq_p16 (poly16x8_t a, poly16x8_t b)
    +------+----+----+----+----+
    |uint  | Y  | N  | N  | Y  |
    +------+----+----+----+----+
-   |float | -  | -  | N  | Y  |
+   |float | -  | N  | N  | Y  |
    +------+----+----+----+----+
    |poly  | Y  | N  | -  | -  |
    +------+----+----+----+----+
@@ -10193,6 +10285,7 @@ __STRUCTN (int, 8, 2)
 __STRUCTN (int, 16, 2)
 __STRUCTN (uint, 8, 2)
 __STRUCTN (uint, 16, 2)
+__STRUCTN (float, 16, 2)
 __STRUCTN (poly, 8, 2)
 __STRUCTN (poly, 16, 2)
 /* 3-element structs.  */
@@ -10204,6 +10297,7 @@ __STRUCTN (uint, 8, 3)
 __STRUCTN (uint, 16, 3)
 __STRUCTN (uint, 32, 3)
 __STRUCTN (uint, 64, 3)
+__STRUCTN (float, 16, 3)
 __STRUCTN (float, 32, 3)
 __STRUCTN (float, 64, 3)
 __STRUCTN (poly, 8, 3)
@@ -10218,8 +10312,8 @@ __STRUCTN (float, 64, 4)
 #undef __STRUCTN
 
 
-#define __ST2_LANE_FUNC(intype, largetype, ptrtype,			     \
-			mode, ptr_mode, funcsuffix, signedtype)		     \
+#define __ST2_LANE_FUNC(intype, largetype, ptrtype, mode,		     \
+			qmode, ptr_mode, funcsuffix, signedtype)	     \
 __extension__ static __inline void					     \
 __attribute__ ((__always_inline__))					     \
 vst2_lane_ ## funcsuffix (ptrtype *__ptr,				     \
@@ -10233,31 +10327,39 @@ vst2_lane_ ## funcsuffix (ptrtype *__ptr,				     \
   __temp.val[1]								     \
     = vcombine_##funcsuffix (__b.val[1],				     \
 			     vcreate_##funcsuffix (__AARCH64_UINT64_C (0))); \
-  __o = __builtin_aarch64_set_qregoi##mode (__o,			     \
-					    (signedtype) __temp.val[0], 0);  \
-  __o = __builtin_aarch64_set_qregoi##mode (__o,			     \
-					    (signedtype) __temp.val[1], 1);  \
+  __o = __builtin_aarch64_set_qregoi##qmode (__o,			     \
+					     (signedtype) __temp.val[0], 0); \
+  __o = __builtin_aarch64_set_qregoi##qmode (__o,			     \
+					     (signedtype) __temp.val[1], 1); \
   __builtin_aarch64_st2_lane##mode ((__builtin_aarch64_simd_ ## ptr_mode *)  \
 				     __ptr, __o, __c);			     \
 }
 
-__ST2_LANE_FUNC (float32x2x2_t, float32x4x2_t, float32_t, v4sf, sf, f32,
+__ST2_LANE_FUNC (float16x4x2_t, float16x8x2_t, float16_t, v4hf, v8hf, hf, f16,
+		 float16x8_t)
+__ST2_LANE_FUNC (float32x2x2_t, float32x4x2_t, float32_t, v2sf, v4sf, sf, f32,
 		 float32x4_t)
-__ST2_LANE_FUNC (float64x1x2_t, float64x2x2_t, float64_t, v2df, df, f64,
+__ST2_LANE_FUNC (float64x1x2_t, float64x2x2_t, float64_t, df, v2df, df, f64,
 		 float64x2_t)
-__ST2_LANE_FUNC (poly8x8x2_t, poly8x16x2_t, poly8_t, v16qi, qi, p8, int8x16_t)
-__ST2_LANE_FUNC (poly16x4x2_t, poly16x8x2_t, poly16_t, v8hi, hi, p16,
+__ST2_LANE_FUNC (poly8x8x2_t, poly8x16x2_t, poly8_t, v8qi, v16qi, qi, p8,
+		 int8x16_t)
+__ST2_LANE_FUNC (poly16x4x2_t, poly16x8x2_t, poly16_t, v4hi, v8hi, hi, p16,
 		 int16x8_t)
-__ST2_LANE_FUNC (int8x8x2_t, int8x16x2_t, int8_t, v16qi, qi, s8, int8x16_t)
-__ST2_LANE_FUNC (int16x4x2_t, int16x8x2_t, int16_t, v8hi, hi, s16, int16x8_t)
-__ST2_LANE_FUNC (int32x2x2_t, int32x4x2_t, int32_t, v4si, si, s32, int32x4_t)
-__ST2_LANE_FUNC (int64x1x2_t, int64x2x2_t, int64_t, v2di, di, s64, int64x2_t)
-__ST2_LANE_FUNC (uint8x8x2_t, uint8x16x2_t, uint8_t, v16qi, qi, u8, int8x16_t)
-__ST2_LANE_FUNC (uint16x4x2_t, uint16x8x2_t, uint16_t, v8hi, hi, u16,
+__ST2_LANE_FUNC (int8x8x2_t, int8x16x2_t, int8_t, v8qi, v16qi, qi, s8,
+		 int8x16_t)
+__ST2_LANE_FUNC (int16x4x2_t, int16x8x2_t, int16_t, v4hi, v8hi, hi, s16,
 		 int16x8_t)
-__ST2_LANE_FUNC (uint32x2x2_t, uint32x4x2_t, uint32_t, v4si, si, u32,
+__ST2_LANE_FUNC (int32x2x2_t, int32x4x2_t, int32_t, v2si, v4si, si, s32,
 		 int32x4_t)
-__ST2_LANE_FUNC (uint64x1x2_t, uint64x2x2_t, uint64_t, v2di, di, u64,
+__ST2_LANE_FUNC (int64x1x2_t, int64x2x2_t, int64_t, di, v2di, di, s64,
+		 int64x2_t)
+__ST2_LANE_FUNC (uint8x8x2_t, uint8x16x2_t, uint8_t, v8qi, v16qi, qi, u8,
+		 int8x16_t)
+__ST2_LANE_FUNC (uint16x4x2_t, uint16x8x2_t, uint16_t, v4hi, v8hi, hi, u16,
+		 int16x8_t)
+__ST2_LANE_FUNC (uint32x2x2_t, uint32x4x2_t, uint32_t, v2si, v4si, si, u32,
+		 int32x4_t)
+__ST2_LANE_FUNC (uint64x1x2_t, uint64x2x2_t, uint64_t, di, v2di, di, u64,
 		 int64x2_t)
 
 #undef __ST2_LANE_FUNC
@@ -10273,6 +10375,7 @@ vst2q_lane_ ## funcsuffix (ptrtype *__ptr,				    \
 				    __ptr, __temp.__o, __c);		    \
 }
 
+__ST2_LANE_FUNC (float16x8x2_t, float16_t, v8hf, hf, f16)
 __ST2_LANE_FUNC (float32x4x2_t, float32_t, v4sf, sf, f32)
 __ST2_LANE_FUNC (float64x2x2_t, float64_t, v2df, df, f64)
 __ST2_LANE_FUNC (poly8x16x2_t, poly8_t, v16qi, qi, p8)
@@ -10286,8 +10389,8 @@ __ST2_LANE_FUNC (uint16x8x2_t, uint16_t, v8hi, hi, u16)
 __ST2_LANE_FUNC (uint32x4x2_t, uint32_t, v4si, si, u32)
 __ST2_LANE_FUNC (uint64x2x2_t, uint64_t, v2di, di, u64)
 
-#define __ST3_LANE_FUNC(intype, largetype, ptrtype,			     \
-			mode, ptr_mode, funcsuffix, signedtype)		     \
+#define __ST3_LANE_FUNC(intype, largetype, ptrtype, mode,		     \
+			qmode, ptr_mode, funcsuffix, signedtype)	     \
 __extension__ static __inline void					     \
 __attribute__ ((__always_inline__))					     \
 vst3_lane_ ## funcsuffix (ptrtype *__ptr,				     \
@@ -10304,33 +10407,41 @@ vst3_lane_ ## funcsuffix (ptrtype *__ptr,				     \
   __temp.val[2]								     \
     = vcombine_##funcsuffix (__b.val[2],				     \
 			     vcreate_##funcsuffix (__AARCH64_UINT64_C (0))); \
-  __o = __builtin_aarch64_set_qregci##mode (__o,			     \
-					    (signedtype) __temp.val[0], 0);  \
-  __o = __builtin_aarch64_set_qregci##mode (__o,			     \
-					    (signedtype) __temp.val[1], 1);  \
-  __o = __builtin_aarch64_set_qregci##mode (__o,			     \
-					    (signedtype) __temp.val[2], 2);  \
+  __o = __builtin_aarch64_set_qregci##qmode (__o,			     \
+					     (signedtype) __temp.val[0], 0); \
+  __o = __builtin_aarch64_set_qregci##qmode (__o,			     \
+					     (signedtype) __temp.val[1], 1); \
+  __o = __builtin_aarch64_set_qregci##qmode (__o,			     \
+					     (signedtype) __temp.val[2], 2); \
   __builtin_aarch64_st3_lane##mode ((__builtin_aarch64_simd_ ## ptr_mode *)  \
 				     __ptr, __o, __c);			     \
 }
 
-__ST3_LANE_FUNC (float32x2x3_t, float32x4x3_t, float32_t, v4sf, sf, f32,
+__ST3_LANE_FUNC (float16x4x3_t, float16x8x3_t, float16_t, v4hf, v8hf, hf, f16,
+		 float16x8_t)
+__ST3_LANE_FUNC (float32x2x3_t, float32x4x3_t, float32_t, v2sf, v4sf, sf, f32,
 		 float32x4_t)
-__ST3_LANE_FUNC (float64x1x3_t, float64x2x3_t, float64_t, v2df, df, f64,
+__ST3_LANE_FUNC (float64x1x3_t, float64x2x3_t, float64_t, df, v2df, df, f64,
 		 float64x2_t)
-__ST3_LANE_FUNC (poly8x8x3_t, poly8x16x3_t, poly8_t, v16qi, qi, p8, int8x16_t)
-__ST3_LANE_FUNC (poly16x4x3_t, poly16x8x3_t, poly16_t, v8hi, hi, p16,
+__ST3_LANE_FUNC (poly8x8x3_t, poly8x16x3_t, poly8_t, v8qi, v16qi, qi, p8,
+		 int8x16_t)
+__ST3_LANE_FUNC (poly16x4x3_t, poly16x8x3_t, poly16_t, v4hi, v8hi, hi, p16,
+		 int16x8_t)
+__ST3_LANE_FUNC (int8x8x3_t, int8x16x3_t, int8_t, v8qi, v16qi, qi, s8,
+		 int8x16_t)
+__ST3_LANE_FUNC (int16x4x3_t, int16x8x3_t, int16_t, v4hi, v8hi, hi, s16,
 		 int16x8_t)
-__ST3_LANE_FUNC (int8x8x3_t, int8x16x3_t, int8_t, v16qi, qi, s8, int8x16_t)
-__ST3_LANE_FUNC (int16x4x3_t, int16x8x3_t, int16_t, v8hi, hi, s16, int16x8_t)
-__ST3_LANE_FUNC (int32x2x3_t, int32x4x3_t, int32_t, v4si, si, s32, int32x4_t)
-__ST3_LANE_FUNC (int64x1x3_t, int64x2x3_t, int64_t, v2di, di, s64, int64x2_t)
-__ST3_LANE_FUNC (uint8x8x3_t, uint8x16x3_t, uint8_t, v16qi, qi, u8, int8x16_t)
-__ST3_LANE_FUNC (uint16x4x3_t, uint16x8x3_t, uint16_t, v8hi, hi, u16,
+__ST3_LANE_FUNC (int32x2x3_t, int32x4x3_t, int32_t, v2si, v4si, si, s32,
+		 int32x4_t)
+__ST3_LANE_FUNC (int64x1x3_t, int64x2x3_t, int64_t, di, v2di, di, s64,
+		 int64x2_t)
+__ST3_LANE_FUNC (uint8x8x3_t, uint8x16x3_t, uint8_t, v8qi, v16qi, qi, u8,
+		 int8x16_t)
+__ST3_LANE_FUNC (uint16x4x3_t, uint16x8x3_t, uint16_t, v4hi, v8hi, hi, u16,
 		 int16x8_t)
-__ST3_LANE_FUNC (uint32x2x3_t, uint32x4x3_t, uint32_t, v4si, si, u32,
+__ST3_LANE_FUNC (uint32x2x3_t, uint32x4x3_t, uint32_t, v2si, v4si, si, u32,
 		 int32x4_t)
-__ST3_LANE_FUNC (uint64x1x3_t, uint64x2x3_t, uint64_t, v2di, di, u64,
+__ST3_LANE_FUNC (uint64x1x3_t, uint64x2x3_t, uint64_t, di, v2di, di, u64,
 		 int64x2_t)
 
 #undef __ST3_LANE_FUNC
@@ -10346,6 +10457,7 @@ vst3q_lane_ ## funcsuffix (ptrtype *__ptr,				    \
 				    __ptr, __temp.__o, __c);		    \
 }
 
+__ST3_LANE_FUNC (float16x8x3_t, float16_t, v8hf, hf, f16)
 __ST3_LANE_FUNC (float32x4x3_t, float32_t, v4sf, sf, f32)
 __ST3_LANE_FUNC (float64x2x3_t, float64_t, v2df, df, f64)
 __ST3_LANE_FUNC (poly8x16x3_t, poly8_t, v16qi, qi, p8)
@@ -10359,8 +10471,8 @@ __ST3_LANE_FUNC (uint16x8x3_t, uint16_t, v8hi, hi, u16)
 __ST3_LANE_FUNC (uint32x4x3_t, uint32_t, v4si, si, u32)
 __ST3_LANE_FUNC (uint64x2x3_t, uint64_t, v2di, di, u64)
 
-#define __ST4_LANE_FUNC(intype, largetype, ptrtype,			     \
-			mode, ptr_mode, funcsuffix, signedtype)		     \
+#define __ST4_LANE_FUNC(intype, largetype, ptrtype, mode,		     \
+			qmode, ptr_mode, funcsuffix, signedtype)	     \
 __extension__ static __inline void					     \
 __attribute__ ((__always_inline__))					     \
 vst4_lane_ ## funcsuffix (ptrtype *__ptr,				     \
@@ -10380,35 +10492,43 @@ vst4_lane_ ## funcsuffix (ptrtype *__ptr,				     \
   __temp.val[3]								     \
     = vcombine_##funcsuffix (__b.val[3],				     \
 			     vcreate_##funcsuffix (__AARCH64_UINT64_C (0))); \
-  __o = __builtin_aarch64_set_qregxi##mode (__o,			     \
-					    (signedtype) __temp.val[0], 0);  \
-  __o = __builtin_aarch64_set_qregxi##mode (__o,			     \
-					    (signedtype) __temp.val[1], 1);  \
-  __o = __builtin_aarch64_set_qregxi##mode (__o,			     \
-					    (signedtype) __temp.val[2], 2);  \
-  __o = __builtin_aarch64_set_qregxi##mode (__o,			     \
-					    (signedtype) __temp.val[3], 3);  \
+  __o = __builtin_aarch64_set_qregxi##qmode (__o,			     \
+					     (signedtype) __temp.val[0], 0); \
+  __o = __builtin_aarch64_set_qregxi##qmode (__o,			     \
+					     (signedtype) __temp.val[1], 1); \
+  __o = __builtin_aarch64_set_qregxi##qmode (__o,			     \
+					     (signedtype) __temp.val[2], 2); \
+  __o = __builtin_aarch64_set_qregxi##qmode (__o,			     \
+					     (signedtype) __temp.val[3], 3); \
   __builtin_aarch64_st4_lane##mode ((__builtin_aarch64_simd_ ## ptr_mode *)  \
 				     __ptr, __o, __c);			     \
 }
 
-__ST4_LANE_FUNC (float32x2x4_t, float32x4x4_t, float32_t, v4sf, sf, f32,
+__ST4_LANE_FUNC (float16x4x4_t, float16x8x4_t, float16_t, v4hf, v8hf, hf, f16,
+		 float16x8_t)
+__ST4_LANE_FUNC (float32x2x4_t, float32x4x4_t, float32_t, v2sf, v4sf, sf, f32,
 		 float32x4_t)
-__ST4_LANE_FUNC (float64x1x4_t, float64x2x4_t, float64_t, v2df, df, f64,
+__ST4_LANE_FUNC (float64x1x4_t, float64x2x4_t, float64_t, df, v2df, df, f64,
 		 float64x2_t)
-__ST4_LANE_FUNC (poly8x8x4_t, poly8x16x4_t, poly8_t, v16qi, qi, p8, int8x16_t)
-__ST4_LANE_FUNC (poly16x4x4_t, poly16x8x4_t, poly16_t, v8hi, hi, p16,
+__ST4_LANE_FUNC (poly8x8x4_t, poly8x16x4_t, poly8_t, v8qi, v16qi, qi, p8,
+		 int8x16_t)
+__ST4_LANE_FUNC (poly16x4x4_t, poly16x8x4_t, poly16_t, v4hi, v8hi, hi, p16,
 		 int16x8_t)
-__ST4_LANE_FUNC (int8x8x4_t, int8x16x4_t, int8_t, v16qi, qi, s8, int8x16_t)
-__ST4_LANE_FUNC (int16x4x4_t, int16x8x4_t, int16_t, v8hi, hi, s16, int16x8_t)
-__ST4_LANE_FUNC (int32x2x4_t, int32x4x4_t, int32_t, v4si, si, s32, int32x4_t)
-__ST4_LANE_FUNC (int64x1x4_t, int64x2x4_t, int64_t, v2di, di, s64, int64x2_t)
-__ST4_LANE_FUNC (uint8x8x4_t, uint8x16x4_t, uint8_t, v16qi, qi, u8, int8x16_t)
-__ST4_LANE_FUNC (uint16x4x4_t, uint16x8x4_t, uint16_t, v8hi, hi, u16,
+__ST4_LANE_FUNC (int8x8x4_t, int8x16x4_t, int8_t, v8qi, v16qi, qi, s8,
+		 int8x16_t)
+__ST4_LANE_FUNC (int16x4x4_t, int16x8x4_t, int16_t, v4hi, v8hi, hi, s16,
 		 int16x8_t)
-__ST4_LANE_FUNC (uint32x2x4_t, uint32x4x4_t, uint32_t, v4si, si, u32,
+__ST4_LANE_FUNC (int32x2x4_t, int32x4x4_t, int32_t, v2si, v4si, si, s32,
 		 int32x4_t)
-__ST4_LANE_FUNC (uint64x1x4_t, uint64x2x4_t, uint64_t, v2di, di, u64,
+__ST4_LANE_FUNC (int64x1x4_t, int64x2x4_t, int64_t, di, v2di, di, s64,
+		 int64x2_t)
+__ST4_LANE_FUNC (uint8x8x4_t, uint8x16x4_t, uint8_t, v8qi, v16qi, qi, u8,
+		 int8x16_t)
+__ST4_LANE_FUNC (uint16x4x4_t, uint16x8x4_t, uint16_t, v4hi, v8hi, hi, u16,
+		 int16x8_t)
+__ST4_LANE_FUNC (uint32x2x4_t, uint32x4x4_t, uint32_t, v2si, v4si, si, u32,
+		 int32x4_t)
+__ST4_LANE_FUNC (uint64x1x4_t, uint64x2x4_t, uint64_t, di, v2di, di, u64,
 		 int64x2_t)
 
 #undef __ST4_LANE_FUNC
@@ -10424,6 +10544,7 @@ vst4q_lane_ ## funcsuffix (ptrtype *__ptr,				    \
 				    __ptr, __temp.__o, __c);		    \
 }
 
+__ST4_LANE_FUNC (float16x8x4_t, float16_t, v8hf, hf, f16)
 __ST4_LANE_FUNC (float32x4x4_t, float32_t, v4sf, sf, f32)
 __ST4_LANE_FUNC (float64x2x4_t, float64_t, v2df, df, f64)
 __ST4_LANE_FUNC (poly8x16x4_t, poly8_t, v16qi, qi, p8)
@@ -11153,13 +11274,14 @@ vtbl3_s8 (int8x8x3_t tab, int8x8_t idx)
 {
   int8x8_t result;
   int8x16x2_t temp;
+  __builtin_aarch64_simd_oi __o;
   temp.val[0] = vcombine_s8 (tab.val[0], tab.val[1]);
   temp.val[1] = vcombine_s8 (tab.val[2], vcreate_s8 (__AARCH64_UINT64_C (0x0)));
-  __asm__ ("ld1 {v16.16b - v17.16b }, %1\n\t"
-	   "tbl %0.8b, {v16.16b - v17.16b}, %2.8b\n\t"
-           : "=w"(result)
-           : "Q"(temp), "w"(idx)
-           : "v16", "v17", "memory");
+  __o = __builtin_aarch64_set_qregoiv16qi (__o,
+					   (int8x16_t) temp.val[0], 0);
+  __o = __builtin_aarch64_set_qregoiv16qi (__o,
+					   (int8x16_t) temp.val[1], 1);
+  result = __builtin_aarch64_tbl3v8qi (__o, idx);
   return result;
 }
 
@@ -11168,13 +11290,14 @@ vtbl3_u8 (uint8x8x3_t tab, uint8x8_t idx)
 {
   uint8x8_t result;
   uint8x16x2_t temp;
+  __builtin_aarch64_simd_oi __o;
   temp.val[0] = vcombine_u8 (tab.val[0], tab.val[1]);
   temp.val[1] = vcombine_u8 (tab.val[2], vcreate_u8 (__AARCH64_UINT64_C (0x0)));
-  __asm__ ("ld1 {v16.16b - v17.16b }, %1\n\t"
-	   "tbl %0.8b, {v16.16b - v17.16b}, %2.8b\n\t"
-           : "=w"(result)
-           : "Q"(temp), "w"(idx)
-           : "v16", "v17", "memory");
+  __o = __builtin_aarch64_set_qregoiv16qi (__o,
+					   (int8x16_t) temp.val[0], 0);
+  __o = __builtin_aarch64_set_qregoiv16qi (__o,
+					   (int8x16_t) temp.val[1], 1);
+  result = (uint8x8_t)__builtin_aarch64_tbl3v8qi (__o, (int8x8_t)idx);
   return result;
 }
 
@@ -11183,13 +11306,14 @@ vtbl3_p8 (poly8x8x3_t tab, uint8x8_t idx)
 {
   poly8x8_t result;
   poly8x16x2_t temp;
+  __builtin_aarch64_simd_oi __o;
   temp.val[0] = vcombine_p8 (tab.val[0], tab.val[1]);
   temp.val[1] = vcombine_p8 (tab.val[2], vcreate_p8 (__AARCH64_UINT64_C (0x0)));
-  __asm__ ("ld1 {v16.16b - v17.16b }, %1\n\t"
-	   "tbl %0.8b, {v16.16b - v17.16b}, %2.8b\n\t"
-           : "=w"(result)
-           : "Q"(temp), "w"(idx)
-           : "v16", "v17", "memory");
+  __o = __builtin_aarch64_set_qregoiv16qi (__o,
+					   (int8x16_t) temp.val[0], 0);
+  __o = __builtin_aarch64_set_qregoiv16qi (__o,
+					   (int8x16_t) temp.val[1], 1);
+  result = (poly8x8_t)__builtin_aarch64_tbl3v8qi (__o, (int8x8_t)idx);
   return result;
 }
 
@@ -11198,13 +11322,14 @@ vtbl4_s8 (int8x8x4_t tab, int8x8_t idx)
 {
   int8x8_t result;
   int8x16x2_t temp;
+  __builtin_aarch64_simd_oi __o;
   temp.val[0] = vcombine_s8 (tab.val[0], tab.val[1]);
   temp.val[1] = vcombine_s8 (tab.val[2], tab.val[3]);
-  __asm__ ("ld1 {v16.16b - v17.16b }, %1\n\t"
-	   "tbl %0.8b, {v16.16b - v17.16b}, %2.8b\n\t"
-           : "=w"(result)
-           : "Q"(temp), "w"(idx)
-           : "v16", "v17", "memory");
+  __o = __builtin_aarch64_set_qregoiv16qi (__o,
+					   (int8x16_t) temp.val[0], 0);
+  __o = __builtin_aarch64_set_qregoiv16qi (__o,
+					   (int8x16_t) temp.val[1], 1);
+  result = __builtin_aarch64_tbl3v8qi (__o, idx);
   return result;
 }
 
@@ -11213,13 +11338,14 @@ vtbl4_u8 (uint8x8x4_t tab, uint8x8_t idx)
 {
   uint8x8_t result;
   uint8x16x2_t temp;
+  __builtin_aarch64_simd_oi __o;
   temp.val[0] = vcombine_u8 (tab.val[0], tab.val[1]);
   temp.val[1] = vcombine_u8 (tab.val[2], tab.val[3]);
-  __asm__ ("ld1 {v16.16b - v17.16b }, %1\n\t"
-	   "tbl %0.8b, {v16.16b - v17.16b}, %2.8b\n\t"
-           : "=w"(result)
-           : "Q"(temp), "w"(idx)
-           : "v16", "v17", "memory");
+  __o = __builtin_aarch64_set_qregoiv16qi (__o,
+					   (int8x16_t) temp.val[0], 0);
+  __o = __builtin_aarch64_set_qregoiv16qi (__o,
+					   (int8x16_t) temp.val[1], 1);
+  result = (uint8x8_t)__builtin_aarch64_tbl3v8qi (__o, (int8x8_t)idx);
   return result;
 }
 
@@ -11228,13 +11354,14 @@ vtbl4_p8 (poly8x8x4_t tab, uint8x8_t idx)
 {
   poly8x8_t result;
   poly8x16x2_t temp;
+  __builtin_aarch64_simd_oi __o;
   temp.val[0] = vcombine_p8 (tab.val[0], tab.val[1]);
   temp.val[1] = vcombine_p8 (tab.val[2], tab.val[3]);
-  __asm__ ("ld1 {v16.16b - v17.16b }, %1\n\t"
-	   "tbl %0.8b, {v16.16b - v17.16b}, %2.8b\n\t"
-           : "=w"(result)
-           : "Q"(temp), "w"(idx)
-           : "v16", "v17", "memory");
+  __o = __builtin_aarch64_set_qregoiv16qi (__o,
+					   (int8x16_t) temp.val[0], 0);
+  __o = __builtin_aarch64_set_qregoiv16qi (__o,
+					   (int8x16_t) temp.val[1], 1);
+  result = (poly8x8_t)__builtin_aarch64_tbl3v8qi (__o, (int8x8_t)idx);
   return result;
 }
 
@@ -11274,51 +11401,6 @@ vtbx2_p8 (poly8x8_t r, poly8x8x2_t tab, uint8x8_t idx)
   return result;
 }
 
-__extension__ static __inline int8x8_t __attribute__ ((__always_inline__))
-vtbx4_s8 (int8x8_t r, int8x8x4_t tab, int8x8_t idx)
-{
-  int8x8_t result = r;
-  int8x16x2_t temp;
-  temp.val[0] = vcombine_s8 (tab.val[0], tab.val[1]);
-  temp.val[1] = vcombine_s8 (tab.val[2], tab.val[3]);
-  __asm__ ("ld1 {v16.16b - v17.16b }, %1\n\t"
-	   "tbx %0.8b, {v16.16b - v17.16b}, %2.8b\n\t"
-           : "+w"(result)
-           : "Q"(temp), "w"(idx)
-           : "v16", "v17", "memory");
-  return result;
-}
-
-__extension__ static __inline uint8x8_t __attribute__ ((__always_inline__))
-vtbx4_u8 (uint8x8_t r, uint8x8x4_t tab, uint8x8_t idx)
-{
-  uint8x8_t result = r;
-  uint8x16x2_t temp;
-  temp.val[0] = vcombine_u8 (tab.val[0], tab.val[1]);
-  temp.val[1] = vcombine_u8 (tab.val[2], tab.val[3]);
-  __asm__ ("ld1 {v16.16b - v17.16b }, %1\n\t"
-	   "tbx %0.8b, {v16.16b - v17.16b}, %2.8b\n\t"
-           : "+w"(result)
-           : "Q"(temp), "w"(idx)
-           : "v16", "v17", "memory");
-  return result;
-}
-
-__extension__ static __inline poly8x8_t __attribute__ ((__always_inline__))
-vtbx4_p8 (poly8x8_t r, poly8x8x4_t tab, uint8x8_t idx)
-{
-  poly8x8_t result = r;
-  poly8x16x2_t temp;
-  temp.val[0] = vcombine_p8 (tab.val[0], tab.val[1]);
-  temp.val[1] = vcombine_p8 (tab.val[2], tab.val[3]);
-  __asm__ ("ld1 {v16.16b - v17.16b }, %1\n\t"
-	   "tbx %0.8b, {v16.16b - v17.16b}, %2.8b\n\t"
-           : "+w"(result)
-           : "Q"(temp), "w"(idx)
-           : "v16", "v17", "memory");
-  return result;
-}
-
 /* End of temporary inline asm.  */
 
 /* Start of optimal implementations in approved order.  */
@@ -11664,35 +11746,34 @@ vbslq_u64 (uint64x2_t __a, uint64x2_t __b, uint64x2_t __c)
   return __builtin_aarch64_simd_bslv2di_uuuu (__a, __b, __c);
 }
 
-#ifdef __ARM_FEATURE_CRYPTO
-
+#pragma GCC push_options
+#pragma GCC target ("+nothing+crypto")
 /* vaes  */
 
-static __inline uint8x16_t
+__extension__ static __inline uint8x16_t __attribute__ ((__always_inline__))
 vaeseq_u8 (uint8x16_t data, uint8x16_t key)
 {
   return __builtin_aarch64_crypto_aesev16qi_uuu (data, key);
 }
 
-static __inline uint8x16_t
+__extension__ static __inline uint8x16_t __attribute__ ((__always_inline__))
 vaesdq_u8 (uint8x16_t data, uint8x16_t key)
 {
   return __builtin_aarch64_crypto_aesdv16qi_uuu (data, key);
 }
 
-static __inline uint8x16_t
+__extension__ static __inline uint8x16_t __attribute__ ((__always_inline__))
 vaesmcq_u8 (uint8x16_t data)
 {
   return __builtin_aarch64_crypto_aesmcv16qi_uu (data);
 }
 
-static __inline uint8x16_t
+__extension__ static __inline uint8x16_t __attribute__ ((__always_inline__))
 vaesimcq_u8 (uint8x16_t data)
 {
   return __builtin_aarch64_crypto_aesimcv16qi_uu (data);
 }
-
-#endif
+#pragma GCC pop_options
 
 /* vcage  */
 
@@ -11887,7 +11968,7 @@ vceq_s32 (int32x2_t __a, int32x2_t __b)
 __extension__ static __inline uint64x1_t __attribute__ ((__always_inline__))
 vceq_s64 (int64x1_t __a, int64x1_t __b)
 {
-  return (uint64x1_t) {__a[0] == __b[0] ? -1ll : 0ll};
+  return (uint64x1_t) (__a == __b);
 }
 
 __extension__ static __inline uint8x8_t __attribute__ ((__always_inline__))
@@ -11911,7 +11992,7 @@ vceq_u32 (uint32x2_t __a, uint32x2_t __b)
 __extension__ static __inline uint64x1_t __attribute__ ((__always_inline__))
 vceq_u64 (uint64x1_t __a, uint64x1_t __b)
 {
-  return (uint64x1_t) {__a[0] == __b[0] ? -1ll : 0ll};
+  return (__a == __b);
 }
 
 __extension__ static __inline uint32x4_t __attribute__ ((__always_inline__))
@@ -12047,7 +12128,7 @@ vceqz_s32 (int32x2_t __a)
 __extension__ static __inline uint64x1_t __attribute__ ((__always_inline__))
 vceqz_s64 (int64x1_t __a)
 {
-  return (uint64x1_t) {__a[0] == 0ll ? -1ll : 0ll};
+  return (uint64x1_t) (__a == __AARCH64_INT64_C (0));
 }
 
 __extension__ static __inline uint8x8_t __attribute__ ((__always_inline__))
@@ -12071,7 +12152,7 @@ vceqz_u32 (uint32x2_t __a)
 __extension__ static __inline uint64x1_t __attribute__ ((__always_inline__))
 vceqz_u64 (uint64x1_t __a)
 {
-  return (uint64x1_t) {__a[0] == 0ll ? -1ll : 0ll};
+  return (__a == __AARCH64_UINT64_C (0));
 }
 
 __extension__ static __inline uint32x4_t __attribute__ ((__always_inline__))
@@ -12201,7 +12282,7 @@ vcge_s32 (int32x2_t __a, int32x2_t __b)
 __extension__ static __inline uint64x1_t __attribute__ ((__always_inline__))
 vcge_s64 (int64x1_t __a, int64x1_t __b)
 {
-  return (uint64x1_t) {__a[0] >= __b[0] ? -1ll : 0ll};
+  return (uint64x1_t) (__a >= __b);
 }
 
 __extension__ static __inline uint8x8_t __attribute__ ((__always_inline__))
@@ -12225,7 +12306,7 @@ vcge_u32 (uint32x2_t __a, uint32x2_t __b)
 __extension__ static __inline uint64x1_t __attribute__ ((__always_inline__))
 vcge_u64 (uint64x1_t __a, uint64x1_t __b)
 {
-  return (uint64x1_t) {__a[0] >= __b[0] ? -1ll : 0ll};
+  return (__a >= __b);
 }
 
 __extension__ static __inline uint32x4_t __attribute__ ((__always_inline__))
@@ -12349,7 +12430,7 @@ vcgez_s32 (int32x2_t __a)
 __extension__ static __inline uint64x1_t __attribute__ ((__always_inline__))
 vcgez_s64 (int64x1_t __a)
 {
-  return (uint64x1_t) {__a[0] >= 0ll ? -1ll : 0ll};
+  return (uint64x1_t) (__a >= __AARCH64_INT64_C (0));
 }
 
 __extension__ static __inline uint32x4_t __attribute__ ((__always_inline__))
@@ -12443,7 +12524,7 @@ vcgt_s32 (int32x2_t __a, int32x2_t __b)
 __extension__ static __inline uint64x1_t __attribute__ ((__always_inline__))
 vcgt_s64 (int64x1_t __a, int64x1_t __b)
 {
-  return (uint64x1_t) (__a[0] > __b[0] ? -1ll : 0ll);
+  return (uint64x1_t) (__a > __b);
 }
 
 __extension__ static __inline uint8x8_t __attribute__ ((__always_inline__))
@@ -12467,7 +12548,7 @@ vcgt_u32 (uint32x2_t __a, uint32x2_t __b)
 __extension__ static __inline uint64x1_t __attribute__ ((__always_inline__))
 vcgt_u64 (uint64x1_t __a, uint64x1_t __b)
 {
-  return (uint64x1_t) (__a[0] > __b[0] ? -1ll : 0ll);
+  return (__a > __b);
 }
 
 __extension__ static __inline uint32x4_t __attribute__ ((__always_inline__))
@@ -12591,7 +12672,7 @@ vcgtz_s32 (int32x2_t __a)
 __extension__ static __inline uint64x1_t __attribute__ ((__always_inline__))
 vcgtz_s64 (int64x1_t __a)
 {
-  return (uint64x1_t) {__a[0] > 0ll ? -1ll : 0ll};
+  return (uint64x1_t) (__a > __AARCH64_INT64_C (0));
 }
 
 __extension__ static __inline uint32x4_t __attribute__ ((__always_inline__))
@@ -12685,7 +12766,7 @@ vcle_s32 (int32x2_t __a, int32x2_t __b)
 __extension__ static __inline uint64x1_t __attribute__ ((__always_inline__))
 vcle_s64 (int64x1_t __a, int64x1_t __b)
 {
-  return (uint64x1_t) {__a[0] <= __b[0] ? -1ll : 0ll};
+  return (uint64x1_t) (__a <= __b);
 }
 
 __extension__ static __inline uint8x8_t __attribute__ ((__always_inline__))
@@ -12709,7 +12790,7 @@ vcle_u32 (uint32x2_t __a, uint32x2_t __b)
 __extension__ static __inline uint64x1_t __attribute__ ((__always_inline__))
 vcle_u64 (uint64x1_t __a, uint64x1_t __b)
 {
-  return (uint64x1_t) {__a[0] <= __b[0] ? -1ll : 0ll};
+  return (__a <= __b);
 }
 
 __extension__ static __inline uint32x4_t __attribute__ ((__always_inline__))
@@ -12833,7 +12914,7 @@ vclez_s32 (int32x2_t __a)
 __extension__ static __inline uint64x1_t __attribute__ ((__always_inline__))
 vclez_s64 (int64x1_t __a)
 {
-  return (uint64x1_t) {__a[0] <= 0ll ? -1ll : 0ll};
+  return (uint64x1_t) (__a <= __AARCH64_INT64_C (0));
 }
 
 __extension__ static __inline uint32x4_t __attribute__ ((__always_inline__))
@@ -12927,7 +13008,7 @@ vclt_s32 (int32x2_t __a, int32x2_t __b)
 __extension__ static __inline uint64x1_t __attribute__ ((__always_inline__))
 vclt_s64 (int64x1_t __a, int64x1_t __b)
 {
-  return (uint64x1_t) {__a[0] < __b[0] ? -1ll : 0ll};
+  return (uint64x1_t) (__a < __b);
 }
 
 __extension__ static __inline uint8x8_t __attribute__ ((__always_inline__))
@@ -12951,7 +13032,7 @@ vclt_u32 (uint32x2_t __a, uint32x2_t __b)
 __extension__ static __inline uint64x1_t __attribute__ ((__always_inline__))
 vclt_u64 (uint64x1_t __a, uint64x1_t __b)
 {
-  return (uint64x1_t) {__a[0] < __b[0] ? -1ll : 0ll};
+  return (__a < __b);
 }
 
 __extension__ static __inline uint32x4_t __attribute__ ((__always_inline__))
@@ -13075,7 +13156,7 @@ vcltz_s32 (int32x2_t __a)
 __extension__ static __inline uint64x1_t __attribute__ ((__always_inline__))
 vcltz_s64 (int64x1_t __a)
 {
-  return (uint64x1_t) {__a[0] < 0ll ? -1ll : 0ll};
+  return (uint64x1_t) (__a < __AARCH64_INT64_C (0));
 }
 
 __extension__ static __inline uint32x4_t __attribute__ ((__always_inline__))
@@ -13286,6 +13367,18 @@ vcntq_u8 (uint8x16_t __a)
 
 /* vcvt (double -> float).  */
 
+__extension__ static __inline float16x4_t __attribute__ ((__always_inline__))
+vcvt_f16_f32 (float32x4_t __a)
+{
+  return __builtin_aarch64_float_truncate_lo_v4hf (__a);
+}
+
+__extension__ static __inline float16x8_t __attribute__ ((__always_inline__))
+vcvt_high_f16_f32 (float16x4_t __a, float32x4_t __b)
+{
+  return __builtin_aarch64_float_truncate_hi_v8hf (__a, __b);
+}
+
 __extension__ static __inline float32x2_t __attribute__ ((__always_inline__))
 vcvt_f32_f64 (float64x2_t __a)
 {
@@ -13300,6 +13393,12 @@ vcvt_high_f32_f64 (float32x2_t __a, float64x2_t __b)
 
 /* vcvt (float -> double).  */
 
+__extension__ static __inline float32x4_t __attribute__ ((__always_inline__))
+vcvt_f32_f16 (float16x4_t __a)
+{
+  return __builtin_aarch64_float_extend_lo_v4sf (__a);
+}
+
 __extension__ static __inline float64x2_t __attribute__ ((__always_inline__))
 vcvt_f64_f32 (float32x2_t __a)
 {
@@ -13307,6 +13406,12 @@ vcvt_f64_f32 (float32x2_t __a)
   return __builtin_aarch64_float_extend_lo_v2df (__a);
 }
 
+__extension__ static __inline float32x4_t __attribute__ ((__always_inline__))
+vcvt_high_f32_f16 (float16x8_t __a)
+{
+  return __builtin_aarch64_vec_unpacks_hi_v8hf (__a);
+}
+
 __extension__ static __inline float64x2_t __attribute__ ((__always_inline__))
 vcvt_high_f64_f32 (float32x4_t __a)
 {
@@ -14880,6 +14985,12 @@ vfmsq_laneq_f64 (float64x2_t __a, float64x2_t __b,
 
 /* vld1 */
 
+__extension__ static __inline float16x4_t __attribute__ ((__always_inline__))
+vld1_f16 (const float16_t *__a)
+{
+  return __builtin_aarch64_ld1v4hf (__a);
+}
+
 __extension__ static __inline float32x2_t __attribute__ ((__always_inline__))
 vld1_f32 (const float32_t *a)
 {
@@ -14959,6 +15070,12 @@ vld1_u64 (const uint64_t *a)
 
 /* vld1q */
 
+__extension__ static __inline float16x8_t __attribute__ ((__always_inline__))
+vld1q_f16 (const float16_t *__a)
+{
+  return __builtin_aarch64_ld1v8hf (__a);
+}
+
 __extension__ static __inline float32x4_t __attribute__ ((__always_inline__))
 vld1q_f32 (const float32_t *a)
 {
@@ -15039,6 +15156,13 @@ vld1q_u64 (const uint64_t *a)
 
 /* vld1_dup  */
 
+__extension__ static __inline float16x4_t __attribute__ ((__always_inline__))
+vld1_dup_f16 (const float16_t* __a)
+{
+  float16_t __f = *__a;
+  return (float16x4_t) { __f, __f, __f, __f };
+}
+
 __extension__ static __inline float32x2_t __attribute__ ((__always_inline__))
 vld1_dup_f32 (const float32_t* __a)
 {
@@ -15113,6 +15237,13 @@ vld1_dup_u64 (const uint64_t* __a)
 
 /* vld1q_dup  */
 
+__extension__ static __inline float16x8_t __attribute__ ((__always_inline__))
+vld1q_dup_f16 (const float16_t* __a)
+{
+  float16_t __f = *__a;
+  return (float16x8_t) { __f, __f, __f, __f, __f, __f, __f, __f };
+}
+
 __extension__ static __inline float32x4_t __attribute__ ((__always_inline__))
 vld1q_dup_f32 (const float32_t* __a)
 {
@@ -15187,6 +15318,12 @@ vld1q_dup_u64 (const uint64_t* __a)
 
 /* vld1_lane  */
 
+__extension__ static __inline float16x4_t __attribute__ ((__always_inline__))
+vld1_lane_f16 (const float16_t *__src, float16x4_t __vec, const int __lane)
+{
+  return __aarch64_vset_lane_any (*__src, __vec, __lane);
+}
+
 __extension__ static __inline float32x2_t __attribute__ ((__always_inline__))
 vld1_lane_f32 (const float32_t *__src, float32x2_t __vec, const int __lane)
 {
@@ -15261,6 +15398,12 @@ vld1_lane_u64 (const uint64_t *__src, uint64x1_t __vec, const int __lane)
 
 /* vld1q_lane  */
 
+__extension__ static __inline float16x8_t __attribute__ ((__always_inline__))
+vld1q_lane_f16 (const float16_t *__src, float16x8_t __vec, const int __lane)
+{
+  return __aarch64_vset_lane_any (*__src, __vec, __lane);
+}
+
 __extension__ static __inline float32x4_t __attribute__ ((__always_inline__))
 vld1q_lane_f32 (const float32_t *__src, float32x4_t __vec, const int __lane)
 {
@@ -15456,6 +15599,17 @@ vld2_u32 (const uint32_t * __a)
   return ret;
 }
 
+__extension__ static __inline float16x4x2_t __attribute__ ((__always_inline__))
+vld2_f16 (const float16_t * __a)
+{
+  float16x4x2_t ret;
+  __builtin_aarch64_simd_oi __o;
+  __o = __builtin_aarch64_ld2v4hf (__a);
+  ret.val[0] = __builtin_aarch64_get_dregoiv4hf (__o, 0);
+  ret.val[1] = __builtin_aarch64_get_dregoiv4hf (__o, 1);
+  return ret;
+}
+
 __extension__ static __inline float32x2x2_t __attribute__ ((__always_inline__))
 vld2_f32 (const float32_t * __a)
 {
@@ -15577,6 +15731,17 @@ vld2q_u64 (const uint64_t * __a)
   return ret;
 }
 
+__extension__ static __inline float16x8x2_t __attribute__ ((__always_inline__))
+vld2q_f16 (const float16_t * __a)
+{
+  float16x8x2_t ret;
+  __builtin_aarch64_simd_oi __o;
+  __o = __builtin_aarch64_ld2v8hf (__a);
+  ret.val[0] = __builtin_aarch64_get_qregoiv8hf (__o, 0);
+  ret.val[1] = __builtin_aarch64_get_qregoiv8hf (__o, 1);
+  return ret;
+}
+
 __extension__ static __inline float32x4x2_t __attribute__ ((__always_inline__))
 vld2q_f32 (const float32_t * __a)
 {
@@ -15731,6 +15896,18 @@ vld3_u32 (const uint32_t * __a)
   return ret;
 }
 
+__extension__ static __inline float16x4x3_t __attribute__ ((__always_inline__))
+vld3_f16 (const float16_t * __a)
+{
+  float16x4x3_t ret;
+  __builtin_aarch64_simd_ci __o;
+  __o = __builtin_aarch64_ld3v4hf (__a);
+  ret.val[0] = __builtin_aarch64_get_dregciv4hf (__o, 0);
+  ret.val[1] = __builtin_aarch64_get_dregciv4hf (__o, 1);
+  ret.val[2] = __builtin_aarch64_get_dregciv4hf (__o, 2);
+  return ret;
+}
+
 __extension__ static __inline float32x2x3_t __attribute__ ((__always_inline__))
 vld3_f32 (const float32_t * __a)
 {
@@ -15863,6 +16040,18 @@ vld3q_u64 (const uint64_t * __a)
   return ret;
 }
 
+__extension__ static __inline float16x8x3_t __attribute__ ((__always_inline__))
+vld3q_f16 (const float16_t * __a)
+{
+  float16x8x3_t ret;
+  __builtin_aarch64_simd_ci __o;
+  __o = __builtin_aarch64_ld3v8hf (__a);
+  ret.val[0] = __builtin_aarch64_get_qregciv8hf (__o, 0);
+  ret.val[1] = __builtin_aarch64_get_qregciv8hf (__o, 1);
+  ret.val[2] = __builtin_aarch64_get_qregciv8hf (__o, 2);
+  return ret;
+}
+
 __extension__ static __inline float32x4x3_t __attribute__ ((__always_inline__))
 vld3q_f32 (const float32_t * __a)
 {
@@ -16030,6 +16219,19 @@ vld4_u32 (const uint32_t * __a)
   return ret;
 }
 
+__extension__ static __inline float16x4x4_t __attribute__ ((__always_inline__))
+vld4_f16 (const float16_t * __a)
+{
+  float16x4x4_t ret;
+  __builtin_aarch64_simd_xi __o;
+  __o = __builtin_aarch64_ld4v4hf (__a);
+  ret.val[0] = __builtin_aarch64_get_dregxiv4hf (__o, 0);
+  ret.val[1] = __builtin_aarch64_get_dregxiv4hf (__o, 1);
+  ret.val[2] = __builtin_aarch64_get_dregxiv4hf (__o, 2);
+  ret.val[3] = __builtin_aarch64_get_dregxiv4hf (__o, 3);
+  return ret;
+}
+
 __extension__ static __inline float32x2x4_t __attribute__ ((__always_inline__))
 vld4_f32 (const float32_t * __a)
 {
@@ -16173,6 +16375,19 @@ vld4q_u64 (const uint64_t * __a)
   return ret;
 }
 
+__extension__ static __inline float16x8x4_t __attribute__ ((__always_inline__))
+vld4q_f16 (const float16_t * __a)
+{
+  float16x8x4_t ret;
+  __builtin_aarch64_simd_xi __o;
+  __o = __builtin_aarch64_ld4v8hf (__a);
+  ret.val[0] = __builtin_aarch64_get_qregxiv8hf (__o, 0);
+  ret.val[1] = __builtin_aarch64_get_qregxiv8hf (__o, 1);
+  ret.val[2] = __builtin_aarch64_get_qregxiv8hf (__o, 2);
+  ret.val[3] = __builtin_aarch64_get_qregxiv8hf (__o, 3);
+  return ret;
+}
+
 __extension__ static __inline float32x4x4_t __attribute__ ((__always_inline__))
 vld4q_f32 (const float32_t * __a)
 {
@@ -16234,6 +16449,17 @@ vld2_dup_s32 (const int32_t * __a)
   return ret;
 }
 
+__extension__ static __inline float16x4x2_t __attribute__ ((__always_inline__))
+vld2_dup_f16 (const float16_t * __a)
+{
+  float16x4x2_t ret;
+  __builtin_aarch64_simd_oi __o;
+  __o = __builtin_aarch64_ld2rv4hf ((const __builtin_aarch64_simd_hf *) __a);
+  ret.val[0] = __builtin_aarch64_get_dregoiv4hf (__o, 0);
+  ret.val[1] = (float16x4_t) __builtin_aarch64_get_dregoiv4hf (__o, 1);
+  return ret;
+}
+
 __extension__ static __inline float32x2x2_t __attribute__ ((__always_inline__))
 vld2_dup_f32 (const float32_t * __a)
 {
@@ -16443,6 +16669,17 @@ vld2q_dup_u64 (const uint64_t * __a)
   return ret;
 }
 
+__extension__ static __inline float16x8x2_t __attribute__ ((__always_inline__))
+vld2q_dup_f16 (const float16_t * __a)
+{
+  float16x8x2_t ret;
+  __builtin_aarch64_simd_oi __o;
+  __o = __builtin_aarch64_ld2rv8hf ((const __builtin_aarch64_simd_hf *) __a);
+  ret.val[0] = (float16x8_t) __builtin_aarch64_get_qregoiv8hf (__o, 0);
+  ret.val[1] = __builtin_aarch64_get_qregoiv8hf (__o, 1);
+  return ret;
+}
+
 __extension__ static __inline float32x4x2_t __attribute__ ((__always_inline__))
 vld2q_dup_f32 (const float32_t * __a)
 {
@@ -16597,6 +16834,18 @@ vld3_dup_u32 (const uint32_t * __a)
   return ret;
 }
 
+__extension__ static __inline float16x4x3_t __attribute__ ((__always_inline__))
+vld3_dup_f16 (const float16_t * __a)
+{
+  float16x4x3_t ret;
+  __builtin_aarch64_simd_ci __o;
+  __o = __builtin_aarch64_ld3rv4hf ((const __builtin_aarch64_simd_hf *) __a);
+  ret.val[0] = (float16x4_t) __builtin_aarch64_get_dregciv4hf (__o, 0);
+  ret.val[1] = (float16x4_t) __builtin_aarch64_get_dregciv4hf (__o, 1);
+  ret.val[2] = (float16x4_t) __builtin_aarch64_get_dregciv4hf (__o, 2);
+  return ret;
+}
+
 __extension__ static __inline float32x2x3_t __attribute__ ((__always_inline__))
 vld3_dup_f32 (const float32_t * __a)
 {
@@ -16729,6 +16978,18 @@ vld3q_dup_u64 (const uint64_t * __a)
   return ret;
 }
 
+__extension__ static __inline float16x8x3_t __attribute__ ((__always_inline__))
+vld3q_dup_f16 (const float16_t * __a)
+{
+  float16x8x3_t ret;
+  __builtin_aarch64_simd_ci __o;
+  __o = __builtin_aarch64_ld3rv8hf ((const __builtin_aarch64_simd_hf *) __a);
+  ret.val[0] = (float16x8_t) __builtin_aarch64_get_qregciv8hf (__o, 0);
+  ret.val[1] = (float16x8_t) __builtin_aarch64_get_qregciv8hf (__o, 1);
+  ret.val[2] = (float16x8_t) __builtin_aarch64_get_qregciv8hf (__o, 2);
+  return ret;
+}
+
 __extension__ static __inline float32x4x3_t __attribute__ ((__always_inline__))
 vld3q_dup_f32 (const float32_t * __a)
 {
@@ -16896,6 +17157,19 @@ vld4_dup_u32 (const uint32_t * __a)
   return ret;
 }
 
+__extension__ static __inline float16x4x4_t __attribute__ ((__always_inline__))
+vld4_dup_f16 (const float16_t * __a)
+{
+  float16x4x4_t ret;
+  __builtin_aarch64_simd_xi __o;
+  __o = __builtin_aarch64_ld4rv4hf ((const __builtin_aarch64_simd_hf *) __a);
+  ret.val[0] = (float16x4_t) __builtin_aarch64_get_dregxiv4hf (__o, 0);
+  ret.val[1] = (float16x4_t) __builtin_aarch64_get_dregxiv4hf (__o, 1);
+  ret.val[2] = (float16x4_t) __builtin_aarch64_get_dregxiv4hf (__o, 2);
+  ret.val[3] = (float16x4_t) __builtin_aarch64_get_dregxiv4hf (__o, 3);
+  return ret;
+}
+
 __extension__ static __inline float32x2x4_t __attribute__ ((__always_inline__))
 vld4_dup_f32 (const float32_t * __a)
 {
@@ -17039,6 +17313,19 @@ vld4q_dup_u64 (const uint64_t * __a)
   return ret;
 }
 
+__extension__ static __inline float16x8x4_t __attribute__ ((__always_inline__))
+vld4q_dup_f16 (const float16_t * __a)
+{
+  float16x8x4_t ret;
+  __builtin_aarch64_simd_xi __o;
+  __o = __builtin_aarch64_ld4rv8hf ((const __builtin_aarch64_simd_hf *) __a);
+  ret.val[0] = (float16x8_t) __builtin_aarch64_get_qregxiv8hf (__o, 0);
+  ret.val[1] = (float16x8_t) __builtin_aarch64_get_qregxiv8hf (__o, 1);
+  ret.val[2] = (float16x8_t) __builtin_aarch64_get_qregxiv8hf (__o, 2);
+  ret.val[3] = (float16x8_t) __builtin_aarch64_get_qregxiv8hf (__o, 3);
+  return ret;
+}
+
 __extension__ static __inline float32x4x4_t __attribute__ ((__always_inline__))
 vld4q_dup_f32 (const float32_t * __a)
 {
@@ -17067,8 +17354,8 @@ vld4q_dup_f64 (const float64_t * __a)
 
 /* vld2_lane */
 
-#define __LD2_LANE_FUNC(intype, vectype, largetype, ptrtype,		   \
-			 mode, ptrmode, funcsuffix, signedtype)		   \
+#define __LD2_LANE_FUNC(intype, vectype, largetype, ptrtype, mode,	   \
+			 qmode, ptrmode, funcsuffix, signedtype)	   \
 __extension__ static __inline intype __attribute__ ((__always_inline__))   \
 vld2_lane_##funcsuffix (const ptrtype * __ptr, intype __b, const int __c)  \
 {									   \
@@ -17078,12 +17365,12 @@ vld2_lane_##funcsuffix (const ptrtype * __ptr, intype __b, const int __c)  \
     vcombine_##funcsuffix (__b.val[0], vcreate_##funcsuffix (0));	   \
   __temp.val[1] =							   \
     vcombine_##funcsuffix (__b.val[1], vcreate_##funcsuffix (0));	   \
-  __o = __builtin_aarch64_set_qregoi##mode (__o,			   \
-					   (signedtype) __temp.val[0],	   \
-					   0);				   \
-  __o = __builtin_aarch64_set_qregoi##mode (__o,			   \
-					   (signedtype) __temp.val[1],	   \
-					   1);				   \
+  __o = __builtin_aarch64_set_qregoi##qmode (__o,			   \
+					    (signedtype) __temp.val[0],	   \
+					    0);				   \
+  __o = __builtin_aarch64_set_qregoi##qmode (__o,			   \
+					    (signedtype) __temp.val[1],	   \
+					    1);				   \
   __o =	__builtin_aarch64_ld2_lane##mode (				   \
 	  (__builtin_aarch64_simd_##ptrmode *) __ptr, __o, __c);	   \
   __b.val[0] = (vectype) __builtin_aarch64_get_dregoidi (__o, 0);	   \
@@ -17091,29 +17378,31 @@ vld2_lane_##funcsuffix (const ptrtype * __ptr, intype __b, const int __c)  \
   return __b;								   \
 }
 
-__LD2_LANE_FUNC (float32x2x2_t, float32x2_t, float32x4x2_t, float32_t, v4sf,
+__LD2_LANE_FUNC (float16x4x2_t, float16x4_t, float16x8x2_t, float16_t, v4hf,
+		 v8hf, hf, f16, float16x8_t)
+__LD2_LANE_FUNC (float32x2x2_t, float32x2_t, float32x4x2_t, float32_t, v2sf, v4sf,
 		 sf, f32, float32x4_t)
-__LD2_LANE_FUNC (float64x1x2_t, float64x1_t, float64x2x2_t, float64_t, v2df,
+__LD2_LANE_FUNC (float64x1x2_t, float64x1_t, float64x2x2_t, float64_t, df, v2df,
 		 df, f64, float64x2_t)
-__LD2_LANE_FUNC (poly8x8x2_t, poly8x8_t, poly8x16x2_t, poly8_t, v16qi, qi, p8,
+__LD2_LANE_FUNC (poly8x8x2_t, poly8x8_t, poly8x16x2_t, poly8_t, v8qi, v16qi, qi, p8,
 		 int8x16_t)
-__LD2_LANE_FUNC (poly16x4x2_t, poly16x4_t, poly16x8x2_t, poly16_t, v8hi, hi,
+__LD2_LANE_FUNC (poly16x4x2_t, poly16x4_t, poly16x8x2_t, poly16_t, v4hi, v8hi, hi,
 		 p16, int16x8_t)
-__LD2_LANE_FUNC (int8x8x2_t, int8x8_t, int8x16x2_t, int8_t, v16qi, qi, s8,
+__LD2_LANE_FUNC (int8x8x2_t, int8x8_t, int8x16x2_t, int8_t, v8qi, v16qi, qi, s8,
 		 int8x16_t)
-__LD2_LANE_FUNC (int16x4x2_t, int16x4_t, int16x8x2_t, int16_t, v8hi, hi, s16,
+__LD2_LANE_FUNC (int16x4x2_t, int16x4_t, int16x8x2_t, int16_t, v4hi, v8hi, hi, s16,
 		 int16x8_t)
-__LD2_LANE_FUNC (int32x2x2_t, int32x2_t, int32x4x2_t, int32_t, v4si, si, s32,
+__LD2_LANE_FUNC (int32x2x2_t, int32x2_t, int32x4x2_t, int32_t, v2si, v4si, si, s32,
 		 int32x4_t)
-__LD2_LANE_FUNC (int64x1x2_t, int64x1_t, int64x2x2_t, int64_t, v2di, di, s64,
+__LD2_LANE_FUNC (int64x1x2_t, int64x1_t, int64x2x2_t, int64_t, di, v2di, di, s64,
 		 int64x2_t)
-__LD2_LANE_FUNC (uint8x8x2_t, uint8x8_t, uint8x16x2_t, uint8_t, v16qi, qi, u8,
+__LD2_LANE_FUNC (uint8x8x2_t, uint8x8_t, uint8x16x2_t, uint8_t, v8qi, v16qi, qi, u8,
 		 int8x16_t)
-__LD2_LANE_FUNC (uint16x4x2_t, uint16x4_t, uint16x8x2_t, uint16_t, v8hi, hi,
+__LD2_LANE_FUNC (uint16x4x2_t, uint16x4_t, uint16x8x2_t, uint16_t, v4hi, v8hi, hi,
 		 u16, int16x8_t)
-__LD2_LANE_FUNC (uint32x2x2_t, uint32x2_t, uint32x4x2_t, uint32_t, v4si, si,
+__LD2_LANE_FUNC (uint32x2x2_t, uint32x2_t, uint32x4x2_t, uint32_t, v2si, v4si, si,
 		 u32, int32x4_t)
-__LD2_LANE_FUNC (uint64x1x2_t, uint64x1_t, uint64x2x2_t, uint64_t, v2di, di,
+__LD2_LANE_FUNC (uint64x1x2_t, uint64x1_t, uint64x2x2_t, uint64_t, di, v2di, di,
 		 u64, int64x2_t)
 
 #undef __LD2_LANE_FUNC
@@ -17135,6 +17424,7 @@ vld2q_lane_##funcsuffix (const ptrtype * __ptr, intype __b, const int __c) \
   return ret;								   \
 }
 
+__LD2_LANE_FUNC (float16x8x2_t, float16x8_t, float16_t, v8hf, hf, f16)
 __LD2_LANE_FUNC (float32x4x2_t, float32x4_t, float32_t, v4sf, sf, f32)
 __LD2_LANE_FUNC (float64x2x2_t, float64x2_t, float64_t, v2df, df, f64)
 __LD2_LANE_FUNC (poly8x16x2_t, poly8x16_t, poly8_t, v16qi, qi, p8)
@@ -17152,8 +17442,8 @@ __LD2_LANE_FUNC (uint64x2x2_t, uint64x2_t, uint64_t, v2di, di, u64)
 
 /* vld3_lane */
 
-#define __LD3_LANE_FUNC(intype, vectype, largetype, ptrtype,		   \
-			 mode, ptrmode, funcsuffix, signedtype)		   \
+#define __LD3_LANE_FUNC(intype, vectype, largetype, ptrtype, mode,	   \
+			 qmode, ptrmode, funcsuffix, signedtype)	   \
 __extension__ static __inline intype __attribute__ ((__always_inline__))   \
 vld3_lane_##funcsuffix (const ptrtype * __ptr, intype __b, const int __c)  \
 {									   \
@@ -17165,15 +17455,15 @@ vld3_lane_##funcsuffix (const ptrtype * __ptr, intype __b, const int __c)  \
     vcombine_##funcsuffix (__b.val[1], vcreate_##funcsuffix (0));	   \
   __temp.val[2] =							   \
     vcombine_##funcsuffix (__b.val[2], vcreate_##funcsuffix (0));	   \
-  __o = __builtin_aarch64_set_qregci##mode (__o,			   \
-					   (signedtype) __temp.val[0],	   \
-					   0);				   \
-  __o = __builtin_aarch64_set_qregci##mode (__o,			   \
-					   (signedtype) __temp.val[1],	   \
-					   1);				   \
-  __o = __builtin_aarch64_set_qregci##mode (__o,			   \
-					   (signedtype) __temp.val[2],	   \
-					   2);				   \
+  __o = __builtin_aarch64_set_qregci##qmode (__o,			   \
+					    (signedtype) __temp.val[0],	   \
+					    0);				   \
+  __o = __builtin_aarch64_set_qregci##qmode (__o,			   \
+					    (signedtype) __temp.val[1],	   \
+					    1);				   \
+  __o = __builtin_aarch64_set_qregci##qmode (__o,			   \
+					    (signedtype) __temp.val[2],	   \
+					    2);				   \
   __o =	__builtin_aarch64_ld3_lane##mode (				   \
 	  (__builtin_aarch64_simd_##ptrmode *) __ptr, __o, __c);	   \
   __b.val[0] = (vectype) __builtin_aarch64_get_dregcidi (__o, 0);	   \
@@ -17182,29 +17472,31 @@ vld3_lane_##funcsuffix (const ptrtype * __ptr, intype __b, const int __c)  \
   return __b;								   \
 }
 
-__LD3_LANE_FUNC (float32x2x3_t, float32x2_t, float32x4x3_t, float32_t, v4sf,
+__LD3_LANE_FUNC (float16x4x3_t, float16x4_t, float16x8x3_t, float16_t, v4hf,
+		 v8hf, hf, f16, float16x8_t)
+__LD3_LANE_FUNC (float32x2x3_t, float32x2_t, float32x4x3_t, float32_t, v2sf, v4sf,
 		 sf, f32, float32x4_t)
-__LD3_LANE_FUNC (float64x1x3_t, float64x1_t, float64x2x3_t, float64_t, v2df,
+__LD3_LANE_FUNC (float64x1x3_t, float64x1_t, float64x2x3_t, float64_t, df, v2df,
 		 df, f64, float64x2_t)
-__LD3_LANE_FUNC (poly8x8x3_t, poly8x8_t, poly8x16x3_t, poly8_t, v16qi, qi, p8,
+__LD3_LANE_FUNC (poly8x8x3_t, poly8x8_t, poly8x16x3_t, poly8_t, v8qi, v16qi, qi, p8,
 		 int8x16_t)
-__LD3_LANE_FUNC (poly16x4x3_t, poly16x4_t, poly16x8x3_t, poly16_t, v8hi, hi,
+__LD3_LANE_FUNC (poly16x4x3_t, poly16x4_t, poly16x8x3_t, poly16_t, v4hi, v8hi, hi,
 		 p16, int16x8_t)
-__LD3_LANE_FUNC (int8x8x3_t, int8x8_t, int8x16x3_t, int8_t, v16qi, qi, s8,
+__LD3_LANE_FUNC (int8x8x3_t, int8x8_t, int8x16x3_t, int8_t, v8qi, v16qi, qi, s8,
 		 int8x16_t)
-__LD3_LANE_FUNC (int16x4x3_t, int16x4_t, int16x8x3_t, int16_t, v8hi, hi, s16,
+__LD3_LANE_FUNC (int16x4x3_t, int16x4_t, int16x8x3_t, int16_t, v4hi, v8hi, hi, s16,
 		 int16x8_t)
-__LD3_LANE_FUNC (int32x2x3_t, int32x2_t, int32x4x3_t, int32_t, v4si, si, s32,
+__LD3_LANE_FUNC (int32x2x3_t, int32x2_t, int32x4x3_t, int32_t, v2si, v4si, si, s32,
 		 int32x4_t)
-__LD3_LANE_FUNC (int64x1x3_t, int64x1_t, int64x2x3_t, int64_t, v2di, di, s64,
+__LD3_LANE_FUNC (int64x1x3_t, int64x1_t, int64x2x3_t, int64_t, di, v2di, di, s64,
 		 int64x2_t)
-__LD3_LANE_FUNC (uint8x8x3_t, uint8x8_t, uint8x16x3_t, uint8_t, v16qi, qi, u8,
+__LD3_LANE_FUNC (uint8x8x3_t, uint8x8_t, uint8x16x3_t, uint8_t, v8qi, v16qi, qi, u8,
 		 int8x16_t)
-__LD3_LANE_FUNC (uint16x4x3_t, uint16x4_t, uint16x8x3_t, uint16_t, v8hi, hi,
+__LD3_LANE_FUNC (uint16x4x3_t, uint16x4_t, uint16x8x3_t, uint16_t, v4hi, v8hi, hi,
 		 u16, int16x8_t)
-__LD3_LANE_FUNC (uint32x2x3_t, uint32x2_t, uint32x4x3_t, uint32_t, v4si, si,
+__LD3_LANE_FUNC (uint32x2x3_t, uint32x2_t, uint32x4x3_t, uint32_t, v2si, v4si, si,
 		 u32, int32x4_t)
-__LD3_LANE_FUNC (uint64x1x3_t, uint64x1_t, uint64x2x3_t, uint64_t, v2di, di,
+__LD3_LANE_FUNC (uint64x1x3_t, uint64x1_t, uint64x2x3_t, uint64_t, di, v2di, di,
 		 u64, int64x2_t)
 
 #undef __LD3_LANE_FUNC
@@ -17228,6 +17520,7 @@ vld3q_lane_##funcsuffix (const ptrtype * __ptr, intype __b, const int __c) \
   return ret;								   \
 }
 
+__LD3_LANE_FUNC (float16x8x3_t, float16x8_t, float16_t, v8hf, hf, f16)
 __LD3_LANE_FUNC (float32x4x3_t, float32x4_t, float32_t, v4sf, sf, f32)
 __LD3_LANE_FUNC (float64x2x3_t, float64x2_t, float64_t, v2df, df, f64)
 __LD3_LANE_FUNC (poly8x16x3_t, poly8x16_t, poly8_t, v16qi, qi, p8)
@@ -17245,8 +17538,8 @@ __LD3_LANE_FUNC (uint64x2x3_t, uint64x2_t, uint64_t, v2di, di, u64)
 
 /* vld4_lane */
 
-#define __LD4_LANE_FUNC(intype, vectype, largetype, ptrtype,		   \
-			 mode, ptrmode, funcsuffix, signedtype)		   \
+#define __LD4_LANE_FUNC(intype, vectype, largetype, ptrtype, mode,	   \
+			 qmode, ptrmode, funcsuffix, signedtype)	   \
 __extension__ static __inline intype __attribute__ ((__always_inline__))   \
 vld4_lane_##funcsuffix (const ptrtype * __ptr, intype __b, const int __c)  \
 {									   \
@@ -17260,18 +17553,18 @@ vld4_lane_##funcsuffix (const ptrtype * __ptr, intype __b, const int __c)  \
     vcombine_##funcsuffix (__b.val[2], vcreate_##funcsuffix (0));	   \
   __temp.val[3] =							   \
     vcombine_##funcsuffix (__b.val[3], vcreate_##funcsuffix (0));	   \
-  __o = __builtin_aarch64_set_qregxi##mode (__o,			   \
-					   (signedtype) __temp.val[0],	   \
-					   0);				   \
-  __o = __builtin_aarch64_set_qregxi##mode (__o,			   \
-					   (signedtype) __temp.val[1],	   \
-					   1);				   \
-  __o = __builtin_aarch64_set_qregxi##mode (__o,			   \
-					   (signedtype) __temp.val[2],	   \
-					   2);				   \
-  __o = __builtin_aarch64_set_qregxi##mode (__o,			   \
-					   (signedtype) __temp.val[3],	   \
-					   3);				   \
+  __o = __builtin_aarch64_set_qregxi##qmode (__o,			   \
+					    (signedtype) __temp.val[0],	   \
+					    0);				   \
+  __o = __builtin_aarch64_set_qregxi##qmode (__o,			   \
+					    (signedtype) __temp.val[1],	   \
+					    1);				   \
+  __o = __builtin_aarch64_set_qregxi##qmode (__o,			   \
+					    (signedtype) __temp.val[2],	   \
+					    2);				   \
+  __o = __builtin_aarch64_set_qregxi##qmode (__o,			   \
+					    (signedtype) __temp.val[3],	   \
+					    3);				   \
   __o =	__builtin_aarch64_ld4_lane##mode (				   \
 	  (__builtin_aarch64_simd_##ptrmode *) __ptr, __o, __c);	   \
   __b.val[0] = (vectype) __builtin_aarch64_get_dregxidi (__o, 0);	   \
@@ -17283,29 +17576,31 @@ vld4_lane_##funcsuffix (const ptrtype * __ptr, intype __b, const int __c)  \
 
 /* vld4q_lane */
 
-__LD4_LANE_FUNC (float32x2x4_t, float32x2_t, float32x4x4_t, float32_t, v4sf,
+__LD4_LANE_FUNC (float16x4x4_t, float16x4_t, float16x8x4_t, float16_t, v4hf,
+		 v8hf, hf, f16, float16x8_t)
+__LD4_LANE_FUNC (float32x2x4_t, float32x2_t, float32x4x4_t, float32_t, v2sf, v4sf,
 		 sf, f32, float32x4_t)
-__LD4_LANE_FUNC (float64x1x4_t, float64x1_t, float64x2x4_t, float64_t, v2df,
+__LD4_LANE_FUNC (float64x1x4_t, float64x1_t, float64x2x4_t, float64_t, df, v2df,
 		 df, f64, float64x2_t)
-__LD4_LANE_FUNC (poly8x8x4_t, poly8x8_t, poly8x16x4_t, poly8_t, v16qi, qi, p8,
+__LD4_LANE_FUNC (poly8x8x4_t, poly8x8_t, poly8x16x4_t, poly8_t, v8qi, v16qi, qi, p8,
 		 int8x16_t)
-__LD4_LANE_FUNC (poly16x4x4_t, poly16x4_t, poly16x8x4_t, poly16_t, v8hi, hi,
+__LD4_LANE_FUNC (poly16x4x4_t, poly16x4_t, poly16x8x4_t, poly16_t, v4hi, v8hi, hi,
 		 p16, int16x8_t)
-__LD4_LANE_FUNC (int8x8x4_t, int8x8_t, int8x16x4_t, int8_t, v16qi, qi, s8,
+__LD4_LANE_FUNC (int8x8x4_t, int8x8_t, int8x16x4_t, int8_t, v8qi, v16qi, qi, s8,
 		 int8x16_t)
-__LD4_LANE_FUNC (int16x4x4_t, int16x4_t, int16x8x4_t, int16_t, v8hi, hi, s16,
+__LD4_LANE_FUNC (int16x4x4_t, int16x4_t, int16x8x4_t, int16_t, v4hi, v8hi, hi, s16,
 		 int16x8_t)
-__LD4_LANE_FUNC (int32x2x4_t, int32x2_t, int32x4x4_t, int32_t, v4si, si, s32,
+__LD4_LANE_FUNC (int32x2x4_t, int32x2_t, int32x4x4_t, int32_t, v2si, v4si, si, s32,
 		 int32x4_t)
-__LD4_LANE_FUNC (int64x1x4_t, int64x1_t, int64x2x4_t, int64_t, v2di, di, s64,
+__LD4_LANE_FUNC (int64x1x4_t, int64x1_t, int64x2x4_t, int64_t, di, v2di, di, s64,
 		 int64x2_t)
-__LD4_LANE_FUNC (uint8x8x4_t, uint8x8_t, uint8x16x4_t, uint8_t, v16qi, qi, u8,
+__LD4_LANE_FUNC (uint8x8x4_t, uint8x8_t, uint8x16x4_t, uint8_t, v8qi, v16qi, qi, u8,
 		 int8x16_t)
-__LD4_LANE_FUNC (uint16x4x4_t, uint16x4_t, uint16x8x4_t, uint16_t, v8hi, hi,
+__LD4_LANE_FUNC (uint16x4x4_t, uint16x4_t, uint16x8x4_t, uint16_t, v4hi, v8hi, hi,
 		 u16, int16x8_t)
-__LD4_LANE_FUNC (uint32x2x4_t, uint32x2_t, uint32x4x4_t, uint32_t, v4si, si,
+__LD4_LANE_FUNC (uint32x2x4_t, uint32x2_t, uint32x4x4_t, uint32_t, v2si, v4si, si,
 		 u32, int32x4_t)
-__LD4_LANE_FUNC (uint64x1x4_t, uint64x1_t, uint64x2x4_t, uint64_t, v2di, di,
+__LD4_LANE_FUNC (uint64x1x4_t, uint64x1_t, uint64x2x4_t, uint64_t, di, v2di, di,
 		 u64, int64x2_t)
 
 #undef __LD4_LANE_FUNC
@@ -17331,6 +17626,7 @@ vld4q_lane_##funcsuffix (const ptrtype * __ptr, intype __b, const int __c) \
   return ret;								   \
 }
 
+__LD4_LANE_FUNC (float16x8x4_t, float16x8_t, float16_t, v8hf, hf, f16)
 __LD4_LANE_FUNC (float32x4x4_t, float32x4_t, float32_t, v4sf, sf, f32)
 __LD4_LANE_FUNC (float64x2x4_t, float64x2_t, float64_t, v2df, df, f64)
 __LD4_LANE_FUNC (poly8x16x4_t, poly8x16_t, poly8_t, v16qi, qi, p8)
@@ -21317,82 +21613,85 @@ vrsrad_n_u64 (uint64_t __a, uint64_t __b, const int __c)
   return __builtin_aarch64_ursra_ndi_uuus (__a, __b, __c);
 }
 
-#ifdef __ARM_FEATURE_CRYPTO
+#pragma GCC push_options
+#pragma GCC target ("+nothing+crypto")
 
 /* vsha1  */
 
-static __inline uint32x4_t
+__extension__ static __inline uint32x4_t __attribute__ ((__always_inline__))
 vsha1cq_u32 (uint32x4_t hash_abcd, uint32_t hash_e, uint32x4_t wk)
 {
   return __builtin_aarch64_crypto_sha1cv4si_uuuu (hash_abcd, hash_e, wk);
 }
-static __inline uint32x4_t
+
+__extension__ static __inline uint32x4_t __attribute__ ((__always_inline__))
 vsha1mq_u32 (uint32x4_t hash_abcd, uint32_t hash_e, uint32x4_t wk)
 {
   return __builtin_aarch64_crypto_sha1mv4si_uuuu (hash_abcd, hash_e, wk);
 }
-static __inline uint32x4_t
+
+__extension__ static __inline uint32x4_t __attribute__ ((__always_inline__))
 vsha1pq_u32 (uint32x4_t hash_abcd, uint32_t hash_e, uint32x4_t wk)
 {
   return __builtin_aarch64_crypto_sha1pv4si_uuuu (hash_abcd, hash_e, wk);
 }
 
-static __inline uint32_t
+__extension__ static __inline uint32_t __attribute__ ((__always_inline__))
 vsha1h_u32 (uint32_t hash_e)
 {
   return __builtin_aarch64_crypto_sha1hsi_uu (hash_e);
 }
 
-static __inline uint32x4_t
+__extension__ static __inline uint32x4_t __attribute__ ((__always_inline__))
 vsha1su0q_u32 (uint32x4_t w0_3, uint32x4_t w4_7, uint32x4_t w8_11)
 {
   return __builtin_aarch64_crypto_sha1su0v4si_uuuu (w0_3, w4_7, w8_11);
 }
 
-static __inline uint32x4_t
+__extension__ static __inline uint32x4_t __attribute__ ((__always_inline__))
 vsha1su1q_u32 (uint32x4_t tw0_3, uint32x4_t w12_15)
 {
   return __builtin_aarch64_crypto_sha1su1v4si_uuu (tw0_3, w12_15);
 }
 
-static __inline uint32x4_t
+__extension__ static __inline uint32x4_t __attribute__ ((__always_inline__))
 vsha256hq_u32 (uint32x4_t hash_abcd, uint32x4_t hash_efgh, uint32x4_t wk)
 {
   return __builtin_aarch64_crypto_sha256hv4si_uuuu (hash_abcd, hash_efgh, wk);
 }
 
-static __inline uint32x4_t
+__extension__ static __inline uint32x4_t __attribute__ ((__always_inline__))
 vsha256h2q_u32 (uint32x4_t hash_efgh, uint32x4_t hash_abcd, uint32x4_t wk)
 {
   return __builtin_aarch64_crypto_sha256h2v4si_uuuu (hash_efgh, hash_abcd, wk);
 }
 
-static __inline uint32x4_t
+__extension__ static __inline uint32x4_t __attribute__ ((__always_inline__))
 vsha256su0q_u32 (uint32x4_t w0_3, uint32x4_t w4_7)
 {
   return __builtin_aarch64_crypto_sha256su0v4si_uuu (w0_3, w4_7);
 }
 
-static __inline uint32x4_t
+__extension__ static __inline uint32x4_t __attribute__ ((__always_inline__))
 vsha256su1q_u32 (uint32x4_t tw0_3, uint32x4_t w8_11, uint32x4_t w12_15)
 {
   return __builtin_aarch64_crypto_sha256su1v4si_uuuu (tw0_3, w8_11, w12_15);
 }
 
-static __inline poly128_t
+__extension__ static __inline poly128_t __attribute__ ((__always_inline__))
 vmull_p64 (poly64_t a, poly64_t b)
 {
   return
     __builtin_aarch64_crypto_pmulldi_ppp (a, b);
 }
 
-static __inline poly128_t
+__extension__ static __inline poly128_t __attribute__ ((__always_inline__))
 vmull_high_p64 (poly64x2_t a, poly64x2_t b)
 {
   return __builtin_aarch64_crypto_pmullv2di_ppp (a, b);
 }
 
-#endif
+#pragma GCC pop_options
 
 /* vshl */
 
@@ -22226,6 +22525,12 @@ vsrid_n_u64 (uint64_t __a, uint64_t __b, const int __c)
 /* vst1 */
 
 __extension__ static __inline void __attribute__ ((__always_inline__))
+vst1_f16 (float16_t *__a, float16x4_t __b)
+{
+  __builtin_aarch64_st1v4hf (__a, __b);
+}
+
+__extension__ static __inline void __attribute__ ((__always_inline__))
 vst1_f32 (float32_t *a, float32x2_t b)
 {
   __builtin_aarch64_st1v2sf ((__builtin_aarch64_simd_sf *) a, b);
@@ -22302,6 +22607,14 @@ vst1_u64 (uint64_t *a, uint64x1_t b)
   *a = b[0];
 }
 
+/* vst1q */
+
+__extension__ static __inline void __attribute__ ((__always_inline__))
+vst1q_f16 (float16_t *__a, float16x8_t __b)
+{
+  __builtin_aarch64_st1v8hf (__a, __b);
+}
+
 __extension__ static __inline void __attribute__ ((__always_inline__))
 vst1q_f32 (float32_t *a, float32x4_t b)
 {
@@ -22314,8 +22627,6 @@ vst1q_f64 (float64_t *a, float64x2_t b)
   __builtin_aarch64_st1v2df ((__builtin_aarch64_simd_df *) a, b);
 }
 
-/* vst1q */
-
 __extension__ static __inline void __attribute__ ((__always_inline__))
 vst1q_p8 (poly8_t *a, poly8x16_t b)
 {
@@ -22382,6 +22693,166 @@ vst1q_u64 (uint64_t *a, uint64x2_t b)
 			     (int64x2_t) b);
 }
 
+/* vst1_lane */
+
+__extension__ static __inline void __attribute__ ((__always_inline__))
+vst1_lane_f16 (float16_t *__a, float16x4_t __b, const int __lane)
+{
+  *__a = __aarch64_vget_lane_any (__b, __lane);
+}
+
+__extension__ static __inline void __attribute__ ((__always_inline__))
+vst1_lane_f32 (float32_t *__a, float32x2_t __b, const int __lane)
+{
+  *__a = __aarch64_vget_lane_any (__b, __lane);
+}
+
+__extension__ static __inline void __attribute__ ((__always_inline__))
+vst1_lane_f64 (float64_t *__a, float64x1_t __b, const int __lane)
+{
+  *__a = __aarch64_vget_lane_any (__b, __lane);
+}
+
+__extension__ static __inline void __attribute__ ((__always_inline__))
+vst1_lane_p8 (poly8_t *__a, poly8x8_t __b, const int __lane)
+{
+  *__a = __aarch64_vget_lane_any (__b, __lane);
+}
+
+__extension__ static __inline void __attribute__ ((__always_inline__))
+vst1_lane_p16 (poly16_t *__a, poly16x4_t __b, const int __lane)
+{
+  *__a = __aarch64_vget_lane_any (__b, __lane);
+}
+
+__extension__ static __inline void __attribute__ ((__always_inline__))
+vst1_lane_s8 (int8_t *__a, int8x8_t __b, const int __lane)
+{
+  *__a = __aarch64_vget_lane_any (__b, __lane);
+}
+
+__extension__ static __inline void __attribute__ ((__always_inline__))
+vst1_lane_s16 (int16_t *__a, int16x4_t __b, const int __lane)
+{
+  *__a = __aarch64_vget_lane_any (__b, __lane);
+}
+
+__extension__ static __inline void __attribute__ ((__always_inline__))
+vst1_lane_s32 (int32_t *__a, int32x2_t __b, const int __lane)
+{
+  *__a = __aarch64_vget_lane_any (__b, __lane);
+}
+
+__extension__ static __inline void __attribute__ ((__always_inline__))
+vst1_lane_s64 (int64_t *__a, int64x1_t __b, const int __lane)
+{
+  *__a = __aarch64_vget_lane_any (__b, __lane);
+}
+
+__extension__ static __inline void __attribute__ ((__always_inline__))
+vst1_lane_u8 (uint8_t *__a, uint8x8_t __b, const int __lane)
+{
+  *__a = __aarch64_vget_lane_any (__b, __lane);
+}
+
+__extension__ static __inline void __attribute__ ((__always_inline__))
+vst1_lane_u16 (uint16_t *__a, uint16x4_t __b, const int __lane)
+{
+  *__a = __aarch64_vget_lane_any (__b, __lane);
+}
+
+__extension__ static __inline void __attribute__ ((__always_inline__))
+vst1_lane_u32 (uint32_t *__a, uint32x2_t __b, const int __lane)
+{
+  *__a = __aarch64_vget_lane_any (__b, __lane);
+}
+
+__extension__ static __inline void __attribute__ ((__always_inline__))
+vst1_lane_u64 (uint64_t *__a, uint64x1_t __b, const int __lane)
+{
+  *__a = __aarch64_vget_lane_any (__b, __lane);
+}
+
+/* vst1q_lane */
+
+__extension__ static __inline void __attribute__ ((__always_inline__))
+vst1q_lane_f16 (float16_t *__a, float16x8_t __b, const int __lane)
+{
+  *__a = __aarch64_vget_lane_any (__b, __lane);
+}
+
+__extension__ static __inline void __attribute__ ((__always_inline__))
+vst1q_lane_f32 (float32_t *__a, float32x4_t __b, const int __lane)
+{
+  *__a = __aarch64_vget_lane_any (__b, __lane);
+}
+
+__extension__ static __inline void __attribute__ ((__always_inline__))
+vst1q_lane_f64 (float64_t *__a, float64x2_t __b, const int __lane)
+{
+  *__a = __aarch64_vget_lane_any (__b, __lane);
+}
+
+__extension__ static __inline void __attribute__ ((__always_inline__))
+vst1q_lane_p8 (poly8_t *__a, poly8x16_t __b, const int __lane)
+{
+  *__a = __aarch64_vget_lane_any (__b, __lane);
+}
+
+__extension__ static __inline void __attribute__ ((__always_inline__))
+vst1q_lane_p16 (poly16_t *__a, poly16x8_t __b, const int __lane)
+{
+  *__a = __aarch64_vget_lane_any (__b, __lane);
+}
+
+__extension__ static __inline void __attribute__ ((__always_inline__))
+vst1q_lane_s8 (int8_t *__a, int8x16_t __b, const int __lane)
+{
+  *__a = __aarch64_vget_lane_any (__b, __lane);
+}
+
+__extension__ static __inline void __attribute__ ((__always_inline__))
+vst1q_lane_s16 (int16_t *__a, int16x8_t __b, const int __lane)
+{
+  *__a = __aarch64_vget_lane_any (__b, __lane);
+}
+
+__extension__ static __inline void __attribute__ ((__always_inline__))
+vst1q_lane_s32 (int32_t *__a, int32x4_t __b, const int __lane)
+{
+  *__a = __aarch64_vget_lane_any (__b, __lane);
+}
+
+__extension__ static __inline void __attribute__ ((__always_inline__))
+vst1q_lane_s64 (int64_t *__a, int64x2_t __b, const int __lane)
+{
+  *__a = __aarch64_vget_lane_any (__b, __lane);
+}
+
+__extension__ static __inline void __attribute__ ((__always_inline__))
+vst1q_lane_u8 (uint8_t *__a, uint8x16_t __b, const int __lane)
+{
+  *__a = __aarch64_vget_lane_any (__b, __lane);
+}
+
+__extension__ static __inline void __attribute__ ((__always_inline__))
+vst1q_lane_u16 (uint16_t *__a, uint16x8_t __b, const int __lane)
+{
+  *__a = __aarch64_vget_lane_any (__b, __lane);
+}
+
+__extension__ static __inline void __attribute__ ((__always_inline__))
+vst1q_lane_u32 (uint32_t *__a, uint32x4_t __b, const int __lane)
+{
+  *__a = __aarch64_vget_lane_any (__b, __lane);
+}
+
+__extension__ static __inline void __attribute__ ((__always_inline__))
+vst1q_lane_u64 (uint64_t *__a, uint64x2_t __b, const int __lane)
+{
+  *__a = __aarch64_vget_lane_any (__b, __lane);
+}
+
 /* vstn */
 
 __extension__ static __inline void
@@ -22517,6 +22988,18 @@ vst2_u32 (uint32_t * __a, uint32x2x2_t val)
 }
 
 __extension__ static __inline void __attribute__ ((__always_inline__))
+vst2_f16 (float16_t * __a, float16x4x2_t val)
+{
+  __builtin_aarch64_simd_oi __o;
+  float16x8x2_t temp;
+  temp.val[0] = vcombine_f16 (val.val[0], vcreate_f16 (__AARCH64_UINT64_C (0)));
+  temp.val[1] = vcombine_f16 (val.val[1], vcreate_f16 (__AARCH64_UINT64_C (0)));
+  __o = __builtin_aarch64_set_qregoiv8hf (__o, temp.val[0], 0);
+  __o = __builtin_aarch64_set_qregoiv8hf (__o, temp.val[1], 1);
+  __builtin_aarch64_st2v4hf (__a, __o);
+}
+
+__extension__ static __inline void __attribute__ ((__always_inline__))
 vst2_f32 (float32_t * __a, float32x2x2_t val)
 {
   __builtin_aarch64_simd_oi __o;
@@ -22619,6 +23102,15 @@ vst2q_u64 (uint64_t * __a, uint64x2x2_t val)
 }
 
 __extension__ static __inline void __attribute__ ((__always_inline__))
+vst2q_f16 (float16_t * __a, float16x8x2_t val)
+{
+  __builtin_aarch64_simd_oi __o;
+  __o = __builtin_aarch64_set_qregoiv8hf (__o, val.val[0], 0);
+  __o = __builtin_aarch64_set_qregoiv8hf (__o, val.val[1], 1);
+  __builtin_aarch64_st2v8hf (__a, __o);
+}
+
+__extension__ static __inline void __attribute__ ((__always_inline__))
 vst2q_f32 (float32_t * __a, float32x4x2_t val)
 {
   __builtin_aarch64_simd_oi __o;
@@ -22791,6 +23283,20 @@ vst3_u32 (uint32_t * __a, uint32x2x3_t val)
 }
 
 __extension__ static __inline void __attribute__ ((__always_inline__))
+vst3_f16 (float16_t * __a, float16x4x3_t val)
+{
+  __builtin_aarch64_simd_ci __o;
+  float16x8x3_t temp;
+  temp.val[0] = vcombine_f16 (val.val[0], vcreate_f16 (__AARCH64_UINT64_C (0)));
+  temp.val[1] = vcombine_f16 (val.val[1], vcreate_f16 (__AARCH64_UINT64_C (0)));
+  temp.val[2] = vcombine_f16 (val.val[2], vcreate_f16 (__AARCH64_UINT64_C (0)));
+  __o = __builtin_aarch64_set_qregciv8hf (__o, (float16x8_t) temp.val[0], 0);
+  __o = __builtin_aarch64_set_qregciv8hf (__o, (float16x8_t) temp.val[1], 1);
+  __o = __builtin_aarch64_set_qregciv8hf (__o, (float16x8_t) temp.val[2], 2);
+  __builtin_aarch64_st3v4hf ((__builtin_aarch64_simd_hf *) __a, __o);
+}
+
+__extension__ static __inline void __attribute__ ((__always_inline__))
 vst3_f32 (float32_t * __a, float32x2x3_t val)
 {
   __builtin_aarch64_simd_ci __o;
@@ -22905,6 +23411,16 @@ vst3q_u64 (uint64_t * __a, uint64x2x3_t val)
 }
 
 __extension__ static __inline void __attribute__ ((__always_inline__))
+vst3q_f16 (float16_t * __a, float16x8x3_t val)
+{
+  __builtin_aarch64_simd_ci __o;
+  __o = __builtin_aarch64_set_qregciv8hf (__o, (float16x8_t) val.val[0], 0);
+  __o = __builtin_aarch64_set_qregciv8hf (__o, (float16x8_t) val.val[1], 1);
+  __o = __builtin_aarch64_set_qregciv8hf (__o, (float16x8_t) val.val[2], 2);
+  __builtin_aarch64_st3v8hf ((__builtin_aarch64_simd_hf *) __a, __o);
+}
+
+__extension__ static __inline void __attribute__ ((__always_inline__))
 vst3q_f32 (float32_t * __a, float32x4x3_t val)
 {
   __builtin_aarch64_simd_ci __o;
@@ -23101,6 +23617,22 @@ vst4_u32 (uint32_t * __a, uint32x2x4_t val)
 }
 
 __extension__ static __inline void __attribute__ ((__always_inline__))
+vst4_f16 (float16_t * __a, float16x4x4_t val)
+{
+  __builtin_aarch64_simd_xi __o;
+  float16x8x4_t temp;
+  temp.val[0] = vcombine_f16 (val.val[0], vcreate_f16 (__AARCH64_UINT64_C (0)));
+  temp.val[1] = vcombine_f16 (val.val[1], vcreate_f16 (__AARCH64_UINT64_C (0)));
+  temp.val[2] = vcombine_f16 (val.val[2], vcreate_f16 (__AARCH64_UINT64_C (0)));
+  temp.val[3] = vcombine_f16 (val.val[3], vcreate_f16 (__AARCH64_UINT64_C (0)));
+  __o = __builtin_aarch64_set_qregxiv8hf (__o, (float16x8_t) temp.val[0], 0);
+  __o = __builtin_aarch64_set_qregxiv8hf (__o, (float16x8_t) temp.val[1], 1);
+  __o = __builtin_aarch64_set_qregxiv8hf (__o, (float16x8_t) temp.val[2], 2);
+  __o = __builtin_aarch64_set_qregxiv8hf (__o, (float16x8_t) temp.val[3], 3);
+  __builtin_aarch64_st4v4hf ((__builtin_aarch64_simd_hf *) __a, __o);
+}
+
+__extension__ static __inline void __attribute__ ((__always_inline__))
 vst4_f32 (float32_t * __a, float32x2x4_t val)
 {
   __builtin_aarch64_simd_xi __o;
@@ -23227,6 +23759,17 @@ vst4q_u64 (uint64_t * __a, uint64x2x4_t val)
 }
 
 __extension__ static __inline void __attribute__ ((__always_inline__))
+vst4q_f16 (float16_t * __a, float16x8x4_t val)
+{
+  __builtin_aarch64_simd_xi __o;
+  __o = __builtin_aarch64_set_qregxiv8hf (__o, (float16x8_t) val.val[0], 0);
+  __o = __builtin_aarch64_set_qregxiv8hf (__o, (float16x8_t) val.val[1], 1);
+  __o = __builtin_aarch64_set_qregxiv8hf (__o, (float16x8_t) val.val[2], 2);
+  __o = __builtin_aarch64_set_qregxiv8hf (__o, (float16x8_t) val.val[3], 3);
+  __builtin_aarch64_st4v8hf ((__builtin_aarch64_simd_hf *) __a, __o);
+}
+
+__extension__ static __inline void __attribute__ ((__always_inline__))
 vst4q_f32 (float32_t * __a, float32x4x4_t val)
 {
   __builtin_aarch64_simd_xi __o;
@@ -23322,6 +23865,58 @@ vtbx3_p8 (poly8x8_t __r, poly8x8x3_t __tab, uint8x8_t __idx)
   return vbsl_p8 (__mask, __tbl, __r);
 }
 
+/* vtbx4  */
+
+__extension__ static __inline int8x8_t __attribute__ ((__always_inline__))
+vtbx4_s8 (int8x8_t __r, int8x8x4_t __tab, int8x8_t __idx)
+{
+  int8x8_t result;
+  int8x16x2_t temp;
+  __builtin_aarch64_simd_oi __o;
+  temp.val[0] = vcombine_s8 (__tab.val[0], __tab.val[1]);
+  temp.val[1] = vcombine_s8 (__tab.val[2], __tab.val[3]);
+  __o = __builtin_aarch64_set_qregoiv16qi (__o,
+					   (int8x16_t) temp.val[0], 0);
+  __o = __builtin_aarch64_set_qregoiv16qi (__o,
+					   (int8x16_t) temp.val[1], 1);
+  result = __builtin_aarch64_tbx4v8qi (__r, __o, __idx);
+  return result;
+}
+
+__extension__ static __inline uint8x8_t __attribute__ ((__always_inline__))
+vtbx4_u8 (uint8x8_t __r, uint8x8x4_t __tab, uint8x8_t __idx)
+{
+  uint8x8_t result;
+  uint8x16x2_t temp;
+  __builtin_aarch64_simd_oi __o;
+  temp.val[0] = vcombine_u8 (__tab.val[0], __tab.val[1]);
+  temp.val[1] = vcombine_u8 (__tab.val[2], __tab.val[3]);
+  __o = __builtin_aarch64_set_qregoiv16qi (__o,
+					   (int8x16_t) temp.val[0], 0);
+  __o = __builtin_aarch64_set_qregoiv16qi (__o,
+					   (int8x16_t) temp.val[1], 1);
+  result = (uint8x8_t)__builtin_aarch64_tbx4v8qi ((int8x8_t)__r, __o,
+						  (int8x8_t)__idx);
+  return result;
+}
+
+__extension__ static __inline poly8x8_t __attribute__ ((__always_inline__))
+vtbx4_p8 (poly8x8_t __r, poly8x8x4_t __tab, uint8x8_t __idx)
+{
+  poly8x8_t result;
+  poly8x16x2_t temp;
+  __builtin_aarch64_simd_oi __o;
+  temp.val[0] = vcombine_p8 (__tab.val[0], __tab.val[1]);
+  temp.val[1] = vcombine_p8 (__tab.val[2], __tab.val[3]);
+  __o = __builtin_aarch64_set_qregoiv16qi (__o,
+					   (int8x16_t) temp.val[0], 0);
+  __o = __builtin_aarch64_set_qregoiv16qi (__o,
+					   (int8x16_t) temp.val[1], 1);
+  result = (poly8x8_t)__builtin_aarch64_tbx4v8qi ((int8x8_t)__r, __o,
+						  (int8x8_t)__idx);
+  return result;
+}
+
 /* vtrn */
 
 __extension__ static __inline float32x2_t __attribute__ ((__always_inline__))
@@ -23887,7 +24482,7 @@ vtst_s32 (int32x2_t __a, int32x2_t __b)
 __extension__ static __inline uint64x1_t __attribute__ ((__always_inline__))
 vtst_s64 (int64x1_t __a, int64x1_t __b)
 {
-  return (uint64x1_t) {(__a[0] & __b[0]) ? -1ll : 0ll};
+  return (uint64x1_t) ((__a & __b) != __AARCH64_INT64_C (0));
 }
 
 __extension__ static __inline uint8x8_t __attribute__ ((__always_inline__))
@@ -23911,7 +24506,7 @@ vtst_u32 (uint32x2_t __a, uint32x2_t __b)
 __extension__ static __inline uint64x1_t __attribute__ ((__always_inline__))
 vtst_u64 (uint64x1_t __a, uint64x1_t __b)
 {
-  return (uint64x1_t) {(__a[0] & __b[0]) ? -1ll : 0ll};
+  return ((__a & __b) != __AARCH64_UINT64_C (0));
 }
 
 __extension__ static __inline uint8x16_t __attribute__ ((__always_inline__))
@@ -25012,6 +25607,6 @@ __INTERLEAVE_LIST (zip)
 #undef __aarch64_vdupq_laneq_u32
 #undef __aarch64_vdupq_laneq_u64
 
-#endif
+#pragma GCC pop_options
 
 #endif
--- a/src/gcc/config/aarch64/atomics.md
+++ b/src/gcc/config/aarch64/atomics.md
@@ -26,9 +26,28 @@
     UNSPECV_STL				; Represent an atomic store or store-release.
     UNSPECV_ATOMIC_CMPSW		; Represent an atomic compare swap.
     UNSPECV_ATOMIC_EXCHG		; Represent an atomic exchange.
+    UNSPECV_ATOMIC_CAS			; Represent an atomic CAS.
+    UNSPECV_ATOMIC_SWP			; Represent an atomic SWP.
     UNSPECV_ATOMIC_OP			; Represent an atomic operation.
+    UNSPECV_ATOMIC_LDOP			; Represent an atomic load-operation
+    UNSPECV_ATOMIC_LDOP_OR		; Represent an atomic load-or
+    UNSPECV_ATOMIC_LDOP_BIC		; Represent an atomic load-bic
+    UNSPECV_ATOMIC_LDOP_XOR		; Represent an atomic load-xor
+    UNSPECV_ATOMIC_LDOP_PLUS		; Represent an atomic load-add
 ])
 
+;; Iterators for load-operate instructions.
+
+(define_int_iterator ATOMIC_LDOP
+ [UNSPECV_ATOMIC_LDOP_OR UNSPECV_ATOMIC_LDOP_BIC
+  UNSPECV_ATOMIC_LDOP_XOR UNSPECV_ATOMIC_LDOP_PLUS])
+
+(define_int_attr atomic_ldop
+ [(UNSPECV_ATOMIC_LDOP_OR "set") (UNSPECV_ATOMIC_LDOP_BIC "clr")
+  (UNSPECV_ATOMIC_LDOP_XOR "eor") (UNSPECV_ATOMIC_LDOP_PLUS "add")])
+
+;; Instruction patterns.
+
 (define_expand "atomic_compare_and_swap<mode>"
   [(match_operand:SI 0 "register_operand" "")			;; bool out
    (match_operand:ALLI 1 "register_operand" "")			;; val out
@@ -45,10 +64,10 @@
   }
 )
 
-(define_insn_and_split "atomic_compare_and_swap<mode>_1"
+(define_insn_and_split "aarch64_compare_and_swap<mode>"
   [(set (reg:CC CC_REGNUM)					;; bool out
     (unspec_volatile:CC [(const_int 0)] UNSPECV_ATOMIC_CMPSW))
-   (set (match_operand:SI 0 "register_operand" "=&r")		;; val out
+   (set (match_operand:SI 0 "register_operand" "=&r")	   ;; val out
     (zero_extend:SI
       (match_operand:SHORT 1 "aarch64_sync_memory_operand" "+Q"))) ;; memory
    (set (match_dup 1)
@@ -57,7 +76,7 @@
        (match_operand:SHORT 3 "register_operand" "r")	;; desired
        (match_operand:SI 4 "const_int_operand")		;; is_weak
        (match_operand:SI 5 "const_int_operand")		;; mod_s
-       (match_operand:SI 6 "const_int_operand")]		;; mod_f
+       (match_operand:SI 6 "const_int_operand")]	;; mod_f
       UNSPECV_ATOMIC_CMPSW))
    (clobber (match_scratch:SI 7 "=&r"))]
   ""
@@ -70,17 +89,17 @@
   }
 )
 
-(define_insn_and_split "atomic_compare_and_swap<mode>_1"
+(define_insn_and_split "aarch64_compare_and_swap<mode>"
   [(set (reg:CC CC_REGNUM)					;; bool out
     (unspec_volatile:CC [(const_int 0)] UNSPECV_ATOMIC_CMPSW))
    (set (match_operand:GPI 0 "register_operand" "=&r")		;; val out
-    (match_operand:GPI 1 "aarch64_sync_memory_operand" "+Q")) ;; memory
+    (match_operand:GPI 1 "aarch64_sync_memory_operand" "+Q"))   ;; memory
    (set (match_dup 1)
     (unspec_volatile:GPI
       [(match_operand:GPI 2 "aarch64_plus_operand" "rI")	;; expect
        (match_operand:GPI 3 "register_operand" "r")		;; desired
-       (match_operand:SI 4 "const_int_operand")		;; is_weak
-       (match_operand:SI 5 "const_int_operand")		;; mod_s
+       (match_operand:SI 4 "const_int_operand")			;; is_weak
+       (match_operand:SI 5 "const_int_operand")			;; mod_s
        (match_operand:SI 6 "const_int_operand")]		;; mod_f
       UNSPECV_ATOMIC_CMPSW))
    (clobber (match_scratch:SI 7 "=&r"))]
@@ -94,7 +113,79 @@
   }
 )
 
-(define_insn_and_split "atomic_exchange<mode>"
+(define_insn_and_split "aarch64_compare_and_swap<mode>_lse"
+  [(set (reg:CC CC_REGNUM)					;; bool out
+    (unspec_volatile:CC [(const_int 0)] UNSPECV_ATOMIC_CMPSW))
+   (set (match_operand:SI 0 "register_operand" "=&r")		;; val out
+    (zero_extend:SI
+      (match_operand:SHORT 1 "aarch64_sync_memory_operand" "+Q"))) ;; memory
+   (set (match_dup 1)
+    (unspec_volatile:SHORT
+      [(match_operand:SI 2 "aarch64_plus_operand" "rI")	;; expected
+       (match_operand:SHORT 3 "register_operand" "r")	;; desired
+       (match_operand:SI 4 "const_int_operand")		;; is_weak
+       (match_operand:SI 5 "const_int_operand")		;; mod_s
+       (match_operand:SI 6 "const_int_operand")]	;; mod_f
+      UNSPECV_ATOMIC_CMPSW))]
+  "TARGET_LSE"
+  "#"
+  "&& reload_completed"
+  [(const_int 0)]
+  {
+    aarch64_gen_atomic_cas (operands[0], operands[1],
+			    operands[2], operands[3],
+			    operands[5]);
+    DONE;
+  }
+)
+
+(define_insn_and_split "aarch64_compare_and_swap<mode>_lse"
+  [(set (reg:CC CC_REGNUM)					;; bool out
+    (unspec_volatile:CC [(const_int 0)] UNSPECV_ATOMIC_CMPSW))
+   (set (match_operand:GPI 0 "register_operand" "=&r")		;; val out
+    (match_operand:GPI 1 "aarch64_sync_memory_operand" "+Q"))   ;; memory
+   (set (match_dup 1)
+    (unspec_volatile:GPI
+      [(match_operand:GPI 2 "aarch64_plus_operand" "rI")	;; expect
+       (match_operand:GPI 3 "register_operand" "r")		;; desired
+       (match_operand:SI 4 "const_int_operand")			;; is_weak
+       (match_operand:SI 5 "const_int_operand")			;; mod_s
+       (match_operand:SI 6 "const_int_operand")]		;; mod_f
+      UNSPECV_ATOMIC_CMPSW))]
+  "TARGET_LSE"
+  "#"
+  "&& reload_completed"
+  [(const_int 0)]
+  {
+    aarch64_gen_atomic_cas (operands[0], operands[1],
+			    operands[2], operands[3],
+			    operands[5]);
+    DONE;
+  }
+)
+
+(define_expand "atomic_exchange<mode>"
+ [(match_operand:ALLI 0 "register_operand" "")
+  (match_operand:ALLI 1 "aarch64_sync_memory_operand" "")
+  (match_operand:ALLI 2 "register_operand" "")
+  (match_operand:SI 3 "const_int_operand" "")]
+  ""
+  {
+    rtx (*gen) (rtx, rtx, rtx, rtx);
+
+    /* Use an atomic SWP when available.  */
+    if (TARGET_LSE)
+      gen = gen_aarch64_atomic_exchange<mode>_lse;
+    else
+      gen = gen_aarch64_atomic_exchange<mode>;
+
+    emit_insn (gen (operands[0], operands[1], operands[2], operands[3]));
+
+    DONE;
+  }
+)
+
+(define_insn_and_split "aarch64_atomic_exchange<mode>"
   [(set (match_operand:ALLI 0 "register_operand" "=&r")		;; output
     (match_operand:ALLI 1 "aarch64_sync_memory_operand" "+Q")) ;; memory
    (set (match_dup 1)
@@ -110,28 +201,87 @@
   [(const_int 0)]
   {
     aarch64_split_atomic_op (SET, operands[0], NULL, operands[1],
-			    operands[2], operands[3], operands[4]);
+			     operands[2], operands[3], operands[4]);
+    DONE;
+  }
+)
+
+(define_insn_and_split "aarch64_atomic_exchange<mode>_lse"
+  [(set (match_operand:ALLI 0 "register_operand" "=&r")
+    (match_operand:ALLI 1 "aarch64_sync_memory_operand" "+Q"))
+   (set (match_dup 1)
+    (unspec_volatile:ALLI
+      [(match_operand:ALLI 2 "register_operand" "r")
+       (match_operand:SI 3 "const_int_operand" "")]
+      UNSPECV_ATOMIC_EXCHG))]
+  "TARGET_LSE"
+  "#"
+  "&& reload_completed"
+  [(const_int 0)]
+  {
+    aarch64_gen_atomic_ldop (SET, operands[0], NULL, operands[1],
+			     operands[2], operands[3]);
+    DONE;
+  }
+)
+
+(define_expand "atomic_<atomic_optab><mode>"
+ [(match_operand:ALLI 0 "aarch64_sync_memory_operand" "")
+  (atomic_op:ALLI
+   (match_operand:ALLI 1 "<atomic_op_operand>" "")
+   (match_operand:SI 2 "const_int_operand"))]
+  ""
+  {
+    rtx (*gen) (rtx, rtx, rtx);
+
+    /* Use an atomic load-operate instruction when possible.  */
+    if (aarch64_atomic_ldop_supported_p (<CODE>))
+      gen = gen_aarch64_atomic_<atomic_optab><mode>_lse;
+    else
+      gen = gen_aarch64_atomic_<atomic_optab><mode>;
+
+    emit_insn (gen (operands[0], operands[1], operands[2]));
+
     DONE;
   }
 )
 
-(define_insn_and_split "atomic_<atomic_optab><mode>"
+(define_insn_and_split "aarch64_atomic_<atomic_optab><mode>"
+ [(set (match_operand:ALLI 0 "aarch64_sync_memory_operand" "+Q")
+   (unspec_volatile:ALLI
+    [(atomic_op:ALLI (match_dup 0)
+      (match_operand:ALLI 1 "<atomic_op_operand>" "r<const_atomic>"))
+     (match_operand:SI 2 "const_int_operand")]
+    UNSPECV_ATOMIC_OP))
+  (clobber (reg:CC CC_REGNUM))
+  (clobber (match_scratch:ALLI 3 "=&r"))
+  (clobber (match_scratch:SI 4 "=&r"))]
+  ""
+  "#"
+  "&& reload_completed"
+  [(const_int 0)]
+  {
+    aarch64_split_atomic_op (<CODE>, NULL, operands[3], operands[0],
+			     operands[1], operands[2], operands[4]);
+    DONE;
+  }
+)
+
+(define_insn_and_split "aarch64_atomic_<atomic_optab><mode>_lse"
   [(set (match_operand:ALLI 0 "aarch64_sync_memory_operand" "+Q")
     (unspec_volatile:ALLI
       [(atomic_op:ALLI (match_dup 0)
 	(match_operand:ALLI 1 "<atomic_op_operand>" "r<const_atomic>"))
-       (match_operand:SI 2 "const_int_operand")]		;; model
+       (match_operand:SI 2 "const_int_operand")]
       UNSPECV_ATOMIC_OP))
-       (clobber (reg:CC CC_REGNUM))
-   (clobber (match_scratch:ALLI 3 "=&r"))
-   (clobber (match_scratch:SI 4 "=&r"))]
-  ""
+   (clobber (match_scratch:ALLI 3 "=&r"))]
+  "TARGET_LSE"
   "#"
   "&& reload_completed"
   [(const_int 0)]
   {
-    aarch64_split_atomic_op (<CODE>, NULL, operands[3], operands[0],
-			    operands[1], operands[2], operands[4]);
+    aarch64_gen_atomic_ldop (<CODE>, operands[3], NULL, operands[0],
+			     operands[1], operands[2]);
     DONE;
   }
 )
@@ -158,7 +308,30 @@
   }
 )
 
-(define_insn_and_split "atomic_fetch_<atomic_optab><mode>"
+;; Load-operate-store, returning the updated memory data.
+
+(define_expand "atomic_fetch_<atomic_optab><mode>"
+ [(match_operand:ALLI 0 "register_operand" "")
+  (match_operand:ALLI 1 "aarch64_sync_memory_operand" "")
+  (atomic_op:ALLI
+   (match_operand:ALLI 2 "<atomic_op_operand>" "")
+   (match_operand:SI 3 "const_int_operand"))]
+ ""
+{
+  rtx (*gen) (rtx, rtx, rtx, rtx);
+
+  /* Use an atomic load-operate instruction when possible.  */
+  if (aarch64_atomic_ldop_supported_p (<CODE>))
+    gen = gen_aarch64_atomic_fetch_<atomic_optab><mode>_lse;
+  else
+    gen = gen_aarch64_atomic_fetch_<atomic_optab><mode>;
+
+  emit_insn (gen (operands[0], operands[1], operands[2], operands[3]));
+
+  DONE;
+})
+
+(define_insn_and_split "aarch64_atomic_fetch_<atomic_optab><mode>"
   [(set (match_operand:ALLI 0 "register_operand" "=&r")
     (match_operand:ALLI 1 "aarch64_sync_memory_operand" "+Q"))
    (set (match_dup 1)
@@ -181,6 +354,26 @@
   }
 )
 
+(define_insn_and_split "aarch64_atomic_fetch_<atomic_optab><mode>_lse"
+  [(set (match_operand:ALLI 0 "register_operand" "=&r")
+    (match_operand:ALLI 1 "aarch64_sync_memory_operand" "+Q"))
+   (set (match_dup 1)
+    (unspec_volatile:ALLI
+      [(atomic_op:ALLI (match_dup 1)
+	(match_operand:ALLI 2 "<atomic_op_operand>" "r<const_atomic>"))
+       (match_operand:SI 3 "const_int_operand")]
+      UNSPECV_ATOMIC_LDOP))]
+  "TARGET_LSE"
+  "#"
+  "&& reload_completed"
+  [(const_int 0)]
+  {
+    aarch64_gen_atomic_ldop (<CODE>, operands[0], NULL, operands[1],
+			     operands[2], operands[3]);
+    DONE;
+  }
+)
+
 (define_insn_and_split "atomic_fetch_nand<mode>"
   [(set (match_operand:ALLI 0 "register_operand" "=&r")
     (match_operand:ALLI 1 "aarch64_sync_memory_operand" "+Q"))
@@ -205,7 +398,31 @@
   }
 )
 
-(define_insn_and_split "atomic_<atomic_optab>_fetch<mode>"
+;; Load-operate-store, returning the original memory data.
+
+(define_expand "atomic_<atomic_optab>_fetch<mode>"
+ [(match_operand:ALLI 0 "register_operand" "")
+  (atomic_op:ALLI
+   (match_operand:ALLI 1 "aarch64_sync_memory_operand" "")
+   (match_operand:ALLI 2 "<atomic_op_operand>" ""))
+  (match_operand:SI 3 "const_int_operand")]
+ ""
+{
+  rtx (*gen) (rtx, rtx, rtx, rtx);
+  rtx value = operands[2];
+
+  /* Use an atomic load-operate instruction when possible.  */
+  if (aarch64_atomic_ldop_supported_p (<CODE>))
+    gen = gen_aarch64_atomic_<atomic_optab>_fetch<mode>_lse;
+  else
+    gen = gen_aarch64_atomic_<atomic_optab>_fetch<mode>;
+
+  emit_insn (gen (operands[0], operands[1], value, operands[3]));
+
+  DONE;
+})
+
+(define_insn_and_split "aarch64_atomic_<atomic_optab>_fetch<mode>"
   [(set (match_operand:ALLI 0 "register_operand" "=&r")
     (atomic_op:ALLI
       (match_operand:ALLI 1 "aarch64_sync_memory_operand" "+Q")
@@ -228,6 +445,29 @@
   }
 )
 
+(define_insn_and_split "aarch64_atomic_<atomic_optab>_fetch<mode>_lse"
+  [(set (match_operand:ALLI 0 "register_operand" "=&r")
+    (atomic_op:ALLI
+     (match_operand:ALLI 1 "aarch64_sync_memory_operand" "+Q")
+     (match_operand:ALLI 2 "<atomic_op_operand>" "r<const_atomic>")))
+   (set (match_dup 1)
+    (unspec_volatile:ALLI
+      [(match_dup 1)
+       (match_dup 2)
+       (match_operand:SI 3 "const_int_operand")]
+      UNSPECV_ATOMIC_LDOP))
+     (clobber (match_scratch:ALLI 4 "=r"))]
+  "TARGET_LSE"
+  "#"
+  "&& reload_completed"
+  [(const_int 0)]
+  {
+    aarch64_gen_atomic_ldop (<CODE>, operands[4], operands[0], operands[1],
+			     operands[2], operands[3]);
+    DONE;
+  }
+)
+
 (define_insn_and_split "atomic_nand_fetch<mode>"
   [(set (match_operand:ALLI 0 "register_operand" "=&r")
     (not:ALLI
@@ -370,3 +610,100 @@
       return "dmb\\tish";
   }
 )
+
+;; ARMv8.1 LSE instructions.
+
+;; Atomic swap with memory.
+(define_insn "aarch64_atomic_swp<mode>"
+ [(set (match_operand:ALLI 0 "register_operand" "+&r")
+   (match_operand:ALLI 1 "aarch64_sync_memory_operand" "+Q"))
+  (set (match_dup 1)
+   (unspec_volatile:ALLI
+    [(match_operand:ALLI 2 "register_operand" "r")
+     (match_operand:SI 3 "const_int_operand" "")]
+    UNSPECV_ATOMIC_SWP))]
+  "TARGET_LSE && reload_completed"
+  {
+    enum memmodel model = memmodel_from_int (INTVAL (operands[3]));
+    if (is_mm_relaxed (model))
+      return "swp<atomic_sfx>\t%<w>2, %<w>0, %1";
+    else if (is_mm_acquire (model) || is_mm_consume (model))
+      return "swpa<atomic_sfx>\t%<w>2, %<w>0, %1";
+    else if (is_mm_release (model))
+      return "swpl<atomic_sfx>\t%<w>2, %<w>0, %1";
+    else
+      return "swpal<atomic_sfx>\t%<w>2, %<w>0, %1";
+  })
+
+;; Atomic compare-and-swap: HI and smaller modes.
+
+(define_insn "aarch64_atomic_cas<mode>"
+ [(set (match_operand:SI 0 "register_operand" "+&r")		  ;; out
+   (zero_extend:SI
+    (match_operand:SHORT 1 "aarch64_sync_memory_operand" "+Q")))  ;; memory.
+  (set (match_dup 1)
+   (unspec_volatile:SHORT
+    [(match_dup 0)
+     (match_operand:SHORT 2 "register_operand" "r")	;; value.
+     (match_operand:SI 3 "const_int_operand" "")]	;; model.
+    UNSPECV_ATOMIC_CAS))]
+ "TARGET_LSE && reload_completed"
+{
+  enum memmodel model = memmodel_from_int (INTVAL (operands[3]));
+  if (is_mm_relaxed (model))
+    return "cas<atomic_sfx>\t%<w>0, %<w>2, %1";
+  else if (is_mm_acquire (model) || is_mm_consume (model))
+    return "casa<atomic_sfx>\t%<w>0, %<w>2, %1";
+  else if (is_mm_release (model))
+    return "casl<atomic_sfx>\t%<w>0, %<w>2, %1";
+  else
+    return "casal<atomic_sfx>\t%<w>0, %<w>2, %1";
+})
+
+;; Atomic compare-and-swap: SI and larger modes.
+
+(define_insn "aarch64_atomic_cas<mode>"
+ [(set (match_operand:GPI 0 "register_operand" "+&r")	      ;; out
+   (match_operand:GPI 1 "aarch64_sync_memory_operand" "+Q"))  ;; memory.
+  (set (match_dup 1)
+   (unspec_volatile:GPI
+    [(match_dup 0)
+     (match_operand:GPI 2 "register_operand" "r")	;; value.
+     (match_operand:SI 3 "const_int_operand" "")]	;; model.
+    UNSPECV_ATOMIC_CAS))]
+  "TARGET_LSE && reload_completed"
+{
+    enum memmodel model = memmodel_from_int (INTVAL (operands[3]));
+    if (is_mm_relaxed (model))
+      return "cas<atomic_sfx>\t%<w>0, %<w>2, %1";
+    else if (is_mm_acquire (model) || is_mm_consume (model))
+      return "casa<atomic_sfx>\t%<w>0, %<w>2, %1";
+    else if (is_mm_release (model))
+      return "casl<atomic_sfx>\t%<w>0, %<w>2, %1";
+    else
+      return "casal<atomic_sfx>\t%<w>0, %<w>2, %1";
+})
+
+;; Atomic load-op: Load data, operate, store result, keep data.
+
+(define_insn "aarch64_atomic_load<atomic_ldop><mode>"
+ [(set (match_operand:ALLI 0 "register_operand" "=r")
+   (match_operand:ALLI 1 "aarch64_sync_memory_operand" "+Q"))
+  (set (match_dup 1)
+   (unspec_volatile:ALLI
+    [(match_dup 1)
+     (match_operand:ALLI 2 "register_operand")
+     (match_operand:SI 3 "const_int_operand")]
+    ATOMIC_LDOP))]
+ "TARGET_LSE && reload_completed"
+ {
+   enum memmodel model = memmodel_from_int (INTVAL (operands[3]));
+   if (is_mm_relaxed (model))
+     return "ld<atomic_ldop><atomic_sfx>\t%<w>2, %<w>0, %1";
+   else if (is_mm_acquire (model) || is_mm_consume (model))
+     return "ld<atomic_ldop>a<atomic_sfx>\t%<w>2, %<w>0, %1";
+   else if (is_mm_release (model))
+     return "ld<atomic_ldop>l<atomic_sfx>\t%<w>2, %<w>0, %1";
+   else
+     return "ld<atomic_ldop>al<atomic_sfx>\t%<w>2, %<w>0, %1";
+ })
--- /dev/null
+++ b/src/gcc/config/aarch64/cortex-a57-fma-steering.c
@@ -0,0 +1,1099 @@
+/* FMA steering optimization pass for Cortex-A57.
+   Copyright (C) 2015 Free Software Foundation, Inc.
+   Contributed by ARM Ltd.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GCC is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+#include "regs.h"
+#include "insn-config.h"
+#include "hard-reg-set.h"
+#include "dominance.h"
+#include "cfg.h"
+#include "cfganal.h"
+#include "predict.h"
+#include "basic-block.h"
+#include "insn-attr.h"
+#include "machmode.h"
+#include "recog.h"
+#include "output.h"
+#include "vec.h"
+#include "hash-map.h"
+#include "bitmap.h"
+#include "obstack.h"
+#include "df.h"
+#include "target.h"
+#include "rtl.h"
+#include "context.h"
+#include "tree-pass.h"
+#include "regrename.h"
+#include "cortex-a57-fma-steering.h"
+#include "aarch64-protos.h"
+
+#include <list>
+
+/* For better performance, the destination of FMADD/FMSUB instructions should
+   have the same parity as their accumulator register if the accumulator
+   contains the result of a previous FMUL or FMADD/FMSUB instruction if
+   targetting Cortex-A57 processors.  Performance is also increased by
+   otherwise keeping a good balance in the parity of the destination register
+   of FMUL or FMADD/FMSUB.
+
+   This pass ensure that registers are renamed so that these conditions hold.
+   We reuse the existing register renaming facility from regrename.c to build
+   dependency chains and expose candidate registers for renaming.
+
+
+   The algorithm has three steps:
+
+   First, the functions of the register renaming pass are called.  These
+   analyze the instructions and produce a list of def/use chains of
+   instructions.
+
+   Next, this information is used to build trees of multiply and
+   multiply-accumulate instructions.  The roots of these trees are any
+   multiply, or any multiply-accumulate whose accumulator is not dependent on
+   a multiply or multiply-accumulate instruction.  A child is added to the
+   tree where a dependency chain exists between the result of the parent
+   instruction and the accumulator operand of the child, as in the diagram
+   below:
+
+		 fmul s2, s0, s1
+		/		\
+   fmadd s0, s1, s1, s2   fmadd s4, s1, s1 s2
+	    |
+   fmadd s3, s1, s1, s0
+
+   Trees made of a single instruction are permitted.
+
+   Finally, renaming is performed.  The parity of the destination register at
+   the root of a tree is checked against the current balance of multiply and
+   multiply-accumulate on each pipeline.  If necessary, the root of a tree is
+   renamed, in which case the rest of the tree is then renamed to keep the same
+   parity in the destination registers of all instructions in the tree.  */
+
+
+
+/* Forward declarations.  */
+class fma_node;
+class fma_root_node;
+class func_fma_steering;
+
+/* Dependencies between FMUL or FMADD/FMSUB instructions and subsequent
+   FMADD/FMSUB instructions form a graph.  This is because alternatives can
+   make a register be set by several FMUL or FMADD/FMSUB instructions in
+   different basic blocks and because of loops.  For ease of browsing, the
+   connected components of this graph are broken up into forests of trees.
+   Forests are represented by fma_forest objects, contained in the fma_forests
+   list.  Using a separate object for the forests allows for a better use of
+   memory as there is some information that is global to each forest, such as
+   the number of FMSUB and FMADD/FMSUB instructions currently scheduled on each
+   floating-point execution pipelines.  */
+
+class fma_forest
+{
+public:
+  fma_forest (func_fma_steering *, fma_root_node *, int);
+  ~fma_forest ();
+
+  int get_id ();
+  std::list<fma_root_node *> *get_roots ();
+  func_fma_steering *get_globals ();
+  int get_target_parity ();
+  void fma_node_created (fma_node *);
+  void merge_forest (fma_forest *);
+  void dump_info ();
+  void dispatch ();
+
+private:
+  /* The list of roots that form this forest.  */
+  std::list<fma_root_node *> *m_roots;
+
+  /* Target parity the destination register of all FMUL and FMADD/FMSUB
+     instructions in this forest should have.  */
+  int m_target_parity;
+
+  /* Link to the instance of func_fma_steering holding data related to the
+     FMA steering of the current function (cfun).  */
+  func_fma_steering *m_globals;
+
+  /* Identifier for the forest (used for dumps).  */
+  int m_id;
+
+  /* Total number of nodes in the forest (for statistics).  */
+  int m_nb_nodes;
+};
+
+class fma_node
+{
+public:
+  fma_node (fma_node *parent, du_chain *chain);
+  ~fma_node ();
+
+  bool root_p ();
+  fma_forest *get_forest ();
+  std::list<fma_node *> *get_children ();
+  rtx_insn *get_insn ();
+  void add_child (fma_node *);
+  int get_parity ();
+  void set_head (du_head *);
+  void rename (fma_forest *);
+  void dump_info (fma_forest *);
+
+protected:
+  /* Root node that lead to this node.  */
+  fma_root_node *m_root;
+
+  /* The parent node of this node.  If the node belong to a chain with several
+     parent nodes, the first one encountered in a depth-first search is chosen
+     as canonical parent.  */
+  fma_node *m_parent;
+
+  /* The list of child nodes.  If a chain contains several parent nodes, one is
+     chosen as canonical parent and the others will have no children.  */
+  std::list<fma_node *> *m_children;
+
+  /* The associated DU_HEAD chain that the insn represented by this object
+     is (one of) the root of.  When a chain contains several roots, the non
+     canonical ones have this field set to NULL.  */
+  struct du_head *m_head;
+
+  /* The FMUL or FMADD/FMSUB instruction this object corresponds to.  */
+  rtx_insn *m_insn;
+};
+
+class fma_root_node : public fma_node
+{
+public:
+  fma_root_node (func_fma_steering *, du_chain *, int);
+
+  fma_forest *get_forest ();
+  void set_forest (fma_forest *);
+  void dump_info (fma_forest *);
+
+private:
+  /* The forest this node belonged to when it was created.  */
+  fma_forest *m_forest;
+};
+
+/* Class holding all data and methods relative to the FMA steering of a given
+   function.  The FMA steering pass could then run in parallel for different
+   functions.  */
+
+class func_fma_steering
+{
+public:
+  func_fma_steering ();
+  ~func_fma_steering ();
+
+  int get_fpu_balance ();
+  void remove_forest (fma_forest *);
+  bool put_node (fma_node *);
+  void update_balance (int);
+  fma_node *get_fma_node (rtx_insn *);
+  void analyze_fma_fmul_insn (fma_forest *, du_chain *, du_head_p);
+  void execute_fma_steering ();
+
+private:
+  void dfs (void (*) (fma_forest *), void (*) (fma_forest *, fma_root_node *),
+	    void (*) (fma_forest *, fma_node *), bool);
+  void analyze ();
+  void rename_fma_trees ();
+
+  /* Mapping between FMUL or FMADD/FMSUB instructions and the associated
+     fma_node object.  Used when analyzing an instruction that is a root of
+     a chain to find if such an object was created because this instruction
+     is also a use in another chain.  */
+  hash_map<rtx_insn *, fma_node *> *m_insn_fma_head_map;
+
+  /* A list of all the forests in a given function.  */
+  std::list<fma_forest *> m_fma_forests;
+
+  /* Balance of FMUL and FMADD/FMSUB instructions between the two FPU
+     pipelines:
+     < 0: more instruction dispatched to the first pipeline
+     == 0: perfect balance
+     > 0: more instruction dispatched to the second pipeline.  */
+  int m_fpu_balance;
+
+  /* Identifier for the next forest created.  */
+  int m_next_forest_id;
+};
+
+/* Rename the register HEAD->regno in all the insns in the chain HEAD to any
+   register not in the set UNAVAILABLE.  Adapted from rename_chains in
+   regrename.c.  */
+
+static bool
+rename_single_chain (du_head_p head, HARD_REG_SET *unavailable)
+{
+  int best_new_reg;
+  int n_uses = 0;
+  struct du_chain *tmp;
+  int reg = head->regno;
+  enum reg_class super_class = NO_REGS;
+
+  if (head->cannot_rename)
+    return false;
+
+  if (fixed_regs[reg] || global_regs[reg]
+      || (frame_pointer_needed && reg == HARD_FRAME_POINTER_REGNUM))
+    return false;
+
+  /* Iterate over elements in the chain in order to:
+     1. Count number of uses, and narrow the set of registers we can
+	use for renaming.
+     2. Compute the superunion of register classes in this chain.  */
+  for (tmp = head->first; tmp; tmp = tmp->next_use)
+    {
+      if (DEBUG_INSN_P (tmp->insn))
+	continue;
+      n_uses++;
+      IOR_COMPL_HARD_REG_SET (*unavailable, reg_class_contents[tmp->cl]);
+      super_class = reg_class_superunion[(int) super_class][(int) tmp->cl];
+    }
+
+  if (n_uses < 1)
+    return false;
+
+  best_new_reg = find_rename_reg (head, super_class, unavailable, reg,
+				  false);
+
+  if (dump_file)
+    {
+      fprintf (dump_file, "Register %s in insn %d", reg_names[reg],
+	       INSN_UID (head->first->insn));
+      if (head->need_caller_save_reg)
+	fprintf (dump_file, " crosses a call");
+    }
+
+  if (best_new_reg == reg)
+    {
+      if (dump_file)
+	fprintf (dump_file, "; no available better choice\n");
+      return false;
+    }
+
+  if (regrename_do_replace (head, best_new_reg))
+    {
+      if (dump_file)
+	fprintf (dump_file, ", renamed as %s\n", reg_names[best_new_reg]);
+      df_set_regs_ever_live (best_new_reg, true);
+    }
+  else
+    {
+      if (dump_file)
+	fprintf (dump_file, ", renaming as %s failed\n",
+		 reg_names[best_new_reg]);
+      return false;
+    }
+  return true;
+}
+
+/* Return whether T is the attribute of a FMADD/FMSUB-like instruction.  */
+
+static bool
+is_fmac_op (enum attr_type t)
+{
+  return (t == TYPE_FMACS) || (t == TYPE_FMACD) || (t == TYPE_NEON_FP_MLA_S);
+}
+
+/* Return whether T is the attribute of a FMUL instruction.  */
+
+static bool
+is_fmul_op (enum attr_type t)
+{
+  return (t == TYPE_FMULS) || (t == TYPE_FMULD) || (t == TYPE_NEON_FP_MUL_S);
+}
+
+/* Return whether INSN is an FMUL (if FMUL_OK is true) or FMADD/FMSUB
+   instruction.  */
+
+static bool
+is_fmul_fmac_insn (rtx_insn *insn, bool fmul_ok)
+{
+  enum attr_type t;
+
+  if (!NONDEBUG_INSN_P (insn))
+    return false;
+
+  if (recog_memoized (insn) < 0)
+    return false;
+
+  /* Only consider chain(s) this instruction is a root of if this is an FMUL or
+     FMADD/FMSUB instruction.  This allows to avoid browsing chains of all
+     instructions for FMUL or FMADD/FMSUB in them.  */
+  t = get_attr_type (insn);
+  return is_fmac_op (t) || (fmul_ok && is_fmul_op (t));
+}
+
+
+/*
+ * Class fma_forest method definitions.
+ */
+
+fma_forest::fma_forest (func_fma_steering *fma_steer, fma_root_node *fma_root,
+			int id)
+{
+      memset (this, 0, sizeof (*this));
+      this->m_globals = fma_steer;
+      this->m_roots = new std::list<fma_root_node *>;
+      this->m_roots->push_back (fma_root);
+      this->m_id = id;
+}
+
+fma_forest::~fma_forest ()
+{
+  delete this->m_roots;
+}
+
+int
+fma_forest::get_id ()
+{
+  return this->m_id;
+}
+
+std::list<fma_root_node *> *
+fma_forest::get_roots ()
+{
+  return this->m_roots;
+}
+
+func_fma_steering *
+fma_forest::get_globals ()
+{
+  return this->m_globals;
+}
+
+int
+fma_forest::get_target_parity ()
+{
+  return this->m_target_parity;
+}
+
+/* Act on the creation of NODE by updating statistics in FOREST and adding an
+   entry for it in the func_fma_steering hashmap.  */
+
+void fma_forest::fma_node_created (fma_node *node)
+{
+  bool created = !this->m_globals->put_node (node);
+
+  gcc_assert (created);
+  this->m_nb_nodes++;
+}
+
+/* Merge REF_FOREST and OTHER_FOREST together, making REF_FOREST the canonical
+   fma_forest object to represent both.  */
+
+void
+fma_forest::merge_forest (fma_forest *other_forest)
+{
+  std::list<fma_root_node *> *other_roots;
+  std::list<fma_root_node *>::iterator other_root_iter;
+
+  if (this == other_forest)
+    return;
+
+  other_roots = other_forest->m_roots;
+
+  /* Update root nodes' pointer to forest.  */
+  for (other_root_iter = other_roots->begin ();
+       other_root_iter != other_roots->end (); other_root_iter++)
+    (*other_root_iter)->set_forest (this);
+
+  /* Remove other_forest from the list of forests and move its tree roots in
+     the list of tree roots of ref_forest.  */
+  this->m_globals->remove_forest (other_forest);
+  this->m_roots->splice (this->m_roots->begin (), *other_roots);
+  delete other_forest;
+
+  this->m_nb_nodes += other_forest->m_nb_nodes;
+}
+
+/* Dump information about the forest FOREST.  */
+
+void
+fma_forest::dump_info ()
+{
+  gcc_assert (dump_file);
+
+  fprintf (dump_file, "Forest #%d has %d nodes\n", this->m_id,
+	   this->m_nb_nodes);
+}
+
+/* Wrapper around fma_forest::dump_info for use as parameter of function
+   pointer type in func_fma_steering::dfs.  */
+
+static void
+dump_forest_info (fma_forest *forest)
+{
+  forest->dump_info ();
+}
+
+/* Dispatch forest to the least utilized pipeline.  */
+
+void
+fma_forest::dispatch ()
+{
+  this->m_target_parity = this->m_roots->front ()->get_parity ();
+  int fpu_balance = this->m_globals->get_fpu_balance ();
+  if (fpu_balance != 0)
+    this->m_target_parity = (fpu_balance < 0);
+
+  if (dump_file)
+    fprintf (dump_file, "Target parity for forest #%d: %s\n", this->m_id,
+	     this->m_target_parity ? "odd" : "even");
+}
+
+/* Wrapper around fma_forest::dispatch for use as parameter of function pointer
+   type in func_fma_steering::dfs.  */
+
+static void
+dispatch_forest (fma_forest *forest)
+{
+  forest->dispatch ();
+}
+
+fma_node::fma_node (fma_node *parent, du_chain *chain)
+{
+  memset (this, 0, sizeof (*this));
+  this->m_parent = parent;
+  this->m_children = new std::list<fma_node *>;
+  this->m_insn = chain->insn;
+  /* root_p () cannot be used to check for root before root is set.  */
+  if (this->m_parent == this)
+    this->m_root = static_cast<fma_root_node *> (parent);
+  else
+    {
+      this->m_root = parent->m_root;
+      this->get_forest ()->fma_node_created (this);
+    }
+}
+
+fma_node::~fma_node ()
+{
+  delete this->m_children;
+}
+
+std::list<fma_node *> *
+fma_node::get_children ()
+{
+  return this->m_children;
+}
+
+rtx_insn *
+fma_node::get_insn ()
+{
+  return this->m_insn;
+}
+
+void
+fma_node::set_head (du_head *head)
+{
+  gcc_assert (!this->m_head);
+  this->m_head = head;
+}
+
+/* Add a child to this node in the list of children.  */
+
+void
+fma_node::add_child (fma_node *child)
+{
+  this->m_children->push_back (child);
+}
+
+/* Return the parity of the destination register of the instruction represented
+   by this node.  */
+
+int
+fma_node::get_parity ()
+{
+  return this->m_head->regno % 2;
+}
+
+/* Get the actual forest associated with a non root node as the one the node
+   points to might have been merged into another one.  In that case the pointer
+   in the root nodes are updated so we return the forest pointer of a root node
+   pointed to by the initial forest.  Despite being a oneliner, this method is
+   defined here as it references a method from fma_root_node.  */
+
+fma_forest *
+fma_node::get_forest ()
+{
+  return this->m_root->get_forest ();
+}
+
+/* Return whether a node is a root node.  */
+
+bool
+fma_node::root_p ()
+{
+  return this->m_root == this;
+}
+
+/* Dump information about the children of node FMA_NODE in forest FOREST.  */
+
+void
+fma_node::dump_info (ATTRIBUTE_UNUSED fma_forest *forest)
+{
+  struct du_chain *chain;
+  std::list<fma_node *>::iterator fma_child;
+
+  gcc_assert (dump_file);
+
+  if (this->get_children ()->empty ())
+    return;
+
+  fprintf (dump_file, "Instruction(s)");
+  for (chain = this->m_head->first; chain; chain = chain->next_use)
+    {
+      if (!is_fmul_fmac_insn (chain->insn, true))
+	continue;
+
+      if (chain->loc != &SET_DEST (PATTERN (chain->insn)))
+	continue;
+
+      fprintf (dump_file, " %d", INSN_UID (chain->insn));
+    }
+
+  fprintf (dump_file, " is(are) accumulator dependency of instructions");
+  for (fma_child = this->get_children ()->begin ();
+       fma_child != this->get_children ()->end (); fma_child++)
+    fprintf (dump_file, " %d", INSN_UID ((*fma_child)->m_insn));
+  fprintf (dump_file, "\n");
+}
+
+/* Wrapper around fma_node::dump_info for use as parameter of function pointer
+   type in func_fma_steering::dfs.  */
+
+static void
+dump_tree_node_info (fma_forest *forest, fma_node *node)
+{
+  node->dump_info (forest);
+}
+
+/* Rename the destination register of a single FMUL or FMADD/FMSUB instruction
+   represented by FMA_NODE to a register that respect the target parity for
+   FOREST or with same parity of the instruction represented by its parent node
+   if it has one.  */
+
+void
+fma_node::rename (fma_forest *forest)
+{
+  int cur_parity, target_parity;
+
+  /* This is alternate root of a chain and thus has no children.  It will be
+     renamed when processing the canonical root for that chain.  */
+  if (!this->m_head)
+    return;
+
+  target_parity = forest->get_target_parity ();
+  if (this->m_parent)
+    target_parity = this->m_parent->get_parity ();
+  cur_parity = this->get_parity ();
+
+  /* Rename if parity differs.  */
+  if (cur_parity != target_parity)
+    {
+      rtx_insn *insn = this->m_insn;
+      HARD_REG_SET unavailable;
+      enum machine_mode mode;
+      int reg;
+
+      if (dump_file)
+	{
+	  unsigned cur_dest_reg = this->m_head->regno;
+
+	  fprintf (dump_file, "FMA or FMUL at insn %d but destination "
+		   "register (%s) has different parity from expected to "
+		   "maximize FPU pipeline utilization\n", INSN_UID (insn),
+		   reg_names[cur_dest_reg]);
+	}
+
+      /* Don't clobber traceback for noreturn functions.  */
+      CLEAR_HARD_REG_SET (unavailable);
+      if (frame_pointer_needed)
+	{
+	  add_to_hard_reg_set (&unavailable, Pmode, FRAME_POINTER_REGNUM);
+	  add_to_hard_reg_set (&unavailable, Pmode, HARD_FRAME_POINTER_REGNUM);
+	}
+
+      /* Exclude registers with wrong parity.  */
+      mode = GET_MODE (SET_DEST (PATTERN (insn)));
+      for (reg = cur_parity; reg < FIRST_PSEUDO_REGISTER; reg += 2)
+	add_to_hard_reg_set (&unavailable, mode, reg);
+
+      if (!rename_single_chain (this->m_head, &unavailable))
+	{
+	  if (dump_file)
+	    fprintf (dump_file, "Destination register of insn %d could not be "
+		     "renamed. Dependent FMA insns will use this parity from "
+		     "there on.\n", INSN_UID (insn));
+	}
+      else
+	cur_parity = target_parity;
+    }
+
+  forest->get_globals ()->update_balance (cur_parity);
+}
+
+/* Wrapper around fma_node::dump_info for use as parameter of function pointer
+   type in func_fma_steering::dfs.  */
+
+static void
+rename_fma_node (fma_forest *forest, fma_node *node)
+{
+  node->rename (forest);
+}
+
+fma_root_node::fma_root_node (func_fma_steering *globals, du_chain *chain,
+			      int id) : fma_node (this, chain)
+{
+  this->m_forest = new fma_forest (globals, this, id);
+  this->m_forest->fma_node_created (this);
+}
+
+fma_forest *
+fma_root_node::get_forest ()
+{
+  return this->m_forest;
+}
+
+void
+fma_root_node::set_forest (fma_forest *ref_forest)
+{
+  this->m_forest = ref_forest;
+}
+
+/* Dump information about the roots of forest FOREST.  */
+
+void
+fma_root_node::dump_info (fma_forest *forest)
+{
+  gcc_assert (dump_file);
+
+  if (this == forest->get_roots ()->front ())
+    fprintf (dump_file, "Instruction(s) at root of forest #%d:",
+	     forest->get_id ());
+  fprintf (dump_file, " %d", INSN_UID (this->m_insn));
+  if (this == forest->get_roots ()->back ())
+    fprintf (dump_file, "\n");
+}
+
+/* Wrapper around fma_root_node::dump_info for use as parameter of function
+   pointer type in func_fma_steering::dfs.  */
+
+static void
+dump_tree_root_info (fma_forest *forest, fma_root_node *node)
+{
+  node->dump_info (forest);
+}
+
+func_fma_steering::func_fma_steering () : m_fpu_balance (0)
+{
+  this->m_insn_fma_head_map = new hash_map<rtx_insn *, fma_node *>;
+  this->m_fma_forests.clear ();
+  this->m_next_forest_id = 0;
+}
+
+func_fma_steering::~func_fma_steering ()
+{
+  delete this->m_insn_fma_head_map;
+}
+
+int
+func_fma_steering::get_fpu_balance ()
+{
+  return this->m_fpu_balance;
+}
+
+void
+func_fma_steering::remove_forest (fma_forest *forest)
+{
+  this->m_fma_forests.remove (forest);
+}
+
+/* Memorize the mapping of this instruction to its fma_node object and return
+   whether such a mapping existed.  */
+
+bool
+func_fma_steering::put_node (fma_node *node)
+{
+  return this->m_insn_fma_head_map->put (node->get_insn (), node);
+}
+
+/* Update the current balance considering a node with the given PARITY.  */
+
+void
+func_fma_steering::update_balance (int parity)
+{
+  this->m_fpu_balance = parity ? this->m_fpu_balance + 1
+			       : this->m_fpu_balance - 1;
+}
+
+/* Return whether an fma_node object exists for instruction INSN and, if not,
+   allocate one in *RET.  */
+
+fma_node *
+func_fma_steering::get_fma_node (rtx_insn *insn)
+{
+  fma_node **fma_slot;
+
+  fma_slot = this->m_insn_fma_head_map->get (insn);
+  if (fma_slot)
+    return *fma_slot;
+  return NULL;
+}
+
+/* Allocate and initialize fma_node objects for the FMUL or FMADD/FMSUB
+   instruction in CHAIN->insn and its dependent FMADD/FMSUB instructions, all
+   part of FOREST.  For the children, the associated head is left untouched
+   (and thus null) as this function will be called again when considering the
+   chain where they are def.  For the parent, the chain is given in HEAD.  */
+
+void
+func_fma_steering::analyze_fma_fmul_insn (fma_forest *ref_forest,
+					  du_chain *chain, du_head_p head)
+{
+  fma_forest *forest;
+  fma_node *node = this->get_fma_node (chain->insn);
+
+  /* This is a root node.  */
+  if (!node)
+    {
+      fma_root_node *root_node;
+
+      root_node = new fma_root_node (this, chain, this->m_next_forest_id++);
+      forest = root_node->get_forest ();
+      node = root_node;
+
+      /* Until proved otherwise, assume this root is not part of an existing
+	 forest and thus add its forest to the list of forests.  */
+      this->m_fma_forests.push_back (forest);
+    }
+  else
+    forest = node->get_forest ();
+
+  node->set_head (head);
+
+  /* fma_node is part of a chain with several defs, one of them having already
+     been processed.  The root of that already processed def is the canonical
+     one and the root of fma_node is added to its forest.  No need to process
+     the children nodes as they were already processed when the other def was
+     processed.  */
+  if (ref_forest)
+    {
+      ref_forest->merge_forest (forest);
+      return;
+    }
+
+  for (chain = head->first; chain; chain = chain->next_use)
+    {
+      fma_node *child_fma;
+      rtx fma_rtx, *accum_rtx_p;
+
+      if (!is_fmul_fmac_insn (chain->insn, false))
+	continue;
+
+      /* Get FMA rtx.  */
+      fma_rtx = SET_SRC (PATTERN (chain->insn));
+      /* FMA is negated.  */
+      if (GET_CODE (fma_rtx) == NEG)
+	fma_rtx = XEXP (fma_rtx, 0);
+      /* Get accumulator rtx.  */
+      accum_rtx_p = &XEXP (fma_rtx, 2);
+      /* Accumulator is negated.  */
+      if (!REG_P (*accum_rtx_p))
+	accum_rtx_p = &XEXP (*accum_rtx_p, 0);
+
+      /* This du_chain structure is not for the accumulator register.  */
+      if (accum_rtx_p != chain->loc)
+	continue;
+
+      /* If object already created, this is a loop carried dependency.  We
+	 don't include this object in the children as we want trees for
+	 rename_fma_trees to not be an infinite loop.  */
+      if (this->get_fma_node (chain->insn))
+	continue;
+
+      child_fma = new fma_node (node, chain);
+
+      /* Memorize the mapping of this instruction to its fma_node object
+	 as it will be processed for the chain starting at its destination
+	 register later.  */
+
+      /* Link to siblings.  */
+      node->add_child (child_fma);
+    }
+}
+
+/* Perform a depth-first search of the forests of fma_node in
+   THIS->m_fma_forests, calling PROCESS_FOREST () on each fma_forest object in
+   THIS->m_fma_forests list, PROCESS_ROOT () on each tree root and
+   PROCESS_NODE () on each node.  If FREE is true, free all std::list in the
+   same dfs.  */
+
+void
+func_fma_steering::dfs (void (*process_forest) (fma_forest *),
+			void (*process_root) (fma_forest *, fma_root_node *),
+			void (*process_node) (fma_forest *, fma_node *),
+			bool free)
+{
+  vec<fma_node *> to_process;
+  std::list<fma_forest *>::iterator forest_iter;
+
+  to_process.create (0);
+
+  /* For each forest.  */
+  for (forest_iter = this->m_fma_forests.begin ();
+       forest_iter != this->m_fma_forests.end (); forest_iter++)
+    {
+      std::list<fma_root_node *>::iterator root_iter;
+
+      if (process_forest)
+	process_forest (*forest_iter);
+
+      /* For each tree root in this forest.  */
+      for (root_iter = (*forest_iter)->get_roots ()->begin ();
+	   root_iter != (*forest_iter)->get_roots ()->end (); root_iter++)
+	{
+	  if (process_root)
+	    process_root (*forest_iter, *root_iter);
+	  to_process.safe_push (*root_iter);
+	}
+
+      /* For each tree node in this forest.  */
+      while (!to_process.is_empty ())
+	{
+	  fma_node *node;
+	  std::list<fma_node *>::iterator child_iter;
+
+	  node = to_process.pop ();
+
+	  if (process_node)
+	    process_node (*forest_iter, node);
+
+	  /* Absence of children might indicate an alternate root of a *chain*.
+	     It's ok to skip it here as the chain will be renamed when
+	     processing the canonical root for that chain.  */
+	  if (node->get_children ()->empty ())
+	    continue;
+
+	  for (child_iter = node->get_children ()->begin ();
+	       child_iter != node->get_children ()->end (); child_iter++)
+	    to_process.safe_push (*child_iter);
+	  if (free)
+	    {
+	      if (node->root_p ())
+		delete static_cast<fma_root_node *> (node);
+	      else
+		delete node;
+	    }
+	}
+      if (free)
+	delete *forest_iter;
+    }
+
+  to_process.release ();
+}
+
+/* Build the dependency trees of FMUL and FMADD/FMSUB instructions.  */
+
+void
+func_fma_steering::analyze ()
+{
+  int i, n_blocks, *bb_dfs_preorder;
+  basic_block bb;
+  rtx_insn *insn;
+
+  bb_dfs_preorder = XNEWVEC (int, last_basic_block_for_fn (cfun));
+  n_blocks = pre_and_rev_post_order_compute (bb_dfs_preorder, NULL, false);
+
+  /* Browse the graph of basic blocks looking for FMUL or FMADD/FMSUB
+     instructions.  */
+  for (i = 0; i < n_blocks; i++)
+    {
+      bb = BASIC_BLOCK_FOR_FN (cfun, bb_dfs_preorder[i]);
+      FOR_BB_INSNS (bb, insn)
+	{
+	  operand_rr_info *dest_op_info;
+	  struct du_chain *chain;
+	  unsigned dest_regno;
+	  fma_forest *forest;
+	  du_head_p head;
+	  int i;
+
+	  if (!is_fmul_fmac_insn (insn, true))
+	    continue;
+
+	  /* Search the chain where this instruction is (one of) the root.  */
+	  dest_op_info = insn_rr[INSN_UID (insn)].op_info;
+	  dest_regno = REGNO (SET_DEST (PATTERN (insn)));
+	  for (i = 0; i < dest_op_info->n_chains; i++)
+	    {
+	      /* The register tracked by this chain does not match the
+		 destination register of insn.  */
+	      if (dest_op_info->heads[i]->regno != dest_regno)
+		continue;
+
+	      head = dest_op_info->heads[i];
+	      /* The chain was merged in another, find the new head.  */
+	      if (!head->first)
+		head = regrename_chain_from_id (head->id);
+
+	      /* Search the chain element for this instruction and, if another
+		 FMUL or FMADD/FMSUB instruction was already processed, note
+		 the forest of its tree.  */
+	      forest = NULL;
+	      for (chain = head->first; chain; chain = chain->next_use)
+		{
+		  fma_node **fma_slot;
+
+		  if (!is_fmul_fmac_insn (chain->insn, true))
+		    continue;
+
+		  /* This is a use, continue.  */
+		  if (chain->loc != &SET_DEST (PATTERN (chain->insn)))
+		    continue;
+
+		  if (chain->insn == insn)
+		    break;
+
+		  fma_slot = this->m_insn_fma_head_map->get (chain->insn);
+		  if (fma_slot && (*fma_slot)->get_children ())
+		    forest = (*fma_slot)->get_forest ();
+		}
+	      if (chain)
+		break;
+	    }
+
+	  /* We didn't find a chain with a def for this instruction.  */
+	  gcc_assert (i < dest_op_info->n_chains);
+
+	  this->analyze_fma_fmul_insn (forest, chain, head);
+	}
+    }
+  free (bb_dfs_preorder);
+
+  if (dump_file)
+    this->dfs (dump_forest_info, dump_tree_root_info, dump_tree_node_info,
+	       false);
+}
+
+/* Perform the renaming of all chains with FMUL or FMADD/FMSUB involved with
+   the objective of keeping FPU pipeline balanced in term of instructions and
+   having FMADD/FMSUB with dependencies on previous FMUL or FMADD/FMSUB be
+   scheduled on the same pipeline.  */
+
+void
+func_fma_steering::rename_fma_trees ()
+{
+  this->dfs (dispatch_forest, NULL, rename_fma_node, true);
+
+  if (dump_file && !this->m_fma_forests.empty ())
+    {
+      fprintf (dump_file, "Function %s has ", current_function_name ());
+      if (this->m_fpu_balance == 0)
+	fprintf (dump_file, "perfect balance of FMUL/FMA chains between the "
+		 "two FPU pipelines\n");
+      else if (this->m_fpu_balance > 0)
+	fprintf (dump_file, "%d more FMUL/FMA chains scheduled on the second "
+		 "FPU pipeline\n", this->m_fpu_balance);
+      else /* this->m_fpu_balance < 0 */
+	fprintf (dump_file, "%d more FMUL/FMA chains scheduled on the first "
+		 "FPU pipeline\n", - this->m_fpu_balance);
+    }
+}
+
+/* Execute FMA steering pass.  */
+
+void
+func_fma_steering::execute_fma_steering ()
+{
+  df_set_flags (DF_LR_RUN_DCE);
+  df_note_add_problem ();
+  df_analyze ();
+  df_set_flags (DF_DEFER_INSN_RESCAN);
+
+  regrename_init (true);
+  regrename_analyze (NULL);
+  this->analyze ();
+  this->rename_fma_trees ();
+  regrename_finish ();
+}
+
+const pass_data pass_data_fma_steering =
+{
+  RTL_PASS, /* type */
+  "fma_steering", /* name */
+  OPTGROUP_NONE, /* optinfo_flags */
+  TV_NONE, /* tv_id */
+  0, /* properties_required */
+  0, /* properties_provided */
+  0, /* properties_destroyed */
+  0, /* todo_flags_start */
+  TODO_df_finish, /* todo_flags_finish */
+};
+
+class pass_fma_steering : public rtl_opt_pass
+{
+public:
+  pass_fma_steering (gcc::context *ctxt)
+    : rtl_opt_pass (pass_data_fma_steering, ctxt)
+  {}
+
+  /* opt_pass methods: */
+  virtual bool gate (function *)
+    {
+      return (aarch64_tune_params.extra_tuning_flags
+	      & AARCH64_EXTRA_TUNE_RENAME_FMA_REGS)
+	      && optimize >= 2;
+    }
+
+  virtual unsigned int execute (function *)
+    {
+      func_fma_steering *fma_steering = new func_fma_steering;
+      fma_steering->execute_fma_steering ();
+      delete fma_steering;
+      return 0;
+    }
+
+}; // class pass_fma_steering
+
+/* Create a new fma steering pass instance.  */
+
+static rtl_opt_pass *
+make_pass_fma_steering (gcc::context *ctxt)
+{
+  return new pass_fma_steering (ctxt);
+}
+
+/* Register the FMA steering pass to the pass manager.  */
+
+void
+aarch64_register_fma_steering ()
+{
+  opt_pass *pass_fma_steering = make_pass_fma_steering (g);
+
+  static struct register_pass_info fma_steering_info
+    = { pass_fma_steering, "rnreg", 1, PASS_POS_INSERT_AFTER };
+
+  register_pass (&fma_steering_info);
+}
--- /dev/null
+++ b/src/gcc/config/aarch64/cortex-a57-fma-steering.h
@@ -0,0 +1,22 @@
+/* This file contains declarations for the FMA steering optimization
+   pass for Cortex-A57.
+   Copyright (C) 2015 Free Software Foundation, Inc.
+   Contributed by ARM Ltd.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GCC is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+void aarch64_register_fma_steering (void);
--- /dev/null
+++ b/src/gcc/config/aarch64/driver-aarch64.c
@@ -0,0 +1,307 @@
+/* Native CPU detection for aarch64.
+   Copyright (C) 2015 Free Software Foundation, Inc.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GCC is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "config.h"
+#include "system.h"
+
+struct arch_extension
+{
+  const char *ext;
+  const char *feat_string;
+};
+
+#define AARCH64_OPT_EXTENSION(EXT_NAME, FLAGS_ON, FLAGS_OFF, FEATURE_STRING) \
+  { EXT_NAME, FEATURE_STRING },
+static struct arch_extension ext_to_feat_string[] =
+{
+#include "aarch64-option-extensions.def"
+};
+#undef AARCH64_OPT_EXTENSION
+
+
+struct aarch64_core_data
+{
+  const char* name;
+  const char* arch;
+  const char* implementer_id;
+  const char* part_no;
+};
+
+#define AARCH64_CORE(CORE_NAME, CORE_IDENT, SCHED, ARCH, FLAGS, COSTS, IMP, PART) \
+  { CORE_NAME, #ARCH, IMP, PART },
+
+static struct aarch64_core_data cpu_data [] =
+{
+#include "aarch64-cores.def"
+  { NULL, NULL, NULL, NULL }
+};
+
+#undef AARCH64_CORE
+
+struct aarch64_arch_driver_info
+{
+  const char* id;
+  const char* name;
+};
+
+#define AARCH64_ARCH(NAME, CORE, ARCH_IDENT, ARCH_REV, FLAGS) \
+  { #ARCH_IDENT, NAME  },
+
+static struct aarch64_arch_driver_info aarch64_arches [] =
+{
+#include "aarch64-arches.def"
+  {NULL, NULL}
+};
+
+#undef AARCH64_ARCH
+
+/* Return the full architecture name string corresponding to the
+   identifier ID.  */
+
+static const char*
+get_arch_name_from_id (const char* id)
+{
+  unsigned int i = 0;
+
+  for (i = 0; aarch64_arches[i].id != NULL; i++)
+    {
+      if (strcmp (id, aarch64_arches[i].id) == 0)
+        return aarch64_arches[i].name;
+    }
+
+  return NULL;
+}
+
+
+/* Check wether the string CORE contains the same CPU part numbers
+   as BL_STRING.  For example CORE="{0xd03, 0xd07}" and BL_STRING="0xd07.0xd03"
+   should return true.  */
+
+static bool
+valid_bL_string_p (const char** core, const char* bL_string)
+{
+  return strstr (bL_string, core[0]) != NULL
+         && strstr (bL_string, core[1]) != NULL;
+}
+
+/*  Return true iff ARR contains STR in one of its two elements.  */
+
+static bool
+contains_string_p (const char** arr, const char* str)
+{
+  bool res = false;
+
+  if (arr[0] != NULL)
+    {
+      res = strstr (arr[0], str) != NULL;
+      if (res)
+        return res;
+
+      if (arr[1] != NULL)
+        return strstr (arr[1], str) != NULL;
+    }
+
+  return false;
+}
+
+/* This will be called by the spec parser in gcc.c when it sees
+   a %:local_cpu_detect(args) construct.  Currently it will be called
+   with either "arch", "cpu" or "tune" as argument depending on if
+   -march=native, -mcpu=native or -mtune=native is to be substituted.
+
+   It returns a string containing new command line parameters to be
+   put at the place of the above two options, depending on what CPU
+   this is executed.  E.g. "-march=armv8-a" on a Cortex-A57 for
+   -march=native.  If the routine can't detect a known processor,
+   the -march or -mtune option is discarded.
+
+   For -mtune and -mcpu arguments it attempts to detect the CPU or
+   a big.LITTLE system.
+   ARGC and ARGV are set depending on the actual arguments given
+   in the spec.  */
+
+const char *
+host_detect_local_cpu (int argc, const char **argv)
+{
+  const char *arch_id = NULL;
+  const char *res = NULL;
+  static const int num_exts = ARRAY_SIZE (ext_to_feat_string);
+  char buf[128];
+  FILE *f = NULL;
+  bool arch = false;
+  bool tune = false;
+  bool cpu = false;
+  unsigned int i = 0;
+  unsigned int core_idx = 0;
+  const char* imps[2] = { NULL, NULL };
+  const char* cores[2] = { NULL, NULL };
+  unsigned int n_cores = 0;
+  unsigned int n_imps = 0;
+  bool processed_exts = false;
+  const char *ext_string = "";
+
+  gcc_assert (argc);
+
+  if (!argv[0])
+    goto not_found;
+
+  /* Are we processing -march, mtune or mcpu?  */
+  arch = strcmp (argv[0], "arch") == 0;
+  if (!arch)
+    tune = strcmp (argv[0], "tune") == 0;
+
+  if (!arch && !tune)
+    cpu = strcmp (argv[0], "cpu") == 0;
+
+  if (!arch && !tune && !cpu)
+    goto not_found;
+
+  f = fopen ("/proc/cpuinfo", "r");
+
+  if (f == NULL)
+    goto not_found;
+
+  /* Look through /proc/cpuinfo to determine the implementer
+     and then the part number that identifies a particular core.  */
+  while (fgets (buf, sizeof (buf), f) != NULL)
+    {
+      if (strstr (buf, "implementer") != NULL)
+	{
+	  for (i = 0; cpu_data[i].name != NULL; i++)
+	    if (strstr (buf, cpu_data[i].implementer_id) != NULL
+                && !contains_string_p (imps, cpu_data[i].implementer_id))
+	      {
+                if (n_imps == 2)
+                  goto not_found;
+
+                imps[n_imps++] = cpu_data[i].implementer_id;
+
+                break;
+	      }
+          continue;
+	}
+
+      if (strstr (buf, "part") != NULL)
+	{
+	  for (i = 0; cpu_data[i].name != NULL; i++)
+	    if (strstr (buf, cpu_data[i].part_no) != NULL
+                && !contains_string_p (cores, cpu_data[i].part_no))
+	      {
+                if (n_cores == 2)
+                  goto not_found;
+
+                cores[n_cores++] = cpu_data[i].part_no;
+	        core_idx = i;
+	        arch_id = cpu_data[i].arch;
+	        break;
+	      }
+          continue;
+        }
+      if (!tune && !processed_exts && strstr (buf, "Features") != NULL)
+        {
+          for (i = 0; i < num_exts; i++)
+            {
+              bool enabled = true;
+              char *p = NULL;
+              char *feat_string = concat (ext_to_feat_string[i].feat_string, NULL);
+
+              p = strtok (feat_string, " ");
+
+              while (p != NULL)
+                {
+                  if (strstr (buf, p) == NULL)
+                    {
+                      enabled = false;
+                      break;
+                    }
+                  p = strtok (NULL, " ");
+                }
+              ext_string = concat (ext_string, "+", enabled ? "" : "no",
+                                   ext_to_feat_string[i].ext, NULL);
+            }
+          processed_exts = true;
+        }
+    }
+
+  fclose (f);
+  f = NULL;
+
+  /* Weird cpuinfo format that we don't know how to handle.  */
+  if (n_cores == 0 || n_cores > 2 || n_imps != 1)
+    goto not_found;
+
+  if (arch && !arch_id)
+    goto not_found;
+
+  if (arch)
+    {
+      const char* arch_name = get_arch_name_from_id (arch_id);
+
+      /* We got some arch indentifier that's not in aarch64-arches.def?  */
+      if (!arch_name)
+        goto not_found;
+
+      res = concat ("-march=", arch_name, NULL);
+    }
+  /* We have big.LITTLE.  */
+  else if (n_cores == 2)
+    {
+      for (i = 0; cpu_data[i].name != NULL; i++)
+        {
+          if (strchr (cpu_data[i].part_no, '.') != NULL
+              && strncmp (cpu_data[i].implementer_id, imps[0], strlen (imps[0]) - 1) == 0
+              && valid_bL_string_p (cores, cpu_data[i].part_no))
+            {
+              res = concat ("-m", cpu ? "cpu" : "tune", "=", cpu_data[i].name, NULL);
+              break;
+            }
+        }
+      if (!res)
+        goto not_found;
+    }
+  /* The simple, non-big.LITTLE case.  */
+  else
+    {
+      if (strncmp (cpu_data[core_idx].implementer_id, imps[0],
+                   strlen (imps[0]) - 1) != 0)
+        goto not_found;
+
+      res = concat ("-m", cpu ? "cpu" : "tune", "=",
+                      cpu_data[core_idx].name, NULL);
+    }
+
+  if (tune)
+    return res;
+
+  res = concat (res, ext_string, NULL);
+
+  return res;
+
+not_found:
+  {
+   /* If detection fails we ignore the option.
+      Clean up and return empty string.  */
+
+    if (f)
+      fclose (f);
+
+    return "";
+  }
+}
+
--- a/src/gcc/config/aarch64/iterators.md
+++ b/src/gcc/config/aarch64/iterators.md
@@ -38,6 +38,12 @@
 ;; Iterator for General Purpose Floating-point registers (32- and 64-bit modes)
 (define_mode_iterator GPF [SF DF])
 
+;; Iterator for all scalar floating point modes (HF, SF, DF and TF)
+(define_mode_iterator GPF_TF_F16 [HF SF DF TF])
+
+;; Double vector modes.
+(define_mode_iterator VDF [V2SF V4HF])
+
 ;; Integer vector modes.
 (define_mode_iterator VDQ_I [V8QI V16QI V4HI V8HI V2SI V4SI V2DI])
 
@@ -49,7 +55,7 @@
 (define_mode_iterator VSDQ_I_DI [V8QI V16QI V4HI V8HI V2SI V4SI V2DI DI])
 
 ;; Double vector modes.
-(define_mode_iterator VD [V8QI V4HI V2SI V2SF])
+(define_mode_iterator VD [V8QI V4HI V4HF V2SI V2SF])
 
 ;; vector, 64-bit container, all integer modes
 (define_mode_iterator VD_BHSI [V8QI V4HI V2SI])
@@ -58,10 +64,10 @@
 (define_mode_iterator VDQ_BHSI [V8QI V16QI V4HI V8HI V2SI V4SI])
 
 ;; Quad vector modes.
-(define_mode_iterator VQ [V16QI V8HI V4SI V2DI V4SF V2DF])
+(define_mode_iterator VQ [V16QI V8HI V4SI V2DI V8HF V4SF V2DF])
 
 ;; VQ without 2 element modes.
-(define_mode_iterator VQ_NO2E [V16QI V8HI V4SI V4SF])
+(define_mode_iterator VQ_NO2E [V16QI V8HI V4SI V8HF V4SF])
 
 ;; Quad vector with only 2 element modes.
 (define_mode_iterator VQ_2E [V2DI V2DF])
@@ -76,7 +82,10 @@
 ;; pointer-sized quantities.  Exactly one of the two alternatives will match.
 (define_mode_iterator PTR [(SI "ptr_mode == SImode") (DI "ptr_mode == DImode")])
 
-;; Vector Float modes.
+;; Vector Float modes suitable for moving, loading and storing.
+(define_mode_iterator VDQF_F16 [V4HF V8HF V2SF V4SF V2DF])
+
+;; Vector Float modes, barring HF modes.
 (define_mode_iterator VDQF [V2SF V4SF V2DF])
 
 ;; Vector Float modes, and DF.
@@ -85,6 +94,9 @@
 ;; Vector single Float modes.
 (define_mode_iterator VDQSF [V2SF V4SF])
 
+;; Quad vector Float modes with half/single elements.
+(define_mode_iterator VQ_HSF [V8HF V4SF])
+
 ;; Modes suitable to use as the return type of a vcond expression.
 (define_mode_iterator VDQF_COND [V2SF V2SI V4SF V4SI V2DF V2DI])
 
@@ -94,15 +106,23 @@
 ;; Vector Float modes with 2 elements.
 (define_mode_iterator V2F [V2SF V2DF])
 
-;; All modes.
+;; All vector modes on which we support any arithmetic operations.
 (define_mode_iterator VALL [V8QI V16QI V4HI V8HI V2SI V4SI V2DI V2SF V4SF V2DF])
 
-;; All vector modes and DI.
+;; All vector modes suitable for moving, loading, and storing.
+(define_mode_iterator VALL_F16 [V8QI V16QI V4HI V8HI V2SI V4SI V2DI
+				V4HF V8HF V2SF V4SF V2DF])
+
+;; All vector modes barring HF modes, plus DI.
 (define_mode_iterator VALLDI [V8QI V16QI V4HI V8HI V2SI V4SI V2DI V2SF V4SF V2DF DI])
 
-;; All vector modes and DI and DF.
+;; All vector modes and DI.
+(define_mode_iterator VALLDI_F16 [V8QI V16QI V4HI V8HI V2SI V4SI V2DI
+				  V4HF V8HF V2SF V4SF V2DF DI])
+
+;; All vector modes, plus DI and DF.
 (define_mode_iterator VALLDIF [V8QI V16QI V4HI V8HI V2SI V4SI
-			       V2DI V2SF V4SF V2DF DI DF])
+			       V2DI V4HF V8HF V2SF V4SF V2DF DI DF])
 
 ;; Vector modes for Integer reduction across lanes.
 (define_mode_iterator VDQV [V8QI V16QI V4HI V8HI V4SI V2DI])
@@ -123,7 +143,7 @@
 (define_mode_iterator VQW [V16QI V8HI V4SI])
 
 ;; Double vector modes for combines.
-(define_mode_iterator VDC [V8QI V4HI V2SI V2SF DI DF])
+(define_mode_iterator VDC [V8QI V4HI V4HF V2SI V2SF DI DF])
 
 ;; Vector modes except double int.
 (define_mode_iterator VDQIF [V8QI V16QI V4HI V8HI V2SI V4SI V2SF V4SF V2DF])
@@ -250,6 +270,7 @@
     UNSPEC_USHLL	; Used in aarch64-simd.md.
     UNSPEC_ADDP		; Used in aarch64-simd.md.
     UNSPEC_TBL		; Used in vector permute patterns.
+    UNSPEC_TBX		; Used in vector permute patterns.
     UNSPEC_CONCAT	; Used in vector permute patterns.
     UNSPEC_ZIP1		; Used in vector permute patterns.
     UNSPEC_ZIP2		; Used in vector permute patterns.
@@ -350,7 +371,8 @@
                          (V2SI "2s") (V4SI  "4s")
                          (DI   "1d") (DF    "1d")
                          (V2DI "2d") (V2SF "2s")
-			 (V4SF "4s") (V2DF "2d")])
+			 (V4SF "4s") (V2DF "2d")
+			 (V4HF "4h") (V8HF "8h")])
 
 (define_mode_attr Vrevsuff [(V4HI "16") (V8HI "16") (V2SI "32")
                             (V4SI "32") (V2DI "64")])
@@ -358,7 +380,8 @@
 (define_mode_attr Vmtype [(V8QI ".8b") (V16QI ".16b")
 			 (V4HI ".4h") (V8HI  ".8h")
 			 (V2SI ".2s") (V4SI  ".4s")
-			 (V2DI ".2d") (V2SF ".2s")
+			 (V2DI ".2d") (V4HF ".4h")
+			 (V8HF ".8h") (V2SF ".2s")
 			 (V4SF ".4s") (V2DF ".2d")
 			 (DI   "")    (SI   "")
 			 (HI   "")    (QI   "")
@@ -375,7 +398,8 @@
 (define_mode_attr Vetype [(V8QI "b") (V16QI "b")
 			  (V4HI "h") (V8HI  "h")
                           (V2SI "s") (V4SI  "s")
-			  (V2DI "d") (V2SF  "s")
+			  (V2DI "d") (V4HF "h")
+			  (V8HF "h") (V2SF  "s")
 			  (V4SF "s") (V2DF  "d")
 			  (SF   "s") (DF  "d")
 			  (QI "b")   (HI "h")
@@ -385,7 +409,8 @@
 (define_mode_attr Vbtype [(V8QI "8b")  (V16QI "16b")
 			  (V4HI "8b") (V8HI  "16b")
 			  (V2SI "8b") (V4SI  "16b")
-			  (V2DI "16b") (V2SF  "8b")
+			  (V2DI "16b") (V4HF "8b")
+			  (V8HF "16b") (V2SF  "8b")
 			  (V4SF "16b") (V2DF  "16b")
 			  (DI   "8b")  (DF    "8b")
 			  (SI   "8b")])
@@ -395,6 +420,7 @@
 			(V4HI "HI") (V8HI "HI")
                         (V2SI "SI") (V4SI "SI")
                         (DI "DI")   (V2DI "DI")
+                        (V4HF "HF") (V8HF "HF")
                         (V2SF "SF") (V4SF "SF")
                         (V2DF "DF") (DF "DF")
 			(SI   "SI") (HI   "HI")
@@ -413,6 +439,7 @@
 			 (V4HI "V8HI") (V8HI "V8HI")
 			 (V2SI "V4SI") (V4SI "V4SI")
 			 (DI   "V2DI") (V2DI "V2DI")
+			 (V4HF "V8HF") (V8HF "V8HF")
 			 (V2SF "V2SF") (V4SF "V4SF")
 			 (V2DF "V2DF") (SI   "V4SI")
 			 (HI   "V8HI") (QI   "V16QI")])
@@ -422,16 +449,22 @@
 			 (V4HI "V2HI")  (V8HI  "V4HI")
 			 (V2SI "SI")    (V4SI  "V2SI")
 			 (V2DI "DI")    (V2SF  "SF")
-			 (V4SF "V2SF")  (V2DF  "DF")])
+			 (V4SF "V2SF")  (V4HF "V2HF")
+			 (V8HF "V4HF")  (V2DF  "DF")])
 
 ;; Double modes of vector modes.
 (define_mode_attr VDBL [(V8QI "V16QI") (V4HI "V8HI")
+			(V4HF "V8HF")
 			(V2SI "V4SI")  (V2SF "V4SF")
 			(SI   "V2SI")  (DI   "V2DI")
 			(DF   "V2DF")])
 
+;; Register suffix for double-length mode.
+(define_mode_attr Vdtype [(V4HF "8h") (V2SF "4s")])
+
 ;; Double modes of vector modes (lower case).
 (define_mode_attr Vdbl [(V8QI "v16qi") (V4HI "v8hi")
+			(V4HF "v8hf")
 			(V2SI "v4si")  (V2SF "v4sf")
 			(SI   "v2si")  (DI   "v2di")
 			(DF   "v2df")])
@@ -462,24 +495,31 @@
 (define_mode_attr VWIDE [(V8QI "V8HI") (V4HI "V4SI")
 			 (V2SI "V2DI") (V16QI "V8HI") 
 			 (V8HI "V4SI") (V4SI "V2DI")
-			 (HI "SI")     (SI "DI")]
-
+			 (HI "SI")     (SI "DI")
+			 (V8HF "V4SF") (V4SF "V2DF")
+			 (V4HF "V4SF") (V2SF "V2DF")]
 )
 
-;; Widened mode register suffixes for VD_BHSI/VQW.
+;; Widened modes of vector modes, lowercase
+(define_mode_attr Vwide [(V2SF "v2df") (V4HF "v4sf")])
+
+;; Widened mode register suffixes for VD_BHSI/VQW/VQ_HSF.
 (define_mode_attr Vwtype [(V8QI "8h") (V4HI "4s")
 			  (V2SI "2d") (V16QI "8h") 
-			  (V8HI "4s") (V4SI "2d")])
+			  (V8HI "4s") (V4SI "2d")
+			  (V8HF "4s") (V4SF "2d")])
 
 ;; Widened mode register suffixes for VDW/VQW.
 (define_mode_attr Vmwtype [(V8QI ".8h") (V4HI ".4s")
 			   (V2SI ".2d") (V16QI ".8h") 
 			   (V8HI ".4s") (V4SI ".2d")
+			   (V4HF ".4s") (V2SF ".2d")
 			   (SI   "")    (HI   "")])
 
-;; Lower part register suffixes for VQW.
+;; Lower part register suffixes for VQW/VQ_HSF.
 (define_mode_attr Vhalftype [(V16QI "8b") (V8HI "4h")
-			     (V4SI "2s")])
+			     (V4SI "2s") (V8HF "4h")
+			     (V4SF "2s")])
 
 ;; Define corresponding core/FP element mode for each vector mode.
 (define_mode_attr vw   [(V8QI "w") (V16QI "w")
@@ -506,6 +546,7 @@
 				(V4HI "V4HI") (V8HI  "V8HI")
 				(V2SI "V2SI") (V4SI  "V4SI")
 				(DI   "DI")   (V2DI  "V2DI")
+				(V4HF "V4HI") (V8HF  "V8HI")
 				(V2SF "V2SI") (V4SF  "V4SI")
 				(V2DF "V2DI") (DF    "DI")
 				(SF   "SI")])
@@ -515,6 +556,7 @@
 				(V4HI "v4hi") (V8HI  "v8hi")
 				(V2SI "v2si") (V4SI  "v4si")
 				(DI   "di")   (V2DI  "v2di")
+				(V4HF "v4hi") (V8HF  "v8hi")
 				(V2SF "v2si") (V4SF  "v4si")
 				(V2DF "v2di") (DF    "di")
 				(SF   "si")])
@@ -533,56 +575,25 @@
 
 (define_mode_attr Vendreg [(OI "T") (CI "U") (XI "V")])
 
+;; This is both the number of Q-Registers needed to hold the corresponding
+;; opaque large integer mode, and the number of elements touched by the
+;; ld..._lane and st..._lane operations.
 (define_mode_attr nregs [(OI "2") (CI "3") (XI "4")])
 
 (define_mode_attr VRL2 [(V8QI "V32QI") (V4HI "V16HI")
+			(V4HF "V16HF")
 			(V2SI "V8SI")  (V2SF "V8SF")
-			(DI   "V4DI")  (DF   "V4DF")
-			(V16QI "V32QI") (V8HI "V16HI")
-			(V4SI "V8SI")  (V4SF "V8SF")
-			(V2DI "V4DI")  (V2DF "V4DF")])
+			(DI   "V4DI")  (DF   "V4DF")])
 
 (define_mode_attr VRL3 [(V8QI "V48QI") (V4HI "V24HI")
+			(V4HF "V24HF")
 			(V2SI "V12SI")  (V2SF "V12SF")
-			(DI   "V6DI")  (DF   "V6DF")
-			(V16QI "V48QI") (V8HI "V24HI")
-			(V4SI "V12SI")  (V4SF "V12SF")
-			(V2DI "V6DI")  (V2DF "V6DF")])
+			(DI   "V6DI")  (DF   "V6DF")])
 
 (define_mode_attr VRL4 [(V8QI "V64QI") (V4HI "V32HI")
+			(V4HF "V32HF")
 			(V2SI "V16SI")  (V2SF "V16SF")
-			(DI   "V8DI")  (DF   "V8DF")
-			(V16QI "V64QI") (V8HI "V32HI")
-			(V4SI "V16SI")  (V4SF "V16SF")
-			(V2DI "V8DI")  (V2DF "V8DF")])
-
-(define_mode_attr VSTRUCT_DREG [(OI "TI") (CI "EI") (XI "OI")])
-
-;; Mode of pair of elements for each vector mode, to define transfer
-;; size for structure lane/dup loads and stores.
-(define_mode_attr V_TWO_ELEM [(V8QI "HI")   (V16QI "HI")
-                              (V4HI "SI")   (V8HI "SI")
-                              (V2SI "V2SI") (V4SI "V2SI")
-                              (DI "V2DI")   (V2DI "V2DI")
-                              (V2SF "V2SF") (V4SF "V2SF")
-                              (DF "V2DI")   (V2DF "V2DI")])
-
-;; Similar, for three elements.
-(define_mode_attr V_THREE_ELEM [(V8QI "BLK") (V16QI "BLK")
-                                (V4HI "BLK") (V8HI "BLK")
-                                (V2SI "BLK") (V4SI "BLK")
-                                (DI "EI")    (V2DI "EI")
-                                (V2SF "BLK") (V4SF "BLK")
-                                (DF "EI")    (V2DF "EI")])
-
-;; Similar, for four elements.
-(define_mode_attr V_FOUR_ELEM [(V8QI "SI")   (V16QI "SI")
-                               (V4HI "V4HI") (V8HI "V4HI")
-                               (V2SI "V4SI") (V4SI "V4SI")
-                               (DI "OI")     (V2DI "OI")
-                               (V2SF "V4SF") (V4SF "V4SF")
-                               (DF "OI")     (V2DF "OI")])
-
+			(DI   "V8DI")  (DF   "V8DF")])
 
 ;; Mode for atomic operation suffixes
 (define_mode_attr atomic_sfx
@@ -600,12 +611,14 @@
 				(V2SI "V4SI") (V4SI  "V2SI")
 				(DI   "V2DI") (V2DI  "DI")
 				(V2SF "V4SF") (V4SF  "V2SF")
+				(V4HF "V8HF") (V8HF  "V4HF")
 				(DF   "V2DF") (V2DF  "DF")])
 
 (define_mode_attr vswap_width_name [(V8QI "to_128") (V16QI "to_64")
 				    (V4HI "to_128") (V8HI  "to_64")
 				    (V2SI "to_128") (V4SI  "to_64")
 				    (DI   "to_128") (V2DI  "to_64")
+				    (V4HF "to_128") (V8HF  "to_64")
 				    (V2SF "to_128") (V4SF  "to_64")
 				    (DF   "to_128") (V2DF  "to_64")])
 
@@ -639,6 +652,7 @@
 		     (V4HI "") (V8HI  "_q")
 		     (V2SI "") (V4SI  "_q")
 		     (DI   "") (V2DI  "_q")
+		     (V4HF "") (V8HF "_q")
 		     (V2SF "") (V4SF  "_q")
 			       (V2DF  "_q")
 		     (QI "") (HI "") (SI "") (DI "") (SF "") (DF "")])
--- a/src/gcc/config/aarch64/t-aarch64
+++ b/src/gcc/config/aarch64/t-aarch64
@@ -48,6 +48,21 @@ aarch-common.o: $(srcdir)/config/arm/aarch-common.c $(CONFIG_H) $(SYSTEM_H) \
 	$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \
 		$(srcdir)/config/arm/aarch-common.c
 
+aarch64-c.o: $(srcdir)/config/aarch64/aarch64-c.c $(CONFIG_H) $(SYSTEM_H) \
+    coretypes.h $(TM_H) $(TREE_H) output.h $(C_COMMON_H)
+	$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \
+		$(srcdir)/config/aarch64/aarch64-c.c
+
+cortex-a57-fma-steering.o: $(srcdir)/config/aarch64/cortex-a57-fma-steering.c \
+    $(CONFIG_H) $(SYSTEM_H) $(TM_H) $(REGS_H) insn-config.h $(RTL_BASE_H) \
+    dominance.h cfg.h cfganal.h $(BASIC_BLOCK_H) $(INSN_ATTR_H) $(RECOG_H) \
+    output.h hash-map.h $(DF_H) $(OBSTACK_H) $(TARGET_H) $(RTL_H) \
+    $(CONTEXT_H) $(TREE_PASS_H) regrename.h \
+    $(srcdir)/config/aarch64/cortex-a57-fma-steering.h \
+    $(srcdir)/config/aarch64/aarch64-protos.h
+	$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \
+		$(srcdir)/config/aarch64/cortex-a57-fma-steering.c
+
 comma=,
 MULTILIB_OPTIONS    = $(subst $(comma),/, $(patsubst %, mabi=%, $(subst $(comma),$(comma)mabi=,$(TM_MULTILIB_CONFIG))))
 MULTILIB_DIRNAMES   = $(subst $(comma), ,$(TM_MULTILIB_CONFIG))
--- a/src/gcc/config/aarch64/thunderx.md
+++ b/src/gcc/config/aarch64/thunderx.md
@@ -39,7 +39,7 @@
 
 (define_insn_reservation "thunderx_shift" 1
   (and (eq_attr "tune" "thunderx")
-       (eq_attr "type" "bfm,extend,shift_imm,shift_reg"))
+       (eq_attr "type" "bfm,extend,shift_imm,shift_reg,rbit,rev"))
   "thunderx_pipe0 | thunderx_pipe1")
 
 
@@ -66,12 +66,18 @@
        (eq_attr "type" "mul,muls,mla,mlas,clz,smull,umull,smlal,umlal"))
   "thunderx_pipe1 + thunderx_mult")
 
-;; Multiply high instructions take an extra cycle and cause the muliply unit to
-;; be busy for an extra cycle.
+;; crcb,crch,crcw is 4 cycles and can only happen on pipe 1
 
-;(define_insn_reservation "thunderx_mul_high" 5
+(define_insn_reservation "thunderx_crc32" 4
+  (and (eq_attr "tune" "thunderx")
+       (eq_attr "type" "crc"))
+  "thunderx_pipe1 + thunderx_mult")
+
+;; crcx is 5 cycles and only happen on pipe 1
+;(define_insn_reservation "thunderx_crc64" 5
 ;  (and (eq_attr "tune" "thunderx")
-;       (eq_attr "type" "smull,umull"))
+;       (eq_attr "type" "crc")
+;       (eq_attr "mode" "DI"))
 ;  "thunderx_pipe1 + thunderx_mult")
 
 (define_insn_reservation "thunderx_div32" 22
@@ -97,6 +103,11 @@
        (eq_attr "type" "store2"))
   "thunderx_pipe0 + thunderx_pipe1")
 
+;; Prefetch are single issued
+;(define_insn_reservation "thunderx_prefetch" 1
+;  (and (eq_attr "tune" "thunderx")
+;       (eq_attr "type" "prefetch"))
+;  "thunderx_pipe0 + thunderx_pipe1")
 
 ;; loads (and load pairs) from L1 take 3 cycles in pipe 0
 (define_insn_reservation "thunderx_load" 3
@@ -121,10 +132,21 @@
        (eq_attr "type" "fconsts,fconstd"))
   "thunderx_pipe1")
 
-;; Moves between fp are 2 cycles including min/max/select/abs/neg
+;; Moves between fp are 2 cycles including min/max
 (define_insn_reservation "thunderx_fmov" 2
   (and (eq_attr "tune" "thunderx")
-       (eq_attr "type" "fmov,f_minmaxs,f_minmaxd,fcsel,ffarithd,ffariths"))
+       (eq_attr "type" "fmov,f_minmaxs,f_minmaxd"))
+  "thunderx_pipe1")
+
+;; ABS, and NEG are 1 cycle
+(define_insn_reservation "thunderx_fabs" 1
+  (and (eq_attr "tune" "thunderx")
+       (eq_attr "type" "ffariths,ffarithd"))
+  "thunderx_pipe1")
+
+(define_insn_reservation "thunderx_fcsel" 3
+  (and (eq_attr "tune" "thunderx")
+       (eq_attr "type" "fcsel"))
   "thunderx_pipe1")
 
 (define_insn_reservation "thunderx_fmovgpr" 2
@@ -132,6 +154,11 @@
        (eq_attr "type" "f_mrc, f_mcr"))
   "thunderx_pipe1")
 
+(define_insn_reservation "thunderx_fcmp" 3
+  (and (eq_attr "tune" "thunderx")
+       (eq_attr "type" "fcmps,fcmpd"))
+  "thunderx_pipe1")
+
 (define_insn_reservation "thunderx_fmul" 6
   (and (eq_attr "tune" "thunderx")
        (eq_attr "type" "fmacs,fmacd,fmuls,fmuld"))
@@ -152,21 +179,21 @@
        (eq_attr "type" "fsqrts"))
   "thunderx_pipe1 + thunderx_divide, thunderx_divide*13")
 
-(define_insn_reservation "thunderx_fsqrtd" 28
+(define_insn_reservation "thunderx_fsqrtd" 31
   (and (eq_attr "tune" "thunderx")
        (eq_attr "type" "fsqrtd"))
-  "thunderx_pipe1 + thunderx_divide, thunderx_divide*31")
+  "thunderx_pipe1 + thunderx_divide, thunderx_divide*27")
 
 ;; The rounding conversion inside fp is 4 cycles
 (define_insn_reservation "thunderx_frint" 4
   (and (eq_attr "tune" "thunderx")
-       (eq_attr "type" "f_rints,f_rintd"))
+       (eq_attr "type" "f_cvt,f_rints,f_rintd"))
   "thunderx_pipe1")
 
 ;; Float to integer with a move from int to/from float is 6 cycles
 (define_insn_reservation "thunderx_f_cvt" 6
   (and (eq_attr "tune" "thunderx")
-       (eq_attr "type" "f_cvt,f_cvtf2i,f_cvti2f"))
+       (eq_attr "type" "f_cvtf2i,f_cvti2f"))
   "thunderx_pipe1")
 
 ;; FP/SIMD load/stores happen in pipe 0
@@ -184,9 +211,12 @@
   "thunderx_pipe0+thunderx_pipe1")
 
 ;; FP/SIMD Stores takes one cycle in pipe 0
+;; ST1 with one registers either multiple structures or single structure is
+;;    also one cycle.
 (define_insn_reservation "thunderx_simd_fp_store" 1
   (and (eq_attr "tune" "thunderx")
-       (eq_attr "type" "f_stored,f_stores,neon_store1_1reg,neon_store1_1reg_q"))
+       (eq_attr "type" "f_stored,f_stores,neon_store1_1reg,neon_store1_1reg_q, \
+			neon_store1_one_lane, neon_store1_one_lane_q"))
   "thunderx_pipe0")
 
 ;; 64bit neon store pairs are single issue for one cycle
@@ -201,24 +231,38 @@
        (eq_attr "type" "neon_store1_2reg_q"))
   "(thunderx_pipe0 + thunderx_pipe1)*2")
 
+;; LD1R/LD1 (with a single struct) takes 6 cycles and issued in pipe0
+(define_insn_reservation "thunderx_neon_ld1" 6
+  (and (eq_attr "tune" "thunderx")
+       (eq_attr "type" "neon_load1_all_lanes"))
+  "thunderx_pipe0")
 
 ;; SIMD/NEON (q forms take an extra cycle)
+;; SIMD For ThunderX is 64bit wide,
 
-;; Thunder simd move instruction types - 2/3 cycles
+;; ThunderX simd move instruction types - 2/3 cycles
+;; ThunderX dup, ins is the same
+;; ThunderX SIMD fabs/fneg instruction types
 (define_insn_reservation "thunderx_neon_move" 2
   (and (eq_attr "tune" "thunderx")
        (eq_attr "type" "neon_logic, neon_bsl, neon_fp_compare_s, \
-			neon_fp_compare_d, neon_move"))
+			neon_fp_compare_d, neon_move, neon_dup, \
+			neon_ins, neon_from_gp, neon_to_gp, \
+			neon_abs, neon_neg, \
+			neon_fp_neg_s, neon_fp_abs_s"))
   "thunderx_pipe1 + thunderx_simd")
 
 (define_insn_reservation "thunderx_neon_move_q" 3
   (and (eq_attr "tune" "thunderx")
        (eq_attr "type" "neon_logic_q, neon_bsl_q, neon_fp_compare_s_q, \
-			neon_fp_compare_d_q, neon_move_q"))
+			neon_fp_compare_d_q, neon_move_q, neon_dup_q, \
+			neon_ins_q, neon_from_gp_q, neon_to_gp_q, \
+			neon_abs_q, neon_neg_q, \
+			neon_fp_neg_s_q, neon_fp_neg_d_q, \
+			neon_fp_abs_s_q, neon_fp_abs_d_q"))
   "thunderx_pipe1 + thunderx_simd, thunderx_simd")
 
-
-;; Thunder simd simple/add instruction types - 4/5 cycles
+;; ThunderX simd simple/add instruction types - 4/5 cycles
 
 (define_insn_reservation "thunderx_neon_add" 4
   (and (eq_attr "tune" "thunderx")
@@ -227,7 +271,9 @@
 			neon_add_halve, neon_sub_halve, neon_qadd, neon_compare, \
 			neon_compare_zero, neon_minmax, neon_abd, neon_add, neon_sub, \
 			neon_fp_minmax_s, neon_fp_minmax_d, neon_reduc_add, neon_cls, \
-			neon_qabs, neon_qneg, neon_fp_addsub_s, neon_fp_addsub_d"))
+			neon_qabs, neon_qneg, neon_fp_addsub_s, neon_fp_addsub_d, \
+			neon_arith_acc, neon_rev, neon_fp_abd_s, neon_fp_abd_d, \
+			neon_fp_reduc_minmax_s"))
   "thunderx_pipe1 + thunderx_simd")
 
 ;; BIG NOTE: neon_add_long/neon_sub_long don't have a q form which is incorrect
@@ -240,13 +286,74 @@
 			neon_compare_zero_q, neon_minmax_q, neon_abd_q, neon_add_q, neon_sub_q, \
 			neon_fp_minmax_s_q, neon_fp_minmax_d_q, neon_reduc_add_q, neon_cls_q, \
 			neon_qabs_q, neon_qneg_q, neon_fp_addsub_s_q, neon_fp_addsub_d_q, \
-			neon_add_long, neon_sub_long"))
+			neon_add_long, neon_sub_long, neon_fp_abd_s_q, neon_fp_abd_d_q, \
+			neon_arith_acc_q, neon_rev_q, \
+			neon_fp_reduc_minmax_s_q, neon_fp_reduc_minmax_d_q"))
   "thunderx_pipe1 + thunderx_simd, thunderx_simd")
 
+;; Multiplies (float and integer) and shifts and permutes (except for TBL) and float conversions
+;; are 6/7 cycles
+(define_insn_reservation "thunderx_neon_mult" 6
+  (and (eq_attr "tune" "thunderx")
+       (eq_attr "type" "neon_fp_mul_s, neon_fp_mul_d, neon_fp_mla_s, neon_fp_mla_d, \
+			neon_mla_b, neon_mla_h, neon_mla_s, \
+			neon_mla_h_scalar, neon_mla_s_scalar, \
+			neon_ext, neon_shift_imm, neon_permute, \
+			neon_int_to_fp_s, neon_int_to_fp_d, neon_shift_reg, \
+			neon_sat_shift_reg, neon_shift_acc, \
+			neon_mul_b, neon_mul_h, neon_mul_s, \
+			neon_mul_h_scalar, neon_mul_s_scalar, \
+			neon_fp_mul_s_scalar, \
+			neon_fp_mla_s_scalar"))
+  "thunderx_pipe1 + thunderx_simd")
+
+(define_insn_reservation "thunderx_neon_mult_q" 7
+  (and (eq_attr "tune" "thunderx")
+       (eq_attr "type" "neon_fp_mul_s_q, neon_fp_mul_d_q, neon_fp_mla_s_q, neon_fp_mla_d_q, \
+			neon_mla_b_q, neon_mla_h_q, neon_mla_s_q, \
+			neon_mla_h_scalar_q, neon_mla_s_scalar_q, \
+			neon_ext_q, neon_shift_imm_q, neon_permute_q, \
+			neon_int_to_fp_s_q, neon_int_to_fp_d_q, neon_shift_reg_q, \
+			neon_sat_shift_reg_q, neon_shift_acc_q, \
+			neon_shift_imm_long, \
+			neon_mul_b_q, neon_mul_h_q, neon_mul_s_q, \
+			neon_mul_h_scalar_q, neon_mul_s_scalar_q, \
+			neon_fp_mul_s_scalar_q, neon_fp_mul_d_scalar_q, \
+			neon_mul_b_long, neon_mul_h_long, neon_mul_s_long, \
+			neon_shift_imm_narrow_q, neon_fp_cvt_widen_s, neon_fp_cvt_narrow_d_q, \
+			neon_fp_mla_s_scalar_q, neon_fp_mla_d_scalar_q"))
+  "thunderx_pipe1 + thunderx_simd, thunderx_simd")
+
+
+;; AES[ED] is 5 cycles
+(define_insn_reservation "thunderx_crypto_aese" 5
+  (and (eq_attr "tune" "thunderx")
+       (eq_attr "type" "crypto_aese"))
+  "thunderx_pipe1 + thunderx_simd, thunderx_simd")
 
-;; Thunder 128bit SIMD reads the upper halve in cycle 2 and writes in the last cycle
-(define_bypass 2 "thunderx_neon_move_q" "thunderx_neon_move_q, thunderx_neon_add_q")
-(define_bypass 4 "thunderx_neon_add_q" "thunderx_neon_move_q, thunderx_neon_add_q")
+;; AES{,I}MC is 3 cycles
+(define_insn_reservation "thunderx_crypto_aesmc" 3
+  (and (eq_attr "tune" "thunderx")
+       (eq_attr "type" "crypto_aesmc"))
+  "thunderx_pipe1 + thunderx_simd, thunderx_simd")
+
+
+;; Thunder 128bit SIMD reads the upper halve in cycle 2 and writes upper halve in the last cycle
+(define_bypass 2 "thunderx_neon_move_q" "thunderx_neon_move_q, thunderx_neon_add_q, thunderx_neon_mult_q")
+(define_bypass 4 "thunderx_neon_add_q" "thunderx_neon_move_q, thunderx_neon_add_q, thunderx_neon_mult_q")
+(define_bypass 6 "thunderx_neon_mult_q" "thunderx_neon_move_q, thunderx_neon_add_q, thunderx_neon_mult_q")
+
+;; 64bit TBL is emulated and takes 160 cycles
+(define_insn_reservation "thunderx_tbl" 160
+  (and (eq_attr "tune" "thunderx")
+       (eq_attr "type" "neon_tbl1"))
+  "(thunderx_pipe1+thunderx_pipe0)*160")
+
+;; 128bit TBL is emulated and takes 320 cycles
+(define_insn_reservation "thunderx_tblq" 320
+  (and (eq_attr "tune" "thunderx")
+       (eq_attr "type" "neon_tbl1_q"))
+  "(thunderx_pipe1+thunderx_pipe0)*320")
 
 ;; Assume both pipes are needed for unknown and multiple-instruction
 ;; patterns.
--- /dev/null
+++ b/src/gcc/config/aarch64/x-aarch64
@@ -0,0 +1,3 @@
+driver-aarch64.o: $(srcdir)/config/aarch64/driver-aarch64.c \
+  $(CONFIG_H) $(SYSTEM_H)
+	$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $<
--- a/src/gcc/config/alpha/linux.h
+++ b/src/gcc/config/alpha/linux.h
@@ -61,10 +61,14 @@ along with GCC; see the file COPYING3.  If not see
 #define OPTION_GLIBC  (DEFAULT_LIBC == LIBC_GLIBC)
 #define OPTION_UCLIBC (DEFAULT_LIBC == LIBC_UCLIBC)
 #define OPTION_BIONIC (DEFAULT_LIBC == LIBC_BIONIC)
+#undef OPTION_MUSL
+#define OPTION_MUSL   (DEFAULT_LIBC == LIBC_MUSL)
 #else
 #define OPTION_GLIBC  (linux_libc == LIBC_GLIBC)
 #define OPTION_UCLIBC (linux_libc == LIBC_UCLIBC)
 #define OPTION_BIONIC (linux_libc == LIBC_BIONIC)
+#undef OPTION_MUSL
+#define OPTION_MUSL   (linux_libc == LIBC_MUSL)
 #endif
 
 /* Determine what functions are present at the runtime;
--- a/src/gcc/config/arm/aarch-common-protos.h
+++ b/src/gcc/config/arm/aarch-common-protos.h
@@ -102,6 +102,8 @@ struct mem_cost_table
   const int storef;		/* SFmode.  */
   const int stored;		/* DFmode.  */
   const int store_unaligned;	/* Extra for unaligned stores.  */
+  const int loadv;		/* Vector load.  */
+  const int storev;		/* Vector store.  */
 };
 
 struct fp_cost_table
--- a/src/gcc/config/arm/aarch-cost-tables.h
+++ b/src/gcc/config/arm/aarch-cost-tables.h
@@ -81,7 +81,9 @@ const struct cpu_cost_table generic_extra_costs =
     1,			/* stm_regs_per_insn_subsequent.  */
     COSTS_N_INSNS (2),	/* storef.  */
     COSTS_N_INSNS (3),	/* stored.  */
-    COSTS_N_INSNS (1)  /* store_unaligned.  */
+    COSTS_N_INSNS (1),	/* store_unaligned.  */
+    COSTS_N_INSNS (1),	/* loadv.  */
+    COSTS_N_INSNS (1)	/* storev.  */
   },
   {
     /* FP SFmode */
@@ -130,12 +132,12 @@ const struct cpu_cost_table cortexa53_extra_costs =
     0,			/* arith.  */
     0,			/* logical.  */
     COSTS_N_INSNS (1),	/* shift.  */
-    COSTS_N_INSNS (2),	/* shift_reg.  */
+    0,			/* shift_reg.  */
     COSTS_N_INSNS (1),	/* arith_shift.  */
-    COSTS_N_INSNS (2),	/* arith_shift_reg.  */
+    COSTS_N_INSNS (1),	/* arith_shift_reg.  */
     COSTS_N_INSNS (1),	/* log_shift.  */
-    COSTS_N_INSNS (2),	/* log_shift_reg.  */
-    0,			/* extend.  */
+    COSTS_N_INSNS (1),	/* log_shift_reg.  */
+    COSTS_N_INSNS (1),	/* extend.  */
     COSTS_N_INSNS (1),	/* extend_arith.  */
     COSTS_N_INSNS (1),	/* bfi.  */
     COSTS_N_INSNS (1),	/* bfx.  */
@@ -182,7 +184,9 @@ const struct cpu_cost_table cortexa53_extra_costs =
     2,				/* stm_regs_per_insn_subsequent.  */
     0,				/* storef.  */
     0,				/* stored.  */
-    COSTS_N_INSNS (1)		/* store_unaligned.  */
+    COSTS_N_INSNS (1),		/* store_unaligned.  */
+    COSTS_N_INSNS (1),		/* loadv.  */
+    COSTS_N_INSNS (1)		/* storev.  */
   },
   {
     /* FP SFmode */
@@ -283,7 +287,9 @@ const struct cpu_cost_table cortexa57_extra_costs =
     2,                         /* stm_regs_per_insn_subsequent.  */
     0,                         /* storef.  */
     0,                         /* stored.  */
-    COSTS_N_INSNS (1)          /* store_unaligned.  */
+    COSTS_N_INSNS (1),         /* store_unaligned.  */
+    COSTS_N_INSNS (1),         /* loadv.  */
+    COSTS_N_INSNS (1)          /* storev.  */
   },
   {
     /* FP SFmode */
@@ -385,6 +391,8 @@ const struct cpu_cost_table xgene1_extra_costs =
     0,                         /* storef.  */
     0,                         /* stored.  */
     0,                         /* store_unaligned.  */
+    COSTS_N_INSNS (1),         /* loadv.  */
+    COSTS_N_INSNS (1)          /* storev.  */
   },
   {
     /* FP SFmode */
--- a/src/gcc/config/arm/arm-arches.def
+++ b/src/gcc/config/arm/arm-arches.def
@@ -23,38 +23,40 @@
 
    The NAME is the name of the architecture, represented as a string
    constant.  The CORE is the identifier for a core representative of
-   this architecture.  ARCH is the architecture revision.  FLAGS are
-   the flags implied by the architecture.
+   this architecture.  ARCH is the architecture revision.  FLAGS is
+   the set of feature flags implied by the architecture.
 
    genopt.sh assumes no whitespace up to the first "," in each entry.  */
 
-ARM_ARCH("armv2",   arm2,       2,   FL_CO_PROC | FL_MODE26 | FL_FOR_ARCH2)
-ARM_ARCH("armv2a",  arm2,       2,   FL_CO_PROC | FL_MODE26 | FL_FOR_ARCH2)
-ARM_ARCH("armv3",   arm6,       3,   FL_CO_PROC | FL_MODE26 | FL_FOR_ARCH3)
-ARM_ARCH("armv3m",  arm7m,      3M,  FL_CO_PROC | FL_MODE26 | FL_FOR_ARCH3M)
-ARM_ARCH("armv4",   arm7tdmi,   4,   FL_CO_PROC | FL_MODE26 | FL_FOR_ARCH4)
+ARM_ARCH("armv2",   arm2,       2,	ARM_FSET_MAKE_CPU1 (FL_CO_PROC | FL_MODE26 | FL_FOR_ARCH2))
+ARM_ARCH("armv2a",  arm2,       2,	ARM_FSET_MAKE_CPU1 (FL_CO_PROC | FL_MODE26 | FL_FOR_ARCH2))
+ARM_ARCH("armv3",   arm6,       3,	ARM_FSET_MAKE_CPU1 (FL_CO_PROC | FL_MODE26 | FL_FOR_ARCH3))
+ARM_ARCH("armv3m",  arm7m,      3M,	ARM_FSET_MAKE_CPU1 (FL_CO_PROC | FL_MODE26 | FL_FOR_ARCH3M))
+ARM_ARCH("armv4",   arm7tdmi,   4,	ARM_FSET_MAKE_CPU1 (FL_CO_PROC | FL_MODE26 | FL_FOR_ARCH4))
 /* Strictly, FL_MODE26 is a permitted option for v4t, but there are no
    implementations that support it, so we will leave it out for now.  */
-ARM_ARCH("armv4t",  arm7tdmi,   4T,  FL_CO_PROC |             FL_FOR_ARCH4T)
-ARM_ARCH("armv5",   arm10tdmi,  5,   FL_CO_PROC |             FL_FOR_ARCH5)
-ARM_ARCH("armv5t",  arm10tdmi,  5T,  FL_CO_PROC |             FL_FOR_ARCH5T)
-ARM_ARCH("armv5e",  arm1026ejs, 5E,  FL_CO_PROC |             FL_FOR_ARCH5E)
-ARM_ARCH("armv5te", arm1026ejs, 5TE, FL_CO_PROC |             FL_FOR_ARCH5TE)
-ARM_ARCH("armv6",   arm1136js,  6,   FL_CO_PROC |             FL_FOR_ARCH6)
-ARM_ARCH("armv6j",  arm1136js,  6J,  FL_CO_PROC |             FL_FOR_ARCH6J)
-ARM_ARCH("armv6k",  mpcore,	6K,  FL_CO_PROC |             FL_FOR_ARCH6K)
-ARM_ARCH("armv6z",  arm1176jzs, 6Z,  FL_CO_PROC |             FL_FOR_ARCH6Z)
-ARM_ARCH("armv6zk", arm1176jzs, 6ZK, FL_CO_PROC |             FL_FOR_ARCH6ZK)
-ARM_ARCH("armv6t2", arm1156t2s, 6T2, FL_CO_PROC |             FL_FOR_ARCH6T2)
-ARM_ARCH("armv6-m", cortexm1,	6M,			      FL_FOR_ARCH6M)
-ARM_ARCH("armv6s-m", cortexm1,	6M,			      FL_FOR_ARCH6M)
-ARM_ARCH("armv7",   cortexa8,	7,   FL_CO_PROC |	      FL_FOR_ARCH7)
-ARM_ARCH("armv7-a", cortexa8,	7A,  FL_CO_PROC |	      FL_FOR_ARCH7A)
-ARM_ARCH("armv7ve", cortexa8,	7A,  FL_CO_PROC |	      FL_FOR_ARCH7VE)
-ARM_ARCH("armv7-r", cortexr4,	7R,  FL_CO_PROC |	      FL_FOR_ARCH7R)
-ARM_ARCH("armv7-m", cortexm3,	7M,  FL_CO_PROC |	      FL_FOR_ARCH7M)
-ARM_ARCH("armv7e-m", cortexm4,  7EM, FL_CO_PROC |	      FL_FOR_ARCH7EM)
-ARM_ARCH("armv8-a", cortexa53,  8A,  FL_CO_PROC |             FL_FOR_ARCH8A)
-ARM_ARCH("armv8-a+crc",cortexa53, 8A,FL_CO_PROC | FL_CRC32  | FL_FOR_ARCH8A)
-ARM_ARCH("iwmmxt",  iwmmxt,     5TE, FL_LDSCHED | FL_STRONG | FL_FOR_ARCH5TE | FL_XSCALE | FL_IWMMXT)
-ARM_ARCH("iwmmxt2", iwmmxt2,    5TE, FL_LDSCHED | FL_STRONG | FL_FOR_ARCH5TE | FL_XSCALE | FL_IWMMXT | FL_IWMMXT2)
+ARM_ARCH("armv4t",  arm7tdmi,   4T,	ARM_FSET_MAKE_CPU1 (FL_CO_PROC |             FL_FOR_ARCH4T))
+ARM_ARCH("armv5",   arm10tdmi,  5,	ARM_FSET_MAKE_CPU1 (FL_CO_PROC |             FL_FOR_ARCH5))
+ARM_ARCH("armv5t",  arm10tdmi,  5T,	ARM_FSET_MAKE_CPU1 (FL_CO_PROC |             FL_FOR_ARCH5T))
+ARM_ARCH("armv5e",  arm1026ejs, 5E,	ARM_FSET_MAKE_CPU1 (FL_CO_PROC |             FL_FOR_ARCH5E))
+ARM_ARCH("armv5te", arm1026ejs, 5TE,	ARM_FSET_MAKE_CPU1 (FL_CO_PROC |             FL_FOR_ARCH5TE))
+ARM_ARCH("armv6",   arm1136js,  6,	ARM_FSET_MAKE_CPU1 (FL_CO_PROC |             FL_FOR_ARCH6))
+ARM_ARCH("armv6j",  arm1136js,  6J,	ARM_FSET_MAKE_CPU1 (FL_CO_PROC |             FL_FOR_ARCH6J))
+ARM_ARCH("armv6k",  mpcore,	6K,	ARM_FSET_MAKE_CPU1 (FL_CO_PROC |             FL_FOR_ARCH6K))
+ARM_ARCH("armv6z",  arm1176jzs, 6Z,	ARM_FSET_MAKE_CPU1 (FL_CO_PROC |             FL_FOR_ARCH6Z))
+ARM_ARCH("armv6kz", arm1176jzs, 6KZ,	ARM_FSET_MAKE_CPU1 (FL_CO_PROC |             FL_FOR_ARCH6KZ))
+ARM_ARCH("armv6zk", arm1176jzs, 6KZ,	ARM_FSET_MAKE_CPU1 (FL_CO_PROC |             FL_FOR_ARCH6KZ))
+ARM_ARCH("armv6t2", arm1156t2s, 6T2,	ARM_FSET_MAKE_CPU1 (FL_CO_PROC |             FL_FOR_ARCH6T2))
+ARM_ARCH("armv6-m", cortexm1,	6M,	ARM_FSET_MAKE_CPU1 (FL_FOR_ARCH6M))
+ARM_ARCH("armv6s-m", cortexm1,	6M,	ARM_FSET_MAKE_CPU1 (FL_FOR_ARCH6M))
+ARM_ARCH("armv7",   cortexa8,	7,	ARM_FSET_MAKE_CPU1 (FL_CO_PROC |	      FL_FOR_ARCH7))
+ARM_ARCH("armv7-a", cortexa8,	7A,	ARM_FSET_MAKE_CPU1 (FL_CO_PROC |	      FL_FOR_ARCH7A))
+ARM_ARCH("armv7ve", cortexa8,	7A,	ARM_FSET_MAKE_CPU1 (FL_CO_PROC |	      FL_FOR_ARCH7VE))
+ARM_ARCH("armv7-r", cortexr4,	7R,	ARM_FSET_MAKE_CPU1 (FL_CO_PROC |	      FL_FOR_ARCH7R))
+ARM_ARCH("armv7-m", cortexm3,	7M,	ARM_FSET_MAKE_CPU1 (FL_CO_PROC |	      FL_FOR_ARCH7M))
+ARM_ARCH("armv7e-m", cortexm4,  7EM,	ARM_FSET_MAKE_CPU1 (FL_CO_PROC |	      FL_FOR_ARCH7EM))
+ARM_ARCH("armv8-a", cortexa53,  8A,	ARM_FSET_MAKE_CPU1 (FL_CO_PROC |             FL_FOR_ARCH8A))
+ARM_ARCH("armv8-a+crc",cortexa53, 8A,   ARM_FSET_MAKE_CPU1 (FL_CO_PROC | FL_CRC32  | FL_FOR_ARCH8A))
+ARM_ARCH("iwmmxt",  iwmmxt,     5TE,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_STRONG | FL_FOR_ARCH5TE | FL_XSCALE | FL_IWMMXT))
+ARM_ARCH("iwmmxt2", iwmmxt2,    5TE,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_STRONG | FL_FOR_ARCH5TE | FL_XSCALE | FL_IWMMXT | FL_IWMMXT2))
+
--- a/src/gcc/config/arm/arm-builtins.c
+++ b/src/gcc/config/arm/arm-builtins.c
@@ -89,7 +89,9 @@ enum arm_type_qualifiers
   /* qualifier_const_pointer | qualifier_map_mode  */
   qualifier_const_pointer_map_mode = 0x86,
   /* Polynomial types.  */
-  qualifier_poly = 0x100
+  qualifier_poly = 0x100,
+  /* Lane indices - must be within range of previous argument = a vector.  */
+  qualifier_lane_index = 0x200
 };
 
 /*  The qualifier_internal allows generation of a unary builtin from
@@ -120,21 +122,40 @@ arm_ternop_qualifiers[SIMD_MAX_BUILTIN_ARGS]
 
 /* T (T, immediate).  */
 static enum arm_type_qualifiers
-arm_getlane_qualifiers[SIMD_MAX_BUILTIN_ARGS]
+arm_binop_imm_qualifiers[SIMD_MAX_BUILTIN_ARGS]
   = { qualifier_none, qualifier_none, qualifier_immediate };
+#define BINOP_IMM_QUALIFIERS (arm_binop_imm_qualifiers)
+
+/* T (T, lane index).  */
+static enum arm_type_qualifiers
+arm_getlane_qualifiers[SIMD_MAX_BUILTIN_ARGS]
+  = { qualifier_none, qualifier_none, qualifier_lane_index };
 #define GETLANE_QUALIFIERS (arm_getlane_qualifiers)
 
 /* T (T, T, T, immediate).  */
 static enum arm_type_qualifiers
-arm_lanemac_qualifiers[SIMD_MAX_BUILTIN_ARGS]
+arm_mac_n_qualifiers[SIMD_MAX_BUILTIN_ARGS]
   = { qualifier_none, qualifier_none, qualifier_none,
       qualifier_none, qualifier_immediate };
-#define LANEMAC_QUALIFIERS (arm_lanemac_qualifiers)
+#define MAC_N_QUALIFIERS (arm_mac_n_qualifiers)
+
+/* T (T, T, T, lane index).  */
+static enum arm_type_qualifiers
+arm_mac_lane_qualifiers[SIMD_MAX_BUILTIN_ARGS]
+  = { qualifier_none, qualifier_none, qualifier_none,
+      qualifier_none, qualifier_lane_index };
+#define MAC_LANE_QUALIFIERS (arm_mac_lane_qualifiers)
 
 /* T (T, T, immediate).  */
 static enum arm_type_qualifiers
-arm_setlane_qualifiers[SIMD_MAX_BUILTIN_ARGS]
+arm_ternop_imm_qualifiers[SIMD_MAX_BUILTIN_ARGS]
   = { qualifier_none, qualifier_none, qualifier_none, qualifier_immediate };
+#define TERNOP_IMM_QUALIFIERS (arm_ternop_imm_qualifiers)
+
+/* T (T, T, lane index).  */
+static enum arm_type_qualifiers
+arm_setlane_qualifiers[SIMD_MAX_BUILTIN_ARGS]
+  = { qualifier_none, qualifier_none, qualifier_none, qualifier_lane_index };
 #define SETLANE_QUALIFIERS (arm_setlane_qualifiers)
 
 /* T (T, T).  */
@@ -183,6 +204,7 @@ arm_storestruct_lane_qualifiers[SIMD_MAX_BUILTIN_ARGS]
 #define di_UP    DImode
 #define v16qi_UP V16QImode
 #define v8hi_UP  V8HImode
+#define v8hf_UP  V8HFmode
 #define v4si_UP  V4SImode
 #define v4sf_UP  V4SFmode
 #define v2di_UP  V2DImode
@@ -231,6 +253,12 @@ typedef struct {
 #define VAR10(T, N, A, B, C, D, E, F, G, H, I, J) \
   VAR9 (T, N, A, B, C, D, E, F, G, H, I) \
   VAR1 (T, N, J)
+#define VAR11(T, N, A, B, C, D, E, F, G, H, I, J, K) \
+  VAR10 (T, N, A, B, C, D, E, F, G, H, I, J) \
+  VAR1 (T, N, K)
+#define VAR12(T, N, A, B, C, D, E, F, G, H, I, J, K, L) \
+  VAR11 (T, N, A, B, C, D, E, F, G, H, I, J, K) \
+  VAR1 (T, N, L)
 
 /* The NEON builtin data can be found in arm_neon_builtins.def.
    The mode entries in the following table correspond to the "key" type of the
@@ -525,12 +553,16 @@ enum arm_builtins
 #undef CRYPTO2
 #undef CRYPTO3
 
+  ARM_BUILTIN_NEON_BASE,
+  ARM_BUILTIN_NEON_LANE_CHECK = ARM_BUILTIN_NEON_BASE,
+
 #include "arm_neon_builtins.def"
 
   ARM_BUILTIN_MAX
 };
 
-#define ARM_BUILTIN_NEON_BASE (ARM_BUILTIN_MAX - ARRAY_SIZE (neon_builtin_data))
+#define ARM_BUILTIN_NEON_PATTERN_START \
+    (ARM_BUILTIN_MAX - ARRAY_SIZE (neon_builtin_data))
 
 #undef CF
 #undef VAR1
@@ -758,13 +790,6 @@ arm_init_simd_builtin_types (void)
   int nelts = sizeof (arm_simd_types) / sizeof (arm_simd_types[0]);
   tree tdecl;
 
-  /* Initialize the HFmode scalar type.  */
-  arm_simd_floatHF_type_node = make_node (REAL_TYPE);
-  TYPE_PRECISION (arm_simd_floatHF_type_node) = GET_MODE_PRECISION (HFmode);
-  layout_type (arm_simd_floatHF_type_node);
-  (*lang_hooks.types.register_builtin_type) (arm_simd_floatHF_type_node,
-					     "__builtin_neon_hf");
-
   /* Poly types are a world of their own.  In order to maintain legacy
      ABI, they get initialized using the old interface, and don't get
      an entry in our mangling table, consequently, they get default
@@ -812,7 +837,10 @@ arm_init_simd_builtin_types (void)
      mangling.  */
 
   /* Continue with standard types.  */
+  /* The __builtin_simd{64,128}_float16 types are kept private unless
+     we have a scalar __fp16 type.  */
   arm_simd_types[Float16x4_t].eltype = arm_simd_floatHF_type_node;
+  arm_simd_types[Float16x8_t].eltype = arm_simd_floatHF_type_node;
   arm_simd_types[Float32x2_t].eltype = float_type_node;
   arm_simd_types[Float32x4_t].eltype = float_type_node;
 
@@ -889,7 +917,7 @@ arm_init_simd_builtin_scalar_types (void)
 static void
 arm_init_neon_builtins (void)
 {
-  unsigned int i, fcode = ARM_BUILTIN_NEON_BASE;
+  unsigned int i, fcode = ARM_BUILTIN_NEON_PATTERN_START;
 
   arm_init_simd_builtin_types ();
 
@@ -899,6 +927,15 @@ arm_init_neon_builtins (void)
      system.  */
   arm_init_simd_builtin_scalar_types ();
 
+  tree lane_check_fpr = build_function_type_list (void_type_node,
+						  intSI_type_node,
+						  intSI_type_node,
+						  NULL);
+  arm_builtin_decls[ARM_BUILTIN_NEON_LANE_CHECK] =
+      add_builtin_function ("__builtin_arm_lane_check", lane_check_fpr,
+			    ARM_BUILTIN_NEON_LANE_CHECK, BUILT_IN_MD,
+			    NULL, NULL_TREE);
+
   for (i = 0; i < ARRAY_SIZE (neon_builtin_data); i++, fcode++)
     {
       bool print_type_signature_p = false;
@@ -1086,10 +1123,11 @@ arm_init_neon_builtins (void)
 #undef NUM_DREG_TYPES
 #undef NUM_QREG_TYPES
 
-#define def_mbuiltin(MASK, NAME, TYPE, CODE)				\
+#define def_mbuiltin(FLAGS, NAME, TYPE, CODE)				\
   do									\
     {									\
-      if ((MASK) & insn_flags)						\
+      const arm_feature_set flags = FLAGS;				\
+      if (ARM_FSET_CPU_SUBSET (flags, insn_flags))			\
 	{								\
 	  tree bdecl;							\
 	  bdecl = add_builtin_function ((NAME), (TYPE), (CODE),		\
@@ -1101,7 +1139,7 @@ arm_init_neon_builtins (void)
 
 struct builtin_description
 {
-  const unsigned int       mask;
+  const arm_feature_set    features;
   const enum insn_code     icode;
   const char * const       name;
   const enum arm_builtins  code;
@@ -1112,11 +1150,13 @@ struct builtin_description
 static const struct builtin_description bdesc_2arg[] =
 {
 #define IWMMXT_BUILTIN(code, string, builtin) \
-  { FL_IWMMXT, CODE_FOR_##code, "__builtin_arm_" string, \
+  { ARM_FSET_MAKE_CPU1 (FL_IWMMXT), CODE_FOR_##code, \
+    "__builtin_arm_" string,			     \
     ARM_BUILTIN_##builtin, UNKNOWN, 0 },
 
 #define IWMMXT2_BUILTIN(code, string, builtin) \
-  { FL_IWMMXT2, CODE_FOR_##code, "__builtin_arm_" string, \
+  { ARM_FSET_MAKE_CPU1 (FL_IWMMXT2), CODE_FOR_##code, \
+    "__builtin_arm_" string,			      \
     ARM_BUILTIN_##builtin, UNKNOWN, 0 },
 
   IWMMXT_BUILTIN (addv8qi3, "waddb", WADDB)
@@ -1199,10 +1239,12 @@ static const struct builtin_description bdesc_2arg[] =
   IWMMXT_BUILTIN (iwmmxt_walignr3, "walignr3", WALIGNR3)
 
 #define IWMMXT_BUILTIN2(code, builtin) \
-  { FL_IWMMXT, CODE_FOR_##code, NULL, ARM_BUILTIN_##builtin, UNKNOWN, 0 },
+  { ARM_FSET_MAKE_CPU1 (FL_IWMMXT), CODE_FOR_##code, NULL, \
+    ARM_BUILTIN_##builtin, UNKNOWN, 0 },
 
 #define IWMMXT2_BUILTIN2(code, builtin) \
-  { FL_IWMMXT2, CODE_FOR_##code, NULL, ARM_BUILTIN_##builtin, UNKNOWN, 0 },
+  { ARM_FSET_MAKE_CPU2 (FL_IWMMXT2), CODE_FOR_##code, NULL, \
+    ARM_BUILTIN_##builtin, UNKNOWN, 0 },
 
   IWMMXT2_BUILTIN2 (iwmmxt_waddbhusm, WADDBHUSM)
   IWMMXT2_BUILTIN2 (iwmmxt_waddbhusl, WADDBHUSL)
@@ -1217,7 +1259,7 @@ static const struct builtin_description bdesc_2arg[] =
 
 
 #define FP_BUILTIN(L, U) \
-  {0, CODE_FOR_##L, "__builtin_arm_"#L, ARM_BUILTIN_##U, \
+  {ARM_FSET_EMPTY, CODE_FOR_##L, "__builtin_arm_"#L, ARM_BUILTIN_##U, \
    UNKNOWN, 0},
 
   FP_BUILTIN (get_fpscr, GET_FPSCR)
@@ -1225,8 +1267,8 @@ static const struct builtin_description bdesc_2arg[] =
 #undef FP_BUILTIN
 
 #define CRC32_BUILTIN(L, U) \
-  {0, CODE_FOR_##L, "__builtin_arm_"#L, ARM_BUILTIN_##U, \
-   UNKNOWN, 0},
+  {ARM_FSET_EMPTY, CODE_FOR_##L, "__builtin_arm_"#L, \
+   ARM_BUILTIN_##U, UNKNOWN, 0},
    CRC32_BUILTIN (crc32b, CRC32B)
    CRC32_BUILTIN (crc32h, CRC32H)
    CRC32_BUILTIN (crc32w, CRC32W)
@@ -1236,9 +1278,9 @@ static const struct builtin_description bdesc_2arg[] =
 #undef CRC32_BUILTIN
 
 
-#define CRYPTO_BUILTIN(L, U) \
-  {0, CODE_FOR_crypto_##L, "__builtin_arm_crypto_"#L, ARM_BUILTIN_CRYPTO_##U, \
-   UNKNOWN, 0},
+#define CRYPTO_BUILTIN(L, U)					   \
+  {ARM_FSET_EMPTY, CODE_FOR_crypto_##L,	"__builtin_arm_crypto_"#L, \
+   ARM_BUILTIN_CRYPTO_##U, UNKNOWN, 0},
 #undef CRYPTO1
 #undef CRYPTO2
 #undef CRYPTO3
@@ -1494,7 +1536,9 @@ arm_init_iwmmxt_builtins (void)
       machine_mode mode;
       tree type;
 
-      if (d->name == 0 || !(d->mask == FL_IWMMXT || d->mask == FL_IWMMXT2))
+      if (d->name == 0 ||
+	  !(ARM_FSET_HAS_CPU1 (d->features, FL_IWMMXT) ||
+	    ARM_FSET_HAS_CPU1 (d->features, FL_IWMMXT2)))
 	continue;
 
       mode = insn_data[d->icode].operand[1].mode;
@@ -1518,17 +1562,17 @@ arm_init_iwmmxt_builtins (void)
 	  gcc_unreachable ();
 	}
 
-      def_mbuiltin (d->mask, d->name, type, d->code);
+      def_mbuiltin (d->features, d->name, type, d->code);
     }
 
   /* Add the remaining MMX insns with somewhat more complicated types.  */
 #define iwmmx_mbuiltin(NAME, TYPE, CODE)			\
-  def_mbuiltin (FL_IWMMXT, "__builtin_arm_" NAME, (TYPE),	\
-		ARM_BUILTIN_ ## CODE)
+  def_mbuiltin (ARM_FSET_MAKE_CPU1 (FL_IWMMXT), "__builtin_arm_" NAME, \
+		(TYPE), ARM_BUILTIN_ ## CODE)
 
 #define iwmmx2_mbuiltin(NAME, TYPE, CODE)                      \
-  def_mbuiltin (FL_IWMMXT2, "__builtin_arm_" NAME, (TYPE),     \
-               ARM_BUILTIN_ ## CODE)
+  def_mbuiltin (ARM_FSET_MAKE_CPU1 (FL_IWMMXT2), "__builtin_arm_" NAME, \
+		(TYPE),	ARM_BUILTIN_ ## CODE)
 
   iwmmx_mbuiltin ("wzero", di_ftype_void, WZERO);
   iwmmx_mbuiltin ("setwcgr0", void_ftype_int, SETWCGR0);
@@ -1682,10 +1726,12 @@ arm_init_iwmmxt_builtins (void)
 static void
 arm_init_fp16_builtins (void)
 {
-  tree fp16_type = make_node (REAL_TYPE);
-  TYPE_PRECISION (fp16_type) = 16;
-  layout_type (fp16_type);
-  (*lang_hooks.types.register_builtin_type) (fp16_type, "__fp16");
+  arm_simd_floatHF_type_node = make_node (REAL_TYPE);
+  TYPE_PRECISION (arm_simd_floatHF_type_node) = GET_MODE_PRECISION (HFmode);
+  layout_type (arm_simd_floatHF_type_node);
+  if (arm_fp16_format)
+    (*lang_hooks.types.register_builtin_type) (arm_simd_floatHF_type_node,
+					       "__fp16");
 }
 
 static void
@@ -1730,12 +1776,13 @@ arm_init_builtins (void)
   if (TARGET_REALLY_IWMMXT)
     arm_init_iwmmxt_builtins ();
 
+  /* This creates the arm_simd_floatHF_type_node so must come before
+     arm_init_neon_builtins which uses it.  */
+  arm_init_fp16_builtins ();
+
   if (TARGET_NEON)
     arm_init_neon_builtins ();
 
-  if (arm_fp16_format)
-    arm_init_fp16_builtins ();
-
   if (TARGET_CRC32)
     arm_init_crc32_builtins ();
 
@@ -1939,6 +1986,7 @@ arm_expand_unop_builtin (enum insn_code icode,
 typedef enum {
   NEON_ARG_COPY_TO_REG,
   NEON_ARG_CONSTANT,
+  NEON_ARG_LANE_INDEX,
   NEON_ARG_MEMORY,
   NEON_ARG_STOP
 } builtin_arg;
@@ -2055,6 +2103,16 @@ arm_expand_neon_args (rtx target, machine_mode map_mode, int fcode,
 		op[argc] = copy_to_mode_reg (mode[argc], op[argc]);
 	      break;
 
+	    case NEON_ARG_LANE_INDEX:
+	      /* Previous argument must be a vector, which this indexes.  */
+	      gcc_assert (argc > 0);
+	      if (CONST_INT_P (op[argc]))
+		{
+		  enum machine_mode vmode = mode[argc - 1];
+		  neon_lane_bounds (op[argc], 0, GET_MODE_NUNITS (vmode), exp);
+		}
+	      /* Fall through - if the lane index isn't a constant then
+		 the next case will error.  */
 	    case NEON_ARG_CONSTANT:
 	      if (!(*insn_data[icode].operand[opno].predicate)
 		  (op[argc], mode[argc]))
@@ -2151,14 +2209,31 @@ arm_expand_neon_args (rtx target, machine_mode map_mode, int fcode,
   return target;
 }
 
-/* Expand a Neon builtin. These are "special" because they don't have symbolic
+/* Expand a Neon builtin, i.e. those registered only if TARGET_NEON holds.
+   Most of these are "special" because they don't have symbolic
    constants defined per-instruction or per instruction-variant. Instead, the
    required info is looked up in the table neon_builtin_data.  */
 static rtx
 arm_expand_neon_builtin (int fcode, tree exp, rtx target)
 {
+  if (fcode == ARM_BUILTIN_NEON_LANE_CHECK)
+    {
+      /* Builtin is only to check bounds of the lane passed to some intrinsics
+	 that are implemented with gcc vector extensions in arm_neon.h.  */
+
+      tree nlanes = CALL_EXPR_ARG (exp, 0);
+      gcc_assert (TREE_CODE (nlanes) == INTEGER_CST);
+      rtx lane_idx = expand_normal (CALL_EXPR_ARG (exp, 1));
+      if (CONST_INT_P (lane_idx))
+	neon_lane_bounds (lane_idx, 0, TREE_INT_CST_LOW (nlanes), exp);
+      else
+	error ("%Klane index must be a constant immediate", exp);
+      /* Don't generate any RTL.  */
+      return const0_rtx;
+    }
+
   neon_builtin_datum *d =
-		&neon_builtin_data[fcode - ARM_BUILTIN_NEON_BASE];
+		&neon_builtin_data[fcode - ARM_BUILTIN_NEON_PATTERN_START];
   enum insn_code icode = d->code;
   builtin_arg args[SIMD_MAX_BUILTIN_ARGS];
   int num_args = insn_data[d->code].n_operands;
@@ -2182,7 +2257,9 @@ arm_expand_neon_builtin (int fcode, tree exp, rtx target)
       int operands_k = k - is_void;
       int expr_args_k = k - 1;
 
-      if (d->qualifiers[qualifiers_k] & qualifier_immediate)
+      if (d->qualifiers[qualifiers_k] & qualifier_lane_index)
+	args[k] = NEON_ARG_LANE_INDEX;
+      else if (d->qualifiers[qualifiers_k] & qualifier_immediate)
 	args[k] = NEON_ARG_CONSTANT;
       else if (d->qualifiers[qualifiers_k] & qualifier_maybe_immediate)
 	{
--- a/src/gcc/config/arm/arm-c.c
+++ b/src/gcc/config/arm/arm-c.c
@@ -31,7 +31,11 @@
 #include "wide-int.h"
 #include "inchash.h"
 #include "tree.h"
+#include "tm_p.h"
 #include "c-family/c-common.h"
+#include "target.h"
+#include "target-def.h"
+#include "c-family/c-pragma.h"
 
 /* Output C specific EABI object attributes.  These can not be done in
    arm.c because they require information from the C frontend.  */
@@ -51,3 +55,223 @@ arm_lang_object_attributes_init (void)
 {
   arm_lang_output_object_attributes_hook = arm_output_c_attributes;
 }
+
+#define builtin_define(TXT) cpp_define (pfile, TXT)
+#define builtin_assert(TXT) cpp_assert (pfile, TXT)
+
+/* Define or undefine macros based on the current target.  If the user does
+   #pragma GCC target, we need to adjust the macros dynamically.  */
+
+static void
+def_or_undef_macro(struct cpp_reader* pfile, const char *name, bool def_p)
+{
+  if (def_p)
+    cpp_define (pfile, name);
+  else
+    cpp_undef (pfile, name);
+}
+
+static void
+arm_cpu_builtins (struct cpp_reader* pfile)
+{
+  def_or_undef_macro (pfile, "__ARM_FEATURE_DSP", TARGET_DSP_MULTIPLY);
+  def_or_undef_macro (pfile, "__ARM_FEATURE_QBIT", TARGET_ARM_QBIT); 
+  def_or_undef_macro (pfile, "__ARM_FEATURE_SAT", TARGET_ARM_SAT);
+  if (TARGET_CRYPTO)
+    builtin_define ("__ARM_FEATURE_CRYPTO");
+  if (unaligned_access)
+    builtin_define ("__ARM_FEATURE_UNALIGNED");
+  if (TARGET_CRC32)
+    builtin_define ("__ARM_FEATURE_CRC32");
+
+  def_or_undef_macro (pfile, "__ARM_32BIT_STATE", TARGET_32BIT); 
+
+  if (TARGET_ARM_FEATURE_LDREX)
+    builtin_define_with_int_value ("__ARM_FEATURE_LDREX", 
+				   TARGET_ARM_FEATURE_LDREX);
+  else
+    cpp_undef (pfile, "__ARM_FEATURE_LDREX");
+
+  def_or_undef_macro (pfile, "__ARM_FEATURE_CLZ",
+		      ((TARGET_ARM_ARCH >= 5 && !TARGET_THUMB)
+		       || TARGET_ARM_ARCH_ISA_THUMB >=2));
+
+  def_or_undef_macro (pfile, "__ARM_FEATURE_SIMD32", TARGET_INT_SIMD);
+
+  builtin_define_with_int_value ("__ARM_SIZEOF_MINIMAL_ENUM",
+				 flag_short_enums ? 1 : 4);
+  builtin_define_type_sizeof ("__ARM_SIZEOF_WCHAR_T", wchar_type_node);
+  if (TARGET_ARM_ARCH_PROFILE)
+    builtin_define_with_int_value ("__ARM_ARCH_PROFILE",
+				   TARGET_ARM_ARCH_PROFILE);
+
+  /* Define __arm__ even when in thumb mode, for
+     consistency with armcc.  */
+  builtin_define ("__arm__");
+  if (TARGET_ARM_ARCH)
+    builtin_define_with_int_value ("__ARM_ARCH", TARGET_ARM_ARCH);
+  if (arm_arch_notm)
+    builtin_define ("__ARM_ARCH_ISA_ARM");
+  builtin_define ("__APCS_32__");
+
+  def_or_undef_macro (pfile, "__thumb__", TARGET_THUMB);
+  def_or_undef_macro (pfile, "__thumb2__", TARGET_THUMB2);
+  if (TARGET_BIG_END)
+    def_or_undef_macro (pfile, "__THUMBEB__", TARGET_THUMB);
+  else
+    def_or_undef_macro (pfile, "__THUMBEL__", TARGET_THUMB);
+
+  if (TARGET_ARM_ARCH_ISA_THUMB)
+    builtin_define_with_int_value ("__ARM_ARCH_ISA_THUMB",
+				   TARGET_ARM_ARCH_ISA_THUMB);
+
+  if (TARGET_BIG_END)
+    {
+      builtin_define ("__ARMEB__");
+      builtin_define ("__ARM_BIG_ENDIAN");
+    }
+  else
+    {
+      builtin_define ("__ARMEL__");
+    }
+
+  if (TARGET_SOFT_FLOAT)
+    builtin_define ("__SOFTFP__");
+
+  if (TARGET_VFP)
+    builtin_define ("__VFP_FP__");
+	
+  if (TARGET_ARM_FP)
+    builtin_define_with_int_value ("__ARM_FP", TARGET_ARM_FP);
+  if (arm_fp16_format == ARM_FP16_FORMAT_IEEE)
+    builtin_define ("__ARM_FP16_FORMAT_IEEE");
+  if (arm_fp16_format == ARM_FP16_FORMAT_ALTERNATIVE)
+    builtin_define ("__ARM_FP16_FORMAT_ALTERNATIVE");
+  if (TARGET_FMA)
+    builtin_define ("__ARM_FEATURE_FMA");
+
+  if (TARGET_NEON)
+    {
+      builtin_define ("__ARM_NEON__");
+      builtin_define ("__ARM_NEON");
+    }
+  if (TARGET_NEON_FP)
+    builtin_define_with_int_value ("__ARM_NEON_FP", TARGET_NEON_FP);
+  
+  /* Add a define for interworking. Needed when building libgcc.a.  */
+  if (arm_cpp_interwork)
+    builtin_define ("__THUMB_INTERWORK__");
+
+
+  builtin_define (arm_arch_name);
+  if (arm_arch_xscale)
+    builtin_define ("__XSCALE__");
+  if (arm_arch_iwmmxt)
+    {
+      builtin_define ("__IWMMXT__");
+      builtin_define ("__ARM_WMMX");
+    }
+  if (arm_arch_iwmmxt2)
+    builtin_define ("__IWMMXT2__");
+  /* ARMv6KZ was originally identified as the misspelled __ARM_ARCH_6ZK__.  To
+     preserve the existing behaviour, the misspelled feature macro must still be
+     defined.  */
+  if (arm_arch6kz)
+    builtin_define ("__ARM_ARCH_6ZK__");
+  if (TARGET_AAPCS_BASED)
+    {
+      if (arm_pcs_default == ARM_PCS_AAPCS_VFP)
+	builtin_define ("__ARM_PCS_VFP");
+      else if (arm_pcs_default == ARM_PCS_AAPCS)
+	builtin_define ("__ARM_PCS");
+      builtin_define ("__ARM_EABI__");
+    }
+
+  def_or_undef_macro (pfile, "__ARM_ARCH_EXT_IDIV__", TARGET_IDIV);
+  def_or_undef_macro (pfile, "__ARM_FEATURE_IDIV", TARGET_IDIV);
+
+  def_or_undef_macro (pfile, "__ARM_ASM_SYNTAX_UNIFIED__", inline_asm_unified);
+}
+
+void
+arm_cpu_cpp_builtins (struct cpp_reader * pfile)
+{
+  builtin_assert ("cpu=arm");
+  builtin_assert ("machine=arm");
+
+  arm_cpu_builtins (pfile);
+}
+
+/* Hook to validate the current #pragma GCC target and set the arch custom
+   mode state.  If ARGS is NULL, then POP_TARGET is used to reset
+   the options.  */
+static bool
+arm_pragma_target_parse (tree args, tree pop_target)
+{
+  tree prev_tree = build_target_option_node (&global_options);
+  tree cur_tree;
+  struct cl_target_option *prev_opt;
+  struct cl_target_option *cur_opt;
+
+  if (! args)
+    {
+      cur_tree = ((pop_target) ? pop_target : target_option_default_node);
+      cl_target_option_restore (&global_options,
+				TREE_TARGET_OPTION (cur_tree));
+    }
+  else
+    {
+      cur_tree = arm_valid_target_attribute_tree (args, &global_options,
+						  &global_options_set);
+      if (cur_tree == NULL_TREE)
+	{
+	  cl_target_option_restore (&global_options,
+				    TREE_TARGET_OPTION (prev_tree));
+	  return false;
+	}
+    }
+
+  target_option_current_node = cur_tree;
+  arm_reset_previous_fndecl ();
+
+  /* Figure out the previous mode.  */
+  prev_opt  = TREE_TARGET_OPTION (prev_tree);
+  cur_opt   = TREE_TARGET_OPTION (cur_tree);
+
+  gcc_assert (prev_opt);
+  gcc_assert (cur_opt);
+
+  if (cur_opt->x_target_flags != prev_opt->x_target_flags)
+    {
+      /* For the definitions, ensure all newly defined macros are considered
+	 as used for -Wunused-macros.  There is no point warning about the
+	 compiler predefined macros.  */
+      cpp_options *cpp_opts = cpp_get_options (parse_in);
+      unsigned char saved_warn_unused_macros = cpp_opts->warn_unused_macros;
+      cpp_opts->warn_unused_macros = 0;
+
+      /* Update macros.  */
+      gcc_assert (cur_opt->x_target_flags == target_flags);
+      arm_cpu_builtins (parse_in);
+
+      cpp_opts->warn_unused_macros = saved_warn_unused_macros;
+    }
+
+  return true;
+}
+
+/* Register target pragmas.  We need to add the hook for parsing #pragma GCC
+   option here rather than in arm.c since it will pull in various preprocessor
+   functions, and those are not present in languages like fortran without a
+   preprocessor.  */
+
+void
+arm_register_target_pragmas (void)
+{
+  /* Update pragma hook to allow parsing #pragma GCC target.  */
+  targetm.target_option.pragma_parse = arm_pragma_target_parse;
+
+#ifdef REGISTER_SUBTARGET_PRAGMAS
+  REGISTER_SUBTARGET_PRAGMAS ();
+#endif
+}
--- a/src/gcc/config/arm/arm-cores.def
+++ b/src/gcc/config/arm/arm-cores.def
@@ -33,7 +33,7 @@
    The TUNE_IDENT is the name of the core for which scheduling decisions
    should be made, represented as an identifier.
    ARCH is the architecture revision implemented by the chip.
-   FLAGS are the bitwise-or of the traits that apply to that core.
+   FLAGS is the set of feature flags of that core.
    This need not include flags implied by the architecture.
    COSTS is the name of the rtx_costs routine to use.
 
@@ -43,134 +43,134 @@
    Some tools assume no whitespace up to the first "," in each entry.  */
 
 /* V2/V2A Architecture Processors */
-ARM_CORE("arm2", 	arm2, arm2,	2, FL_CO_PROC | FL_MODE26, slowmul)
-ARM_CORE("arm250", 	arm250, arm250,	2, FL_CO_PROC | FL_MODE26, slowmul)
-ARM_CORE("arm3",	arm3, arm3,	2, FL_CO_PROC | FL_MODE26, slowmul)
+ARM_CORE("arm2",	arm2, arm2,	2,	ARM_FSET_MAKE_CPU1 (FL_CO_PROC | FL_MODE26 | FL_FOR_ARCH2), slowmul)
+ARM_CORE("arm250",	arm250, arm250,	2,	ARM_FSET_MAKE_CPU1 (FL_CO_PROC | FL_MODE26 | FL_FOR_ARCH2), slowmul)
+ARM_CORE("arm3",	arm3, arm3,	2,	ARM_FSET_MAKE_CPU1 (FL_CO_PROC | FL_MODE26 | FL_FOR_ARCH2), slowmul)
 
 /* V3 Architecture Processors */
-ARM_CORE("arm6",	arm6, arm6,		3, FL_CO_PROC | FL_MODE26, slowmul)
-ARM_CORE("arm60",	arm60, arm60,		3, FL_CO_PROC | FL_MODE26, slowmul)
-ARM_CORE("arm600",	arm600, arm600,		3, FL_CO_PROC | FL_MODE26 | FL_WBUF, slowmul)
-ARM_CORE("arm610",	arm610, arm610,		3, FL_MODE26 | FL_WBUF, slowmul)
-ARM_CORE("arm620",	arm620, arm620,		3, FL_CO_PROC | FL_MODE26 | FL_WBUF, slowmul)
-ARM_CORE("arm7",	arm7, arm7,		3, FL_CO_PROC | FL_MODE26, slowmul)
-ARM_CORE("arm7d",	arm7d, arm7d,		3, FL_CO_PROC | FL_MODE26, slowmul)
-ARM_CORE("arm7di",	arm7di, arm7di,		3, FL_CO_PROC | FL_MODE26, slowmul)
-ARM_CORE("arm70",	arm70, arm70,		3, FL_CO_PROC | FL_MODE26, slowmul)
-ARM_CORE("arm700",	arm700, arm700,		3, FL_CO_PROC | FL_MODE26 | FL_WBUF, slowmul)
-ARM_CORE("arm700i",	arm700i, arm700i,	3, FL_CO_PROC | FL_MODE26 | FL_WBUF, slowmul)
-ARM_CORE("arm710",	arm710, arm710,		3, FL_MODE26 | FL_WBUF, slowmul)
-ARM_CORE("arm720",	arm720, arm720,		3, FL_MODE26 | FL_WBUF, slowmul)
-ARM_CORE("arm710c",	arm710c, arm710c,	3, FL_MODE26 | FL_WBUF, slowmul)
-ARM_CORE("arm7100",	arm7100, arm7100,	3, FL_MODE26 | FL_WBUF, slowmul)
-ARM_CORE("arm7500",	arm7500, arm7500,	3, FL_MODE26 | FL_WBUF, slowmul)
+ARM_CORE("arm6",	arm6, arm6,		3,	ARM_FSET_MAKE_CPU1 (FL_CO_PROC | FL_MODE26 | FL_FOR_ARCH3), slowmul)
+ARM_CORE("arm60",	arm60, arm60,		3,	ARM_FSET_MAKE_CPU1 (FL_CO_PROC | FL_MODE26 | FL_FOR_ARCH3), slowmul)
+ARM_CORE("arm600",	arm600, arm600,		3,	ARM_FSET_MAKE_CPU1 (FL_CO_PROC | FL_MODE26 | FL_WBUF | FL_FOR_ARCH3), slowmul)
+ARM_CORE("arm610",	arm610, arm610,		3,	ARM_FSET_MAKE_CPU1 (FL_MODE26 | FL_WBUF | FL_FOR_ARCH3), slowmul)
+ARM_CORE("arm620",	arm620, arm620,		3,	ARM_FSET_MAKE_CPU1 (FL_CO_PROC | FL_MODE26 | FL_WBUF | FL_FOR_ARCH3), slowmul)
+ARM_CORE("arm7",	arm7, arm7,		3,	ARM_FSET_MAKE_CPU1 (FL_CO_PROC | FL_MODE26 | FL_FOR_ARCH3), slowmul)
+ARM_CORE("arm7d",	arm7d, arm7d,		3,	ARM_FSET_MAKE_CPU1 (FL_CO_PROC | FL_MODE26 | FL_FOR_ARCH3), slowmul)
+ARM_CORE("arm7di",	arm7di, arm7di,		3,	ARM_FSET_MAKE_CPU1 (FL_CO_PROC | FL_MODE26 | FL_FOR_ARCH3), slowmul)
+ARM_CORE("arm70",	arm70, arm70,		3,	ARM_FSET_MAKE_CPU1 (FL_CO_PROC | FL_MODE26 | FL_FOR_ARCH3), slowmul)
+ARM_CORE("arm700",	arm700, arm700,		3,	ARM_FSET_MAKE_CPU1 (FL_CO_PROC | FL_MODE26 | FL_WBUF | FL_FOR_ARCH3), slowmul)
+ARM_CORE("arm700i",	arm700i, arm700i,	3,	ARM_FSET_MAKE_CPU1 (FL_CO_PROC | FL_MODE26 | FL_WBUF | FL_FOR_ARCH3), slowmul)
+ARM_CORE("arm710",	arm710, arm710,		3,	ARM_FSET_MAKE_CPU1 (FL_MODE26 | FL_WBUF | FL_FOR_ARCH3), slowmul)
+ARM_CORE("arm720",	arm720, arm720,		3,	ARM_FSET_MAKE_CPU1 (FL_MODE26 | FL_WBUF | FL_FOR_ARCH3), slowmul)
+ARM_CORE("arm710c",	arm710c, arm710c,	3,	ARM_FSET_MAKE_CPU1 (FL_MODE26 | FL_WBUF | FL_FOR_ARCH3), slowmul)
+ARM_CORE("arm7100",	arm7100, arm7100,	3,	ARM_FSET_MAKE_CPU1 (FL_MODE26 | FL_WBUF | FL_FOR_ARCH3), slowmul)
+ARM_CORE("arm7500",	arm7500, arm7500,	3,	ARM_FSET_MAKE_CPU1 (FL_MODE26 | FL_WBUF | FL_FOR_ARCH3), slowmul)
 /* Doesn't have an external co-proc, but does have embedded fpa. */
-ARM_CORE("arm7500fe", arm7500fe, arm7500fe,	3, FL_CO_PROC | FL_MODE26 | FL_WBUF, slowmul)
+ARM_CORE("arm7500fe", arm7500fe, arm7500fe,	3,	ARM_FSET_MAKE_CPU1 (FL_CO_PROC | FL_MODE26 | FL_WBUF | FL_FOR_ARCH3), slowmul)
 
 /* V3M Architecture Processors */
 /* arm7m doesn't exist on its own, but only with D, ("and", and I), but
    those don't alter the code, so arm7m is sometimes used.  */
-ARM_CORE("arm7m",   arm7m, arm7m,	3M, FL_CO_PROC | FL_MODE26, fastmul)
-ARM_CORE("arm7dm",  arm7dm, arm7dm,	3M, FL_CO_PROC | FL_MODE26, fastmul)
-ARM_CORE("arm7dmi", arm7dmi, arm7dmi,	3M, FL_CO_PROC | FL_MODE26, fastmul)
+ARM_CORE("arm7m",   arm7m, arm7m,	3M,	ARM_FSET_MAKE_CPU1 (FL_CO_PROC | FL_MODE26 | FL_FOR_ARCH3M), fastmul)
+ARM_CORE("arm7dm",  arm7dm, arm7dm,	3M,	ARM_FSET_MAKE_CPU1 (FL_CO_PROC | FL_MODE26 | FL_FOR_ARCH3M), fastmul)
+ARM_CORE("arm7dmi", arm7dmi, arm7dmi,	3M,	ARM_FSET_MAKE_CPU1 (FL_CO_PROC | FL_MODE26 | FL_FOR_ARCH3M), fastmul)
 
 /* V4 Architecture Processors */
-ARM_CORE("arm8",          arm8, arm8,			4, FL_MODE26 | FL_LDSCHED, fastmul)
-ARM_CORE("arm810",        arm810, arm810,		4, FL_MODE26 | FL_LDSCHED, fastmul)
-ARM_CORE("strongarm",     strongarm, strongarm,		4, FL_MODE26 | FL_LDSCHED | FL_STRONG, strongarm)
-ARM_CORE("strongarm110",  strongarm110, strongarm110,	4, FL_MODE26 | FL_LDSCHED | FL_STRONG, strongarm)
-ARM_CORE("strongarm1100", strongarm1100, strongarm1100, 4, FL_MODE26 | FL_LDSCHED | FL_STRONG, strongarm)
-ARM_CORE("strongarm1110", strongarm1110, strongarm1110, 4, FL_MODE26 | FL_LDSCHED | FL_STRONG, strongarm)
-ARM_CORE("fa526",         fa526, fa526,			4, FL_LDSCHED, fastmul)
-ARM_CORE("fa626",         fa626, fa626,			4, FL_LDSCHED, fastmul)
+ARM_CORE("arm8",          arm8, arm8,			4,	ARM_FSET_MAKE_CPU1 (FL_MODE26 | FL_LDSCHED | FL_FOR_ARCH4), fastmul)
+ARM_CORE("arm810",        arm810, arm810,		4,	ARM_FSET_MAKE_CPU1 (FL_MODE26 | FL_LDSCHED | FL_FOR_ARCH4), fastmul)
+ARM_CORE("strongarm",     strongarm, strongarm,		4,	ARM_FSET_MAKE_CPU1 (FL_MODE26 | FL_LDSCHED | FL_STRONG | FL_FOR_ARCH4), strongarm)
+ARM_CORE("strongarm110",  strongarm110, strongarm110,	4,	ARM_FSET_MAKE_CPU1 (FL_MODE26 | FL_LDSCHED | FL_STRONG | FL_FOR_ARCH4), strongarm)
+ARM_CORE("strongarm1100", strongarm1100, strongarm1100, 4,	ARM_FSET_MAKE_CPU1 (FL_MODE26 | FL_LDSCHED | FL_STRONG | FL_FOR_ARCH4), strongarm)
+ARM_CORE("strongarm1110", strongarm1110, strongarm1110, 4,	ARM_FSET_MAKE_CPU1 (FL_MODE26 | FL_LDSCHED | FL_STRONG | FL_FOR_ARCH4), strongarm)
+ARM_CORE("fa526",         fa526, fa526,			4,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_FOR_ARCH4), fastmul)
+ARM_CORE("fa626",         fa626, fa626,			4,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_FOR_ARCH4), fastmul)
 
 /* V4T Architecture Processors */
-ARM_CORE("arm7tdmi",	arm7tdmi, arm7tdmi,	4T, FL_CO_PROC, fastmul)
-ARM_CORE("arm7tdmi-s",	arm7tdmis, arm7tdmis,	4T, FL_CO_PROC, fastmul)
-ARM_CORE("arm710t",	arm710t, arm710t,	4T, FL_WBUF,    fastmul)
-ARM_CORE("arm720t",	arm720t, arm720t,	4T, FL_WBUF,    fastmul)
-ARM_CORE("arm740t",	arm740t, arm740t,	4T, FL_WBUF,    fastmul)
-ARM_CORE("arm9",	arm9, arm9,		4T, FL_LDSCHED, fastmul)
-ARM_CORE("arm9tdmi",	arm9tdmi, arm9tdmi,	4T, FL_LDSCHED, fastmul)
-ARM_CORE("arm920",	arm920, arm920,		4T, FL_LDSCHED, fastmul)
-ARM_CORE("arm920t",	arm920t, arm920t,	4T, FL_LDSCHED, fastmul)
-ARM_CORE("arm922t",	arm922t, arm922t,	4T, FL_LDSCHED, fastmul)
-ARM_CORE("arm940t",	arm940t, arm940t,	4T, FL_LDSCHED, fastmul)
-ARM_CORE("ep9312",	ep9312, ep9312,		4T, FL_LDSCHED, fastmul)
+ARM_CORE("arm7tdmi",	arm7tdmi, arm7tdmi,	4T,	ARM_FSET_MAKE_CPU1 (FL_CO_PROC | FL_FOR_ARCH4T), fastmul)
+ARM_CORE("arm7tdmi-s",	arm7tdmis, arm7tdmis,	4T,	ARM_FSET_MAKE_CPU1 (FL_CO_PROC | FL_FOR_ARCH4T), fastmul)
+ARM_CORE("arm710t",	arm710t, arm710t,	4T,	ARM_FSET_MAKE_CPU1 (FL_WBUF | FL_FOR_ARCH4T),    fastmul)
+ARM_CORE("arm720t",	arm720t, arm720t,	4T,	ARM_FSET_MAKE_CPU1 (FL_WBUF | FL_FOR_ARCH4T),    fastmul)
+ARM_CORE("arm740t",	arm740t, arm740t,	4T,	ARM_FSET_MAKE_CPU1 (FL_WBUF | FL_FOR_ARCH4T),    fastmul)
+ARM_CORE("arm9",	arm9, arm9,		4T,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_FOR_ARCH4T), fastmul)
+ARM_CORE("arm9tdmi",	arm9tdmi, arm9tdmi,	4T,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_FOR_ARCH4T), fastmul)
+ARM_CORE("arm920",	arm920, arm920,		4T,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_FOR_ARCH4T), fastmul)
+ARM_CORE("arm920t",	arm920t, arm920t,	4T,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_FOR_ARCH4T), fastmul)
+ARM_CORE("arm922t",	arm922t, arm922t,	4T,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_FOR_ARCH4T), fastmul)
+ARM_CORE("arm940t",	arm940t, arm940t,	4T,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_FOR_ARCH4T), fastmul)
+ARM_CORE("ep9312",	ep9312, ep9312,		4T,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_FOR_ARCH4T), fastmul)
 
 /* V5T Architecture Processors */
-ARM_CORE("arm10tdmi",	arm10tdmi, arm10tdmi,	5T, FL_LDSCHED, fastmul)
-ARM_CORE("arm1020t",	arm1020t, arm1020t,	5T, FL_LDSCHED, fastmul)
+ARM_CORE("arm10tdmi",	arm10tdmi, arm10tdmi,	5T,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_FOR_ARCH5T), fastmul)
+ARM_CORE("arm1020t",	arm1020t, arm1020t,	5T,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_FOR_ARCH5T), fastmul)
 
 /* V5TE Architecture Processors */
-ARM_CORE("arm9e",	arm9e, arm9e,		5TE, FL_LDSCHED, 9e)
-ARM_CORE("arm946e-s",	arm946es, arm946es,	5TE, FL_LDSCHED, 9e)
-ARM_CORE("arm966e-s",	arm966es, arm966es,	5TE, FL_LDSCHED, 9e)
-ARM_CORE("arm968e-s",	arm968es, arm968es,	5TE, FL_LDSCHED, 9e)
-ARM_CORE("arm10e",	arm10e, arm10e,		5TE, FL_LDSCHED, fastmul)
-ARM_CORE("arm1020e",	arm1020e, arm1020e,	5TE, FL_LDSCHED, fastmul)
-ARM_CORE("arm1022e",	arm1022e, arm1022e,	5TE, FL_LDSCHED, fastmul)
-ARM_CORE("xscale",	xscale, xscale,		5TE, FL_LDSCHED | FL_STRONG | FL_XSCALE, xscale)
-ARM_CORE("iwmmxt",	iwmmxt, iwmmxt,		5TE, FL_LDSCHED | FL_STRONG | FL_XSCALE | FL_IWMMXT, xscale)
-ARM_CORE("iwmmxt2",	iwmmxt2, iwmmxt2,	5TE, FL_LDSCHED | FL_STRONG | FL_XSCALE | FL_IWMMXT | FL_IWMMXT2, xscale)
-ARM_CORE("fa606te",	fa606te, fa606te,	5TE, FL_LDSCHED, 9e)
-ARM_CORE("fa626te",	fa626te, fa626te,	5TE, FL_LDSCHED, 9e)
-ARM_CORE("fmp626",	fmp626, fmp626,		5TE, FL_LDSCHED, 9e)
-ARM_CORE("fa726te",	fa726te, fa726te,	5TE, FL_LDSCHED, fa726te)
+ARM_CORE("arm9e",	arm9e, arm9e,		5TE,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_FOR_ARCH5TE), 9e)
+ARM_CORE("arm946e-s",	arm946es, arm946es,	5TE,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_FOR_ARCH5TE), 9e)
+ARM_CORE("arm966e-s",	arm966es, arm966es,	5TE,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_FOR_ARCH5TE), 9e)
+ARM_CORE("arm968e-s",	arm968es, arm968es,	5TE,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_FOR_ARCH5TE), 9e)
+ARM_CORE("arm10e",	arm10e, arm10e,		5TE,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_FOR_ARCH5TE), fastmul)
+ARM_CORE("arm1020e",	arm1020e, arm1020e,	5TE,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_FOR_ARCH5TE), fastmul)
+ARM_CORE("arm1022e",	arm1022e, arm1022e,	5TE,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_FOR_ARCH5TE), fastmul)
+ARM_CORE("xscale",	xscale, xscale,		5TE,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_STRONG | FL_XSCALE | FL_FOR_ARCH5TE), xscale)
+ARM_CORE("iwmmxt",	iwmmxt, iwmmxt,		5TE,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_STRONG | FL_XSCALE | FL_IWMMXT | FL_FOR_ARCH5TE), xscale)
+ARM_CORE("iwmmxt2",	iwmmxt2, iwmmxt2,	5TE,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_STRONG | FL_XSCALE | FL_IWMMXT | FL_IWMMXT2 | FL_FOR_ARCH5TE), xscale)
+ARM_CORE("fa606te",	fa606te, fa606te,	5TE,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_FOR_ARCH5TE), 9e)
+ARM_CORE("fa626te",	fa626te, fa626te,	5TE,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_FOR_ARCH5TE), 9e)
+ARM_CORE("fmp626",	fmp626, fmp626,		5TE,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_FOR_ARCH5TE), 9e)
+ARM_CORE("fa726te",	fa726te, fa726te,	5TE,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_FOR_ARCH5TE), fa726te)
 
 /* V5TEJ Architecture Processors */
-ARM_CORE("arm926ej-s",	arm926ejs, arm926ejs,	5TEJ, FL_LDSCHED, 9e)
-ARM_CORE("arm1026ej-s",	arm1026ejs, arm1026ejs,	5TEJ, FL_LDSCHED, 9e)
+ARM_CORE("arm926ej-s",	arm926ejs, arm926ejs,	5TEJ,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_FOR_ARCH5TEJ), 9e)
+ARM_CORE("arm1026ej-s",	arm1026ejs, arm1026ejs,	5TEJ,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_FOR_ARCH5TEJ), 9e)
 
 /* V6 Architecture Processors */
-ARM_CORE("arm1136j-s",		arm1136js, arm1136js,		6J,  FL_LDSCHED, 9e)
-ARM_CORE("arm1136jf-s",		arm1136jfs, arm1136jfs,		6J,  FL_LDSCHED | FL_VFPV2, 9e)
-ARM_CORE("arm1176jz-s",		arm1176jzs, arm1176jzs,		6ZK, FL_LDSCHED, 9e)
-ARM_CORE("arm1176jzf-s",	arm1176jzfs, arm1176jzfs,	6ZK, FL_LDSCHED | FL_VFPV2, 9e)
-ARM_CORE("mpcorenovfp",		mpcorenovfp, mpcorenovfp,	6K,  FL_LDSCHED, 9e)
-ARM_CORE("mpcore",		mpcore, mpcore,			6K,  FL_LDSCHED | FL_VFPV2, 9e)
-ARM_CORE("arm1156t2-s",		arm1156t2s, arm1156t2s,		6T2, FL_LDSCHED, v6t2)
-ARM_CORE("arm1156t2f-s",	arm1156t2fs, arm1156t2fs,	6T2, FL_LDSCHED | FL_VFPV2, v6t2)
+ARM_CORE("arm1136j-s",		arm1136js, arm1136js,		6J,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_FOR_ARCH6J), 9e)
+ARM_CORE("arm1136jf-s",		arm1136jfs, arm1136jfs,		6J,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_VFPV2 | FL_FOR_ARCH6J), 9e)
+ARM_CORE("arm1176jz-s",		arm1176jzs, arm1176jzs,		6KZ,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_FOR_ARCH6KZ), 9e)
+ARM_CORE("arm1176jzf-s",	arm1176jzfs, arm1176jzfs,	6KZ,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_VFPV2 | FL_FOR_ARCH6KZ), 9e)
+ARM_CORE("mpcorenovfp",		mpcorenovfp, mpcorenovfp,	6K,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_FOR_ARCH6K), 9e)
+ARM_CORE("mpcore",		mpcore, mpcore,			6K,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_VFPV2 | FL_FOR_ARCH6K), 9e)
+ARM_CORE("arm1156t2-s",		arm1156t2s, arm1156t2s,		6T2,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_FOR_ARCH6T2), v6t2)
+ARM_CORE("arm1156t2f-s",	arm1156t2fs, arm1156t2fs,	6T2,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_VFPV2 | FL_FOR_ARCH6T2), v6t2)
 
 /* V6M Architecture Processors */
-ARM_CORE("cortex-m1",		cortexm1, cortexm1,		6M, FL_LDSCHED, v6m)
-ARM_CORE("cortex-m0",		cortexm0, cortexm0,		6M, FL_LDSCHED, v6m)
-ARM_CORE("cortex-m0plus",	cortexm0plus, cortexm0plus,	6M, FL_LDSCHED, v6m)
+ARM_CORE("cortex-m1",		cortexm1, cortexm1,		6M,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_FOR_ARCH6M), v6m)
+ARM_CORE("cortex-m0",		cortexm0, cortexm0,		6M,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_FOR_ARCH6M), v6m)
+ARM_CORE("cortex-m0plus",	cortexm0plus, cortexm0plus,	6M,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_FOR_ARCH6M), v6m)
 
 /* V6M Architecture Processors for small-multiply implementations.  */
-ARM_CORE("cortex-m1.small-multiply",	cortexm1smallmultiply, cortexm1,	6M, FL_LDSCHED | FL_SMALLMUL, v6m)
-ARM_CORE("cortex-m0.small-multiply",	cortexm0smallmultiply, cortexm0,	6M, FL_LDSCHED | FL_SMALLMUL, v6m)
-ARM_CORE("cortex-m0plus.small-multiply",cortexm0plussmallmultiply, cortexm0plus,6M, FL_LDSCHED | FL_SMALLMUL, v6m)
+ARM_CORE("cortex-m1.small-multiply",	cortexm1smallmultiply, cortexm1,	6M,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_SMALLMUL | FL_FOR_ARCH6M), v6m)
+ARM_CORE("cortex-m0.small-multiply",	cortexm0smallmultiply, cortexm0,	6M,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_SMALLMUL | FL_FOR_ARCH6M), v6m)
+ARM_CORE("cortex-m0plus.small-multiply",cortexm0plussmallmultiply, cortexm0plus,6M,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_SMALLMUL | FL_FOR_ARCH6M), v6m)
 
 /* V7 Architecture Processors */
-ARM_CORE("generic-armv7-a",	genericv7a, genericv7a,		7A,  FL_LDSCHED, cortex)
-ARM_CORE("cortex-a5",		cortexa5, cortexa5,		7A,  FL_LDSCHED, cortex_a5)
-ARM_CORE("cortex-a7",		cortexa7, cortexa7,		7A,  FL_LDSCHED | FL_THUMB_DIV | FL_ARM_DIV, cortex_a7)
-ARM_CORE("cortex-a8",		cortexa8, cortexa8,		7A,  FL_LDSCHED, cortex_a8)
-ARM_CORE("cortex-a9",		cortexa9, cortexa9,		7A,  FL_LDSCHED, cortex_a9)
-ARM_CORE("cortex-a12",	  	cortexa12, cortexa17,		7A,  FL_LDSCHED | FL_THUMB_DIV | FL_ARM_DIV, cortex_a12)
-ARM_CORE("cortex-a15",		cortexa15, cortexa15,		7A,  FL_LDSCHED | FL_THUMB_DIV | FL_ARM_DIV, cortex_a15)
-ARM_CORE("cortex-a17",		cortexa17, cortexa17,		7A,  FL_LDSCHED | FL_THUMB_DIV | FL_ARM_DIV, cortex_a12)
-ARM_CORE("cortex-r4",		cortexr4, cortexr4,		7R,  FL_LDSCHED, cortex)
-ARM_CORE("cortex-r4f",		cortexr4f, cortexr4f,		7R,  FL_LDSCHED, cortex)
-ARM_CORE("cortex-r5",		cortexr5, cortexr5,		7R,  FL_LDSCHED | FL_ARM_DIV, cortex)
-ARM_CORE("cortex-r7",		cortexr7, cortexr7,		7R,  FL_LDSCHED | FL_ARM_DIV, cortex)
-ARM_CORE("cortex-m7",		cortexm7, cortexm7,		7EM, FL_LDSCHED | FL_NO_VOLATILE_CE, cortex_m7)
-ARM_CORE("cortex-m4",		cortexm4, cortexm4,		7EM, FL_LDSCHED, v7m)
-ARM_CORE("cortex-m3",		cortexm3, cortexm3,		7M,  FL_LDSCHED, v7m)
-ARM_CORE("marvell-pj4",		marvell_pj4, marvell_pj4,	7A,  FL_LDSCHED, 9e)
+ARM_CORE("generic-armv7-a",	genericv7a, genericv7a,		7A,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_FOR_ARCH7A), cortex)
+ARM_CORE("cortex-a5",		cortexa5, cortexa5,		7A,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_FOR_ARCH7A), cortex_a5)
+ARM_CORE("cortex-a7",		cortexa7, cortexa7,		7A,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_THUMB_DIV | FL_ARM_DIV | FL_FOR_ARCH7A), cortex_a7)
+ARM_CORE("cortex-a8",		cortexa8, cortexa8,		7A,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_FOR_ARCH7A), cortex_a8)
+ARM_CORE("cortex-a9",		cortexa9, cortexa9,		7A,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_FOR_ARCH7A), cortex_a9)
+ARM_CORE("cortex-a12",		cortexa12, cortexa17,		7A,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_THUMB_DIV | FL_ARM_DIV | FL_FOR_ARCH7A), cortex_a12)
+ARM_CORE("cortex-a15",		cortexa15, cortexa15,		7A,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_THUMB_DIV | FL_ARM_DIV | FL_FOR_ARCH7A), cortex_a15)
+ARM_CORE("cortex-a17",		cortexa17, cortexa17,		7A,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_THUMB_DIV | FL_ARM_DIV | FL_FOR_ARCH7A), cortex_a12)
+ARM_CORE("cortex-r4",		cortexr4, cortexr4,		7R,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_FOR_ARCH7R), cortex)
+ARM_CORE("cortex-r4f",		cortexr4f, cortexr4f,		7R,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_FOR_ARCH7R), cortex)
+ARM_CORE("cortex-r5",		cortexr5, cortexr5,		7R,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_ARM_DIV | FL_FOR_ARCH7R), cortex)
+ARM_CORE("cortex-r7",		cortexr7, cortexr7,		7R,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_ARM_DIV | FL_FOR_ARCH7R), cortex)
+ARM_CORE("cortex-m7",		cortexm7, cortexm7,		7EM,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_NO_VOLATILE_CE | FL_FOR_ARCH7EM), cortex_m7)
+ARM_CORE("cortex-m4",		cortexm4, cortexm4,		7EM,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_FOR_ARCH7EM), v7m)
+ARM_CORE("cortex-m3",		cortexm3, cortexm3,		7M,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_FOR_ARCH7M), v7m)
+ARM_CORE("marvell-pj4",		marvell_pj4, marvell_pj4,	7A,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_FOR_ARCH7A), marvell_pj4)
 
 /* V7 big.LITTLE implementations */
-ARM_CORE("cortex-a15.cortex-a7", cortexa15cortexa7, cortexa7,	7A,  FL_LDSCHED | FL_THUMB_DIV | FL_ARM_DIV, cortex_a15)
-ARM_CORE("cortex-a17.cortex-a7", cortexa17cortexa7, cortexa7,	7A,  FL_LDSCHED | FL_THUMB_DIV | FL_ARM_DIV, cortex_a12)
+ARM_CORE("cortex-a15.cortex-a7", cortexa15cortexa7, cortexa7,	7A,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_THUMB_DIV | FL_ARM_DIV | FL_FOR_ARCH7A), cortex_a15)
+ARM_CORE("cortex-a17.cortex-a7", cortexa17cortexa7, cortexa7,	7A,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_THUMB_DIV | FL_ARM_DIV | FL_FOR_ARCH7A), cortex_a12)
 
 /* V8 Architecture Processors */
-ARM_CORE("cortex-a53",	cortexa53, cortexa53,	8A, FL_LDSCHED | FL_CRC32, cortex_a53)
-ARM_CORE("cortex-a57",	cortexa57, cortexa57,	8A, FL_LDSCHED | FL_CRC32, cortex_a57)
-ARM_CORE("cortex-a72",	cortexa72, cortexa57,	8A, FL_LDSCHED | FL_CRC32, cortex_a57)
-ARM_CORE("exynos-m1",	exynosm1,  cortexa57,	8A, FL_LDSCHED | FL_CRC32, cortex_a57)
-ARM_CORE("xgene1",      xgene1,    xgene1,      8A, FL_LDSCHED,            xgene1)
+ARM_CORE("cortex-a53",	cortexa53, cortexa53,	8A,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_CRC32 | FL_FOR_ARCH8A), cortex_a53)
+ARM_CORE("cortex-a57",	cortexa57, cortexa57,	8A,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_CRC32 | FL_FOR_ARCH8A), cortex_a57)
+ARM_CORE("cortex-a72",	cortexa72, cortexa57,	8A,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_CRC32 | FL_FOR_ARCH8A), cortex_a57)
+ARM_CORE("exynos-m1",	exynosm1,  cortexa57,	8A,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_CRC32 | FL_FOR_ARCH8A), cortex_a57)
+ARM_CORE("xgene1",      xgene1,    xgene1,      8A,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_FOR_ARCH8A),            xgene1)
 
 /* V8 big.LITTLE implementations */
-ARM_CORE("cortex-a57.cortex-a53", cortexa57cortexa53, cortexa53, 8A,  FL_LDSCHED | FL_CRC32, cortex_a57)
-ARM_CORE("cortex-a72.cortex-a53", cortexa72cortexa53, cortexa53, 8A,  FL_LDSCHED | FL_CRC32, cortex_a57)
+ARM_CORE("cortex-a57.cortex-a53", cortexa57cortexa53, cortexa53, 8A,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_CRC32 | FL_FOR_ARCH8A), cortex_a57)
+ARM_CORE("cortex-a72.cortex-a53", cortexa72cortexa53, cortexa53, 8A,	ARM_FSET_MAKE_CPU1 (FL_LDSCHED | FL_CRC32 | FL_FOR_ARCH8A), cortex_a57)
--- a/src/gcc/config/arm/arm-fpus.def
+++ b/src/gcc/config/arm/arm-fpus.def
@@ -19,30 +19,30 @@
 
 /* Before using #include to read this file, define a macro:
 
-      ARM_FPU(NAME, MODEL, REV, VFP_REGS, NEON, FP16, CRYPTO)
+      ARM_FPU(NAME, MODEL, REV, VFP_REGS, FEATURES)
 
    The arguments are the fields of struct arm_fpu_desc.
 
    genopt.sh assumes no whitespace up to the first "," in each entry.  */
 
-ARM_FPU("vfp",		ARM_FP_MODEL_VFP, 2, VFP_REG_D16, false, false, false)
-ARM_FPU("vfpv3",	ARM_FP_MODEL_VFP, 3, VFP_REG_D32, false, false, false)
-ARM_FPU("vfpv3-fp16",	ARM_FP_MODEL_VFP, 3, VFP_REG_D32, false, true, false)
-ARM_FPU("vfpv3-d16",	ARM_FP_MODEL_VFP, 3, VFP_REG_D16, false, false, false)
-ARM_FPU("vfpv3-d16-fp16",	ARM_FP_MODEL_VFP, 3, VFP_REG_D16, false, true, false)
-ARM_FPU("vfpv3xd",	ARM_FP_MODEL_VFP, 3, VFP_REG_SINGLE, false, false, false)
-ARM_FPU("vfpv3xd-fp16",	ARM_FP_MODEL_VFP, 3, VFP_REG_SINGLE, false, true, false)
-ARM_FPU("neon",		ARM_FP_MODEL_VFP, 3, VFP_REG_D32, true , false, false)
-ARM_FPU("neon-fp16",	ARM_FP_MODEL_VFP, 3, VFP_REG_D32, true, true, false)
-ARM_FPU("vfpv4",	ARM_FP_MODEL_VFP, 4, VFP_REG_D32, false, true, false)
-ARM_FPU("vfpv4-d16",	ARM_FP_MODEL_VFP, 4, VFP_REG_D16, false, true, false)
-ARM_FPU("fpv4-sp-d16",	ARM_FP_MODEL_VFP, 4, VFP_REG_SINGLE, false, true, false)
-ARM_FPU("fpv5-sp-d16",	ARM_FP_MODEL_VFP, 5, VFP_REG_SINGLE, false, true, false)
-ARM_FPU("fpv5-d16",	ARM_FP_MODEL_VFP, 5, VFP_REG_D16, false, true, false)
-ARM_FPU("neon-vfpv4",	ARM_FP_MODEL_VFP, 4, VFP_REG_D32, true, true, false)
-ARM_FPU("fp-armv8",	ARM_FP_MODEL_VFP, 8, VFP_REG_D32, false, true, false)
-ARM_FPU("neon-fp-armv8",ARM_FP_MODEL_VFP, 8, VFP_REG_D32, true, true, false)
+ARM_FPU("vfp",		ARM_FP_MODEL_VFP, 2, VFP_REG_D16, FPU_FL_NONE)
+ARM_FPU("vfpv3",	ARM_FP_MODEL_VFP, 3, VFP_REG_D32, FPU_FL_NONE)
+ARM_FPU("vfpv3-fp16",	ARM_FP_MODEL_VFP, 3, VFP_REG_D32, FPU_FL_FP16)
+ARM_FPU("vfpv3-d16",	ARM_FP_MODEL_VFP, 3, VFP_REG_D16, FPU_FL_NONE)
+ARM_FPU("vfpv3-d16-fp16",	ARM_FP_MODEL_VFP, 3, VFP_REG_D16, FPU_FL_FP16)
+ARM_FPU("vfpv3xd",	ARM_FP_MODEL_VFP, 3, VFP_REG_SINGLE, FPU_FL_NONE)
+ARM_FPU("vfpv3xd-fp16",	ARM_FP_MODEL_VFP, 3, VFP_REG_SINGLE, FPU_FL_FP16)
+ARM_FPU("neon",		ARM_FP_MODEL_VFP, 3, VFP_REG_D32, FPU_FL_NEON)
+ARM_FPU("neon-fp16",	ARM_FP_MODEL_VFP, 3, VFP_REG_D32, FPU_FL_NEON | FPU_FL_FP16)
+ARM_FPU("vfpv4",	ARM_FP_MODEL_VFP, 4, VFP_REG_D32, FPU_FL_FP16)
+ARM_FPU("vfpv4-d16",	ARM_FP_MODEL_VFP, 4, VFP_REG_D16, FPU_FL_FP16)
+ARM_FPU("fpv4-sp-d16",	ARM_FP_MODEL_VFP, 4, VFP_REG_SINGLE, FPU_FL_FP16)
+ARM_FPU("fpv5-sp-d16",	ARM_FP_MODEL_VFP, 5, VFP_REG_SINGLE, FPU_FL_FP16)
+ARM_FPU("fpv5-d16",	ARM_FP_MODEL_VFP, 5, VFP_REG_D16, FPU_FL_FP16)
+ARM_FPU("neon-vfpv4",	ARM_FP_MODEL_VFP, 4, VFP_REG_D32, FPU_FL_NEON | FPU_FL_FP16)
+ARM_FPU("fp-armv8",	ARM_FP_MODEL_VFP, 8, VFP_REG_D32, FPU_FL_FP16)
+ARM_FPU("neon-fp-armv8",ARM_FP_MODEL_VFP, 8, VFP_REG_D32, FPU_FL_NEON | FPU_FL_FP16)
 ARM_FPU("crypto-neon-fp-armv8",
-			ARM_FP_MODEL_VFP, 8, VFP_REG_D32, true, true, true)
+			ARM_FP_MODEL_VFP, 8, VFP_REG_D32, FPU_FL_NEON | FPU_FL_FP16 | FPU_FL_CRYPTO)
 /* Compatibility aliases.  */
-ARM_FPU("vfp3",		ARM_FP_MODEL_VFP, 3, VFP_REG_D32, false, false, false)
+ARM_FPU("vfp3",		ARM_FP_MODEL_VFP, 3, VFP_REG_D32, FPU_FL_NONE)
--- a/src/gcc/config/arm/arm-protos.h
+++ b/src/gcc/config/arm/arm-protos.h
@@ -30,6 +30,7 @@ extern void arm_load_pic_register (unsigned long);
 extern int arm_volatile_func (void);
 extern void arm_expand_prologue (void);
 extern void arm_expand_epilogue (bool);
+extern void arm_declare_function_name (FILE *, const char *, tree);
 extern void thumb2_expand_return (bool);
 extern const char *arm_strip_name_encoding (const char *);
 extern void arm_asm_output_labelref (FILE *, const char *);
@@ -66,10 +67,6 @@ extern rtx legitimize_tls_address (rtx, rtx);
 extern bool arm_legitimate_address_p (machine_mode, rtx, bool);
 extern int arm_legitimate_address_outer_p (machine_mode, rtx, RTX_CODE, int);
 extern int thumb_legitimate_offset_p (machine_mode, HOST_WIDE_INT);
-extern bool arm_legitimize_reload_address (rtx *, machine_mode, int, int,
-					   int);
-extern rtx thumb_legitimize_reload_address (rtx *, machine_mode, int, int,
-					    int);
 extern int thumb1_legitimate_address_p (machine_mode, rtx, int);
 extern bool ldm_stm_operation_p (rtx, bool, machine_mode mode,
                                  bool, bool);
@@ -89,7 +86,7 @@ extern void neon_pairwise_reduce (rtx, rtx, machine_mode,
 extern rtx neon_make_constant (rtx);
 extern tree arm_builtin_vectorized_function (tree, tree, tree);
 extern void neon_expand_vector_init (rtx, rtx);
-extern void neon_lane_bounds (rtx, HOST_WIDE_INT, HOST_WIDE_INT);
+extern void neon_lane_bounds (rtx, HOST_WIDE_INT, HOST_WIDE_INT, const_tree);
 extern void neon_const_bounds (rtx, HOST_WIDE_INT, HOST_WIDE_INT);
 extern HOST_WIDE_INT neon_element_bits (machine_mode);
 extern void neon_reinterpret (rtx, rtx);
@@ -185,9 +182,6 @@ extern const char *thumb1_unexpanded_epilogue (void);
 extern void thumb1_expand_prologue (void);
 extern void thumb1_expand_epilogue (void);
 extern const char *thumb1_output_interwork (void);
-#ifdef TREE_CODE
-extern int is_called_in_ARM_mode (tree);
-#endif
 extern int thumb_shiftable_const (unsigned HOST_WIDE_INT);
 #ifdef RTX_CODE
 extern enum arm_cond_code maybe_get_arm_condition_code (rtx);
@@ -216,14 +210,15 @@ extern int arm_dllexport_p (tree);
 extern int arm_dllimport_p (tree);
 extern void arm_mark_dllexport (tree);
 extern void arm_mark_dllimport (tree);
+extern bool arm_change_mode_p (tree);
 #endif
 
+extern tree arm_valid_target_attribute_tree (tree, struct gcc_options *,
+					     struct gcc_options *);
 extern void arm_pr_long_calls (struct cpp_reader *);
 extern void arm_pr_no_long_calls (struct cpp_reader *);
 extern void arm_pr_long_calls_off (struct cpp_reader *);
 
-extern void arm_lang_object_attributes_init(void);
-
 extern const char *arm_mangle_type (const_tree);
 extern const char *arm_mangle_builtin_type (const_tree);
 
@@ -257,13 +252,6 @@ struct cpu_vec_costs {
 
 struct cpu_cost_table;
 
-enum arm_sched_autopref
-  {
-    ARM_SCHED_AUTOPREF_OFF,
-    ARM_SCHED_AUTOPREF_RANK,
-    ARM_SCHED_AUTOPREF_FULL
-  };
-
 /* Dump function ARM_PRINT_TUNE_INFO should be updated whenever this
    structure is modified.  */
 
@@ -272,39 +260,58 @@ struct tune_params
   bool (*rtx_costs) (rtx, RTX_CODE, RTX_CODE, int *, bool);
   const struct cpu_cost_table *insn_extra_cost;
   bool (*sched_adjust_cost) (rtx_insn *, rtx, rtx_insn *, int *);
+  int (*branch_cost) (bool, bool);
+  /* Vectorizer costs.  */
+  const struct cpu_vec_costs* vec_costs;
   int constant_limit;
   /* Maximum number of instructions to conditionalise.  */
   int max_insns_skipped;
-  int num_prefetch_slots;
-  int l1_cache_size;
-  int l1_cache_line_size;
-  bool prefer_constant_pool;
-  int (*branch_cost) (bool, bool);
+  /* Maximum number of instructions to inline calls to memset.  */
+  int max_insns_inline_memset;
+  /* Issue rate of the processor.  */
+  unsigned int issue_rate;
+  /* Explicit prefetch data.  */
+  struct
+    {
+      int num_slots;
+      int l1_cache_size;
+      int l1_cache_line_size;
+    } prefetch;
+  enum {PREF_CONST_POOL_FALSE, PREF_CONST_POOL_TRUE}
+    prefer_constant_pool: 1;
   /* Prefer STRD/LDRD instructions over PUSH/POP/LDM/STM.  */
-  bool prefer_ldrd_strd;
+  enum {PREF_LDRD_FALSE, PREF_LDRD_TRUE} prefer_ldrd_strd: 1;
   /* The preference for non short cirtcuit operation when optimizing for
      performance. The first element covers Thumb state and the second one
      is for ARM state.  */
-  bool logical_op_non_short_circuit[2];
-  /* Vectorizer costs.  */
-  const struct cpu_vec_costs* vec_costs;
-  /* Prefer Neon for 64-bit bitops.  */
-  bool prefer_neon_for_64bits;
+  enum log_op_non_short_circuit {LOG_OP_NON_SHORT_CIRCUIT_FALSE,
+				 LOG_OP_NON_SHORT_CIRCUIT_TRUE};
+  log_op_non_short_circuit logical_op_non_short_circuit_thumb: 1;
+  log_op_non_short_circuit logical_op_non_short_circuit_arm: 1;
   /* Prefer 32-bit encoding instead of flag-setting 16-bit encoding.  */
-  bool disparage_flag_setting_t16_encodings;
-  /* Prefer 32-bit encoding instead of 16-bit encoding where subset of flags
-     would be set.  */
-  bool disparage_partial_flag_setting_t16_encodings;
+  enum {DISPARAGE_FLAGS_NEITHER, DISPARAGE_FLAGS_PARTIAL, DISPARAGE_FLAGS_ALL}
+    disparage_flag_setting_t16_encodings: 2;
+  enum {PREF_NEON_64_FALSE, PREF_NEON_64_TRUE} prefer_neon_for_64bits: 1;
   /* Prefer to inline string operations like memset by using Neon.  */
-  bool string_ops_prefer_neon;
-  /* Maximum number of instructions to inline calls to memset.  */
-  int max_insns_inline_memset;
-  /* Bitfield encoding the fuseable pairs of instructions.  */
-  unsigned int fuseable_ops;
+  enum {PREF_NEON_STRINGOPS_FALSE, PREF_NEON_STRINGOPS_TRUE}
+    string_ops_prefer_neon: 1;
+  /* Bitfield encoding the fusible pairs of instructions.  Use FUSE_OPS
+     in an initializer if multiple fusion operations are supported on a
+     target.  */
+  enum fuse_ops
+  {
+    FUSE_NOTHING   = 0,
+    FUSE_MOVW_MOVT = 1 << 0
+  } fusible_ops: 1;
   /* Depth of scheduling queue to check for L2 autoprefetcher.  */
-  enum arm_sched_autopref sched_autopref;
+  enum {SCHED_AUTOPREF_OFF, SCHED_AUTOPREF_RANK, SCHED_AUTOPREF_FULL}
+    sched_autopref: 2;
 };
 
+/* Smash multiple fusion operations into a type that can be used for an
+   initializer.  */
+#define FUSE_OPS(x) ((tune_params::fuse_ops) (x))
+
 extern const struct tune_params *current_tune;
 extern int vfp3_const_double_for_fract_bits (rtx);
 /* return power of two from operand, otherwise 0.  */
@@ -324,14 +331,23 @@ extern bool arm_autoinc_modes_ok_p (machine_mode, enum arm_auto_incmodes);
 
 extern void arm_emit_eabi_attribute (const char *, int, int);
 
+extern void arm_reset_previous_fndecl (void);
+
 /* Defined in gcc/common/config/arm-common.c.  */
 extern const char *arm_rewrite_selected_cpu (const char *name);
 
+/* Defined in gcc/common/config/arm-c.c.  */
+extern void arm_lang_object_attributes_init (void);
+extern void arm_register_target_pragmas (void);
+extern void arm_cpu_cpp_builtins (struct cpp_reader *);
+
 extern bool arm_is_constant_pool_ref (rtx);
 
 /* Flags used to identify the presence of processor capabilities.  */
 
 /* Bit values used to identify processor capabilities.  */
+#define FL_NONE	      (0)	      /* No flags.  */
+#define FL_ANY	      (0xffffffff)    /* All flags.  */
 #define FL_CO_PROC    (1 << 0)        /* Has external co-processor bus */
 #define FL_ARCH3M     (1 << 1)        /* Extended multiply */
 #define FL_MODE26     (1 << 2)        /* 26-bit mode support */
@@ -368,6 +384,7 @@ extern bool arm_is_constant_pool_ref (rtx);
 
 #define FL_IWMMXT     (1 << 29)	      /* XScale v2 or "Intel Wireless MMX technology".  */
 #define FL_IWMMXT2    (1 << 30)       /* "Intel Wireless MMX2 technology".  */
+#define FL_ARCH6KZ    (1 << 31)       /* ARMv6KZ architecture.  */
 
 /* Flags that only effect tuning, not available instructions.  */
 #define FL_TUNE		(FL_WBUF | FL_VFPV2 | FL_STRONG | FL_LDSCHED \
@@ -387,7 +404,7 @@ extern bool arm_is_constant_pool_ref (rtx);
 #define FL_FOR_ARCH6J	FL_FOR_ARCH6
 #define FL_FOR_ARCH6K	(FL_FOR_ARCH6 | FL_ARCH6K)
 #define FL_FOR_ARCH6Z	FL_FOR_ARCH6
-#define FL_FOR_ARCH6ZK	FL_FOR_ARCH6K
+#define FL_FOR_ARCH6KZ	(FL_FOR_ARCH6K | FL_ARCH6KZ)
 #define FL_FOR_ARCH6T2	(FL_FOR_ARCH6 | FL_THUMB2)
 #define FL_FOR_ARCH6M	(FL_FOR_ARCH6 & ~FL_NOTM)
 #define FL_FOR_ARCH7	((FL_FOR_ARCH6T2 & ~FL_NOTM) | FL_ARCH7)
@@ -398,13 +415,116 @@ extern bool arm_is_constant_pool_ref (rtx);
 #define FL_FOR_ARCH7EM  (FL_FOR_ARCH7M | FL_ARCH7EM)
 #define FL_FOR_ARCH8A	(FL_FOR_ARCH7VE | FL_ARCH8)
 
+/* There are too many feature bits to fit in a single word so the set of cpu and
+   fpu capabilities is a structure.  A feature set is created and manipulated
+   with the ARM_FSET macros.  */
+
+typedef struct
+{
+  unsigned long cpu[2];
+} arm_feature_set;
+
+
+/* Initialize a feature set.  */
+
+#define ARM_FSET_MAKE(CPU1,CPU2) { { (CPU1), (CPU2) } }
+
+#define ARM_FSET_MAKE_CPU1(CPU1) ARM_FSET_MAKE ((CPU1), (FL_NONE))
+#define ARM_FSET_MAKE_CPU2(CPU2) ARM_FSET_MAKE ((FL_NONE), (CPU2))
+
+/* Accessors.  */
+
+#define ARM_FSET_CPU1(S) ((S).cpu[0])
+#define ARM_FSET_CPU2(S) ((S).cpu[1])
+
+/* Useful combinations.  */
+
+#define ARM_FSET_EMPTY ARM_FSET_MAKE (FL_NONE, FL_NONE)
+#define ARM_FSET_ANY ARM_FSET_MAKE (FL_ANY, FL_ANY)
+
+/* Tests for a specific CPU feature.  */
+
+#define ARM_FSET_HAS_CPU1(A, F)  \
+  (((A).cpu[0] & ((unsigned long)(F))) == ((unsigned long)(F)))
+#define ARM_FSET_HAS_CPU2(A, F)  \
+  (((A).cpu[1] & ((unsigned long)(F))) == ((unsigned long)(F)))
+#define ARM_FSET_HAS_CPU(A, F1, F2)				\
+  (ARM_FSET_HAS_CPU1 ((A), (F1)) && ARM_FSET_HAS_CPU2 ((A), (F2)))
+
+/* Add a feature to a feature set.  */
+
+#define ARM_FSET_ADD_CPU1(DST, F)		\
+  do {						\
+    (DST).cpu[0] |= (F);			\
+  } while (0)
+
+#define ARM_FSET_ADD_CPU2(DST, F)		\
+  do {						\
+    (DST).cpu[1] |= (F);			\
+  } while (0)
+
+/* Remove a feature from a feature set.  */
+
+#define ARM_FSET_DEL_CPU1(DST, F)		\
+  do {						\
+    (DST).cpu[0] &= ~(F);			\
+  } while (0)
+
+#define ARM_FSET_DEL_CPU2(DST, F)		\
+  do {						\
+    (DST).cpu[1] &= ~(F);			\
+  } while (0)
+
+/* Union of feature sets.  */
+
+#define ARM_FSET_UNION(DST,F1,F2)		\
+  do {						\
+    (DST).cpu[0] = (F1).cpu[0] | (F2).cpu[0];	\
+    (DST).cpu[1] = (F1).cpu[1] | (F2).cpu[1];	\
+  } while (0)
+
+/* Intersection of feature sets.  */
+
+#define ARM_FSET_INTER(DST,F1,F2)		\
+  do {						\
+    (DST).cpu[0] = (F1).cpu[0] & (F2).cpu[0];	\
+    (DST).cpu[1] = (F1).cpu[1] & (F2).cpu[1];	\
+  } while (0)
+
+/* Exclusive disjunction.  */
+
+#define ARM_FSET_XOR(DST,F1,F2)				\
+  do {							\
+    (DST).cpu[0] = (F1).cpu[0] ^ (F2).cpu[0];		\
+    (DST).cpu[1] = (F1).cpu[1] ^ (F2).cpu[1];		\
+  } while (0)
+
+/* Difference of feature sets: F1 excluding the elements of F2.  */
+
+#define ARM_FSET_EXCLUDE(DST,F1,F2)		\
+  do {						\
+    (DST).cpu[0] = (F1).cpu[0] & ~(F2).cpu[0];	\
+    (DST).cpu[1] = (F1).cpu[1] & ~(F2).cpu[1];	\
+  } while (0)
+
+/* Test for an empty feature set.  */
+
+#define ARM_FSET_IS_EMPTY(A)		\
+  (!((A).cpu[0]) && !((A).cpu[1]))
+
+/* Tests whether the cpu features of A are a subset of B.  */
+
+#define ARM_FSET_CPU_SUBSET(A,B)					\
+  ((((A).cpu[0] & (B).cpu[0]) == (A).cpu[0])				\
+   && (((A).cpu[1] & (B).cpu[1]) == (A).cpu[1]))
+
 /* The bits in this mask specify which
    instructions we are allowed to generate.  */
-extern unsigned long insn_flags;
+extern arm_feature_set insn_flags;
 
 /* The bits in this mask specify which instruction scheduling options should
    be used.  */
-extern unsigned long tune_flags;
+extern arm_feature_set tune_flags;
 
 /* Nonzero if this chip supports the ARM Architecture 3M extensions.  */
 extern int arm_arch3m;
@@ -427,6 +547,9 @@ extern int arm_arch6;
 /* Nonzero if this chip supports the ARM 6K extensions.  */
 extern int arm_arch6k;
 
+/* Nonzero if this chip supports the ARM 6KZ extensions.  */
+extern int arm_arch6kz;
+
 /* Nonzero if instructions present in ARMv6-M can be used.  */
 extern int arm_arch6m;
 
@@ -467,12 +590,6 @@ extern int arm_tune_wbuf;
 /* Nonzero if tuning for Cortex-A9.  */
 extern int arm_tune_cortex_a9;
 
-/* Nonzero if generating Thumb instructions.  */
-extern int thumb_code;
-
-/* Nonzero if generating Thumb-1 instructions.  */
-extern int thumb1_code;
-
 /* Nonzero if we should define __THUMB_INTERWORK__ in the
    preprocessor.
    XXX This is a bit of a hack, it's intended to help work around
--- a/src/gcc/config/arm/arm-simd-builtin-types.def
+++ b/src/gcc/config/arm/arm-simd-builtin-types.def
@@ -44,5 +44,7 @@
 
   ENTRY (Float16x4_t, V4HF, none, 64, float16, 18)
   ENTRY (Float32x2_t, V2SF, none, 64, float32, 18)
+
+  ENTRY (Float16x8_t, V8HF, none, 128, float16, 19)
   ENTRY (Float32x4_t, V4SF, none, 128, float32, 19)
 
--- a/src/gcc/config/arm/arm-tables.opt
+++ b/src/gcc/config/arm/arm-tables.opt
@@ -371,46 +371,49 @@ EnumValue
 Enum(arm_arch) String(armv6z) Value(13)
 
 EnumValue
-Enum(arm_arch) String(armv6zk) Value(14)
+Enum(arm_arch) String(armv6kz) Value(14)
 
 EnumValue
-Enum(arm_arch) String(armv6t2) Value(15)
+Enum(arm_arch) String(armv6zk) Value(15)
 
 EnumValue
-Enum(arm_arch) String(armv6-m) Value(16)
+Enum(arm_arch) String(armv6t2) Value(16)
 
 EnumValue
-Enum(arm_arch) String(armv6s-m) Value(17)
+Enum(arm_arch) String(armv6-m) Value(17)
 
 EnumValue
-Enum(arm_arch) String(armv7) Value(18)
+Enum(arm_arch) String(armv6s-m) Value(18)
 
 EnumValue
-Enum(arm_arch) String(armv7-a) Value(19)
+Enum(arm_arch) String(armv7) Value(19)
 
 EnumValue
-Enum(arm_arch) String(armv7ve) Value(20)
+Enum(arm_arch) String(armv7-a) Value(20)
 
 EnumValue
-Enum(arm_arch) String(armv7-r) Value(21)
+Enum(arm_arch) String(armv7ve) Value(21)
 
 EnumValue
-Enum(arm_arch) String(armv7-m) Value(22)
+Enum(arm_arch) String(armv7-r) Value(22)
 
 EnumValue
-Enum(arm_arch) String(armv7e-m) Value(23)
+Enum(arm_arch) String(armv7-m) Value(23)
 
 EnumValue
-Enum(arm_arch) String(armv8-a) Value(24)
+Enum(arm_arch) String(armv7e-m) Value(24)
 
 EnumValue
-Enum(arm_arch) String(armv8-a+crc) Value(25)
+Enum(arm_arch) String(armv8-a) Value(25)
 
 EnumValue
-Enum(arm_arch) String(iwmmxt) Value(26)
+Enum(arm_arch) String(armv8-a+crc) Value(26)
 
 EnumValue
-Enum(arm_arch) String(iwmmxt2) Value(27)
+Enum(arm_arch) String(iwmmxt) Value(27)
+
+EnumValue
+Enum(arm_arch) String(iwmmxt2) Value(28)
 
 Enum
 Name(arm_fpu) Type(int)
--- a/src/gcc/config/arm/arm.c
+++ b/src/gcc/config/arm/arm.c
@@ -94,10 +94,12 @@
 #include "opts.h"
 #include "dumpfile.h"
 #include "gimple-expr.h"
+#include "target-globals.h"
 #include "builtins.h"
 #include "tm-constrs.h"
 #include "rtl-iter.h"
 #include "sched-int.h"
+#include "tree.h"
 
 /* Forward definitions of types.  */
 typedef struct minipool_node    Mnode;
@@ -117,10 +119,12 @@ static int arm_compute_static_chain_stack_bytes (void);
 static arm_stack_offsets *arm_get_frame_offsets (void);
 static void arm_add_gc_roots (void);
 static int arm_gen_constant (enum rtx_code, machine_mode, rtx,
-			     HOST_WIDE_INT, rtx, rtx, int, int);
+			     unsigned HOST_WIDE_INT, rtx, rtx, int, int);
 static unsigned bit_count (unsigned long);
+static unsigned feature_count (const arm_feature_set*);
 static int arm_address_register_rtx_p (rtx, int);
 static int arm_legitimate_index_p (machine_mode, rtx, RTX_CODE, int);
+static bool is_called_in_ARM_mode (tree);
 static int thumb2_legitimate_index_p (machine_mode, rtx, int);
 static int thumb1_base_register_rtx_p (rtx, machine_mode, int);
 static rtx arm_legitimize_address (rtx, rtx, machine_mode);
@@ -231,6 +235,7 @@ static void arm_encode_section_info (tree, rtx, int);
 
 static void arm_file_end (void);
 static void arm_file_start (void);
+static void arm_insert_attributes (tree, tree *);
 
 static void arm_setup_incoming_varargs (cumulative_args_t, machine_mode,
 					tree, int *, int);
@@ -264,6 +269,10 @@ static tree arm_build_builtin_va_list (void);
 static void arm_expand_builtin_va_start (tree, rtx);
 static tree arm_gimplify_va_arg_expr (tree, tree, gimple_seq *, gimple_seq *);
 static void arm_option_override (void);
+static void arm_option_print (FILE *, int, struct cl_target_option *);
+static void arm_set_current_function (tree);
+static bool arm_can_inline_p (tree, tree);
+static bool arm_valid_target_attribute_p (tree, tree, tree, int);
 static unsigned HOST_WIDE_INT arm_shift_truncation_mask (machine_mode);
 static bool arm_macro_fusion_p (void);
 static bool arm_cannot_copy_insn_p (rtx_insn *);
@@ -386,6 +395,9 @@ static const struct attribute_spec arm_attribute_table[] =
 #undef  TARGET_ATTRIBUTE_TABLE
 #define TARGET_ATTRIBUTE_TABLE arm_attribute_table
 
+#undef  TARGET_INSERT_ATTRIBUTES
+#define TARGET_INSERT_ATTRIBUTES arm_insert_attributes
+
 #undef TARGET_ASM_FILE_START
 #define TARGET_ASM_FILE_START arm_file_start
 #undef TARGET_ASM_FILE_END
@@ -412,9 +424,15 @@ static const struct attribute_spec arm_attribute_table[] =
 #undef  TARGET_ASM_FUNCTION_EPILOGUE
 #define TARGET_ASM_FUNCTION_EPILOGUE arm_output_function_epilogue
 
+#undef TARGET_CAN_INLINE_P
+#define TARGET_CAN_INLINE_P arm_can_inline_p
+
 #undef  TARGET_OPTION_OVERRIDE
 #define TARGET_OPTION_OVERRIDE arm_option_override
 
+#undef TARGET_OPTION_PRINT
+#define TARGET_OPTION_PRINT arm_option_print
+
 #undef  TARGET_COMP_TYPE_ATTRIBUTES
 #define TARGET_COMP_TYPE_ATTRIBUTES arm_comp_type_attributes
 
@@ -430,6 +448,12 @@ static const struct attribute_spec arm_attribute_table[] =
 #undef  TARGET_SCHED_ADJUST_COST
 #define TARGET_SCHED_ADJUST_COST arm_adjust_cost
 
+#undef TARGET_SET_CURRENT_FUNCTION
+#define TARGET_SET_CURRENT_FUNCTION arm_set_current_function
+
+#undef TARGET_OPTION_VALID_ATTRIBUTE_P
+#define TARGET_OPTION_VALID_ATTRIBUTE_P arm_valid_target_attribute_p
+
 #undef TARGET_SCHED_REORDER
 #define TARGET_SCHED_REORDER arm_sched_reorder
 
@@ -772,11 +796,11 @@ static int thumb_call_reg_needed;
 
 /* The bits in this mask specify which
    instructions we are allowed to generate.  */
-unsigned long insn_flags = 0;
+arm_feature_set insn_flags = ARM_FSET_EMPTY;
 
 /* The bits in this mask specify which instruction scheduling options should
    be used.  */
-unsigned long tune_flags = 0;
+arm_feature_set tune_flags = ARM_FSET_EMPTY;
 
 /* The highest ARM architecture version supported by the
    target.  */
@@ -806,6 +830,9 @@ int arm_arch6 = 0;
 /* Nonzero if this chip supports the ARM 6K extensions.  */
 int arm_arch6k = 0;
 
+/* Nonzero if this chip supports the ARM 6KZ extensions.  */
+int arm_arch6kz = 0;
+
 /* Nonzero if instructions present in ARMv6-M can be used.  */
 int arm_arch6m = 0;
 
@@ -846,12 +873,6 @@ int arm_tune_wbuf = 0;
 /* Nonzero if tuning for Cortex-A9.  */
 int arm_tune_cortex_a9 = 0;
 
-/* Nonzero if generating Thumb instructions.  */
-int thumb_code = 0;
-
-/* Nonzero if generating Thumb-1 instructions.  */
-int thumb1_code = 0;
-
 /* Nonzero if we should define __THUMB_INTERWORK__ in the
    preprocessor.
    XXX This is a bit of a hack, it's intended to help work around
@@ -935,16 +956,18 @@ struct processors
   enum processor_type core;
   const char *arch;
   enum base_architecture base_arch;
-  const unsigned long flags;
+  const arm_feature_set flags;
   const struct tune_params *const tune;
 };
 
 
-#define ARM_PREFETCH_NOT_BENEFICIAL 0, -1, -1
-#define ARM_PREFETCH_BENEFICIAL(prefetch_slots,l1_size,l1_line_size) \
-  prefetch_slots, \
-  l1_size, \
-  l1_line_size
+#define ARM_PREFETCH_NOT_BENEFICIAL { 0, -1, -1 }
+#define ARM_PREFETCH_BENEFICIAL(num_slots,l1_size,l1_line_size) \
+  {								\
+    num_slots,							\
+    l1_size,							\
+    l1_line_size						\
+  }
 
 /* arm generic vectorizer costs.  */
 static const
@@ -1027,7 +1050,9 @@ const struct cpu_cost_table cortexa9_extra_costs =
     2,			/* stm_regs_per_insn_subsequent.  */
     COSTS_N_INSNS (1),	/* storef.  */
     COSTS_N_INSNS (1),	/* stored.  */
-    COSTS_N_INSNS (1)	/* store_unaligned.  */
+    COSTS_N_INSNS (1),	/* store_unaligned.  */
+    COSTS_N_INSNS (1),	/* loadv.  */
+    COSTS_N_INSNS (1)	/* storev.  */
   },
   {
     /* FP SFmode */
@@ -1128,7 +1153,9 @@ const struct cpu_cost_table cortexa8_extra_costs =
     2,			/* stm_regs_per_insn_subsequent.  */
     COSTS_N_INSNS (1),	/* storef.  */
     COSTS_N_INSNS (1),	/* stored.  */
-    COSTS_N_INSNS (1)	/* store_unaligned.  */
+    COSTS_N_INSNS (1),	/* store_unaligned.  */
+    COSTS_N_INSNS (1),	/* loadv.  */
+    COSTS_N_INSNS (1)	/* storev.  */
   },
   {
     /* FP SFmode */
@@ -1230,7 +1257,9 @@ const struct cpu_cost_table cortexa5_extra_costs =
     2,			/* stm_regs_per_insn_subsequent.  */
     COSTS_N_INSNS (2),	/* storef.  */
     COSTS_N_INSNS (2),	/* stored.  */
-    COSTS_N_INSNS (1)	/* store_unaligned.  */
+    COSTS_N_INSNS (1),	/* store_unaligned.  */
+    COSTS_N_INSNS (1),	/* loadv.  */
+    COSTS_N_INSNS (1)	/* storev.  */
   },
   {
     /* FP SFmode */
@@ -1333,7 +1362,9 @@ const struct cpu_cost_table cortexa7_extra_costs =
     2,			/* stm_regs_per_insn_subsequent.  */
     COSTS_N_INSNS (2),	/* storef.  */
     COSTS_N_INSNS (2),	/* stored.  */
-    COSTS_N_INSNS (1)	/* store_unaligned.  */
+    COSTS_N_INSNS (1),	/* store_unaligned.  */
+    COSTS_N_INSNS (1),	/* loadv.  */
+    COSTS_N_INSNS (1)	/* storev.  */
   },
   {
     /* FP SFmode */
@@ -1434,7 +1465,9 @@ const struct cpu_cost_table cortexa12_extra_costs =
     2,			/* stm_regs_per_insn_subsequent.  */
     COSTS_N_INSNS (2),	/* storef.  */
     COSTS_N_INSNS (2),	/* stored.  */
-    0			/* store_unaligned.  */
+    0,			/* store_unaligned.  */
+    COSTS_N_INSNS (1),	/* loadv.  */
+    COSTS_N_INSNS (1)	/* storev.  */
   },
   {
     /* FP SFmode */
@@ -1535,7 +1568,9 @@ const struct cpu_cost_table cortexa15_extra_costs =
     2,			/* stm_regs_per_insn_subsequent.  */
     0,			/* storef.  */
     0,			/* stored.  */
-    0			/* store_unaligned.  */
+    0,			/* store_unaligned.  */
+    COSTS_N_INSNS (1),	/* loadv.  */
+    COSTS_N_INSNS (1)	/* storev.  */
   },
   {
     /* FP SFmode */
@@ -1636,7 +1671,9 @@ const struct cpu_cost_table v7m_extra_costs =
     1,			/* stm_regs_per_insn_subsequent.  */
     COSTS_N_INSNS (2),	/* storef.  */
     COSTS_N_INSNS (3),	/* stored.  */
-    COSTS_N_INSNS (1)  /* store_unaligned.  */
+    COSTS_N_INSNS (1),	/* store_unaligned.  */
+    COSTS_N_INSNS (1),	/* loadv.  */
+    COSTS_N_INSNS (1)	/* storev.  */
   },
   {
     /* FP SFmode */
@@ -1678,49 +1715,50 @@ const struct cpu_cost_table v7m_extra_costs =
   }
 };
 
-#define ARM_FUSE_NOTHING	(0)
-#define ARM_FUSE_MOVW_MOVT	(1 << 0)
-
 const struct tune_params arm_slowmul_tune =
 {
   arm_slowmul_rtx_costs,
-  NULL,
-  NULL,						/* Sched adj cost.  */
+  NULL,					/* Insn extra costs.  */
+  NULL,					/* Sched adj cost.  */
+  arm_default_branch_cost,
+  &arm_default_vec_cost,
   3,						/* Constant limit.  */
   5,						/* Max cond insns.  */
+  8,						/* Memset max inline.  */
+  1,						/* Issue rate.  */
   ARM_PREFETCH_NOT_BENEFICIAL,
-  true,						/* Prefer constant pool.  */
-  arm_default_branch_cost,
-  false,					/* Prefer LDRD/STRD.  */
-  {true, true},					/* Prefer non short circuit.  */
-  &arm_default_vec_cost,                        /* Vectorizer costs.  */
-  false,                                        /* Prefer Neon for 64-bits bitops.  */
-  false, false,                                 /* Prefer 32-bit encodings.  */
-  false,					/* Prefer Neon for stringops.  */
-  8,						/* Maximum insns to inline memset.  */
-  ARM_FUSE_NOTHING,				/* Fuseable pairs of instructions.  */
-  ARM_SCHED_AUTOPREF_OFF			/* Sched L2 autopref.  */
+  tune_params::PREF_CONST_POOL_TRUE,
+  tune_params::PREF_LDRD_FALSE,
+  tune_params::LOG_OP_NON_SHORT_CIRCUIT_TRUE,		/* Thumb.  */
+  tune_params::LOG_OP_NON_SHORT_CIRCUIT_TRUE,		/* ARM.  */
+  tune_params::DISPARAGE_FLAGS_NEITHER,
+  tune_params::PREF_NEON_64_FALSE,
+  tune_params::PREF_NEON_STRINGOPS_FALSE,
+  tune_params::FUSE_NOTHING,
+  tune_params::SCHED_AUTOPREF_OFF
 };
 
 const struct tune_params arm_fastmul_tune =
 {
   arm_fastmul_rtx_costs,
-  NULL,
-  NULL,						/* Sched adj cost.  */
+  NULL,					/* Insn extra costs.  */
+  NULL,					/* Sched adj cost.  */
+  arm_default_branch_cost,
+  &arm_default_vec_cost,
   1,						/* Constant limit.  */
   5,						/* Max cond insns.  */
+  8,						/* Memset max inline.  */
+  1,						/* Issue rate.  */
   ARM_PREFETCH_NOT_BENEFICIAL,
-  true,						/* Prefer constant pool.  */
-  arm_default_branch_cost,
-  false,					/* Prefer LDRD/STRD.  */
-  {true, true},					/* Prefer non short circuit.  */
-  &arm_default_vec_cost,                        /* Vectorizer costs.  */
-  false,                                        /* Prefer Neon for 64-bits bitops.  */
-  false, false,                                 /* Prefer 32-bit encodings.  */
-  false,					/* Prefer Neon for stringops.  */
-  8,						/* Maximum insns to inline memset.  */
-  ARM_FUSE_NOTHING,				/* Fuseable pairs of instructions.  */
-  ARM_SCHED_AUTOPREF_OFF			/* Sched L2 autopref.  */
+  tune_params::PREF_CONST_POOL_TRUE,
+  tune_params::PREF_LDRD_FALSE,
+  tune_params::LOG_OP_NON_SHORT_CIRCUIT_TRUE,		/* Thumb.  */
+  tune_params::LOG_OP_NON_SHORT_CIRCUIT_TRUE,		/* ARM.  */
+  tune_params::DISPARAGE_FLAGS_NEITHER,
+  tune_params::PREF_NEON_64_FALSE,
+  tune_params::PREF_NEON_STRINGOPS_FALSE,
+  tune_params::FUSE_NOTHING,
+  tune_params::SCHED_AUTOPREF_OFF
 };
 
 /* StrongARM has early execution of branches, so a sequence that is worth
@@ -1729,233 +1767,279 @@ const struct tune_params arm_fastmul_tune =
 const struct tune_params arm_strongarm_tune =
 {
   arm_fastmul_rtx_costs,
-  NULL,
-  NULL,						/* Sched adj cost.  */
+  NULL,					/* Insn extra costs.  */
+  NULL,					/* Sched adj cost.  */
+  arm_default_branch_cost,
+  &arm_default_vec_cost,
   1,						/* Constant limit.  */
   3,						/* Max cond insns.  */
+  8,						/* Memset max inline.  */
+  1,						/* Issue rate.  */
   ARM_PREFETCH_NOT_BENEFICIAL,
-  true,						/* Prefer constant pool.  */
-  arm_default_branch_cost,
-  false,					/* Prefer LDRD/STRD.  */
-  {true, true},					/* Prefer non short circuit.  */
-  &arm_default_vec_cost,                        /* Vectorizer costs.  */
-  false,                                        /* Prefer Neon for 64-bits bitops.  */
-  false, false,                                 /* Prefer 32-bit encodings.  */
-  false,					/* Prefer Neon for stringops.  */
-  8,						/* Maximum insns to inline memset.  */
-  ARM_FUSE_NOTHING,				/* Fuseable pairs of instructions.  */
-  ARM_SCHED_AUTOPREF_OFF			/* Sched L2 autopref.  */
+  tune_params::PREF_CONST_POOL_TRUE,
+  tune_params::PREF_LDRD_FALSE,
+  tune_params::LOG_OP_NON_SHORT_CIRCUIT_TRUE,		/* Thumb.  */
+  tune_params::LOG_OP_NON_SHORT_CIRCUIT_TRUE,		/* ARM.  */
+  tune_params::DISPARAGE_FLAGS_NEITHER,
+  tune_params::PREF_NEON_64_FALSE,
+  tune_params::PREF_NEON_STRINGOPS_FALSE,
+  tune_params::FUSE_NOTHING,
+  tune_params::SCHED_AUTOPREF_OFF
 };
 
 const struct tune_params arm_xscale_tune =
 {
   arm_xscale_rtx_costs,
-  NULL,
+  NULL,					/* Insn extra costs.  */
   xscale_sched_adjust_cost,
+  arm_default_branch_cost,
+  &arm_default_vec_cost,
   2,						/* Constant limit.  */
   3,						/* Max cond insns.  */
+  8,						/* Memset max inline.  */
+  1,						/* Issue rate.  */
   ARM_PREFETCH_NOT_BENEFICIAL,
-  true,						/* Prefer constant pool.  */
-  arm_default_branch_cost,
-  false,					/* Prefer LDRD/STRD.  */
-  {true, true},					/* Prefer non short circuit.  */
-  &arm_default_vec_cost,                        /* Vectorizer costs.  */
-  false,                                        /* Prefer Neon for 64-bits bitops.  */
-  false, false,                                 /* Prefer 32-bit encodings.  */
-  false,					/* Prefer Neon for stringops.  */
-  8,						/* Maximum insns to inline memset.  */
-  ARM_FUSE_NOTHING,				/* Fuseable pairs of instructions.  */
-  ARM_SCHED_AUTOPREF_OFF			/* Sched L2 autopref.  */
+  tune_params::PREF_CONST_POOL_TRUE,
+  tune_params::PREF_LDRD_FALSE,
+  tune_params::LOG_OP_NON_SHORT_CIRCUIT_TRUE,		/* Thumb.  */
+  tune_params::LOG_OP_NON_SHORT_CIRCUIT_TRUE,		/* ARM.  */
+  tune_params::DISPARAGE_FLAGS_NEITHER,
+  tune_params::PREF_NEON_64_FALSE,
+  tune_params::PREF_NEON_STRINGOPS_FALSE,
+  tune_params::FUSE_NOTHING,
+  tune_params::SCHED_AUTOPREF_OFF
 };
 
 const struct tune_params arm_9e_tune =
 {
   arm_9e_rtx_costs,
-  NULL,
-  NULL,						/* Sched adj cost.  */
+  NULL,					/* Insn extra costs.  */
+  NULL,					/* Sched adj cost.  */
+  arm_default_branch_cost,
+  &arm_default_vec_cost,
   1,						/* Constant limit.  */
   5,						/* Max cond insns.  */
+  8,						/* Memset max inline.  */
+  1,						/* Issue rate.  */
   ARM_PREFETCH_NOT_BENEFICIAL,
-  true,						/* Prefer constant pool.  */
+  tune_params::PREF_CONST_POOL_TRUE,
+  tune_params::PREF_LDRD_FALSE,
+  tune_params::LOG_OP_NON_SHORT_CIRCUIT_TRUE,		/* Thumb.  */
+  tune_params::LOG_OP_NON_SHORT_CIRCUIT_TRUE,		/* ARM.  */
+  tune_params::DISPARAGE_FLAGS_NEITHER,
+  tune_params::PREF_NEON_64_FALSE,
+  tune_params::PREF_NEON_STRINGOPS_FALSE,
+  tune_params::FUSE_NOTHING,
+  tune_params::SCHED_AUTOPREF_OFF
+};
+
+const struct tune_params arm_marvell_pj4_tune =
+{
+  arm_9e_rtx_costs,
+  NULL,					/* Insn extra costs.  */
+  NULL,					/* Sched adj cost.  */
   arm_default_branch_cost,
-  false,					/* Prefer LDRD/STRD.  */
-  {true, true},					/* Prefer non short circuit.  */
-  &arm_default_vec_cost,                        /* Vectorizer costs.  */
-  false,                                        /* Prefer Neon for 64-bits bitops.  */
-  false, false,                                 /* Prefer 32-bit encodings.  */
-  false,					/* Prefer Neon for stringops.  */
-  8,						/* Maximum insns to inline memset.  */
-  ARM_FUSE_NOTHING,				/* Fuseable pairs of instructions.  */
-  ARM_SCHED_AUTOPREF_OFF			/* Sched L2 autopref.  */
+  &arm_default_vec_cost,
+  1,						/* Constant limit.  */
+  5,						/* Max cond insns.  */
+  8,						/* Memset max inline.  */
+  2,						/* Issue rate.  */
+  ARM_PREFETCH_NOT_BENEFICIAL,
+  tune_params::PREF_CONST_POOL_TRUE,
+  tune_params::PREF_LDRD_FALSE,
+  tune_params::LOG_OP_NON_SHORT_CIRCUIT_TRUE,		/* Thumb.  */
+  tune_params::LOG_OP_NON_SHORT_CIRCUIT_TRUE,		/* ARM.  */
+  tune_params::DISPARAGE_FLAGS_NEITHER,
+  tune_params::PREF_NEON_64_FALSE,
+  tune_params::PREF_NEON_STRINGOPS_FALSE,
+  tune_params::FUSE_NOTHING,
+  tune_params::SCHED_AUTOPREF_OFF
 };
 
 const struct tune_params arm_v6t2_tune =
 {
   arm_9e_rtx_costs,
-  NULL,
-  NULL,						/* Sched adj cost.  */
+  NULL,					/* Insn extra costs.  */
+  NULL,					/* Sched adj cost.  */
+  arm_default_branch_cost,
+  &arm_default_vec_cost,
   1,						/* Constant limit.  */
   5,						/* Max cond insns.  */
+  8,						/* Memset max inline.  */
+  1,						/* Issue rate.  */
   ARM_PREFETCH_NOT_BENEFICIAL,
-  false,					/* Prefer constant pool.  */
-  arm_default_branch_cost,
-  false,					/* Prefer LDRD/STRD.  */
-  {true, true},					/* Prefer non short circuit.  */
-  &arm_default_vec_cost,                        /* Vectorizer costs.  */
-  false,                                        /* Prefer Neon for 64-bits bitops.  */
-  false, false,                                 /* Prefer 32-bit encodings.  */
-  false,					/* Prefer Neon for stringops.  */
-  8,						/* Maximum insns to inline memset.  */
-  ARM_FUSE_NOTHING,				/* Fuseable pairs of instructions.  */
-  ARM_SCHED_AUTOPREF_OFF			/* Sched L2 autopref.  */
+  tune_params::PREF_CONST_POOL_FALSE,
+  tune_params::PREF_LDRD_FALSE,
+  tune_params::LOG_OP_NON_SHORT_CIRCUIT_TRUE,		/* Thumb.  */
+  tune_params::LOG_OP_NON_SHORT_CIRCUIT_TRUE,		/* ARM.  */
+  tune_params::DISPARAGE_FLAGS_NEITHER,
+  tune_params::PREF_NEON_64_FALSE,
+  tune_params::PREF_NEON_STRINGOPS_FALSE,
+  tune_params::FUSE_NOTHING,
+  tune_params::SCHED_AUTOPREF_OFF
 };
 
+
 /* Generic Cortex tuning.  Use more specific tunings if appropriate.  */
 const struct tune_params arm_cortex_tune =
 {
   arm_9e_rtx_costs,
   &generic_extra_costs,
-  NULL,						/* Sched adj cost.  */
+  NULL,					/* Sched adj cost.  */
+  arm_default_branch_cost,
+  &arm_default_vec_cost,
   1,						/* Constant limit.  */
   5,						/* Max cond insns.  */
+  8,						/* Memset max inline.  */
+  2,						/* Issue rate.  */
   ARM_PREFETCH_NOT_BENEFICIAL,
-  false,					/* Prefer constant pool.  */
-  arm_default_branch_cost,
-  false,					/* Prefer LDRD/STRD.  */
-  {true, true},					/* Prefer non short circuit.  */
-  &arm_default_vec_cost,                        /* Vectorizer costs.  */
-  false,                                        /* Prefer Neon for 64-bits bitops.  */
-  false, false,                                 /* Prefer 32-bit encodings.  */
-  false,					/* Prefer Neon for stringops.  */
-  8,						/* Maximum insns to inline memset.  */
-  ARM_FUSE_NOTHING,				/* Fuseable pairs of instructions.  */
-  ARM_SCHED_AUTOPREF_OFF			/* Sched L2 autopref.  */
+  tune_params::PREF_CONST_POOL_FALSE,
+  tune_params::PREF_LDRD_FALSE,
+  tune_params::LOG_OP_NON_SHORT_CIRCUIT_TRUE,		/* Thumb.  */
+  tune_params::LOG_OP_NON_SHORT_CIRCUIT_TRUE,		/* ARM.  */
+  tune_params::DISPARAGE_FLAGS_NEITHER,
+  tune_params::PREF_NEON_64_FALSE,
+  tune_params::PREF_NEON_STRINGOPS_FALSE,
+  tune_params::FUSE_NOTHING,
+  tune_params::SCHED_AUTOPREF_OFF
 };
 
 const struct tune_params arm_cortex_a8_tune =
 {
   arm_9e_rtx_costs,
   &cortexa8_extra_costs,
-  NULL,						/* Sched adj cost.  */
+  NULL,					/* Sched adj cost.  */
+  arm_default_branch_cost,
+  &arm_default_vec_cost,
   1,						/* Constant limit.  */
   5,						/* Max cond insns.  */
+  8,						/* Memset max inline.  */
+  2,						/* Issue rate.  */
   ARM_PREFETCH_NOT_BENEFICIAL,
-  false,					/* Prefer constant pool.  */
-  arm_default_branch_cost,
-  false,					/* Prefer LDRD/STRD.  */
-  {true, true},					/* Prefer non short circuit.  */
-  &arm_default_vec_cost,                        /* Vectorizer costs.  */
-  false,                                        /* Prefer Neon for 64-bits bitops.  */
-  false, false,                                 /* Prefer 32-bit encodings.  */
-  true,						/* Prefer Neon for stringops.  */
-  8,						/* Maximum insns to inline memset.  */
-  ARM_FUSE_NOTHING,				/* Fuseable pairs of instructions.  */
-  ARM_SCHED_AUTOPREF_OFF			/* Sched L2 autopref.  */
+  tune_params::PREF_CONST_POOL_FALSE,
+  tune_params::PREF_LDRD_FALSE,
+  tune_params::LOG_OP_NON_SHORT_CIRCUIT_TRUE,		/* Thumb.  */
+  tune_params::LOG_OP_NON_SHORT_CIRCUIT_TRUE,		/* ARM.  */
+  tune_params::DISPARAGE_FLAGS_NEITHER,
+  tune_params::PREF_NEON_64_FALSE,
+  tune_params::PREF_NEON_STRINGOPS_TRUE,
+  tune_params::FUSE_NOTHING,
+  tune_params::SCHED_AUTOPREF_OFF
 };
 
 const struct tune_params arm_cortex_a7_tune =
 {
   arm_9e_rtx_costs,
   &cortexa7_extra_costs,
-  NULL,
+  NULL,					/* Sched adj cost.  */
+  arm_default_branch_cost,
+  &arm_default_vec_cost,
   1,						/* Constant limit.  */
   5,						/* Max cond insns.  */
+  8,						/* Memset max inline.  */
+  2,						/* Issue rate.  */
   ARM_PREFETCH_NOT_BENEFICIAL,
-  false,					/* Prefer constant pool.  */
-  arm_default_branch_cost,
-  false,					/* Prefer LDRD/STRD.  */
-  {true, true},					/* Prefer non short circuit.  */
-  &arm_default_vec_cost,			/* Vectorizer costs.  */
-  false,					/* Prefer Neon for 64-bits bitops.  */
-  false, false,                                 /* Prefer 32-bit encodings.  */
-  true,						/* Prefer Neon for stringops.  */
-  8,						/* Maximum insns to inline memset.  */
-  ARM_FUSE_NOTHING,				/* Fuseable pairs of instructions.  */
-  ARM_SCHED_AUTOPREF_OFF			/* Sched L2 autopref.  */
+  tune_params::PREF_CONST_POOL_FALSE,
+  tune_params::PREF_LDRD_FALSE,
+  tune_params::LOG_OP_NON_SHORT_CIRCUIT_TRUE,		/* Thumb.  */
+  tune_params::LOG_OP_NON_SHORT_CIRCUIT_TRUE,		/* ARM.  */
+  tune_params::DISPARAGE_FLAGS_NEITHER,
+  tune_params::PREF_NEON_64_FALSE,
+  tune_params::PREF_NEON_STRINGOPS_TRUE,
+  tune_params::FUSE_NOTHING,
+  tune_params::SCHED_AUTOPREF_OFF
 };
 
 const struct tune_params arm_cortex_a15_tune =
 {
   arm_9e_rtx_costs,
   &cortexa15_extra_costs,
-  NULL,						/* Sched adj cost.  */
+  NULL,					/* Sched adj cost.  */
+  arm_default_branch_cost,
+  &arm_default_vec_cost,
   1,						/* Constant limit.  */
   2,						/* Max cond insns.  */
+  8,						/* Memset max inline.  */
+  3,						/* Issue rate.  */
   ARM_PREFETCH_NOT_BENEFICIAL,
-  false,					/* Prefer constant pool.  */
-  arm_default_branch_cost,
-  true,						/* Prefer LDRD/STRD.  */
-  {true, true},					/* Prefer non short circuit.  */
-  &arm_default_vec_cost,                        /* Vectorizer costs.  */
-  false,                                        /* Prefer Neon for 64-bits bitops.  */
-  true, true,                                   /* Prefer 32-bit encodings.  */
-  true,						/* Prefer Neon for stringops.  */
-  8,						/* Maximum insns to inline memset.  */
-  ARM_FUSE_NOTHING,				/* Fuseable pairs of instructions.  */
-  ARM_SCHED_AUTOPREF_FULL			/* Sched L2 autopref.  */
+  tune_params::PREF_CONST_POOL_FALSE,
+  tune_params::PREF_LDRD_TRUE,
+  tune_params::LOG_OP_NON_SHORT_CIRCUIT_TRUE,		/* Thumb.  */
+  tune_params::LOG_OP_NON_SHORT_CIRCUIT_TRUE,		/* ARM.  */
+  tune_params::DISPARAGE_FLAGS_ALL,
+  tune_params::PREF_NEON_64_FALSE,
+  tune_params::PREF_NEON_STRINGOPS_TRUE,
+  tune_params::FUSE_NOTHING,
+  tune_params::SCHED_AUTOPREF_FULL
 };
 
 const struct tune_params arm_cortex_a53_tune =
 {
   arm_9e_rtx_costs,
   &cortexa53_extra_costs,
-  NULL,						/* Scheduler cost adjustment.  */
+  NULL,					/* Sched adj cost.  */
+  arm_default_branch_cost,
+  &arm_default_vec_cost,
   1,						/* Constant limit.  */
   5,						/* Max cond insns.  */
+  8,						/* Memset max inline.  */
+  2,						/* Issue rate.  */
   ARM_PREFETCH_NOT_BENEFICIAL,
-  false,					/* Prefer constant pool.  */
-  arm_default_branch_cost,
-  false,					/* Prefer LDRD/STRD.  */
-  {true, true},					/* Prefer non short circuit.  */
-  &arm_default_vec_cost,			/* Vectorizer costs.  */
-  false,					/* Prefer Neon for 64-bits bitops.  */
-  false, false,                                 /* Prefer 32-bit encodings.  */
-  true,						/* Prefer Neon for stringops.  */
-  8,						/* Maximum insns to inline memset.  */
-  ARM_FUSE_MOVW_MOVT,				/* Fuseable pairs of instructions.  */
-  ARM_SCHED_AUTOPREF_OFF			/* Sched L2 autopref.  */
+  tune_params::PREF_CONST_POOL_FALSE,
+  tune_params::PREF_LDRD_FALSE,
+  tune_params::LOG_OP_NON_SHORT_CIRCUIT_TRUE,		/* Thumb.  */
+  tune_params::LOG_OP_NON_SHORT_CIRCUIT_TRUE,		/* ARM.  */
+  tune_params::DISPARAGE_FLAGS_NEITHER,
+  tune_params::PREF_NEON_64_FALSE,
+  tune_params::PREF_NEON_STRINGOPS_TRUE,
+  FUSE_OPS (tune_params::FUSE_MOVW_MOVT),
+  tune_params::SCHED_AUTOPREF_OFF
 };
 
 const struct tune_params arm_cortex_a57_tune =
 {
   arm_9e_rtx_costs,
   &cortexa57_extra_costs,
-  NULL,                                         /* Scheduler cost adjustment.  */
-  1,                                           /* Constant limit.  */
-  2,                                           /* Max cond insns.  */
-  ARM_PREFETCH_NOT_BENEFICIAL,
-  false,                                       /* Prefer constant pool.  */
+  NULL,					/* Sched adj cost.  */
   arm_default_branch_cost,
-  true,                                       /* Prefer LDRD/STRD.  */
-  {true, true},                                /* Prefer non short circuit.  */
-  &arm_default_vec_cost,                       /* Vectorizer costs.  */
-  false,                                       /* Prefer Neon for 64-bits bitops.  */
-  true, true,                                  /* Prefer 32-bit encodings.  */
-  true,						/* Prefer Neon for stringops.  */
-  8,						/* Maximum insns to inline memset.  */
-  ARM_FUSE_MOVW_MOVT,				/* Fuseable pairs of instructions.  */
-  ARM_SCHED_AUTOPREF_FULL			/* Sched L2 autopref.  */
+  &arm_default_vec_cost,
+  1,						/* Constant limit.  */
+  2,						/* Max cond insns.  */
+  8,						/* Memset max inline.  */
+  3,						/* Issue rate.  */
+  ARM_PREFETCH_NOT_BENEFICIAL,
+  tune_params::PREF_CONST_POOL_FALSE,
+  tune_params::PREF_LDRD_TRUE,
+  tune_params::LOG_OP_NON_SHORT_CIRCUIT_TRUE,		/* Thumb.  */
+  tune_params::LOG_OP_NON_SHORT_CIRCUIT_TRUE,		/* ARM.  */
+  tune_params::DISPARAGE_FLAGS_ALL,
+  tune_params::PREF_NEON_64_FALSE,
+  tune_params::PREF_NEON_STRINGOPS_TRUE,
+  FUSE_OPS (tune_params::FUSE_MOVW_MOVT),
+  tune_params::SCHED_AUTOPREF_FULL
 };
 
 const struct tune_params arm_xgene1_tune =
 {
   arm_9e_rtx_costs,
   &xgene1_extra_costs,
-  NULL,                                        /* Scheduler cost adjustment.  */
-  1,                                           /* Constant limit.  */
-  2,                                           /* Max cond insns.  */
-  ARM_PREFETCH_NOT_BENEFICIAL,
-  false,                                       /* Prefer constant pool.  */
+  NULL,					/* Sched adj cost.  */
   arm_default_branch_cost,
-  true,                                        /* Prefer LDRD/STRD.  */
-  {true, true},                                /* Prefer non short circuit.  */
-  &arm_default_vec_cost,                       /* Vectorizer costs.  */
-  false,                                       /* Prefer Neon for 64-bits bitops.  */
-  true, true,                                  /* Prefer 32-bit encodings.  */
-  false,				       /* Prefer Neon for stringops.  */
-  32,					       /* Maximum insns to inline memset.  */
-  ARM_FUSE_NOTHING,				/* Fuseable pairs of instructions.  */
-  ARM_SCHED_AUTOPREF_OFF			/* Sched L2 autopref.  */
+  &arm_default_vec_cost,
+  1,						/* Constant limit.  */
+  2,						/* Max cond insns.  */
+  32,						/* Memset max inline.  */
+  4,						/* Issue rate.  */
+  ARM_PREFETCH_NOT_BENEFICIAL,
+  tune_params::PREF_CONST_POOL_FALSE,
+  tune_params::PREF_LDRD_TRUE,
+  tune_params::LOG_OP_NON_SHORT_CIRCUIT_TRUE,		/* Thumb.  */
+  tune_params::LOG_OP_NON_SHORT_CIRCUIT_TRUE,		/* ARM.  */
+  tune_params::DISPARAGE_FLAGS_ALL,
+  tune_params::PREF_NEON_64_FALSE,
+  tune_params::PREF_NEON_STRINGOPS_FALSE,
+  tune_params::FUSE_NOTHING,
+  tune_params::SCHED_AUTOPREF_OFF
 };
 
 /* Branches can be dual-issued on Cortex-A5, so conditional execution is
@@ -1965,21 +2049,23 @@ const struct tune_params arm_cortex_a5_tune =
 {
   arm_9e_rtx_costs,
   &cortexa5_extra_costs,
-  NULL,						/* Sched adj cost.  */
+  NULL,					/* Sched adj cost.  */
+  arm_cortex_a5_branch_cost,
+  &arm_default_vec_cost,
   1,						/* Constant limit.  */
   1,						/* Max cond insns.  */
+  8,						/* Memset max inline.  */
+  2,						/* Issue rate.  */
   ARM_PREFETCH_NOT_BENEFICIAL,
-  false,					/* Prefer constant pool.  */
-  arm_cortex_a5_branch_cost,
-  false,					/* Prefer LDRD/STRD.  */
-  {false, false},				/* Prefer non short circuit.  */
-  &arm_default_vec_cost,                        /* Vectorizer costs.  */
-  false,                                        /* Prefer Neon for 64-bits bitops.  */
-  false, false,                                 /* Prefer 32-bit encodings.  */
-  true,						/* Prefer Neon for stringops.  */
-  8,						/* Maximum insns to inline memset.  */
-  ARM_FUSE_NOTHING,				/* Fuseable pairs of instructions.  */
-  ARM_SCHED_AUTOPREF_OFF			/* Sched L2 autopref.  */
+  tune_params::PREF_CONST_POOL_FALSE,
+  tune_params::PREF_LDRD_FALSE,
+  tune_params::LOG_OP_NON_SHORT_CIRCUIT_FALSE,		/* Thumb.  */
+  tune_params::LOG_OP_NON_SHORT_CIRCUIT_FALSE,		/* ARM.  */
+  tune_params::DISPARAGE_FLAGS_NEITHER,
+  tune_params::PREF_NEON_64_FALSE,
+  tune_params::PREF_NEON_STRINGOPS_TRUE,
+  tune_params::FUSE_NOTHING,
+  tune_params::SCHED_AUTOPREF_OFF
 };
 
 const struct tune_params arm_cortex_a9_tune =
@@ -1987,41 +2073,45 @@ const struct tune_params arm_cortex_a9_tune =
   arm_9e_rtx_costs,
   &cortexa9_extra_costs,
   cortex_a9_sched_adjust_cost,
+  arm_default_branch_cost,
+  &arm_default_vec_cost,
   1,						/* Constant limit.  */
   5,						/* Max cond insns.  */
+  8,						/* Memset max inline.  */
+  2,						/* Issue rate.  */
   ARM_PREFETCH_BENEFICIAL(4,32,32),
-  false,					/* Prefer constant pool.  */
-  arm_default_branch_cost,
-  false,					/* Prefer LDRD/STRD.  */
-  {true, true},					/* Prefer non short circuit.  */
-  &arm_default_vec_cost,                        /* Vectorizer costs.  */
-  false,                                        /* Prefer Neon for 64-bits bitops.  */
-  false, false,                                 /* Prefer 32-bit encodings.  */
-  false,					/* Prefer Neon for stringops.  */
-  8,						/* Maximum insns to inline memset.  */
-  ARM_FUSE_NOTHING,				/* Fuseable pairs of instructions.  */
-  ARM_SCHED_AUTOPREF_OFF			/* Sched L2 autopref.  */
+  tune_params::PREF_CONST_POOL_FALSE,
+  tune_params::PREF_LDRD_FALSE,
+  tune_params::LOG_OP_NON_SHORT_CIRCUIT_TRUE,		/* Thumb.  */
+  tune_params::LOG_OP_NON_SHORT_CIRCUIT_TRUE,		/* ARM.  */
+  tune_params::DISPARAGE_FLAGS_NEITHER,
+  tune_params::PREF_NEON_64_FALSE,
+  tune_params::PREF_NEON_STRINGOPS_FALSE,
+  tune_params::FUSE_NOTHING,
+  tune_params::SCHED_AUTOPREF_OFF
 };
 
 const struct tune_params arm_cortex_a12_tune =
 {
   arm_9e_rtx_costs,
   &cortexa12_extra_costs,
-  NULL,						/* Sched adj cost.  */
+  NULL,					/* Sched adj cost.  */
+  arm_default_branch_cost,
+  &arm_default_vec_cost,                        /* Vectorizer costs.  */
   1,						/* Constant limit.  */
   2,						/* Max cond insns.  */
+  8,						/* Memset max inline.  */
+  2,						/* Issue rate.  */
   ARM_PREFETCH_NOT_BENEFICIAL,
-  false,					/* Prefer constant pool.  */
-  arm_default_branch_cost,
-  true,						/* Prefer LDRD/STRD.  */
-  {true, true},					/* Prefer non short circuit.  */
-  &arm_default_vec_cost,                        /* Vectorizer costs.  */
-  false,                                        /* Prefer Neon for 64-bits bitops.  */
-  true, true,                                   /* Prefer 32-bit encodings.  */
-  true,						/* Prefer Neon for stringops.  */
-  8,						/* Maximum insns to inline memset.  */
-  ARM_FUSE_MOVW_MOVT,				/* Fuseable pairs of instructions.  */
-  ARM_SCHED_AUTOPREF_OFF			/* Sched L2 autopref.  */
+  tune_params::PREF_CONST_POOL_FALSE,
+  tune_params::PREF_LDRD_TRUE,
+  tune_params::LOG_OP_NON_SHORT_CIRCUIT_TRUE,		/* Thumb.  */
+  tune_params::LOG_OP_NON_SHORT_CIRCUIT_TRUE,		/* ARM.  */
+  tune_params::DISPARAGE_FLAGS_ALL,
+  tune_params::PREF_NEON_64_FALSE,
+  tune_params::PREF_NEON_STRINGOPS_TRUE,
+  FUSE_OPS (tune_params::FUSE_MOVW_MOVT),
+  tune_params::SCHED_AUTOPREF_OFF
 };
 
 /* armv7m tuning.  On Cortex-M4 cores for example, MOVW/MOVT take a single
@@ -2035,21 +2125,23 @@ const struct tune_params arm_v7m_tune =
 {
   arm_9e_rtx_costs,
   &v7m_extra_costs,
-  NULL,						/* Sched adj cost.  */
+  NULL,					/* Sched adj cost.  */
+  arm_cortex_m_branch_cost,
+  &arm_default_vec_cost,
   1,						/* Constant limit.  */
   2,						/* Max cond insns.  */
+  8,						/* Memset max inline.  */
+  1,						/* Issue rate.  */
   ARM_PREFETCH_NOT_BENEFICIAL,
-  true,						/* Prefer constant pool.  */
-  arm_cortex_m_branch_cost,
-  false,					/* Prefer LDRD/STRD.  */
-  {false, false},				/* Prefer non short circuit.  */
-  &arm_default_vec_cost,                        /* Vectorizer costs.  */
-  false,                                        /* Prefer Neon for 64-bits bitops.  */
-  false, false,                                 /* Prefer 32-bit encodings.  */
-  false,					/* Prefer Neon for stringops.  */
-  8,						/* Maximum insns to inline memset.  */
-  ARM_FUSE_NOTHING,				/* Fuseable pairs of instructions.  */
-  ARM_SCHED_AUTOPREF_OFF			/* Sched L2 autopref.  */
+  tune_params::PREF_CONST_POOL_TRUE,
+  tune_params::PREF_LDRD_FALSE,
+  tune_params::LOG_OP_NON_SHORT_CIRCUIT_FALSE,		/* Thumb.  */
+  tune_params::LOG_OP_NON_SHORT_CIRCUIT_FALSE,		/* ARM.  */
+  tune_params::DISPARAGE_FLAGS_NEITHER,
+  tune_params::PREF_NEON_64_FALSE,
+  tune_params::PREF_NEON_STRINGOPS_FALSE,
+  tune_params::FUSE_NOTHING,
+  tune_params::SCHED_AUTOPREF_OFF
 };
 
 /* Cortex-M7 tuning.  */
@@ -2058,21 +2150,23 @@ const struct tune_params arm_cortex_m7_tune =
 {
   arm_9e_rtx_costs,
   &v7m_extra_costs,
-  NULL,						/* Sched adj cost.  */
+  NULL,					/* Sched adj cost.  */
+  arm_cortex_m7_branch_cost,
+  &arm_default_vec_cost,
   0,						/* Constant limit.  */
   1,						/* Max cond insns.  */
+  8,						/* Memset max inline.  */
+  2,						/* Issue rate.  */
   ARM_PREFETCH_NOT_BENEFICIAL,
-  true,						/* Prefer constant pool.  */
-  arm_cortex_m7_branch_cost,
-  false,					/* Prefer LDRD/STRD.  */
-  {true, true},					/* Prefer non short circuit.  */
-  &arm_default_vec_cost,                        /* Vectorizer costs.  */
-  false,                                        /* Prefer Neon for 64-bits bitops.  */
-  false, false,                                 /* Prefer 32-bit encodings.  */
-  false,					/* Prefer Neon for stringops.  */
-  8,						/* Maximum insns to inline memset.  */
-  ARM_FUSE_NOTHING,				/* Fuseable pairs of instructions.  */
-  ARM_SCHED_AUTOPREF_OFF			/* Sched L2 autopref.  */
+  tune_params::PREF_CONST_POOL_TRUE,
+  tune_params::PREF_LDRD_FALSE,
+  tune_params::LOG_OP_NON_SHORT_CIRCUIT_TRUE,		/* Thumb.  */
+  tune_params::LOG_OP_NON_SHORT_CIRCUIT_TRUE,		/* ARM.  */
+  tune_params::DISPARAGE_FLAGS_NEITHER,
+  tune_params::PREF_NEON_64_FALSE,
+  tune_params::PREF_NEON_STRINGOPS_FALSE,
+  tune_params::FUSE_NOTHING,
+  tune_params::SCHED_AUTOPREF_OFF
 };
 
 /* The arm_v6m_tune is duplicated from arm_cortex_tune, rather than
@@ -2080,43 +2174,47 @@ const struct tune_params arm_cortex_m7_tune =
 const struct tune_params arm_v6m_tune =
 {
   arm_9e_rtx_costs,
-  NULL,
-  NULL,						/* Sched adj cost.  */
+  NULL,					/* Insn extra costs.  */
+  NULL,					/* Sched adj cost.  */
+  arm_default_branch_cost,
+  &arm_default_vec_cost,                        /* Vectorizer costs.  */
   1,						/* Constant limit.  */
   5,						/* Max cond insns.  */
+  8,						/* Memset max inline.  */
+  1,						/* Issue rate.  */
   ARM_PREFETCH_NOT_BENEFICIAL,
-  false,					/* Prefer constant pool.  */
-  arm_default_branch_cost,
-  false,					/* Prefer LDRD/STRD.  */
-  {false, false},				/* Prefer non short circuit.  */
-  &arm_default_vec_cost,                        /* Vectorizer costs.  */
-  false,                                        /* Prefer Neon for 64-bits bitops.  */
-  false, false,                                 /* Prefer 32-bit encodings.  */
-  false,					/* Prefer Neon for stringops.  */
-  8,						/* Maximum insns to inline memset.  */
-  ARM_FUSE_NOTHING,				/* Fuseable pairs of instructions.  */
-  ARM_SCHED_AUTOPREF_OFF			/* Sched L2 autopref.  */
+  tune_params::PREF_CONST_POOL_FALSE,
+  tune_params::PREF_LDRD_FALSE,
+  tune_params::LOG_OP_NON_SHORT_CIRCUIT_FALSE,		/* Thumb.  */
+  tune_params::LOG_OP_NON_SHORT_CIRCUIT_FALSE,		/* ARM.  */
+  tune_params::DISPARAGE_FLAGS_NEITHER,
+  tune_params::PREF_NEON_64_FALSE,
+  tune_params::PREF_NEON_STRINGOPS_FALSE,
+  tune_params::FUSE_NOTHING,
+  tune_params::SCHED_AUTOPREF_OFF
 };
 
 const struct tune_params arm_fa726te_tune =
 {
   arm_9e_rtx_costs,
-  NULL,
+  NULL,					/* Insn extra costs.  */
   fa726te_sched_adjust_cost,
+  arm_default_branch_cost,
+  &arm_default_vec_cost,
   1,						/* Constant limit.  */
   5,						/* Max cond insns.  */
+  8,						/* Memset max inline.  */
+  2,						/* Issue rate.  */
   ARM_PREFETCH_NOT_BENEFICIAL,
-  true,						/* Prefer constant pool.  */
-  arm_default_branch_cost,
-  false,					/* Prefer LDRD/STRD.  */
-  {true, true},					/* Prefer non short circuit.  */
-  &arm_default_vec_cost,                        /* Vectorizer costs.  */
-  false,                                        /* Prefer Neon for 64-bits bitops.  */
-  false, false,                                 /* Prefer 32-bit encodings.  */
-  false,					/* Prefer Neon for stringops.  */
-  8,						/* Maximum insns to inline memset.  */
-  ARM_FUSE_NOTHING,				/* Fuseable pairs of instructions.  */
-  ARM_SCHED_AUTOPREF_OFF			/* Sched L2 autopref.  */
+  tune_params::PREF_CONST_POOL_TRUE,
+  tune_params::PREF_LDRD_FALSE,
+  tune_params::LOG_OP_NON_SHORT_CIRCUIT_TRUE,		/* Thumb.  */
+  tune_params::LOG_OP_NON_SHORT_CIRCUIT_TRUE,		/* ARM.  */
+  tune_params::DISPARAGE_FLAGS_NEITHER,
+  tune_params::PREF_NEON_64_FALSE,
+  tune_params::PREF_NEON_STRINGOPS_FALSE,
+  tune_params::FUSE_NOTHING,
+  tune_params::SCHED_AUTOPREF_OFF
 };
 
 
@@ -2127,10 +2225,10 @@ static const struct processors all_cores[] =
   /* ARM Cores */
 #define ARM_CORE(NAME, X, IDENT, ARCH, FLAGS, COSTS) \
   {NAME, IDENT, #ARCH, BASE_ARCH_##ARCH,	  \
-    FLAGS | FL_FOR_ARCH##ARCH, &arm_##COSTS##_tune},
+   FLAGS, &arm_##COSTS##_tune},
 #include "arm-cores.def"
 #undef ARM_CORE
-  {NULL, arm_none, NULL, BASE_ARCH_0, 0, NULL}
+  {NULL, arm_none, NULL, BASE_ARCH_0, ARM_FSET_EMPTY, NULL}
 };
 
 static const struct processors all_architectures[] =
@@ -2143,7 +2241,7 @@ static const struct processors all_architectures[] =
   {NAME, CORE, #ARCH, BASE_ARCH_##ARCH, FLAGS, NULL},
 #include "arm-arches.def"
 #undef ARM_ARCH
-  {NULL, arm_none, NULL, BASE_ARCH_0, 0, NULL}
+  {NULL, arm_none, NULL, BASE_ARCH_0, ARM_FSET_EMPTY, NULL}
 };
 
 
@@ -2161,8 +2259,8 @@ char arm_arch_name[] = "__ARM_ARCH_0UNK__";
 
 static const struct arm_fpu_desc all_fpus[] =
 {
-#define ARM_FPU(NAME, MODEL, REV, VFP_REGS, NEON, FP16, CRYPTO) \
-  { NAME, MODEL, REV, VFP_REGS, NEON, FP16, CRYPTO },
+#define ARM_FPU(NAME, MODEL, REV, VFP_REGS, FEATURES) \
+  { NAME, MODEL, REV, VFP_REGS, FEATURES },
 #include "arm-fpus.def"
 #undef ARM_FPU
 };
@@ -2209,6 +2307,14 @@ bit_count (unsigned long value)
   return count;
 }
 
+/* Return the number of features in feature-set SET.  */
+static unsigned
+feature_count (const arm_feature_set * set)
+{
+  return (bit_count (ARM_FSET_CPU1 (*set))
+	  + bit_count (ARM_FSET_CPU2 (*set)));
+}
+
 typedef struct
 {
   machine_mode mode;
@@ -2626,6 +2732,172 @@ arm_gimplify_va_arg_expr (tree valist, tree type, gimple_seq *pre_p,
   return std_gimplify_va_arg_expr (valist, type, pre_p, post_p);
 }
 
+/* Check any incompatible options that the user has specified.  */
+static void
+arm_option_check_internal (struct gcc_options *opts)
+{
+  int flags = opts->x_target_flags;
+
+  /* Make sure that the processor choice does not conflict with any of the
+     other command line choices.  */
+  if (TARGET_ARM_P (flags) && !ARM_FSET_HAS_CPU1 (insn_flags, FL_NOTM))
+    error ("target CPU does not support ARM mode");
+
+  /* TARGET_BACKTRACE calls leaf_function_p, which causes a crash if done
+     from here where no function is being compiled currently.  */
+  if ((TARGET_TPCS_FRAME || TARGET_TPCS_LEAF_FRAME) && TARGET_ARM_P (flags))
+    warning (0, "enabling backtrace support is only meaningful when compiling for the Thumb");
+
+  if (TARGET_ARM_P (flags) && TARGET_CALLEE_INTERWORKING)
+    warning (0, "enabling callee interworking support is only meaningful when compiling for the Thumb");
+
+  /* If this target is normally configured to use APCS frames, warn if they
+     are turned off and debugging is turned on.  */
+  if (TARGET_ARM_P (flags)
+      && write_symbols != NO_DEBUG
+      && !TARGET_APCS_FRAME
+      && (TARGET_DEFAULT & MASK_APCS_FRAME))
+    warning (0, "-g with -mno-apcs-frame may not give sensible debugging");
+
+  /* iWMMXt unsupported under Thumb mode.  */
+  if (TARGET_THUMB_P (flags) && TARGET_IWMMXT)
+    error ("iWMMXt unsupported under Thumb mode");
+
+  if (TARGET_HARD_TP && TARGET_THUMB1_P (flags))
+    error ("can not use -mtp=cp15 with 16-bit Thumb");
+
+  if (TARGET_THUMB_P (flags) && TARGET_VXWORKS_RTP && flag_pic)
+    {
+      error ("RTP PIC is incompatible with Thumb");
+      flag_pic = 0;
+    }
+
+  /* We only support -mslow-flash-data on armv7-m targets.  */
+  if (target_slow_flash_data
+      && ((!(arm_arch7 && !arm_arch_notm) && !arm_arch7em)
+	  || (TARGET_THUMB1_P (flags) || flag_pic || TARGET_NEON)))
+    error ("-mslow-flash-data only supports non-pic code on armv7-m targets");
+}
+
+/* Recompute the global settings depending on target attribute options.  */
+
+static void
+arm_option_params_internal (void)
+{
+  /* If we are not using the default (ARM mode) section anchor offset
+     ranges, then set the correct ranges now.  */
+  if (TARGET_THUMB1)
+    {
+      /* Thumb-1 LDR instructions cannot have negative offsets.
+         Permissible positive offset ranges are 5-bit (for byte loads),
+         6-bit (for halfword loads), or 7-bit (for word loads).
+         Empirical results suggest a 7-bit anchor range gives the best
+         overall code size.  */
+      targetm.min_anchor_offset = 0;
+      targetm.max_anchor_offset = 127;
+    }
+  else if (TARGET_THUMB2)
+    {
+      /* The minimum is set such that the total size of the block
+         for a particular anchor is 248 + 1 + 4095 bytes, which is
+         divisible by eight, ensuring natural spacing of anchors.  */
+      targetm.min_anchor_offset = -248;
+      targetm.max_anchor_offset = 4095;
+    }
+  else
+    {
+      targetm.min_anchor_offset = TARGET_MIN_ANCHOR_OFFSET;
+      targetm.max_anchor_offset = TARGET_MAX_ANCHOR_OFFSET;
+    }
+
+  if (optimize_size)
+    {
+      /* If optimizing for size, bump the number of instructions that we
+         are prepared to conditionally execute (even on a StrongARM).  */
+      max_insns_skipped = 6;
+
+      /* For THUMB2, we limit the conditional sequence to one IT block.  */
+      if (TARGET_THUMB2)
+        max_insns_skipped = arm_restrict_it ? 1 : 4;
+    }
+  else
+    /* When -mrestrict-it is in use tone down the if-conversion.  */
+    max_insns_skipped = (TARGET_THUMB2 && arm_restrict_it)
+      ? 1 : current_tune->max_insns_skipped;
+}
+
+/* True if -mflip-thumb should next add an attribute for the default
+   mode, false if it should next add an attribute for the opposite mode.  */
+static GTY(()) bool thumb_flipper;
+
+/* Options after initial target override.  */
+static GTY(()) tree init_optimize;
+
+/* Reset options between modes that the user has specified.  */
+static void
+arm_option_override_internal (struct gcc_options *opts,
+			      struct gcc_options *opts_set)
+{
+  if (TARGET_THUMB_P (opts->x_target_flags)
+      && !(ARM_FSET_HAS_CPU1 (insn_flags, FL_THUMB)))
+    {
+      warning (0, "target CPU does not support THUMB instructions");
+      opts->x_target_flags &= ~MASK_THUMB;
+    }
+
+  if (TARGET_APCS_FRAME && TARGET_THUMB_P (opts->x_target_flags))
+    {
+      /* warning (0, "ignoring -mapcs-frame because -mthumb was used"); */
+      opts->x_target_flags &= ~MASK_APCS_FRAME;
+    }
+
+  /* Callee super interworking implies thumb interworking.  Adding
+     this to the flags here simplifies the logic elsewhere.  */
+  if (TARGET_THUMB_P (opts->x_target_flags) && TARGET_CALLEE_INTERWORKING)
+    opts->x_target_flags |= MASK_INTERWORK;
+
+  /* need to remember initial values so combinaisons of options like
+     -mflip-thumb -mthumb -fno-schedule-insns work for any attribute.  */
+  cl_optimization *to = TREE_OPTIMIZATION (init_optimize);
+
+  if (! opts_set->x_arm_restrict_it)
+    opts->x_arm_restrict_it = arm_arch8;
+
+  if (!TARGET_THUMB2_P (opts->x_target_flags))
+    opts->x_arm_restrict_it = 0;
+
+  /* Don't warn since it's on by default in -O2.  */
+  if (TARGET_THUMB1_P (opts->x_target_flags))
+    opts->x_flag_schedule_insns = 0;
+  else
+    opts->x_flag_schedule_insns = to->x_flag_schedule_insns;
+
+  /* Disable shrink-wrap when optimizing function for size, since it tends to
+     generate additional returns.  */
+  if (optimize_function_for_size_p (cfun)
+      && TARGET_THUMB2_P (opts->x_target_flags))
+    opts->x_flag_shrink_wrap = false;
+  else
+    opts->x_flag_shrink_wrap = to->x_flag_shrink_wrap;
+
+  /* In Thumb1 mode, we emit the epilogue in RTL, but the last insn
+     - epilogue_insns - does not accurately model the corresponding insns
+     emitted in the asm file.  In particular, see the comment in thumb_exit
+     'Find out how many of the (return) argument registers we can corrupt'.
+     As a consequence, the epilogue may clobber registers without fipa-ra
+     finding out about it.  Therefore, disable fipa-ra in Thumb1 mode.
+     TODO: Accurately model clobbers for epilogue_insns and reenable
+     fipa-ra.  */
+  if (TARGET_THUMB1_P (opts->x_target_flags))
+    opts->x_flag_ipa_ra = 0;
+  else
+    opts->x_flag_ipa_ra = to->x_flag_ipa_ra;
+
+  /* Thumb2 inline assembly code should always use unified syntax.
+     This will apply to ARM and Thumb1 eventually.  */
+  opts->x_inline_asm_unified = TARGET_THUMB2_P (opts->x_target_flags);
+}
+
 /* Fix up any incompatible options that the user has specified.  */
 static void
 arm_option_override (void)
@@ -2654,8 +2926,13 @@ arm_option_override (void)
     {
       if (arm_selected_cpu)
 	{
+	  const arm_feature_set tuning_flags = ARM_FSET_MAKE_CPU1 (FL_TUNE);
+	  arm_feature_set selected_flags;
+	  ARM_FSET_XOR (selected_flags, arm_selected_cpu->flags,
+			arm_selected_arch->flags);
+	  ARM_FSET_EXCLUDE (selected_flags, selected_flags, tuning_flags);
 	  /* Check for conflict between mcpu and march.  */
-	  if ((arm_selected_cpu->flags ^ arm_selected_arch->flags) & ~FL_TUNE)
+	  if (!ARM_FSET_IS_EMPTY (selected_flags))
 	    {
 	      warning (0, "switch -mcpu=%s conflicts with -march=%s switch",
 		       arm_selected_cpu->name, arm_selected_arch->name);
@@ -2679,7 +2956,7 @@ arm_option_override (void)
   if (!arm_selected_cpu)
     {
       const struct processors * sel;
-      unsigned int        sought;
+      arm_feature_set sought = ARM_FSET_EMPTY;;
 
       arm_selected_cpu = &all_cores[TARGET_CPU_DEFAULT];
       if (!arm_selected_cpu->name)
@@ -2699,26 +2976,27 @@ arm_option_override (void)
 
       /* Now check to see if the user has specified some command line
 	 switch that require certain abilities from the cpu.  */
-      sought = 0;
 
       if (TARGET_INTERWORK || TARGET_THUMB)
 	{
-	  sought |= (FL_THUMB | FL_MODE32);
+	  ARM_FSET_ADD_CPU1 (sought, FL_THUMB);
+	  ARM_FSET_ADD_CPU1 (sought, FL_MODE32);
 
 	  /* There are no ARM processors that support both APCS-26 and
 	     interworking.  Therefore we force FL_MODE26 to be removed
 	     from insn_flags here (if it was set), so that the search
 	     below will always be able to find a compatible processor.  */
-	  insn_flags &= ~FL_MODE26;
+	  ARM_FSET_DEL_CPU1 (insn_flags, FL_MODE26);
 	}
 
-      if (sought != 0 && ((sought & insn_flags) != sought))
+      if (!ARM_FSET_IS_EMPTY (sought)
+	  && !(ARM_FSET_CPU_SUBSET (sought, insn_flags)))
 	{
 	  /* Try to locate a CPU type that supports all of the abilities
 	     of the default CPU, plus the extra abilities requested by
 	     the user.  */
 	  for (sel = all_cores; sel->name != NULL; sel++)
-	    if ((sel->flags & sought) == (sought | insn_flags))
+	    if (ARM_FSET_CPU_SUBSET (sought, sel->flags))
 	      break;
 
 	  if (sel->name == NULL)
@@ -2738,19 +3016,23 @@ arm_option_override (void)
 		 command line options we scan the array again looking
 		 for a best match.  */
 	      for (sel = all_cores; sel->name != NULL; sel++)
-		if ((sel->flags & sought) == sought)
-		  {
-		    unsigned count;
-
-		    count = bit_count (sel->flags & insn_flags);
-
-		    if (count >= current_bit_count)
-		      {
-			best_fit = sel;
-			current_bit_count = count;
-		      }
-		  }
+		{
+		  arm_feature_set required = ARM_FSET_EMPTY;
+		  ARM_FSET_UNION (required, sought, insn_flags);
+		  if (ARM_FSET_CPU_SUBSET (required, sel->flags))
+		    {
+		      unsigned count;
+		      arm_feature_set flags;
+		      ARM_FSET_INTER (flags, sel->flags, insn_flags);
+		      count = feature_count (&flags);
 
+		      if (count >= current_bit_count)
+			{
+			  best_fit = sel;
+			  current_bit_count = count;
+			}
+		    }
+		}
 	      gcc_assert (best_fit);
 	      sel = best_fit;
 	    }
@@ -2772,44 +3054,19 @@ arm_option_override (void)
   tune_flags = arm_selected_tune->flags;
   current_tune = arm_selected_tune->tune;
 
-  /* Make sure that the processor choice does not conflict with any of the
-     other command line choices.  */
-  if (TARGET_ARM && !(insn_flags & FL_NOTM))
-    error ("target CPU does not support ARM mode");
+  /* TBD: Dwarf info for apcs frame is not handled yet.  */
+  if (TARGET_APCS_FRAME)
+    flag_shrink_wrap = false;
 
   /* BPABI targets use linker tricks to allow interworking on cores
      without thumb support.  */
-  if (TARGET_INTERWORK && !((insn_flags & FL_THUMB) || TARGET_BPABI))
+  if (TARGET_INTERWORK
+      && !(ARM_FSET_HAS_CPU1 (insn_flags, FL_THUMB) || TARGET_BPABI))
     {
       warning (0, "target CPU does not support interworking" );
       target_flags &= ~MASK_INTERWORK;
     }
 
-  if (TARGET_THUMB && !(insn_flags & FL_THUMB))
-    {
-      warning (0, "target CPU does not support THUMB instructions");
-      target_flags &= ~MASK_THUMB;
-    }
-
-  if (TARGET_APCS_FRAME && TARGET_THUMB)
-    {
-      /* warning (0, "ignoring -mapcs-frame because -mthumb was used"); */
-      target_flags &= ~MASK_APCS_FRAME;
-    }
-
-  /* Callee super interworking implies thumb interworking.  Adding
-     this to the flags here simplifies the logic elsewhere.  */
-  if (TARGET_THUMB && TARGET_CALLEE_INTERWORKING)
-    target_flags |= MASK_INTERWORK;
-
-  /* TARGET_BACKTRACE calls leaf_function_p, which causes a crash if done
-     from here where no function is being compiled currently.  */
-  if ((TARGET_TPCS_FRAME || TARGET_TPCS_LEAF_FRAME) && TARGET_ARM)
-    warning (0, "enabling backtrace support is only meaningful when compiling for the Thumb");
-
-  if (TARGET_ARM && TARGET_CALLEE_INTERWORKING)
-    warning (0, "enabling callee interworking support is only meaningful when compiling for the Thumb");
-
   if (TARGET_APCS_STACK && !TARGET_APCS_FRAME)
     {
       warning (0, "-mapcs-stack-check incompatible with -mno-apcs-frame");
@@ -2825,73 +3082,38 @@ arm_option_override (void)
   if (TARGET_APCS_REENT)
     warning (0, "APCS reentrant code not supported.  Ignored");
 
-  /* If this target is normally configured to use APCS frames, warn if they
-     are turned off and debugging is turned on.  */
-  if (TARGET_ARM
-      && write_symbols != NO_DEBUG
-      && !TARGET_APCS_FRAME
-      && (TARGET_DEFAULT & MASK_APCS_FRAME))
-    warning (0, "-g with -mno-apcs-frame may not give sensible debugging");
-
   if (TARGET_APCS_FLOAT)
     warning (0, "passing floating point arguments in fp regs not yet supported");
 
   /* Initialize boolean versions of the flags, for use in the arm.md file.  */
-  arm_arch3m = (insn_flags & FL_ARCH3M) != 0;
-  arm_arch4 = (insn_flags & FL_ARCH4) != 0;
-  arm_arch4t = arm_arch4 & ((insn_flags & FL_THUMB) != 0);
-  arm_arch5 = (insn_flags & FL_ARCH5) != 0;
-  arm_arch5e = (insn_flags & FL_ARCH5E) != 0;
-  arm_arch6 = (insn_flags & FL_ARCH6) != 0;
-  arm_arch6k = (insn_flags & FL_ARCH6K) != 0;
-  arm_arch_notm = (insn_flags & FL_NOTM) != 0;
+  arm_arch3m = ARM_FSET_HAS_CPU1 (insn_flags, FL_ARCH3M);
+  arm_arch4 = ARM_FSET_HAS_CPU1 (insn_flags, FL_ARCH4);
+  arm_arch4t = arm_arch4 && (ARM_FSET_HAS_CPU1 (insn_flags, FL_THUMB));
+  arm_arch5 = ARM_FSET_HAS_CPU1 (insn_flags, FL_ARCH5);
+  arm_arch5e = ARM_FSET_HAS_CPU1 (insn_flags, FL_ARCH5E);
+  arm_arch6 = ARM_FSET_HAS_CPU1 (insn_flags, FL_ARCH6);
+  arm_arch6k = ARM_FSET_HAS_CPU1 (insn_flags, FL_ARCH6K);
+  arm_arch6kz = arm_arch6k && ARM_FSET_HAS_CPU1 (insn_flags, FL_ARCH6KZ);
+  arm_arch_notm = ARM_FSET_HAS_CPU1 (insn_flags, FL_NOTM);
   arm_arch6m = arm_arch6 && !arm_arch_notm;
-  arm_arch7 = (insn_flags & FL_ARCH7) != 0;
-  arm_arch7em = (insn_flags & FL_ARCH7EM) != 0;
-  arm_arch8 = (insn_flags & FL_ARCH8) != 0;
-  arm_arch_thumb2 = (insn_flags & FL_THUMB2) != 0;
-  arm_arch_xscale = (insn_flags & FL_XSCALE) != 0;
-
-  arm_ld_sched = (tune_flags & FL_LDSCHED) != 0;
-  arm_tune_strongarm = (tune_flags & FL_STRONG) != 0;
-  thumb_code = TARGET_ARM == 0;
-  thumb1_code = TARGET_THUMB1 != 0;
-  arm_tune_wbuf = (tune_flags & FL_WBUF) != 0;
-  arm_tune_xscale = (tune_flags & FL_XSCALE) != 0;
-  arm_arch_iwmmxt = (insn_flags & FL_IWMMXT) != 0;
-  arm_arch_iwmmxt2 = (insn_flags & FL_IWMMXT2) != 0;
-  arm_arch_thumb_hwdiv = (insn_flags & FL_THUMB_DIV) != 0;
-  arm_arch_arm_hwdiv = (insn_flags & FL_ARM_DIV) != 0;
-  arm_arch_no_volatile_ce = (insn_flags & FL_NO_VOLATILE_CE) != 0;
+  arm_arch7 = ARM_FSET_HAS_CPU1 (insn_flags, FL_ARCH7);
+  arm_arch7em = ARM_FSET_HAS_CPU1 (insn_flags, FL_ARCH7EM);
+  arm_arch8 = ARM_FSET_HAS_CPU1 (insn_flags, FL_ARCH8);
+  arm_arch_thumb2 = ARM_FSET_HAS_CPU1 (insn_flags, FL_THUMB2);
+  arm_arch_xscale = ARM_FSET_HAS_CPU1 (insn_flags, FL_XSCALE);
+
+  arm_ld_sched = ARM_FSET_HAS_CPU1 (tune_flags, FL_LDSCHED);
+  arm_tune_strongarm = ARM_FSET_HAS_CPU1 (tune_flags, FL_STRONG);
+  arm_tune_wbuf = ARM_FSET_HAS_CPU1 (tune_flags, FL_WBUF);
+  arm_tune_xscale = ARM_FSET_HAS_CPU1 (tune_flags, FL_XSCALE);
+  arm_arch_iwmmxt = ARM_FSET_HAS_CPU1 (insn_flags, FL_IWMMXT);
+  arm_arch_iwmmxt2 = ARM_FSET_HAS_CPU1 (insn_flags, FL_IWMMXT2);
+  arm_arch_thumb_hwdiv = ARM_FSET_HAS_CPU1 (insn_flags, FL_THUMB_DIV);
+  arm_arch_arm_hwdiv = ARM_FSET_HAS_CPU1 (insn_flags, FL_ARM_DIV);
+  arm_arch_no_volatile_ce = ARM_FSET_HAS_CPU1 (insn_flags, FL_NO_VOLATILE_CE);
   arm_tune_cortex_a9 = (arm_tune == cortexa9) != 0;
-  arm_arch_crc = (insn_flags & FL_CRC32) != 0;
-  arm_m_profile_small_mul = (insn_flags & FL_SMALLMUL) != 0;
-  if (arm_restrict_it == 2)
-    arm_restrict_it = arm_arch8 && TARGET_THUMB2;
-
-  if (!TARGET_THUMB2)
-    arm_restrict_it = 0;
-
-  /* If we are not using the default (ARM mode) section anchor offset
-     ranges, then set the correct ranges now.  */
-  if (TARGET_THUMB1)
-    {
-      /* Thumb-1 LDR instructions cannot have negative offsets.
-         Permissible positive offset ranges are 5-bit (for byte loads),
-         6-bit (for halfword loads), or 7-bit (for word loads).
-         Empirical results suggest a 7-bit anchor range gives the best
-         overall code size.  */
-      targetm.min_anchor_offset = 0;
-      targetm.max_anchor_offset = 127;
-    }
-  else if (TARGET_THUMB2)
-    {
-      /* The minimum is set such that the total size of the block
-         for a particular anchor is 248 + 1 + 4095 bytes, which is
-         divisible by eight, ensuring natural spacing of anchors.  */
-      targetm.min_anchor_offset = -248;
-      targetm.max_anchor_offset = 4095;
-    }
+  arm_arch_crc = ARM_FSET_HAS_CPU1 (insn_flags, FL_CRC32);
+  arm_m_profile_small_mul = ARM_FSET_HAS_CPU1 (insn_flags, FL_SMALLMUL);
 
   /* V5 code we generate is completely interworking capable, so we turn off
      TARGET_INTERWORK here to avoid many tests later on.  */
@@ -2951,10 +3173,6 @@ arm_option_override (void)
   if (TARGET_IWMMXT && TARGET_NEON)
     error ("iWMMXt and NEON are incompatible");
 
-  /* iWMMXt unsupported under Thumb mode.  */
-  if (TARGET_THUMB && TARGET_IWMMXT)
-    error ("iWMMXt unsupported under Thumb mode");
-
   /* __fp16 support currently assumes the core has ldrh.  */
   if (!arm_arch4 && arm_fp16_format != ARM_FP16_FORMAT_NONE)
     sorry ("__fp16 and no ldrh");
@@ -2987,7 +3205,7 @@ arm_option_override (void)
 
   /* For arm2/3 there is no need to do any scheduling if we are doing
      software floating-point.  */
-  if (TARGET_SOFT_FLOAT && (tune_flags & FL_MODE32) == 0)
+  if (TARGET_SOFT_FLOAT && !ARM_FSET_HAS_CPU1 (tune_flags, FL_MODE32))
     flag_schedule_insns = flag_schedule_insns_after_reload = 0;
 
   /* Use the cp15 method if it is available.  */
@@ -2999,9 +3217,6 @@ arm_option_override (void)
 	target_thread_pointer = TP_SOFT;
     }
 
-  if (TARGET_HARD_TP && TARGET_THUMB1)
-    error ("can not use -mtp=cp15 with 16-bit Thumb");
-
   /* Override the default structure alignment for AAPCS ABI.  */
   if (!global_options_set.x_arm_structure_size_boundary)
     {
@@ -3024,12 +3239,6 @@ arm_option_override (void)
 	}
     }
 
-  if (!TARGET_ARM && TARGET_VXWORKS_RTP && flag_pic)
-    {
-      error ("RTP PIC is incompatible with Thumb");
-      flag_pic = 0;
-    }
-
   /* If stack checking is disabled, we can use r10 as the PIC register,
      which keeps r9 available.  The EABI specifies r9 as the PIC register.  */
   if (flag_pic && TARGET_SINGLE_PIC_BASE)
@@ -3097,25 +3306,6 @@ arm_option_override (void)
       unaligned_access = 0;
     }
 
-  if (TARGET_THUMB1 && flag_schedule_insns)
-    {
-      /* Don't warn since it's on by default in -O2.  */
-      flag_schedule_insns = 0;
-    }
-
-  if (optimize_size)
-    {
-      /* If optimizing for size, bump the number of instructions that we
-         are prepared to conditionally execute (even on a StrongARM).  */
-      max_insns_skipped = 6;
-
-      /* For THUMB2, we limit the conditional sequence to one IT block.  */
-      if (TARGET_THUMB2)
-	max_insns_skipped = MAX_INSN_PER_IT_BLOCK;
-    }
-  else
-    max_insns_skipped = current_tune->max_insns_skipped;
-
   /* Hot/Cold partitioning is not currently supported, since we can't
      handle literal pool placement in that case.  */
   if (flag_reorder_blocks_and_partition)
@@ -3140,31 +3330,33 @@ arm_option_override (void)
       && abi_version_at_least(2))
     flag_strict_volatile_bitfields = 1;
 
-  /* Enable sw prefetching at -O3 for CPUS that have prefetch, and we have deemed
-     it beneficial (signified by setting num_prefetch_slots to 1 or more.)  */
+  /* Enable sw prefetching at -O3 for CPUS that have prefetch, and we
+     have deemed it beneficial (signified by setting
+     prefetch.num_slots to 1 or more).  */
   if (flag_prefetch_loop_arrays < 0
       && HAVE_prefetch
       && optimize >= 3
-      && current_tune->num_prefetch_slots > 0)
+      && current_tune->prefetch.num_slots > 0)
     flag_prefetch_loop_arrays = 1;
 
-  /* Set up parameters to be used in prefetching algorithm.  Do not override the
-     defaults unless we are tuning for a core we have researched values for.  */
-  if (current_tune->num_prefetch_slots > 0)
+  /* Set up parameters to be used in prefetching algorithm.  Do not
+     override the defaults unless we are tuning for a core we have
+     researched values for.  */
+  if (current_tune->prefetch.num_slots > 0)
     maybe_set_param_value (PARAM_SIMULTANEOUS_PREFETCHES,
-                           current_tune->num_prefetch_slots,
-                           global_options.x_param_values,
-                           global_options_set.x_param_values);
-  if (current_tune->l1_cache_line_size >= 0)
+			   current_tune->prefetch.num_slots,
+			   global_options.x_param_values,
+			   global_options_set.x_param_values);
+  if (current_tune->prefetch.l1_cache_line_size >= 0)
     maybe_set_param_value (PARAM_L1_CACHE_LINE_SIZE,
-                           current_tune->l1_cache_line_size,
-                           global_options.x_param_values,
-                           global_options_set.x_param_values);
-  if (current_tune->l1_cache_size >= 0)
+			   current_tune->prefetch.l1_cache_line_size,
+			   global_options.x_param_values,
+			   global_options_set.x_param_values);
+  if (current_tune->prefetch.l1_cache_size >= 0)
     maybe_set_param_value (PARAM_L1_CACHE_SIZE,
-                           current_tune->l1_cache_size,
-                           global_options.x_param_values,
-                           global_options_set.x_param_values);
+			   current_tune->prefetch.l1_cache_size,
+			   global_options.x_param_values,
+			   global_options_set.x_param_values);
 
   /* Use Neon to perform 64-bits operations rather than core
      registers.  */
@@ -3174,67 +3366,63 @@ arm_option_override (void)
 
   /* Use the alternative scheduling-pressure algorithm by default.  */
   maybe_set_param_value (PARAM_SCHED_PRESSURE_ALGORITHM, SCHED_PRESSURE_MODEL,
-                         global_options.x_param_values,
-                         global_options_set.x_param_values);
+			 global_options.x_param_values,
+			 global_options_set.x_param_values);
 
   /* Look through ready list and all of queue for instructions
      relevant for L2 auto-prefetcher.  */
   int param_sched_autopref_queue_depth;
-  if (current_tune->sched_autopref == ARM_SCHED_AUTOPREF_OFF)
-    param_sched_autopref_queue_depth = -1;
-  else if (current_tune->sched_autopref == ARM_SCHED_AUTOPREF_RANK)
-    param_sched_autopref_queue_depth = 0;
-  else if (current_tune->sched_autopref == ARM_SCHED_AUTOPREF_FULL)
-    param_sched_autopref_queue_depth = max_insn_queue_index + 1;
-  else
-    gcc_unreachable ();
+
+  switch (current_tune->sched_autopref)
+    {
+    case tune_params::SCHED_AUTOPREF_OFF:
+      param_sched_autopref_queue_depth = -1;
+      break;
+
+    case tune_params::SCHED_AUTOPREF_RANK:
+      param_sched_autopref_queue_depth = 0;
+      break;
+
+    case tune_params::SCHED_AUTOPREF_FULL:
+      param_sched_autopref_queue_depth = max_insn_queue_index + 1;
+      break;
+
+    default:
+      gcc_unreachable ();
+    }
+
   maybe_set_param_value (PARAM_SCHED_AUTOPREF_QUEUE_DEPTH,
 			 param_sched_autopref_queue_depth,
-                         global_options.x_param_values,
-                         global_options_set.x_param_values);
-
-  /* Disable shrink-wrap when optimizing function for size, since it tends to
-     generate additional returns.  */
-  if (optimize_function_for_size_p (cfun) && TARGET_THUMB2)
-    flag_shrink_wrap = false;
-  /* TBD: Dwarf info for apcs frame is not handled yet.  */
-  if (TARGET_APCS_FRAME)
-    flag_shrink_wrap = false;
-
-  /* We only support -mslow-flash-data on armv7-m targets.  */
-  if (target_slow_flash_data
-      && ((!(arm_arch7 && !arm_arch_notm) && !arm_arch7em)
-	  || (TARGET_THUMB1 || flag_pic || TARGET_NEON)))
-    error ("-mslow-flash-data only supports non-pic code on armv7-m targets");
+			 global_options.x_param_values,
+			 global_options_set.x_param_values);
 
   /* Currently, for slow flash data, we just disable literal pools.  */
   if (target_slow_flash_data)
     arm_disable_literal_pool = true;
 
-  /* Thumb2 inline assembly code should always use unified syntax.
-     This will apply to ARM and Thumb1 eventually.  */
-  if (TARGET_THUMB2)
-    inline_asm_unified = 1;
-
   /* Disable scheduling fusion by default if it's not armv7 processor
      or doesn't prefer ldrd/strd.  */
   if (flag_schedule_fusion == 2
       && (!arm_arch7 || !current_tune->prefer_ldrd_strd))
     flag_schedule_fusion = 0;
 
-  /* In Thumb1 mode, we emit the epilogue in RTL, but the last insn
-     - epilogue_insns - does not accurately model the corresponding insns
-     emitted in the asm file.  In particular, see the comment in thumb_exit
-     'Find out how many of the (return) argument registers we can corrupt'.
-     As a consequence, the epilogue may clobber registers without fipa-ra
-     finding out about it.  Therefore, disable fipa-ra in Thumb1 mode.
-     TODO: Accurately model clobbers for epilogue_insns and reenable
-     fipa-ra.  */
-  if (TARGET_THUMB1)
-    flag_ipa_ra = 0;
+  /* Need to remember initial options before they are overriden.  */
+  init_optimize = build_optimization_node (&global_options);
+
+  arm_option_override_internal (&global_options, &global_options_set);
+  arm_option_check_internal (&global_options);
+  arm_option_params_internal ();
 
   /* Register global variables with the garbage collector.  */
   arm_add_gc_roots ();
+
+  /* Save the initial options in case the user does function specific
+     options.  */
+  target_option_default_node = target_option_current_node
+    = build_target_option_node (&global_options);
+
+  /* Init initial mode for testing.  */
+  thumb_flipper = TARGET_THUMB;
 }
 
 static void
@@ -3388,13 +3576,20 @@ arm_warn_func_return (tree decl)
 static void
 arm_asm_trampoline_template (FILE *f)
 {
+  if (TARGET_UNIFIED_ASM)
+    fprintf (f, "\t.syntax unified\n");
+  else
+    fprintf (f, "\t.syntax divided\n");
+
   if (TARGET_ARM)
     {
+      fprintf (f, "\t.arm\n");
       asm_fprintf (f, "\tldr\t%r, [%r, #0]\n", STATIC_CHAIN_REGNUM, PC_REGNUM);
       asm_fprintf (f, "\tldr\t%r, [%r, #0]\n", PC_REGNUM, PC_REGNUM);
     }
   else if (TARGET_THUMB2)
     {
+      fprintf (f, "\t.thumb\n");
       /* The Thumb-2 trampoline is similar to the arm implementation.
 	 Unlike 16-bit Thumb, we enter the stub in thumb mode.  */
       asm_fprintf (f, "\tldr.w\t%r, [%r, #4]\n",
@@ -4058,8 +4253,8 @@ emit_constant_insn (rtx cond, rtx pattern)
 
 static int
 arm_gen_constant (enum rtx_code code, machine_mode mode, rtx cond,
-		  HOST_WIDE_INT val, rtx target, rtx source, int subtargets,
-		  int generate)
+		  unsigned HOST_WIDE_INT val, rtx target, rtx source,
+		  int subtargets, int generate)
 {
   int can_invert = 0;
   int can_negate = 0;
@@ -4437,7 +4632,7 @@ arm_gen_constant (enum rtx_code code, machine_mode mode, rtx cond,
 	  mvn	r0, r0, asl #12
 	  mvn	r0, r0, lsr #12  */
       if (set_sign_bit_copies > 8
-	  && (val & (-1 << (32 - set_sign_bit_copies))) == val)
+	  && (val & (HOST_WIDE_INT_M1U << (32 - set_sign_bit_copies))) == val)
 	{
 	  if (generate)
 	    {
@@ -7946,236 +8141,6 @@ thumb_legitimize_address (rtx x, rtx orig_x, machine_mode mode)
   return x;
 }
 
-bool
-arm_legitimize_reload_address (rtx *p,
-			       machine_mode mode,
-			       int opnum, int type,
-			       int ind_levels ATTRIBUTE_UNUSED)
-{
-  /* We must recognize output that we have already generated ourselves.  */
-  if (GET_CODE (*p) == PLUS
-      && GET_CODE (XEXP (*p, 0)) == PLUS
-      && REG_P (XEXP (XEXP (*p, 0), 0))
-      && CONST_INT_P (XEXP (XEXP (*p, 0), 1))
-      && CONST_INT_P (XEXP (*p, 1)))
-    {
-      push_reload (XEXP (*p, 0), NULL_RTX, &XEXP (*p, 0), NULL,
-		   MODE_BASE_REG_CLASS (mode), GET_MODE (*p),
-		   VOIDmode, 0, 0, opnum, (enum reload_type) type);
-      return true;
-    }
-
-  if (GET_CODE (*p) == PLUS
-      && REG_P (XEXP (*p, 0))
-      && ARM_REGNO_OK_FOR_BASE_P (REGNO (XEXP (*p, 0)))
-      /* If the base register is equivalent to a constant, let the generic
-	 code handle it.  Otherwise we will run into problems if a future
-	 reload pass decides to rematerialize the constant.  */
-      && !reg_equiv_constant (ORIGINAL_REGNO (XEXP (*p, 0)))
-      && CONST_INT_P (XEXP (*p, 1)))
-    {
-      HOST_WIDE_INT val = INTVAL (XEXP (*p, 1));
-      HOST_WIDE_INT low, high;
-
-      /* Detect coprocessor load/stores.  */
-      bool coproc_p = ((TARGET_HARD_FLOAT
-			&& TARGET_VFP
-			&& (mode == SFmode || mode == DFmode))
-		       || (TARGET_REALLY_IWMMXT
-			   && VALID_IWMMXT_REG_MODE (mode))
-		       || (TARGET_NEON
-			   && (VALID_NEON_DREG_MODE (mode)
-			       || VALID_NEON_QREG_MODE (mode))));
-
-      /* For some conditions, bail out when lower two bits are unaligned.  */
-      if ((val & 0x3) != 0
-	  /* Coprocessor load/store indexes are 8-bits + '00' appended.  */
-	  && (coproc_p
-	      /* For DI, and DF under soft-float: */
-	      || ((mode == DImode || mode == DFmode)
-		  /* Without ldrd, we use stm/ldm, which does not
-		     fair well with unaligned bits.  */
-		  && (! TARGET_LDRD
-		      /* Thumb-2 ldrd/strd is [-1020,+1020] in steps of 4.  */
-		      || TARGET_THUMB2))))
-	return false;
-
-      /* When breaking down a [reg+index] reload address into [(reg+high)+low],
-	 of which the (reg+high) gets turned into a reload add insn,
-	 we try to decompose the index into high/low values that can often
-	 also lead to better reload CSE.
-	 For example:
-	         ldr r0, [r2, #4100]  // Offset too large
-		 ldr r1, [r2, #4104]  // Offset too large
-
-	 is best reloaded as:
-	         add t1, r2, #4096
-		 ldr r0, [t1, #4]
-		 add t2, r2, #4096
-		 ldr r1, [t2, #8]
-
-	 which post-reload CSE can simplify in most cases to eliminate the
-	 second add instruction:
-	         add t1, r2, #4096
-		 ldr r0, [t1, #4]
-		 ldr r1, [t1, #8]
-
-	 The idea here is that we want to split out the bits of the constant
-	 as a mask, rather than as subtracting the maximum offset that the
-	 respective type of load/store used can handle.
-
-	 When encountering negative offsets, we can still utilize it even if
-	 the overall offset is positive; sometimes this may lead to an immediate
-	 that can be constructed with fewer instructions.
-	 For example:
-	         ldr r0, [r2, #0x3FFFFC]
-
-	 This is best reloaded as:
-	         add t1, r2, #0x400000
-		 ldr r0, [t1, #-4]
-
-	 The trick for spotting this for a load insn with N bits of offset
-	 (i.e. bits N-1:0) is to look at bit N; if it is set, then chose a
-	 negative offset that is going to make bit N and all the bits below
-	 it become zero in the remainder part.
-
-	 The SIGN_MAG_LOW_ADDR_BITS macro below implements this, with respect
-	 to sign-magnitude addressing (i.e. separate +- bit, or 1's complement),
-	 used in most cases of ARM load/store instructions.  */
-
-#define SIGN_MAG_LOW_ADDR_BITS(VAL, N)					\
-      (((VAL) & ((1 << (N)) - 1))					\
-       ? (((VAL) & ((1 << ((N) + 1)) - 1)) ^ (1 << (N))) - (1 << (N))	\
-       : 0)
-
-      if (coproc_p)
-	{
-	  low = SIGN_MAG_LOW_ADDR_BITS (val, 10);
-
-	  /* NEON quad-word load/stores are made of two double-word accesses,
-	     so the valid index range is reduced by 8. Treat as 9-bit range if
-	     we go over it.  */
-	  if (TARGET_NEON && VALID_NEON_QREG_MODE (mode) && low >= 1016)
-	    low = SIGN_MAG_LOW_ADDR_BITS (val, 9);
-	}
-      else if (GET_MODE_SIZE (mode) == 8)
-	{
-	  if (TARGET_LDRD)
-	    low = (TARGET_THUMB2
-		   ? SIGN_MAG_LOW_ADDR_BITS (val, 10)
-		   : SIGN_MAG_LOW_ADDR_BITS (val, 8));
-	  else
-	    /* For pre-ARMv5TE (without ldrd), we use ldm/stm(db/da/ib)
-	       to access doublewords. The supported load/store offsets are
-	       -8, -4, and 4, which we try to produce here.  */
-	    low = ((val & 0xf) ^ 0x8) - 0x8;
-	}
-      else if (GET_MODE_SIZE (mode) < 8)
-	{
-	  /* NEON element load/stores do not have an offset.  */
-	  if (TARGET_NEON_FP16 && mode == HFmode)
-	    return false;
-
-	  if (TARGET_THUMB2)
-	    {
-	      /* Thumb-2 has an asymmetrical index range of (-256,4096).
-		 Try the wider 12-bit range first, and re-try if the result
-		 is out of range.  */
-	      low = SIGN_MAG_LOW_ADDR_BITS (val, 12);
-	      if (low < -255)
-		low = SIGN_MAG_LOW_ADDR_BITS (val, 8);
-	    }
-	  else
-	    {
-	      if (mode == HImode || mode == HFmode)
-		{
-		  if (arm_arch4)
-		    low = SIGN_MAG_LOW_ADDR_BITS (val, 8);
-		  else
-		    {
-		      /* The storehi/movhi_bytes fallbacks can use only
-			 [-4094,+4094] of the full ldrb/strb index range.  */
-		      low = SIGN_MAG_LOW_ADDR_BITS (val, 12);
-		      if (low == 4095 || low == -4095)
-			return false;
-		    }
-		}
-	      else
-		low = SIGN_MAG_LOW_ADDR_BITS (val, 12);
-	    }
-	}
-      else
-	return false;
-
-      high = ((((val - low) & (unsigned HOST_WIDE_INT) 0xffffffff)
-	       ^ (unsigned HOST_WIDE_INT) 0x80000000)
-	      - (unsigned HOST_WIDE_INT) 0x80000000);
-      /* Check for overflow or zero */
-      if (low == 0 || high == 0 || (high + low != val))
-	return false;
-
-      /* Reload the high part into a base reg; leave the low part
-	 in the mem.
-	 Note that replacing this gen_rtx_PLUS with plus_constant is
-	 wrong in this case because we rely on the
-	 (plus (plus reg c1) c2) structure being preserved so that
-	 XEXP (*p, 0) in push_reload below uses the correct term.  */
-      *p = gen_rtx_PLUS (GET_MODE (*p),
-			 gen_rtx_PLUS (GET_MODE (*p), XEXP (*p, 0),
-				       GEN_INT (high)),
-			 GEN_INT (low));
-      push_reload (XEXP (*p, 0), NULL_RTX, &XEXP (*p, 0), NULL,
-		   MODE_BASE_REG_CLASS (mode), GET_MODE (*p),
-		   VOIDmode, 0, 0, opnum, (enum reload_type) type);
-      return true;
-    }
-
-  return false;
-}
-
-rtx
-thumb_legitimize_reload_address (rtx *x_p,
-				 machine_mode mode,
-				 int opnum, int type,
-				 int ind_levels ATTRIBUTE_UNUSED)
-{
-  rtx x = *x_p;
-
-  if (GET_CODE (x) == PLUS
-      && GET_MODE_SIZE (mode) < 4
-      && REG_P (XEXP (x, 0))
-      && XEXP (x, 0) == stack_pointer_rtx
-      && CONST_INT_P (XEXP (x, 1))
-      && !thumb_legitimate_offset_p (mode, INTVAL (XEXP (x, 1))))
-    {
-      rtx orig_x = x;
-
-      x = copy_rtx (x);
-      push_reload (orig_x, NULL_RTX, x_p, NULL, MODE_BASE_REG_CLASS (mode),
-		   Pmode, VOIDmode, 0, 0, opnum, (enum reload_type) type);
-      return x;
-    }
-
-  /* If both registers are hi-regs, then it's better to reload the
-     entire expression rather than each register individually.  That
-     only requires one reload register rather than two.  */
-  if (GET_CODE (x) == PLUS
-      && REG_P (XEXP (x, 0))
-      && REG_P (XEXP (x, 1))
-      && !REG_MODE_OK_FOR_REG_BASE_P (XEXP (x, 0), mode)
-      && !REG_MODE_OK_FOR_REG_BASE_P (XEXP (x, 1), mode))
-    {
-      rtx orig_x = x;
-
-      x = copy_rtx (x);
-      push_reload (orig_x, NULL_RTX, x_p, NULL, MODE_BASE_REG_CLASS (mode),
-		   Pmode, VOIDmode, 0, 0, opnum, (enum reload_type) type);
-      return x;
-    }
-
-  return NULL;
-}
-
 /* Return TRUE if X contains any TLS symbol references.  */
 
 bool
@@ -9399,7 +9364,8 @@ static bool
 arm_unspec_cost (rtx x, enum rtx_code /* outer_code */, bool speed_p, int *cost)
 {
   const struct cpu_cost_table *extra_cost = current_tune->insn_extra_cost;
-  gcc_assert (GET_CODE (x) == UNSPEC);
+  rtx_code code = GET_CODE (x);
+  gcc_assert (code == UNSPEC || code == UNSPEC_VOLATILE);
 
   switch (XINT (x, 1))
     {
@@ -9445,7 +9411,7 @@ arm_unspec_cost (rtx x, enum rtx_code /* outer_code */, bool speed_p, int *cost)
       *cost = COSTS_N_INSNS (2);
       break;
     }
-  return false;
+  return true;
 }
 
 /* Cost of a libcall.  We assume one insn per argument, an amount for the
@@ -11008,6 +10974,7 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,
       *cost = LIBCALL_COST (1);
       return false;
 
+    case UNSPEC_VOLATILE:
     case UNSPEC:
       return arm_unspec_cost (x, outer_code, speed_p, cost);
 
@@ -12908,12 +12875,12 @@ neon_expand_vector_init (rtx target, rtx vals)
 }
 
 /* Ensure OPERAND lies between LOW (inclusive) and HIGH (exclusive).  Raise
-   ERR if it doesn't.  FIXME: NEON bounds checks occur late in compilation, so
-   reported source locations are bogus.  */
+   ERR if it doesn't.  EXP indicates the source location, which includes the
+   inlining history for intrinsics.  */
 
 static void
 bounds_check (rtx operand, HOST_WIDE_INT low, HOST_WIDE_INT high,
-	      const char *err)
+	      const_tree exp, const char *desc)
 {
   HOST_WIDE_INT lane;
 
@@ -12922,15 +12889,22 @@ bounds_check (rtx operand, HOST_WIDE_INT low, HOST_WIDE_INT high,
   lane = INTVAL (operand);
 
   if (lane < low || lane >= high)
-    error (err);
+    {
+      if (exp)
+	error ("%K%s %wd out of range %wd - %wd",
+	       exp, desc, lane, low, high - 1);
+      else
+	error ("%s %wd out of range %wd - %wd", desc, lane, low, high - 1);
+    }
 }
 
 /* Bounds-check lanes.  */
 
 void
-neon_lane_bounds (rtx operand, HOST_WIDE_INT low, HOST_WIDE_INT high)
+neon_lane_bounds (rtx operand, HOST_WIDE_INT low, HOST_WIDE_INT high,
+		  const_tree exp)
 {
-  bounds_check (operand, low, high, "lane out of range");
+  bounds_check (operand, low, high, exp, "lane");
 }
 
 /* Bounds-check constants.  */
@@ -12938,7 +12912,7 @@ neon_lane_bounds (rtx operand, HOST_WIDE_INT low, HOST_WIDE_INT high)
 void
 neon_const_bounds (rtx operand, HOST_WIDE_INT low, HOST_WIDE_INT high)
 {
-  bounds_check (operand, low, high, "constant out of range");
+  bounds_check (operand, low, high, NULL_TREE, "constant");
 }
 
 HOST_WIDE_INT
@@ -14525,7 +14499,10 @@ arm_block_move_unaligned_straight (rtx dstbase, rtx srcbase,
 				srcoffset + j * UNITS_PER_WORD - src_autoinc);
 	  mem = adjust_automodify_address (srcbase, SImode, addr,
 					   srcoffset + j * UNITS_PER_WORD);
-	  emit_insn (gen_unaligned_loadsi (regs[j], mem));
+	  if (src_aligned)
+	    emit_move_insn (regs[j], mem);
+	  else
+	    emit_insn (gen_unaligned_loadsi (regs[j], mem));
 	}
       srcoffset += words * UNITS_PER_WORD;
     }
@@ -14544,7 +14521,10 @@ arm_block_move_unaligned_straight (rtx dstbase, rtx srcbase,
 				dstoffset + j * UNITS_PER_WORD - dst_autoinc);
 	  mem = adjust_automodify_address (dstbase, SImode, addr,
 					   dstoffset + j * UNITS_PER_WORD);
-	  emit_insn (gen_unaligned_storesi (mem, regs[j]));
+	  if (dst_aligned)
+	    emit_move_insn (mem, regs[j]);
+	  else
+	    emit_insn (gen_unaligned_storesi (mem, regs[j]));
 	}
       dstoffset += words * UNITS_PER_WORD;
     }
@@ -17287,14 +17267,16 @@ thumb2_reorg (void)
 
   FOR_EACH_BB_FN (bb, cfun)
     {
-      if (current_tune->disparage_flag_setting_t16_encodings
+      if ((current_tune->disparage_flag_setting_t16_encodings
+	   == tune_params::DISPARAGE_FLAGS_ALL)
 	  && optimize_bb_for_speed_p (bb))
 	continue;
 
       rtx_insn *insn;
       Convert_Action action = SKIP;
       Convert_Action action_for_partial_flag_setting
-	= (current_tune->disparage_partial_flag_setting_t16_encodings
+	= ((current_tune->disparage_flag_setting_t16_encodings
+	    != tune_params::DISPARAGE_FLAGS_NEITHER)
 	   && optimize_bb_for_speed_p (bb))
 	  ? SKIP : CONV;
 
@@ -17699,7 +17681,7 @@ arm_output_multireg_pop (rtx *operands, bool return_pc, rtx cond, bool reverse,
     }
 
   conditional = reverse ? "%?%D0" : "%?%d0";
-  if ((regno_base == SP_REGNUM) && TARGET_UNIFIED_ASM)
+  if ((regno_base == SP_REGNUM) && TARGET_THUMB)
     {
       /* Output pop (not stmfd) because it has a shorter encoding.  */
       gcc_assert (update);
@@ -17998,19 +17980,27 @@ output_mov_long_double_arm_from_arm (rtx *operands)
 void
 arm_emit_movpair (rtx dest, rtx src)
  {
+  rtx insn;
+
   /* If the src is an immediate, simplify it.  */
   if (CONST_INT_P (src))
     {
       HOST_WIDE_INT val = INTVAL (src);
       emit_set_insn (dest, GEN_INT (val & 0x0000ffff));
       if ((val >> 16) & 0x0000ffff)
-        emit_set_insn (gen_rtx_ZERO_EXTRACT (SImode, dest, GEN_INT (16),
-                                             GEN_INT (16)),
-                       GEN_INT ((val >> 16) & 0x0000ffff));
+	{
+	  emit_set_insn (gen_rtx_ZERO_EXTRACT (SImode, dest, GEN_INT (16),
+					       GEN_INT (16)),
+			 GEN_INT ((val >> 16) & 0x0000ffff));
+	  insn = get_last_insn ();
+	  set_unique_reg_note (insn, REG_EQUAL, copy_rtx (src));
+	}
       return;
     }
    emit_set_insn (dest, gen_rtx_HIGH (SImode, src));
    emit_set_insn (dest, gen_rtx_LO_SUM (SImode, dest, src));
+   insn = get_last_insn ();
+   set_unique_reg_note (insn, REG_EQUAL, copy_rtx (src));
  }
 
 /* Output a move between double words.  It must be REG<-MEM
@@ -24077,19 +24067,19 @@ thumb_far_jump_used_p (void)
 }
 
 /* Return nonzero if FUNC must be entered in ARM mode.  */
-int
+static bool
 is_called_in_ARM_mode (tree func)
 {
   gcc_assert (TREE_CODE (func) == FUNCTION_DECL);
 
   /* Ignore the problem about functions whose address is taken.  */
   if (TARGET_CALLEE_INTERWORKING && TREE_PUBLIC (func))
-    return TRUE;
+    return true;
 
 #ifdef ARM_PE
   return lookup_attribute ("interfacearm", DECL_ATTRIBUTES (func)) != NULL_TREE;
 #else
-  return FALSE;
+  return false;
 #endif
 }
 
@@ -24375,6 +24365,24 @@ arm_init_expanders (void)
     mark_reg_pointer (arg_pointer_rtx, PARM_BOUNDARY);
 }
 
+/* Check that FUNC is called with a different mode.  */
+
+bool
+arm_change_mode_p (tree func)
+{
+  if (TREE_CODE (func) != FUNCTION_DECL)
+    return false;
+
+  tree callee_tree = DECL_FUNCTION_SPECIFIC_TARGET (func);
+
+  if (!callee_tree)
+    callee_tree = target_option_default_node;
+
+  struct cl_target_option *callee_opts = TREE_TARGET_OPTION (callee_tree);
+  int flags = callee_opts->x_target_flags;
+
+  return (TARGET_THUMB_P (flags) != TARGET_THUMB);
+}
 
 /* Like arm_compute_initial_elimination offset.  Simpler because there
    isn't an ABI specified frame pointer for Thumb.  Instead, we set it
@@ -25660,12 +25668,12 @@ arm_print_tune_info (void)
 	       current_tune->constant_limit);
   asm_fprintf (asm_out_file, "\t\t@max_insns_skipped:\t%d\n",
 	       current_tune->max_insns_skipped);
-  asm_fprintf (asm_out_file, "\t\t@num_prefetch_slots:\t%d\n",
-	       current_tune->num_prefetch_slots);
-  asm_fprintf (asm_out_file, "\t\t@l1_cache_size:\t%d\n",
-	       current_tune->l1_cache_size);
-  asm_fprintf (asm_out_file, "\t\t@l1_cache_line_size:\t%d\n",
-	       current_tune->l1_cache_line_size);
+  asm_fprintf (asm_out_file, "\t\t@prefetch.num_slots:\t%d\n",
+	       current_tune->prefetch.num_slots);
+  asm_fprintf (asm_out_file, "\t\t@prefetch.l1_cache_size:\t%d\n",
+	       current_tune->prefetch.l1_cache_size);
+  asm_fprintf (asm_out_file, "\t\t@prefetch.l1_cache_line_size:\t%d\n",
+	       current_tune->prefetch.l1_cache_line_size);
   asm_fprintf (asm_out_file, "\t\t@prefer_constant_pool:\t%d\n",
 	       (int) current_tune->prefer_constant_pool);
   asm_fprintf (asm_out_file, "\t\t@branch_cost:\t(s:speed, p:predictable)\n");
@@ -25681,23 +25689,19 @@ arm_print_tune_info (void)
   asm_fprintf (asm_out_file, "\t\t@prefer_ldrd_strd:\t%d\n",
 	       (int) current_tune->prefer_ldrd_strd);
   asm_fprintf (asm_out_file, "\t\t@logical_op_non_short_circuit:\t[%d,%d]\n",
-	       (int) current_tune->logical_op_non_short_circuit[0],
-	       (int) current_tune->logical_op_non_short_circuit[1]);
+	       (int) current_tune->logical_op_non_short_circuit_thumb,
+	       (int) current_tune->logical_op_non_short_circuit_arm);
   asm_fprintf (asm_out_file, "\t\t@prefer_neon_for_64bits:\t%d\n",
 	       (int) current_tune->prefer_neon_for_64bits);
   asm_fprintf (asm_out_file,
 	       "\t\t@disparage_flag_setting_t16_encodings:\t%d\n",
 	       (int) current_tune->disparage_flag_setting_t16_encodings);
-  asm_fprintf (asm_out_file,
-	       "\t\t@disparage_partial_flag_setting_t16_encodings:\t%d\n",
-	       (int) current_tune
-	               ->disparage_partial_flag_setting_t16_encodings);
   asm_fprintf (asm_out_file, "\t\t@string_ops_prefer_neon:\t%d\n",
 	       (int) current_tune->string_ops_prefer_neon);
   asm_fprintf (asm_out_file, "\t\t@max_insns_inline_memset:\t%d\n",
 	       current_tune->max_insns_inline_memset);
-  asm_fprintf (asm_out_file, "\t\t@fuseable_ops:\t%u\n",
-	       current_tune->fuseable_ops);
+  asm_fprintf (asm_out_file, "\t\t@fusible_ops:\t%u\n",
+	       current_tune->fusible_ops);
   asm_fprintf (asm_out_file, "\t\t@sched_autopref:\t%d\n",
 	       (int) current_tune->sched_autopref);
 }
@@ -25707,9 +25711,6 @@ arm_file_start (void)
 {
   int val;
 
-  if (TARGET_UNIFIED_ASM)
-    asm_fprintf (asm_out_file, "\t.syntax unified\n");
-
   if (TARGET_BPABI)
     {
       const char *fpu_name;
@@ -26376,7 +26377,8 @@ arm_vector_mode_supported_p (machine_mode mode)
 {
   /* Neon also supports V2SImode, etc. listed in the clause below.  */
   if (TARGET_NEON && (mode == V2SFmode || mode == V4SImode || mode == V8HImode
-      || mode == V4HFmode || mode == V16QImode || mode == V4SFmode || mode == V2DImode))
+      || mode == V4HFmode || mode == V16QImode || mode == V4SFmode
+      || mode == V2DImode || mode == V8HFmode))
     return true;
 
   if ((TARGET_NEON || TARGET_IWMMXT)
@@ -26509,7 +26511,7 @@ arm_dbx_register_number (unsigned int regno)
   if (IS_IWMMXT_REGNUM (regno))
     return 112 + regno - FIRST_IWMMXT_REGNUM;
 
-  gcc_unreachable ();
+  return DWARF_FRAME_REGISTERS;
 }
 
 /* Dwarf models VFPv3 registers as 32 64-bit registers.
@@ -27213,40 +27215,12 @@ thumb2_output_casesi (rtx *operands)
     }
 }
 
-/* Most ARM cores are single issue, but some newer ones can dual issue.
-   The scheduler descriptions rely on this being correct.  */
+/* Implement TARGET_SCHED_ISSUE_RATE.  Lookup the issue rate in the
+   per-core tuning structs.  */
 static int
 arm_issue_rate (void)
 {
-  switch (arm_tune)
-    {
-    case xgene1:
-      return 4;
-
-    case cortexa15:
-    case cortexa57:
-    case exynosm1:
-      return 3;
-
-    case cortexm7:
-    case cortexr4:
-    case cortexr4f:
-    case cortexr5:
-    case genericv7a:
-    case cortexa5:
-    case cortexa7:
-    case cortexa8:
-    case cortexa9:
-    case cortexa12:
-    case cortexa17:
-    case cortexa53:
-    case fa726te:
-    case marvell_pj4:
-      return 2;
-
-    default:
-      return 1;
-    }
+  return current_tune->issue_rate;
 }
 
 /* Return how many instructions should scheduler lookahead to choose the
@@ -29422,7 +29396,7 @@ arm_gen_setmem (rtx *operands)
 static bool
 arm_macro_fusion_p (void)
 {
-  return current_tune->fuseable_ops != ARM_FUSE_NOTHING;
+  return current_tune->fusible_ops != tune_params::FUSE_NOTHING;
 }
 
 
@@ -29443,44 +29417,44 @@ aarch_macro_fusion_pair_p (rtx_insn* prev, rtx_insn* curr)
   if (!arm_macro_fusion_p ())
     return false;
 
-  if (current_tune->fuseable_ops & ARM_FUSE_MOVW_MOVT)
+  if (current_tune->fusible_ops & tune_params::FUSE_MOVW_MOVT)
     {
       /* We are trying to fuse
-         movw imm / movt imm
-         instructions as a group that gets scheduled together.  */
+	 movw imm / movt imm
+	 instructions as a group that gets scheduled together.  */
 
       set_dest = SET_DEST (curr_set);
 
       if (GET_MODE (set_dest) != SImode)
-        return false;
+	return false;
 
       /* We are trying to match:
-         prev (movw)  == (set (reg r0) (const_int imm16))
-         curr (movt) == (set (zero_extract (reg r0)
-                                           (const_int 16)
-                                           (const_int 16))
-                             (const_int imm16_1))
-         or
-         prev (movw) == (set (reg r1)
-                              (high (symbol_ref ("SYM"))))
-         curr (movt) == (set (reg r0)
-                             (lo_sum (reg r1)
-                                     (symbol_ref ("SYM"))))  */
+	 prev (movw)  == (set (reg r0) (const_int imm16))
+	 curr (movt) == (set (zero_extract (reg r0)
+					  (const_int 16)
+					   (const_int 16))
+			     (const_int imm16_1))
+	 or
+	 prev (movw) == (set (reg r1)
+			      (high (symbol_ref ("SYM"))))
+	 curr (movt) == (set (reg r0)
+			     (lo_sum (reg r1)
+				     (symbol_ref ("SYM"))))  */
       if (GET_CODE (set_dest) == ZERO_EXTRACT)
-        {
-          if (CONST_INT_P (SET_SRC (curr_set))
-              && CONST_INT_P (SET_SRC (prev_set))
-              && REG_P (XEXP (set_dest, 0))
-              && REG_P (SET_DEST (prev_set))
-              && REGNO (XEXP (set_dest, 0)) == REGNO (SET_DEST (prev_set)))
-            return true;
-        }
+	{
+	  if (CONST_INT_P (SET_SRC (curr_set))
+	      && CONST_INT_P (SET_SRC (prev_set))
+	      && REG_P (XEXP (set_dest, 0))
+	      && REG_P (SET_DEST (prev_set))
+	      && REGNO (XEXP (set_dest, 0)) == REGNO (SET_DEST (prev_set)))
+	    return true;
+	}
       else if (GET_CODE (SET_SRC (curr_set)) == LO_SUM
-               && REG_P (SET_DEST (curr_set))
-               && REG_P (SET_DEST (prev_set))
-               && GET_CODE (SET_SRC (prev_set)) == HIGH
-               && REGNO (SET_DEST (curr_set)) == REGNO (SET_DEST (prev_set)))
-             return true;
+	       && REG_P (SET_DEST (curr_set))
+	       && REG_P (SET_DEST (prev_set))
+	       && GET_CODE (SET_SRC (prev_set)) == HIGH
+	       && REGNO (SET_DEST (curr_set)) == REGNO (SET_DEST (prev_set)))
+	     return true;
     }
   return false;
 }
@@ -29544,6 +29518,273 @@ arm_is_constant_pool_ref (rtx x)
 	  && CONSTANT_POOL_ADDRESS_P (XEXP (x, 0)));
 }
 
+/* Remember the last target of arm_set_current_function.  */
+static GTY(()) tree arm_previous_fndecl;
+
+/* Invalidate arm_previous_fndecl.  */
+void
+arm_reset_previous_fndecl (void)
+{
+  arm_previous_fndecl = NULL_TREE;
+}
+
+/* Establish appropriate back-end context for processing the function
+   FNDECL.  The argument might be NULL to indicate processing at top
+   level, outside of any function scope.  */
+static void
+arm_set_current_function (tree fndecl)
+{
+  if (!fndecl || fndecl == arm_previous_fndecl)
+    return;
+
+  tree old_tree = (arm_previous_fndecl
+		   ? DECL_FUNCTION_SPECIFIC_TARGET (arm_previous_fndecl)
+		   : NULL_TREE);
+
+  tree new_tree = DECL_FUNCTION_SPECIFIC_TARGET (fndecl);
+
+  arm_previous_fndecl = fndecl;
+  if (old_tree == new_tree)
+    return;
+
+  if (new_tree && new_tree != target_option_default_node)
+    {
+      cl_target_option_restore (&global_options,
+				TREE_TARGET_OPTION (new_tree));
+
+      if (TREE_TARGET_GLOBALS (new_tree))
+	restore_target_globals (TREE_TARGET_GLOBALS (new_tree));
+      else
+	TREE_TARGET_GLOBALS (new_tree)
+	  = save_target_globals_default_opts ();
+    }
+
+  else if (old_tree && old_tree != target_option_default_node)
+    {
+      new_tree = target_option_current_node;
+
+      cl_target_option_restore (&global_options,
+				TREE_TARGET_OPTION (new_tree));
+      if (TREE_TARGET_GLOBALS (new_tree))
+	restore_target_globals (TREE_TARGET_GLOBALS (new_tree));
+      else if (new_tree == target_option_default_node)
+	restore_target_globals (&default_target_globals);
+      else
+	TREE_TARGET_GLOBALS (new_tree)
+	  = save_target_globals_default_opts ();
+    }
+
+  arm_option_params_internal ();
+}
+
+/* Implement TARGET_OPTION_PRINT.  */
+
+static void
+arm_option_print (FILE *file, int indent, struct cl_target_option *ptr)
+{
+  int flags = ptr->x_target_flags;
+
+  fprintf (file, "%*sselected arch %s\n", indent, "",
+	   TARGET_THUMB2_P (flags) ? "thumb2" :
+	   TARGET_THUMB_P (flags) ? "thumb1" :
+	   "arm");
+}
+
+/* Hook to determine if one function can safely inline another.  */
+
+static bool
+arm_can_inline_p (tree caller ATTRIBUTE_UNUSED, tree callee ATTRIBUTE_UNUSED)
+{
+  /* Overidde default hook: Always OK to inline between different modes. 
+     Function with mode specific instructions, e.g using asm, must be explicitely 
+     protected with noinline.  */
+  return true;
+}
+
+/* Inner function to process the attribute((target(...))), take an argument and
+   set the current options from the argument.  If we have a list, recursively
+   go over the list.  */
+
+static bool
+arm_valid_target_attribute_rec (tree args, struct gcc_options *opts)
+{
+  if (TREE_CODE (args) == TREE_LIST)
+    {
+      bool ret = true;
+      for (; args; args = TREE_CHAIN (args))
+	if (TREE_VALUE (args)
+	    && !arm_valid_target_attribute_rec (TREE_VALUE (args), opts))
+	  ret = false;
+      return ret;
+    }
+
+  else if (TREE_CODE (args) != STRING_CST)
+    {
+      error ("attribute %<target%> argument not a string");
+      return false;
+    }
+
+  char *argstr = ASTRDUP (TREE_STRING_POINTER (args));
+  while (argstr && *argstr != '\0')
+    {
+      while (ISSPACE (*argstr))
+	argstr++;
+
+      if (!strcmp (argstr, "thumb"))
+	{
+	  opts->x_target_flags |= MASK_THUMB;
+	  arm_option_check_internal (opts);
+	  return true;
+	}
+
+      if (!strcmp (argstr, "arm"))
+	{
+	  opts->x_target_flags &= ~MASK_THUMB;
+	  arm_option_check_internal (opts);
+	  return true;
+	}
+
+      warning (0, "attribute(target(\"%s\")) is unknown", argstr);
+      return false;
+    }
+
+  return false;
+}
+
+/* Return a TARGET_OPTION_NODE tree of the target options listed or NULL.  */
+
+tree
+arm_valid_target_attribute_tree (tree args, struct gcc_options *opts,
+				 struct gcc_options *opts_set)
+{
+  if (!arm_valid_target_attribute_rec (args, opts))
+    return NULL_TREE;
+
+  /* Do any overrides, such as global options arch=xxx.  */
+  arm_option_override_internal (opts, opts_set);
+
+  return build_target_option_node (opts);
+}
+
+static void 
+add_attribute  (const char * mode, tree *attributes)
+{
+  size_t len = strlen (mode);
+  tree value = build_string (len, mode);
+
+  TREE_TYPE (value) = build_array_type (char_type_node,
+					build_index_type (size_int (len)));
+
+  *attributes = tree_cons (get_identifier ("target"),
+			   build_tree_list (NULL_TREE, value),
+			   *attributes);
+}
+
+/* For testing. Insert thumb or arm modes alternatively on functions.  */
+
+static void
+arm_insert_attributes (tree fndecl, tree * attributes)
+{
+  const char *mode;
+
+  if (! TARGET_FLIP_THUMB)
+    return;
+
+  if (TREE_CODE (fndecl) != FUNCTION_DECL || DECL_EXTERNAL(fndecl)
+      || DECL_BUILT_IN (fndecl) || DECL_ARTIFICIAL (fndecl))
+   return;
+
+  /* Nested definitions must inherit mode.  */
+  if (current_function_decl)
+   {
+     mode = TARGET_THUMB ? "thumb" : "arm";      
+     add_attribute (mode, attributes);
+     return;
+   }
+
+  /* If there is already a setting don't change it.  */
+  if (lookup_attribute ("target", *attributes) != NULL)
+    return;
+
+  mode = thumb_flipper ? "thumb" : "arm";
+  add_attribute (mode, attributes);
+
+  thumb_flipper = !thumb_flipper;
+}
+
+/* Hook to validate attribute((target("string"))).  */
+
+static bool
+arm_valid_target_attribute_p (tree fndecl, tree ARG_UNUSED (name),
+			      tree args, int ARG_UNUSED (flags))
+{
+  bool ret = true;
+  struct gcc_options func_options;
+  tree cur_tree, new_optimize;
+  gcc_assert ((fndecl != NULL_TREE) && (args != NULL_TREE));
+
+  /* Get the optimization options of the current function.  */
+  tree func_optimize = DECL_FUNCTION_SPECIFIC_OPTIMIZATION (fndecl);
+
+  /* If the function changed the optimization levels as well as setting target
+     options, start with the optimizations specified.  */
+  if (!func_optimize)
+    func_optimize = optimization_default_node;
+
+  /* Init func_options.  */
+  memset (&func_options, 0, sizeof (func_options));
+  init_options_struct (&func_options, NULL);
+  lang_hooks.init_options_struct (&func_options);
+
+  /* Initialize func_options to the defaults.  */
+  cl_optimization_restore (&func_options,
+			   TREE_OPTIMIZATION (func_optimize));
+
+  cl_target_option_restore (&func_options,
+			    TREE_TARGET_OPTION (target_option_default_node));
+
+  /* Set func_options flags with new target mode.  */
+  cur_tree = arm_valid_target_attribute_tree (args, &func_options,
+					      &global_options_set);
+
+  if (cur_tree == NULL_TREE)
+    ret = false;
+
+  new_optimize = build_optimization_node (&func_options);
+
+  DECL_FUNCTION_SPECIFIC_TARGET (fndecl) = cur_tree;
+
+  DECL_FUNCTION_SPECIFIC_OPTIMIZATION (fndecl) = new_optimize;
+
+  return ret;
+}
+
+void
+arm_declare_function_name (FILE *stream, const char *name, tree decl)
+{
+  if (TARGET_UNIFIED_ASM)
+    fprintf (stream, "\t.syntax unified\n");
+  else
+    fprintf (stream, "\t.syntax divided\n");
+
+  if (TARGET_THUMB)
+    {
+      if (is_called_in_ARM_mode (decl)
+	  || (TARGET_THUMB1 && !TARGET_THUMB1_ONLY
+	      && cfun->is_thunk))
+	fprintf (stream, "\t.code 32\n");
+      else if (TARGET_THUMB1)
+	fprintf (stream, "\t.code\t16\n\t.thumb_func\n");
+      else
+	fprintf (stream, "\t.thumb\n\t.thumb_func\n");
+    }
+  else
+    fprintf (stream, "\t.arm\n");
+
+  if (TARGET_POKE_FUNCTION_NAME)
+    arm_poke_function_name (stream, (const char *) name);
+}
+
 /* If MEM is in the form of [base+offset], extract the two parts
    of address and set to BASE and OFFSET, otherwise return false
    after clearing BASE and OFFSET.  */
--- a/src/gcc/config/arm/arm.h
+++ b/src/gcc/config/arm/arm.h
@@ -45,132 +45,7 @@
 extern char arm_arch_name[];
 
 /* Target CPU builtins.  */
-#define TARGET_CPU_CPP_BUILTINS()			\
-  do							\
-    {							\
-	if (TARGET_DSP_MULTIPLY)			\
-	   builtin_define ("__ARM_FEATURE_DSP");	\
-        if (TARGET_ARM_QBIT)				\
-           builtin_define ("__ARM_FEATURE_QBIT");	\
-        if (TARGET_ARM_SAT)				\
-           builtin_define ("__ARM_FEATURE_SAT");	\
-        if (TARGET_CRYPTO)				\
-	   builtin_define ("__ARM_FEATURE_CRYPTO");	\
-	if (unaligned_access)				\
-	  builtin_define ("__ARM_FEATURE_UNALIGNED");	\
-	if (TARGET_CRC32)				\
-	  builtin_define ("__ARM_FEATURE_CRC32");	\
-	if (TARGET_32BIT)				\
-	  builtin_define ("__ARM_32BIT_STATE");		\
-	if (TARGET_ARM_FEATURE_LDREX)				\
-	  builtin_define_with_int_value (			\
-	    "__ARM_FEATURE_LDREX", TARGET_ARM_FEATURE_LDREX);	\
-	if ((TARGET_ARM_ARCH >= 5 && !TARGET_THUMB)		\
-	     || TARGET_ARM_ARCH_ISA_THUMB >=2)			\
-	  builtin_define ("__ARM_FEATURE_CLZ");			\
-	if (TARGET_INT_SIMD)					\
-	  builtin_define ("__ARM_FEATURE_SIMD32");		\
-								\
-	builtin_define_with_int_value (				\
-	  "__ARM_SIZEOF_MINIMAL_ENUM",				\
-	  flag_short_enums ? 1 : 4);				\
-	builtin_define_type_sizeof ("__ARM_SIZEOF_WCHAR_T",	\
-				    wchar_type_node);		\
-	if (TARGET_ARM_ARCH_PROFILE)				\
-	  builtin_define_with_int_value (			\
-	    "__ARM_ARCH_PROFILE", TARGET_ARM_ARCH_PROFILE);	\
-								\
-	/* Define __arm__ even when in thumb mode, for	\
-	   consistency with armcc.  */			\
-	builtin_define ("__arm__");			\
-	if (TARGET_ARM_ARCH)				\
-	  builtin_define_with_int_value (		\
-	    "__ARM_ARCH", TARGET_ARM_ARCH);		\
-	if (arm_arch_notm)				\
-	  builtin_define ("__ARM_ARCH_ISA_ARM");	\
-	builtin_define ("__APCS_32__");			\
-	if (TARGET_THUMB)				\
-	  builtin_define ("__thumb__");			\
-	if (TARGET_THUMB2)				\
-	  builtin_define ("__thumb2__");		\
-	if (TARGET_ARM_ARCH_ISA_THUMB)			\
-	  builtin_define_with_int_value (		\
-	    "__ARM_ARCH_ISA_THUMB",			\
-	    TARGET_ARM_ARCH_ISA_THUMB);			\
-							\
-	if (TARGET_BIG_END)				\
-	  {						\
-	    builtin_define ("__ARMEB__");		\
-	    builtin_define ("__ARM_BIG_ENDIAN");	\
-	    if (TARGET_THUMB)				\
-	      builtin_define ("__THUMBEB__");		\
-	  }						\
-        else						\
-	  {						\
-	    builtin_define ("__ARMEL__");		\
-	    if (TARGET_THUMB)				\
-	      builtin_define ("__THUMBEL__");		\
-	  }						\
-							\
-	if (TARGET_SOFT_FLOAT)				\
-	  builtin_define ("__SOFTFP__");		\
-							\
-	if (TARGET_VFP)					\
-	  builtin_define ("__VFP_FP__");		\
-							\
-	if (TARGET_ARM_FP)				\
-	  builtin_define_with_int_value (		\
-	    "__ARM_FP", TARGET_ARM_FP);			\
-	if (arm_fp16_format == ARM_FP16_FORMAT_IEEE)		\
-	  builtin_define ("__ARM_FP16_FORMAT_IEEE");		\
-	if (arm_fp16_format == ARM_FP16_FORMAT_ALTERNATIVE)	\
-	  builtin_define ("__ARM_FP16_FORMAT_ALTERNATIVE");	\
-        if (TARGET_FMA)					\
-          builtin_define ("__ARM_FEATURE_FMA");		\
-							\
-	if (TARGET_NEON)				\
-	  {						\
-	    builtin_define ("__ARM_NEON__");		\
-	    builtin_define ("__ARM_NEON");		\
-	  }						\
-	if (TARGET_NEON_FP)				\
-	  builtin_define_with_int_value (		\
-	    "__ARM_NEON_FP", TARGET_NEON_FP);		\
-							\
-	/* Add a define for interworking.		\
-	   Needed when building libgcc.a.  */		\
-	if (arm_cpp_interwork)				\
-	  builtin_define ("__THUMB_INTERWORK__");	\
-							\
-	builtin_assert ("cpu=arm");			\
-	builtin_assert ("machine=arm");			\
-							\
-	builtin_define (arm_arch_name);			\
-	if (arm_arch_xscale)				\
-	  builtin_define ("__XSCALE__");		\
-	if (arm_arch_iwmmxt)				\
-          {						\
-	    builtin_define ("__IWMMXT__");		\
-	    builtin_define ("__ARM_WMMX");		\
-	  }						\
-	if (arm_arch_iwmmxt2)				\
-	  builtin_define ("__IWMMXT2__");		\
-	if (TARGET_AAPCS_BASED)				\
-	  {						\
-	    if (arm_pcs_default == ARM_PCS_AAPCS_VFP)	\
-	      builtin_define ("__ARM_PCS_VFP");		\
-	    else if (arm_pcs_default == ARM_PCS_AAPCS)	\
-	      builtin_define ("__ARM_PCS");		\
-	    builtin_define ("__ARM_EABI__");		\
-	  }						\
-	if (TARGET_IDIV)				\
-         {						\
-            builtin_define ("__ARM_ARCH_EXT_IDIV__");	\
-            builtin_define ("__ARM_FEATURE_IDIV");	\
-         }						\
-	if (inline_asm_unified)				\
-	  builtin_define ("__ARM_ASM_SYNTAX_UNIFIED__");\
-    } while (0)
+#define TARGET_CPU_CPP_BUILTINS() arm_cpu_cpp_builtins (pfile)
 
 #include "config/arm/arm-opts.h"
 
@@ -252,6 +127,11 @@ extern void (*arm_lang_output_object_attributes_hook)(void);
 #define SUBTARGET_CPP_SPEC      ""
 #endif
 
+/* Tree Target Specification.  */
+#define TARGET_ARM_P(flags)    (!TARGET_THUMB_P (flags))
+#define TARGET_THUMB1_P(flags) (TARGET_THUMB_P (flags) && !arm_arch_thumb2)
+#define TARGET_THUMB2_P(flags) (TARGET_THUMB_P (flags) && arm_arch_thumb2)
+
 /* Run-time Target Specification.  */
 #define TARGET_SOFT_FLOAT		(arm_float_abi == ARM_FLOAT_ABI_SOFT)
 /* Use hardware floating point instructions. */
@@ -311,11 +191,13 @@ extern void (*arm_lang_output_object_attributes_hook)(void);
 #define TARGET_VFP_DOUBLE (TARGET_VFP && arm_fpu_desc->regs != VFP_REG_SINGLE)
 
 /* FPU supports half-precision floating-point with NEON element load/store.  */
-#define TARGET_NEON_FP16 \
-  (TARGET_VFP && arm_fpu_desc->neon && arm_fpu_desc->fp16)
+#define TARGET_NEON_FP16						\
+  (TARGET_VFP								\
+   && ARM_FPU_FSET_HAS (arm_fpu_desc->features, FPU_FL_NEON | FPU_FL_FP16))
 
 /* FPU supports VFP half-precision floating-point.  */
-#define TARGET_FP16 (TARGET_VFP && arm_fpu_desc->fp16)
+#define TARGET_FP16							\
+  (TARGET_VFP && ARM_FPU_FSET_HAS (arm_fpu_desc->features, FPU_FL_FP16))
 
 /* FPU supports fused-multiply-add operations.  */
 #define TARGET_FMA (TARGET_VFP && arm_fpu_desc->rev >= 4)
@@ -324,14 +206,18 @@ extern void (*arm_lang_output_object_attributes_hook)(void);
 #define TARGET_FPU_ARMV8 (TARGET_VFP && arm_fpu_desc->rev >= 8)
 
 /* FPU supports Crypto extensions.  */
-#define TARGET_CRYPTO (TARGET_VFP && arm_fpu_desc->crypto)
+#define TARGET_CRYPTO							\
+  (TARGET_VFP && ARM_FPU_FSET_HAS (arm_fpu_desc->features, FPU_FL_CRYPTO))
+
 
 /* FPU supports Neon instructions.  The setting of this macro gets
    revealed via __ARM_NEON__ so we add extra guards upon TARGET_32BIT
    and TARGET_HARD_FLOAT to ensure that NEON instructions are
    available.  */
-#define TARGET_NEON (TARGET_32BIT && TARGET_HARD_FLOAT \
-		     && TARGET_VFP && arm_fpu_desc->neon)
+#define TARGET_NEON							\
+  (TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP			\
+   && ARM_FPU_FSET_HAS (arm_fpu_desc->features, FPU_FL_NEON))
+
 
 /* Q-bit is present.  */
 #define TARGET_ARM_QBIT \
@@ -367,21 +253,21 @@ extern void (*arm_lang_output_object_attributes_hook)(void);
 #define TARGET_HAVE_MEMORY_BARRIER (TARGET_HAVE_DMB || TARGET_HAVE_DMB_MCR)
 
 /* Nonzero if this chip supports ldrex and strex */
-#define TARGET_HAVE_LDREX	((arm_arch6 && TARGET_ARM) || arm_arch7)
+#define TARGET_HAVE_LDREX        ((arm_arch6 && TARGET_ARM) || arm_arch7)
 
 /* Nonzero if this chip supports ldrex{bh} and strex{bh}.  */
-#define TARGET_HAVE_LDREXBH	((arm_arch6k && TARGET_ARM) || arm_arch7)
+#define TARGET_HAVE_LDREXBH ((arm_arch6k && TARGET_ARM) || arm_arch7)
 
 /* Nonzero if this chip supports ldrexd and strexd.  */
-#define TARGET_HAVE_LDREXD	(((arm_arch6k && TARGET_ARM) || arm_arch7) \
-				 && arm_arch_notm)
+#define TARGET_HAVE_LDREXD (((arm_arch6k && TARGET_ARM) \
+			     || arm_arch7) && arm_arch_notm)
 
 /* Nonzero if this chip supports load-acquire and store-release.  */
 #define TARGET_HAVE_LDACQ	(TARGET_ARM_ARCH >= 8)
 
 /* Nonzero if integer division instructions supported.  */
-#define TARGET_IDIV		((TARGET_ARM && arm_arch_arm_hwdiv) \
-				 || (TARGET_THUMB2 && arm_arch_thumb_hwdiv))
+#define TARGET_IDIV	((TARGET_ARM && arm_arch_arm_hwdiv)	\
+			 || (TARGET_THUMB2 && arm_arch_thumb_hwdiv))
 
 /* Nonzero if disallow volatile memory access in IT block.  */
 #define TARGET_NO_VOLATILE_CE		(arm_arch_no_volatile_ce)
@@ -389,6 +275,12 @@ extern void (*arm_lang_output_object_attributes_hook)(void);
 /* Should NEON be used for 64-bits bitops.  */
 #define TARGET_PREFER_NEON_64BITS (prefer_neon_for_64bits)
 
+/* Should constant I be slplit for OP.  */
+#define DONT_EARLY_SPLIT_CONSTANT(i, op) \
+				((optimize >= 2) \
+				 && can_create_pseudo_p () \
+				 && !const_ok_for_op (i, op))
+
 /* True iff the full BPABI is being used.  If TARGET_BPABI is true,
    then TARGET_AAPCS_BASED must be true -- but the converse does not
    hold.  TARGET_BPABI implies the use of the BPABI runtime library,
@@ -417,6 +309,19 @@ extern void (*arm_lang_output_object_attributes_hook)(void);
   {"mode", "%{!marm:%{!mthumb:-m%(VALUE)}}"}, \
   {"tls", "%{!mtls-dialect=*:-mtls-dialect=%(VALUE)}"},
 
+/* FPU feature sets.  */
+
+typedef unsigned long arm_fpu_feature_set;
+
+/* Test for an FPU feature.  */
+#define ARM_FPU_FSET_HAS(S,F) (((S) & (F)) == (F))
+
+/* FPU Features.  */
+#define FPU_FL_NONE	(0)
+#define FPU_FL_NEON	(1 << 0)	/* NEON instructions.  */
+#define FPU_FL_FP16	(1 << 1)	/* Half-precision.  */
+#define FPU_FL_CRYPTO	(1 << 2)	/* Crypto extensions.  */
+
 /* Which floating point model to use.  */
 enum arm_fp_model
 {
@@ -439,9 +344,7 @@ extern const struct arm_fpu_desc
   enum arm_fp_model model;
   int rev;
   enum vfp_reg_type regs;
-  int neon;
-  int fp16;
-  int crypto;
+  arm_fpu_feature_set features;
 } *arm_fpu_desc;
 
 /* Which floating point hardware to schedule for.  */
@@ -473,7 +376,7 @@ enum base_architecture
   BASE_ARCH_5TEJ = 5,
   BASE_ARCH_6 = 6,
   BASE_ARCH_6J = 6,
-  BASE_ARCH_6ZK = 6,
+  BASE_ARCH_6KZ = 6,
   BASE_ARCH_6K = 6,
   BASE_ARCH_6T2 = 6,
   BASE_ARCH_6M = 6,
@@ -528,12 +431,6 @@ extern int arm_arch8;
 /* Nonzero if this chip can benefit from load scheduling.  */
 extern int arm_ld_sched;
 
-/* Nonzero if generating Thumb code, either Thumb-1 or Thumb-2.  */
-extern int thumb_code;
-
-/* Nonzero if generating Thumb-1 code.  */
-extern int thumb1_code;
-
 /* Nonzero if this chip is a StrongARM.  */
 extern int arm_tune_strongarm;
 
@@ -1104,7 +1001,7 @@ extern int arm_arch_crc;
 /* Modes valid for Neon Q registers.  */
 #define VALID_NEON_QREG_MODE(MODE) \
   ((MODE) == V4SImode || (MODE) == V8HImode || (MODE) == V16QImode \
-   || (MODE) == V4SFmode || (MODE) == V2DImode)
+   || (MODE) == V8HFmode || (MODE) == V4SFmode || (MODE) == V2DImode)
 
 /* Structure modes valid for Neon registers.  */
 #define VALID_NEON_STRUCT_MODE(MODE) \
@@ -1360,46 +1257,6 @@ enum reg_class
      ? GENERAL_REGS : NO_REGS)					\
     : THUMB_SECONDARY_INPUT_RELOAD_CLASS (CLASS, MODE, X)))
 
-/* Try a machine-dependent way of reloading an illegitimate address
-   operand.  If we find one, push the reload and jump to WIN.  This
-   macro is used in only one place: `find_reloads_address' in reload.c.
-
-   For the ARM, we wish to handle large displacements off a base
-   register by splitting the addend across a MOV and the mem insn.
-   This can cut the number of reloads needed.  */
-#define ARM_LEGITIMIZE_RELOAD_ADDRESS(X, MODE, OPNUM, TYPE, IND, WIN)	   \
-  do									   \
-    {									   \
-      if (arm_legitimize_reload_address (&X, MODE, OPNUM, TYPE, IND))	   \
-	goto WIN;							   \
-    }									   \
-  while (0)
-
-/* XXX If an HImode FP+large_offset address is converted to an HImode
-   SP+large_offset address, then reload won't know how to fix it.  It sees
-   only that SP isn't valid for HImode, and so reloads the SP into an index
-   register, but the resulting address is still invalid because the offset
-   is too big.  We fix it here instead by reloading the entire address.  */
-/* We could probably achieve better results by defining PROMOTE_MODE to help
-   cope with the variances between the Thumb's signed and unsigned byte and
-   halfword load instructions.  */
-/* ??? This should be safe for thumb2, but we may be able to do better.  */
-#define THUMB_LEGITIMIZE_RELOAD_ADDRESS(X, MODE, OPNUM, TYPE, IND_L, WIN)     \
-do {									      \
-  rtx new_x = thumb_legitimize_reload_address (&X, MODE, OPNUM, TYPE, IND_L); \
-  if (new_x)								      \
-    {									      \
-      X = new_x;							      \
-      goto WIN;								      \
-    }									      \
-} while (0)
-
-#define LEGITIMIZE_RELOAD_ADDRESS(X, MODE, OPNUM, TYPE, IND_LEVELS, WIN)   \
-  if (TARGET_ARM)							   \
-    ARM_LEGITIMIZE_RELOAD_ADDRESS (X, MODE, OPNUM, TYPE, IND_LEVELS, WIN); \
-  else									   \
-    THUMB_LEGITIMIZE_RELOAD_ADDRESS (X, MODE, OPNUM, TYPE, IND_LEVELS, WIN)
-
 /* Return the maximum number of consecutive registers
    needed to represent mode MODE in a register of class CLASS.
    ARM regs are UNITS_PER_WORD bits.  
@@ -2096,10 +1953,11 @@ enum arm_auto_incmodes
   (current_tune->branch_cost (speed_p, predictable_p))
 
 /* False if short circuit operation is preferred.  */
-#define LOGICAL_OP_NON_SHORT_CIRCUIT				\
-  ((optimize_size)						\
-   ? (TARGET_THUMB ? false : true)				\
-   : (current_tune->logical_op_non_short_circuit[TARGET_ARM]))
+#define LOGICAL_OP_NON_SHORT_CIRCUIT					\
+  ((optimize_size)							\
+   ? (TARGET_THUMB ? false : true)					\
+   : TARGET_THUMB ? static_cast<bool> (current_tune->logical_op_non_short_circuit_thumb) \
+   : static_cast<bool> (current_tune->logical_op_non_short_circuit_arm))
 
 
 /* Position Independent Code.  */
@@ -2135,7 +1993,8 @@ extern int making_const_table;
   c_register_pragma (0, "long_calls", arm_pr_long_calls);		\
   c_register_pragma (0, "no_long_calls", arm_pr_no_long_calls);		\
   c_register_pragma (0, "long_calls_off", arm_pr_long_calls_off);	\
-  arm_lang_object_attributes_init(); \
+  arm_lang_object_attributes_init();					\
+  arm_register_target_pragmas();                                       \
 } while (0)
 
 /* Condition code information.  */
@@ -2222,23 +2081,7 @@ extern int making_const_table;
    ? 1 : 0)
 
 #define ARM_DECLARE_FUNCTION_NAME(STREAM, NAME, DECL) 	\
-  do							\
-    {							\
-      if (TARGET_THUMB) 				\
-        {						\
-          if (is_called_in_ARM_mode (DECL)		\
-	      || (TARGET_THUMB1 && !TARGET_THUMB1_ONLY	\
-		  && cfun->is_thunk))	\
-            fprintf (STREAM, "\t.code 32\n") ;		\
-          else if (TARGET_THUMB1)			\
-           fprintf (STREAM, "\t.code\t16\n\t.thumb_func\n") ;	\
-          else						\
-           fprintf (STREAM, "\t.thumb\n\t.thumb_func\n") ;	\
-        }						\
-      if (TARGET_POKE_FUNCTION_NAME)			\
-        arm_poke_function_name (STREAM, (const char *) NAME);	\
-    }							\
-  while (0)
+  arm_declare_function_name ((STREAM), (NAME), (DECL));
 
 /* For aliases of functions we use .thumb_set instead.  */
 #define ASM_OUTPUT_DEF_FROM_DECLS(FILE, DECL1, DECL2)		\
@@ -2413,4 +2256,8 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);
 
 #define DRIVER_SELF_SPECS MCPU_MTUNE_NATIVE_SPECS
 #define TARGET_SUPPORTS_WIDE_INT 1
+
+/* For switching between functions with different target attributes.  */
+#define SWITCHABLE_TARGET 1
+
 #endif /* ! GCC_ARM_H */
--- a/src/gcc/config/arm/arm.md
+++ b/src/gcc/config/arm/arm.md
@@ -69,13 +69,17 @@
 ; IS_THUMB is set to 'yes' when we are generating Thumb code, and 'no' when
 ; generating ARM code.  This is used to control the length of some insn
 ; patterns that share the same RTL in both ARM and Thumb code.
-(define_attr "is_thumb" "no,yes" (const (symbol_ref "thumb_code")))
+(define_attr "is_thumb" "yes,no"
+  (const (if_then_else (symbol_ref "TARGET_THUMB")
+		       (const_string "yes") (const_string "no"))))
 
 ; IS_ARCH6 is set to 'yes' when we are generating code form ARMv6.
 (define_attr "is_arch6" "no,yes" (const (symbol_ref "arm_arch6")))
 
 ; IS_THUMB1 is set to 'yes' iff we are generating Thumb-1 code.
-(define_attr "is_thumb1" "no,yes" (const (symbol_ref "thumb1_code")))
+(define_attr "is_thumb1" "yes,no"
+  (const (if_then_else (symbol_ref "TARGET_THUMB1")
+		       (const_string "yes") (const_string "no"))))
 
 ; We use this attribute to disable alternatives that can produce 32-bit
 ; instructions inside an IT-block in Thumb2 state.  ARMv8 deprecates IT blocks
@@ -1164,10 +1168,16 @@
     {
       if (TARGET_32BIT)
         {
-          arm_split_constant (MINUS, SImode, NULL_RTX,
-	                      INTVAL (operands[1]), operands[0],
-	  		      operands[2], optimize && can_create_pseudo_p ());
-          DONE;
+	  if (DONT_EARLY_SPLIT_CONSTANT (INTVAL (operands[1]), MINUS))
+	    operands[1] = force_reg (SImode, operands[1]);
+	  else
+	    {
+	      arm_split_constant (MINUS, SImode, NULL_RTX,
+				  INTVAL (operands[1]), operands[0],
+				  operands[2],
+				  optimize && can_create_pseudo_p ());
+	      DONE;
+	    }
 	}
       else /* TARGET_THUMB1 */
         operands[1] = force_reg (SImode, operands[1]);
@@ -1177,9 +1187,9 @@
 
 ; ??? Check Thumb-2 split length
 (define_insn_and_split "*arm_subsi3_insn"
-  [(set (match_operand:SI           0 "s_register_operand" "=l,l ,l ,l ,r ,r,r,rk,r")
-	(minus:SI (match_operand:SI 1 "reg_or_int_operand" "l ,0 ,l ,Pz,rI,r,r,k ,?n")
-		  (match_operand:SI 2 "reg_or_int_operand" "l ,Py,Pd,l ,r ,I,r,r ,r")))]
+  [(set (match_operand:SI           0 "s_register_operand" "=l,l ,l ,l ,r,r,r,rk,r")
+	(minus:SI (match_operand:SI 1 "reg_or_int_operand" "l ,0 ,l ,Pz,I,r,r,k ,?n")
+		  (match_operand:SI 2 "reg_or_int_operand" "l ,Py,Pd,l ,r,I,r,r ,r")))]
   "TARGET_32BIT"
   "@
    sub%?\\t%0, %1, %2
@@ -2078,14 +2088,19 @@
 	      operands[1] = convert_to_mode (QImode, operands[1], 1);
 	      emit_insn (gen_thumb2_zero_extendqisi2_v6 (operands[0],
 							 operands[1]));
+	      DONE;
 	    }
+	  else if (DONT_EARLY_SPLIT_CONSTANT (INTVAL (operands[2]), AND))
+	    operands[2] = force_reg (SImode, operands[2]);
 	  else
-	    arm_split_constant (AND, SImode, NULL_RTX,
-				INTVAL (operands[2]), operands[0],
-				operands[1],
-				optimize && can_create_pseudo_p ());
+	    {
+	      arm_split_constant (AND, SImode, NULL_RTX,
+				  INTVAL (operands[2]), operands[0],
+				  operands[1],
+				  optimize && can_create_pseudo_p ());
 
-          DONE;
+	      DONE;
+	    }
         }
     }
   else /* TARGET_THUMB1 */
@@ -2768,6 +2783,55 @@
 		      (const_string "logic_shift_reg")))]
 )
 
+;; Shifted bics pattern used to set up CC status register and not reusing
+;; bics output.  Pattern restricts Thumb2 shift operand as bics for Thumb2
+;; does not support shift by register.
+(define_insn "andsi_not_shiftsi_si_scc_no_reuse"
+  [(set (reg:CC_NOOV CC_REGNUM)
+	(compare:CC_NOOV
+		(and:SI (not:SI (match_operator:SI 0 "shift_operator"
+			[(match_operand:SI 1 "s_register_operand" "r")
+			 (match_operand:SI 2 "arm_rhs_operand" "rM")]))
+			(match_operand:SI 3 "s_register_operand" "r"))
+		(const_int 0)))
+   (clobber (match_scratch:SI 4 "=r"))]
+  "TARGET_ARM || (TARGET_THUMB2 && CONST_INT_P (operands[2]))"
+  "bic%.%?\\t%4, %3, %1%S0"
+  [(set_attr "predicable" "yes")
+   (set_attr "predicable_short_it" "no")
+   (set_attr "conds" "set")
+   (set_attr "shift" "1")
+   (set (attr "type") (if_then_else (match_operand 2 "const_int_operand" "")
+		      (const_string "logic_shift_imm")
+		      (const_string "logic_shift_reg")))]
+)
+
+;; Same as andsi_not_shiftsi_si_scc_no_reuse, but the bics result is also
+;; getting reused later.
+(define_insn "andsi_not_shiftsi_si_scc"
+  [(parallel [(set (reg:CC_NOOV CC_REGNUM)
+	(compare:CC_NOOV
+		(and:SI (not:SI (match_operator:SI 0 "shift_operator"
+			[(match_operand:SI 1 "s_register_operand" "r")
+			 (match_operand:SI 2 "arm_rhs_operand" "rM")]))
+			(match_operand:SI 3 "s_register_operand" "r"))
+		(const_int 0)))
+	(set (match_operand:SI 4 "s_register_operand" "=r")
+	     (and:SI (not:SI (match_op_dup 0
+		     [(match_dup 1)
+		      (match_dup 2)]))
+		     (match_dup 3)))])]
+  "TARGET_ARM || (TARGET_THUMB2 && CONST_INT_P (operands[2]))"
+  "bic%.%?\\t%4, %3, %1%S0"
+  [(set_attr "predicable" "yes")
+   (set_attr "predicable_short_it" "no")
+   (set_attr "conds" "set")
+   (set_attr "shift" "1")
+   (set (attr "type") (if_then_else (match_operand 2 "const_int_operand" "")
+		      (const_string "logic_shift_imm")
+		      (const_string "logic_shift_reg")))]
+)
+
 (define_insn "*andsi_notsi_si_compare0"
   [(set (reg:CC_NOOV CC_REGNUM)
 	(compare:CC_NOOV
@@ -2884,10 +2948,16 @@
     {
       if (TARGET_32BIT)
         {
-          arm_split_constant (IOR, SImode, NULL_RTX,
-	                      INTVAL (operands[2]), operands[0], operands[1],
-			      optimize && can_create_pseudo_p ());
-          DONE;
+	  if (DONT_EARLY_SPLIT_CONSTANT (INTVAL (operands[2]), IOR))
+	    operands[2] = force_reg (SImode, operands[2]);
+	  else
+	    {
+	      arm_split_constant (IOR, SImode, NULL_RTX,
+				  INTVAL (operands[2]), operands[0],
+				  operands[1],
+				  optimize && can_create_pseudo_p ());
+	      DONE;
+	    }
 	}
       else /* TARGET_THUMB1 */
         {
@@ -3054,10 +3124,16 @@
     {
       if (TARGET_32BIT)
         {
-          arm_split_constant (XOR, SImode, NULL_RTX,
-	                      INTVAL (operands[2]), operands[0], operands[1],
-			      optimize && can_create_pseudo_p ());
-          DONE;
+	  if (DONT_EARLY_SPLIT_CONSTANT (INTVAL (operands[2]), XOR))
+	    operands[2] = force_reg (SImode, operands[2]);
+	  else
+	    {
+	      arm_split_constant (XOR, SImode, NULL_RTX,
+				  INTVAL (operands[2]), operands[0],
+				  operands[1],
+				  optimize && can_create_pseudo_p ());
+	      DONE;
+	    }
 	}
       else /* TARGET_THUMB1 */
         {
@@ -5076,7 +5152,7 @@
 
 (define_split
   [(set (match_operand:SI 0 "s_register_operand" "")
-	(ior_xor:SI (and:SI (ashift:SI
+	(IOR_XOR:SI (and:SI (ashift:SI
 			     (match_operand:SI 1 "s_register_operand" "")
 			     (match_operand:SI 2 "const_int_operand" ""))
 			    (match_operand:SI 3 "const_int_operand" ""))
@@ -5088,7 +5164,7 @@
        == (GET_MODE_MASK (GET_MODE (operands[5]))
            & (GET_MODE_MASK (GET_MODE (operands[5]))
 	      << (INTVAL (operands[2])))))"
-  [(set (match_dup 0) (ior_xor:SI (ashift:SI (match_dup 1) (match_dup 2))
+  [(set (match_dup 0) (IOR_XOR:SI (ashift:SI (match_dup 1) (match_dup 2))
 				  (match_dup 4)))
    (set (match_dup 0) (zero_extend:SI (match_dup 5)))]
   "operands[5] = gen_lowpart (GET_MODE (operands[5]), operands[0]);"
@@ -5590,10 +5666,18 @@
           && !(const_ok_for_arm (INTVAL (operands[1]))
                || const_ok_for_arm (~INTVAL (operands[1]))))
         {
-           arm_split_constant (SET, SImode, NULL_RTX,
-	                       INTVAL (operands[1]), operands[0], NULL_RTX,
-			       optimize && can_create_pseudo_p ());
-          DONE;
+	   if (DONT_EARLY_SPLIT_CONSTANT (INTVAL (operands[1]), SET))
+	     {
+		emit_insn (gen_rtx_SET (SImode, operands[0], operands[1]));
+		DONE;
+	     }
+	  else
+	     {
+		arm_split_constant (SET, SImode, NULL_RTX,
+	                            INTVAL (operands[1]), operands[0], NULL_RTX,
+			            optimize && can_create_pseudo_p ());
+		DONE;
+	     }
         }
     }
   else /* TARGET_THUMB1...  */
@@ -5667,7 +5751,7 @@
   [(set_attr "predicable" "yes")
    (set_attr "predicable_short_it" "no")
    (set_attr "length" "4")
-   (set_attr "type" "mov_imm")]
+   (set_attr "type" "alu_sreg")]
 )
 
 (define_insn "*arm_movsi_insn"
@@ -6713,7 +6797,7 @@
 
   /* Support only fixed point registers.  */
   if (!CONST_INT_P (operands[2])
-      || INTVAL (operands[2]) > 14
+      || INTVAL (operands[2]) > MAX_LDM_STM_OPS
       || INTVAL (operands[2]) < 2
       || !MEM_P (operands[1])
       || !REG_P (operands[0])
@@ -6738,7 +6822,7 @@
 
   /* Support only fixed point registers.  */
   if (!CONST_INT_P (operands[2])
-      || INTVAL (operands[2]) > 14
+      || INTVAL (operands[2]) > MAX_LDM_STM_OPS
       || INTVAL (operands[2]) < 2
       || !REG_P (operands[1])
       || !MEM_P (operands[0])
@@ -6923,7 +7007,7 @@
   [(set_attr "conds" "set")
    (set_attr "shift" "1")
    (set_attr "arch" "32,a,a")
-   (set_attr "type" "alus_shift_imm,alu_shift_reg,alus_shift_imm")])
+   (set_attr "type" "alus_shift_imm,alus_shift_reg,alus_shift_imm")])
 
 (define_insn "*cmpsi_shiftsi_swp"
   [(set (reg:CC_SWP CC_REGNUM)
@@ -6936,7 +7020,7 @@
   [(set_attr "conds" "set")
    (set_attr "shift" "1")
    (set_attr "arch" "32,a,a")
-   (set_attr "type" "alus_shift_imm,alu_shift_reg,alus_shift_imm")])
+   (set_attr "type" "alus_shift_imm,alus_shift_reg,alus_shift_imm")])
 
 (define_insn "*arm_cmpsi_negshiftsi_si"
   [(set (reg:CC_Z CC_REGNUM)
@@ -7529,10 +7613,10 @@
                                         (const_string "mov_imm")
                                         (const_string "mov_reg"))
                           (const_string "mvn_imm")
-                          (const_string "mov_reg")
-                          (const_string "mov_reg")
-                          (const_string "mov_reg")
-                          (const_string "mov_reg")])]
+                          (const_string "multiple")
+                          (const_string "multiple")
+                          (const_string "multiple")
+                          (const_string "multiple")])]
 )
 
 (define_insn "*movsfcc_soft_insn"
@@ -7755,6 +7839,13 @@
    && !arm_is_long_call_p (SYMBOL_REF_DECL (operands[0]))"
   "*
   {
+   rtx op = operands[0];
+
+   /* Switch mode now when possible.  */
+   if (SYMBOL_REF_DECL (op) && !TREE_PUBLIC (SYMBOL_REF_DECL (op))
+        && arm_arch5 && arm_change_mode_p (SYMBOL_REF_DECL (op)))
+      return NEED_PLT_RELOC ? \"blx%?\\t%a0(PLT)\" : \"blx%?\\t(%a0)\";
+
     return NEED_PLT_RELOC ? \"bl%?\\t%a0(PLT)\" : \"bl%?\\t%a0\";
   }"
   [(set_attr "type" "call")]
@@ -7772,6 +7863,13 @@
    && !arm_is_long_call_p (SYMBOL_REF_DECL (operands[1]))"
   "*
   {
+   rtx op = operands[1];
+
+   /* Switch mode now when possible.  */
+   if (SYMBOL_REF_DECL (op) && !TREE_PUBLIC (SYMBOL_REF_DECL (op))
+        && arm_arch5 && arm_change_mode_p (SYMBOL_REF_DECL (op)))
+      return NEED_PLT_RELOC ? \"blx%?\\t%a1(PLT)\" : \"blx%?\\t(%a1)\";
+
     return NEED_PLT_RELOC ? \"bl%?\\t%a1(PLT)\" : \"bl%?\\t%a1\";
   }"
   [(set_attr "type" "call")]
@@ -7885,7 +7983,7 @@
 )
 
 (define_expand "<return_str>return"
-  [(returns)]
+  [(RETURNS)]
   "(TARGET_ARM || (TARGET_THUMB2
                    && ARM_FUNC_TYPE (arm_current_func_type ()) == ARM_FT_NORMAL
                    && !IS_STACKALIGN (arm_current_func_type ())))
@@ -7923,7 +8021,7 @@
   [(set (pc)
         (if_then_else (match_operator 0 "arm_comparison_operator"
 		       [(match_operand 1 "cc_register" "") (const_int 0)])
-                      (returns)
+                      (RETURNS)
                       (pc)))]
   "TARGET_ARM  <return_cond_true>"
   "*
@@ -7946,7 +8044,7 @@
         (if_then_else (match_operator 0 "arm_comparison_operator"
 		       [(match_operand 1 "cc_register" "") (const_int 0)])
                       (pc)
-		      (returns)))]
+		      (RETURNS)))]
   "TARGET_ARM <return_cond_true>"
   "*
   {
@@ -8280,7 +8378,7 @@
 
 (define_insn "*<arith_shift_insn>_multsi"
   [(set (match_operand:SI 0 "s_register_operand" "=r,r")
-	(shiftable_ops:SI
+	(SHIFTABLE_OPS:SI
 	 (mult:SI (match_operand:SI 2 "s_register_operand" "r,r")
 		  (match_operand:SI 3 "power_of_two_operand" ""))
 	 (match_operand:SI 1 "s_register_operand" "rk,<t2_binop0>")))]
@@ -8294,7 +8392,7 @@
 
 (define_insn "*<arith_shift_insn>_shiftsi"
   [(set (match_operand:SI 0 "s_register_operand" "=r,r,r")
-	(shiftable_ops:SI
+	(SHIFTABLE_OPS:SI
 	 (match_operator:SI 2 "shift_nomul_operator"
 	  [(match_operand:SI 3 "s_register_operand" "r,r,r")
 	   (match_operand:SI 4 "shift_amount_operand" "M,M,r")])
@@ -8690,7 +8788,14 @@
     return \"\";
   "
   [(set_attr "conds" "use")
-   (set_attr "type" "mov_reg,mov_reg,multiple")
+   (set_attr_alternative "type"
+                         [(if_then_else (match_operand 2 "const_int_operand" "")
+                                        (const_string "mov_imm")
+                                        (const_string "mov_reg"))
+                          (if_then_else (match_operand 1 "const_int_operand" "")
+                                        (const_string "mov_imm")
+                                        (const_string "mov_reg"))
+                          (const_string "multiple")])
    (set_attr "length" "4,4,8")]
 )
 
@@ -9486,8 +9591,8 @@
                                         (const_string "alu_imm" )
                                         (const_string "alu_sreg"))
                           (const_string "alu_imm")
-                          (const_string "alu_sreg")
-                          (const_string "alu_sreg")])]
+                          (const_string "multiple")
+                          (const_string "multiple")])]
 )
 
 (define_insn "*ifcompare_move_plus"
@@ -9524,7 +9629,13 @@
    sub%D4\\t%0, %2, #%n3\;mov%d4\\t%0, %1"
   [(set_attr "conds" "use")
    (set_attr "length" "4,4,8,8")
-   (set_attr "type" "alu_sreg,alu_imm,multiple,multiple")]
+   (set_attr_alternative "type"
+                         [(if_then_else (match_operand 3 "const_int_operand" "")
+                                        (const_string "alu_imm" )
+                                        (const_string "alu_sreg"))
+                          (const_string "alu_imm")
+                          (const_string "multiple")
+                          (const_string "multiple")])]
 )
 
 (define_insn "*ifcompare_arith_arith"
@@ -9619,7 +9730,11 @@
    %I5%d4\\t%0, %2, %3\;mov%D4\\t%0, %1"
   [(set_attr "conds" "use")
    (set_attr "length" "4,8")
-   (set_attr "type" "alu_shift_reg,multiple")]
+   (set_attr_alternative "type"
+                         [(if_then_else (match_operand 3 "const_int_operand" "")
+                                        (const_string "alu_shift_imm" )
+                                        (const_string "alu_shift_reg"))
+                          (const_string "multiple")])]
 )
 
 (define_insn "*ifcompare_move_arith"
@@ -9680,7 +9795,11 @@
    %I5%D4\\t%0, %2, %3\;mov%d4\\t%0, %1"
   [(set_attr "conds" "use")
    (set_attr "length" "4,8")
-   (set_attr "type" "alu_shift_reg,multiple")]
+   (set_attr_alternative "type"
+                         [(if_then_else (match_operand 3 "const_int_operand" "")
+                                        (const_string "alu_shift_imm" )
+                                        (const_string "alu_shift_reg"))
+                          (const_string "multiple")])]
 )
 
 (define_insn "*ifcompare_move_not"
@@ -9787,7 +9906,12 @@
   [(set_attr "conds" "use")
    (set_attr "shift" "2")
    (set_attr "length" "4,8,8")
-   (set_attr "type" "mov_shift_reg,multiple,multiple")]
+   (set_attr_alternative "type"
+                         [(if_then_else (match_operand 3 "const_int_operand" "")
+                                        (const_string "mov_shift" )
+                                        (const_string "mov_shift_reg"))
+                          (const_string "multiple")
+                          (const_string "multiple")])]
 )
 
 (define_insn "*ifcompare_move_shift"
@@ -9825,7 +9949,12 @@
   [(set_attr "conds" "use")
    (set_attr "shift" "2")
    (set_attr "length" "4,8,8")
-   (set_attr "type" "mov_shift_reg,multiple,multiple")]
+   (set_attr_alternative "type"
+                         [(if_then_else (match_operand 3 "const_int_operand" "")
+                                        (const_string "mov_shift" )
+                                        (const_string "mov_shift_reg"))
+                          (const_string "multiple")
+                          (const_string "multiple")])]
 )
 
 (define_insn "*ifcompare_shift_shift"
@@ -10906,7 +11035,7 @@
  [(set_attr "predicable" "yes")
   (set_attr "predicable_short_it" "no")
   (set_attr "length" "4")
-  (set_attr "type" "mov_imm")]
+  (set_attr "type" "alu_sreg")]
 )
 
 (define_insn "*arm_rev"
--- a/src/gcc/config/arm/arm.opt
+++ b/src/gcc/config/arm/arm.opt
@@ -122,6 +122,10 @@ Enum(float_abi_type) String(softfp) Value(ARM_FLOAT_ABI_SOFTFP)
 EnumValue
 Enum(float_abi_type) String(hard) Value(ARM_FLOAT_ABI_HARD)
 
+mflip-thumb
+Target Report Var(TARGET_FLIP_THUMB) Undocumented
+Switch ARM/Thumb modes on alternating functions for compiler testing
+
 mfp16-format=
 Target RejectNegative Joined Enum(arm_fp16_format_type) Var(arm_fp16_format) Init(ARM_FP16_FORMAT_NONE)
 Specify the __fp16 floating-point format
@@ -182,7 +186,7 @@ Target RejectNegative Joined UInteger Var(arm_structure_size_boundary) Init(DEFA
 Specify the minimum bit alignment of structures
 
 mthumb
-Target Report RejectNegative Mask(THUMB)
+Target Report RejectNegative Mask(THUMB) Save
 Generate code for Thumb state
 
 mthumb-interwork
@@ -246,7 +250,7 @@ Target Report Var(target_word_relocations) Init(TARGET_DEFAULT_WORD_RELOCATIONS)
 Only generate absolute relocations on word sized values.
 
 mrestrict-it
-Target Report Var(arm_restrict_it) Init(2)
+Target Report Var(arm_restrict_it) Init(2) Save
 Generate IT blocks appropriate for ARMv8.
 
 mold-rtx-costs
@@ -275,5 +279,5 @@ Target Report Var(target_slow_flash_data) Init(0)
 Assume loading data from flash is slower than fetching instructions.
 
 masm-syntax-unified
-Target Report Var(inline_asm_unified) Init(0)
+Target Report Var(inline_asm_unified) Init(0) Save
 Assume unified syntax for Thumb inline assembly code.
--- a/src/gcc/config/arm/arm_neon.h
+++ b/src/gcc/config/arm/arm_neon.h
@@ -41,7 +41,10 @@ typedef __simd64_int8_t int8x8_t;
 typedef __simd64_int16_t int16x4_t;
 typedef __simd64_int32_t int32x2_t;
 typedef __builtin_neon_di int64x1_t;
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+typedef __fp16 float16_t;
 typedef __simd64_float16_t float16x4_t;
+#endif
 typedef __simd64_float32_t float32x2_t;
 typedef __simd64_poly8_t poly8x8_t;
 typedef __simd64_poly16_t poly16x4_t;
@@ -57,6 +60,9 @@ typedef __simd128_int8_t int8x16_t;
 typedef __simd128_int16_t int16x8_t;
 typedef __simd128_int32_t int32x4_t;
 typedef __simd128_int64_t int64x2_t;
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+typedef __simd128_float16_t float16x8_t;
+#endif
 typedef __simd128_float32_t float32x4_t;
 typedef __simd128_poly8_t poly8x16_t;
 typedef __simd128_poly16_t poly16x8_t;
@@ -160,6 +166,20 @@ typedef struct uint64x2x2_t
   uint64x2_t val[2];
 } uint64x2x2_t;
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+typedef struct float16x4x2_t
+{
+  float16x4_t val[2];
+} float16x4x2_t;
+#endif
+
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+typedef struct float16x8x2_t
+{
+  float16x8_t val[2];
+} float16x8x2_t;
+#endif
+
 typedef struct float32x2x2_t
 {
   float32x2_t val[2];
@@ -286,6 +306,20 @@ typedef struct uint64x2x3_t
   uint64x2_t val[3];
 } uint64x2x3_t;
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+typedef struct float16x4x3_t
+{
+  float16x4_t val[3];
+} float16x4x3_t;
+#endif
+
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+typedef struct float16x8x3_t
+{
+  float16x8_t val[3];
+} float16x8x3_t;
+#endif
+
 typedef struct float32x2x3_t
 {
   float32x2_t val[3];
@@ -412,6 +446,20 @@ typedef struct uint64x2x4_t
   uint64x2_t val[4];
 } uint64x2x4_t;
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+typedef struct float16x4x4_t
+{
+  float16x4_t val[4];
+} float16x4x4_t;
+#endif
+
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+typedef struct float16x8x4_t
+{
+  float16x8_t val[4];
+} float16x8x4_t;
+#endif
+
 typedef struct float32x2x4_t
 {
   float32x2_t val[4];
@@ -5201,6 +5249,21 @@ vget_lane_s32 (int32x2_t __a, const int __b)
   return (int32_t)__builtin_neon_vget_lanev2si (__a, __b);
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+/* Functions cannot accept or return __FP16 types.  Even if the function
+   were marked always-inline so there were no call sites, the declaration
+   would nonetheless raise an error.  Hence, we must use a macro instead.  */
+
+#define vget_lane_f16(__v, __idx)		\
+  __extension__					\
+    ({						\
+      float16x4_t __vec = (__v);		\
+      __builtin_arm_lane_check (4, __idx);	\
+      float16_t __res = __vec[__idx];		\
+      __res;					\
+    })
+#endif
+
 __extension__ static __inline float32_t __attribute__ ((__always_inline__))
 vget_lane_f32 (float32x2_t __a, const int __b)
 {
@@ -5267,6 +5330,17 @@ vgetq_lane_s32 (int32x4_t __a, const int __b)
   return (int32_t)__builtin_neon_vget_lanev4si (__a, __b);
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+#define vgetq_lane_f16(__v, __idx)		\
+  __extension__					\
+    ({						\
+      float16x8_t __vec = (__v);		\
+      __builtin_arm_lane_check (8, __idx);	\
+      float16_t __res = __vec[__idx];		\
+      __res;					\
+    })
+#endif
+
 __extension__ static __inline float32_t __attribute__ ((__always_inline__))
 vgetq_lane_f32 (float32x4_t __a, const int __b)
 {
@@ -5333,6 +5407,18 @@ vset_lane_s32 (int32_t __a, int32x2_t __b, const int __c)
   return (int32x2_t)__builtin_neon_vset_lanev2si ((__builtin_neon_si) __a, __b, __c);
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+#define vset_lane_f16(__e, __v, __idx)		\
+  __extension__					\
+    ({						\
+      float16_t __elem = (__e);			\
+      float16x4_t __vec = (__v);		\
+      __builtin_arm_lane_check (4, __idx);	\
+      __vec[__idx] = __elem;			\
+      __vec;					\
+    })
+#endif
+
 __extension__ static __inline float32x2_t __attribute__ ((__always_inline__))
 vset_lane_f32 (float32_t __a, float32x2_t __b, const int __c)
 {
@@ -5399,6 +5485,18 @@ vsetq_lane_s32 (int32_t __a, int32x4_t __b, const int __c)
   return (int32x4_t)__builtin_neon_vset_lanev4si ((__builtin_neon_si) __a, __b, __c);
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+#define vsetq_lane_f16(__e, __v, __idx)		\
+  __extension__					\
+    ({						\
+      float16_t __elem = (__e);			\
+      float16x8_t __vec = (__v);		\
+      __builtin_arm_lane_check (8, __idx);	\
+      __vec[__idx] = __elem;			\
+      __vec;					\
+    })
+#endif
+
 __extension__ static __inline float32x4_t __attribute__ ((__always_inline__))
 vsetq_lane_f32 (float32_t __a, float32x4_t __b, const int __c)
 {
@@ -5479,6 +5577,14 @@ vcreate_s64 (uint64_t __a)
   return (int64x1_t)__builtin_neon_vcreatedi ((__builtin_neon_di) __a);
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline float16x4_t __attribute__ ((__always_inline__))
+vcreate_f16 (uint64_t __a)
+{
+  return (float16x4_t) __a;
+}
+#endif
+
 __extension__ static __inline float32x2_t __attribute__ ((__always_inline__))
 vcreate_f32 (uint64_t __a)
 {
@@ -5981,6 +6087,14 @@ vcombine_s64 (int64x1_t __a, int64x1_t __b)
   return (int64x2_t)__builtin_neon_vcombinedi (__a, __b);
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline float16x8_t __attribute__ ((__always_inline__))
+vcombine_f16 (float16x4_t __a, float16x4_t __b)
+{
+  return __builtin_neon_vcombinev4hf (__a, __b);
+}
+#endif
+
 __extension__ static __inline float32x4_t __attribute__ ((__always_inline__))
 vcombine_f32 (float32x2_t __a, float32x2_t __b)
 {
@@ -6055,6 +6169,14 @@ vget_high_s64 (int64x2_t __a)
   return (int64x1_t)__builtin_neon_vget_highv2di (__a);
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline float16x4_t __attribute__ ((__always_inline__))
+vget_high_f16 (float16x8_t __a)
+{
+  return __builtin_neon_vget_highv8hf (__a);
+}
+#endif
+
 __extension__ static __inline float32x2_t __attribute__ ((__always_inline__))
 vget_high_f32 (float32x4_t __a)
 {
@@ -6115,6 +6237,14 @@ vget_low_s32 (int32x4_t __a)
   return (int32x2_t)__builtin_neon_vget_lowv4si (__a);
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline float16x4_t __attribute__ ((__always_inline__))
+vget_low_f16 (float16x8_t __a)
+{
+  return __builtin_neon_vget_lowv8hf (__a);
+}
+#endif
+
 __extension__ static __inline float32x2_t __attribute__ ((__always_inline__))
 vget_low_f32 (float32x4_t __a)
 {
@@ -6220,21 +6350,25 @@ vcvtq_u32_f32 (float32x4_t __a)
 }
 
 #if ((__ARM_FP & 0x2) != 0)
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
 __extension__ static __inline float16x4_t __attribute__ ((__always_inline__))
 vcvt_f16_f32 (float32x4_t __a)
 {
   return (float16x4_t)__builtin_neon_vcvtv4hfv4sf (__a);
 }
-
 #endif
+#endif
+
 #if ((__ARM_FP & 0x2) != 0)
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
 __extension__ static __inline float32x4_t __attribute__ ((__always_inline__))
 vcvt_f32_f16 (float16x4_t __a)
 {
   return (float32x4_t)__builtin_neon_vcvtv4sfv4hf (__a);
 }
-
 #endif
+#endif
+
 __extension__ static __inline int32x2_t __attribute__ ((__always_inline__))
 vcvt_n_s32_f32 (float32x2_t __a, const int __b)
 {
@@ -8662,6 +8796,14 @@ vld1_s64 (const int64_t * __a)
   return (int64x1_t)__builtin_neon_vld1di ((const __builtin_neon_di *) __a);
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline float16x4_t __attribute__ ((__always_inline__))
+vld1_f16 (const float16_t * __a)
+{
+  return __builtin_neon_vld1v4hf (__a);
+}
+#endif
+
 __extension__ static __inline float32x2_t __attribute__ ((__always_inline__))
 vld1_f32 (const float32_t * __a)
 {
@@ -8736,6 +8878,14 @@ vld1q_s64 (const int64_t * __a)
   return (int64x2_t)__builtin_neon_vld1v2di ((const __builtin_neon_di *) __a);
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline float16x8_t __attribute__ ((__always_inline__))
+vld1q_f16 (const float16_t * __a)
+{
+  return __builtin_neon_vld1v8hf (__a);
+}
+#endif
+
 __extension__ static __inline float32x4_t __attribute__ ((__always_inline__))
 vld1q_f32 (const float32_t * __a)
 {
@@ -8796,6 +8946,14 @@ vld1_lane_s32 (const int32_t * __a, int32x2_t __b, const int __c)
   return (int32x2_t)__builtin_neon_vld1_lanev2si ((const __builtin_neon_si *) __a, __b, __c);
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline float16x4_t __attribute__ ((__always_inline__))
+vld1_lane_f16 (const float16_t * __a, float16x4_t __b, const int __c)
+{
+  return vset_lane_f16 (*__a, __b, __c);
+}
+#endif
+
 __extension__ static __inline float32x2_t __attribute__ ((__always_inline__))
 vld1_lane_f32 (const float32_t * __a, float32x2_t __b, const int __c)
 {
@@ -8870,6 +9028,14 @@ vld1q_lane_s32 (const int32_t * __a, int32x4_t __b, const int __c)
   return (int32x4_t)__builtin_neon_vld1_lanev4si ((const __builtin_neon_si *) __a, __b, __c);
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline float16x8_t __attribute__ ((__always_inline__))
+vld1q_lane_f16 (const float16_t * __a, float16x8_t __b, const int __c)
+{
+  return vsetq_lane_f16 (*__a, __b, __c);
+}
+#endif
+
 __extension__ static __inline float32x4_t __attribute__ ((__always_inline__))
 vld1q_lane_f32 (const float32_t * __a, float32x4_t __b, const int __c)
 {
@@ -8944,6 +9110,15 @@ vld1_dup_s32 (const int32_t * __a)
   return (int32x2_t)__builtin_neon_vld1_dupv2si ((const __builtin_neon_si *) __a);
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline float16x4_t __attribute__ ((__always_inline__))
+vld1_dup_f16 (const float16_t * __a)
+{
+  float16_t __f = *__a;
+  return (float16x4_t) { __f, __f, __f, __f };
+}
+#endif
+
 __extension__ static __inline float32x2_t __attribute__ ((__always_inline__))
 vld1_dup_f32 (const float32_t * __a)
 {
@@ -9018,6 +9193,15 @@ vld1q_dup_s32 (const int32_t * __a)
   return (int32x4_t)__builtin_neon_vld1_dupv4si ((const __builtin_neon_si *) __a);
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline float16x8_t __attribute__ ((__always_inline__))
+vld1q_dup_f16 (const float16_t * __a)
+{
+  float16_t __f = *__a;
+  return (float16x8_t) { __f, __f, __f, __f, __f, __f, __f, __f };
+}
+#endif
+
 __extension__ static __inline float32x4_t __attribute__ ((__always_inline__))
 vld1q_dup_f32 (const float32_t * __a)
 {
@@ -9106,6 +9290,14 @@ vst1_s64 (int64_t * __a, int64x1_t __b)
   __builtin_neon_vst1di ((__builtin_neon_di *) __a, __b);
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline void __attribute__ ((__always_inline__))
+vst1_f16 (float16_t * __a, float16x4_t __b)
+{
+  __builtin_neon_vst1v4hf (__a, __b);
+}
+#endif
+
 __extension__ static __inline void __attribute__ ((__always_inline__))
 vst1_f32 (float32_t * __a, float32x2_t __b)
 {
@@ -9180,6 +9372,14 @@ vst1q_s64 (int64_t * __a, int64x2_t __b)
   __builtin_neon_vst1v2di ((__builtin_neon_di *) __a, __b);
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline void __attribute__ ((__always_inline__))
+vst1q_f16 (float16_t * __a, float16x8_t __b)
+{
+  __builtin_neon_vst1v8hf (__a, __b);
+}
+#endif
+
 __extension__ static __inline void __attribute__ ((__always_inline__))
 vst1q_f32 (float32_t * __a, float32x4_t __b)
 {
@@ -9240,6 +9440,14 @@ vst1_lane_s32 (int32_t * __a, int32x2_t __b, const int __c)
   __builtin_neon_vst1_lanev2si ((__builtin_neon_si *) __a, __b, __c);
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline void __attribute__ ((__always_inline__))
+vst1_lane_f16 (float16_t * __a, float16x4_t __b, const int __c)
+{
+  __builtin_neon_vst1_lanev4hf (__a, __b, __c);
+}
+#endif
+
 __extension__ static __inline void __attribute__ ((__always_inline__))
 vst1_lane_f32 (float32_t * __a, float32x2_t __b, const int __c)
 {
@@ -9314,6 +9522,14 @@ vst1q_lane_s32 (int32_t * __a, int32x4_t __b, const int __c)
   __builtin_neon_vst1_lanev4si ((__builtin_neon_si *) __a, __b, __c);
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline void __attribute__ ((__always_inline__))
+vst1q_lane_f16 (float16_t * __a, float16x8_t __b, const int __c)
+{
+  __builtin_neon_vst1_lanev8hf (__a, __b, __c);
+}
+#endif
+
 __extension__ static __inline void __attribute__ ((__always_inline__))
 vst1q_lane_f32 (float32_t * __a, float32x4_t __b, const int __c)
 {
@@ -9394,6 +9610,16 @@ vld2_s32 (const int32_t * __a)
   return __rv.__i;
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline float16x4x2_t __attribute__ ((__always_inline__))
+vld2_f16 (const float16_t * __a)
+{
+  union { float16x4x2_t __i; __builtin_neon_ti __o; } __rv;
+  __rv.__o = __builtin_neon_vld2v4hf (__a);
+  return __rv.__i;
+}
+#endif
+
 __extension__ static __inline float32x2x2_t __attribute__ ((__always_inline__))
 vld2_f32 (const float32_t * __a)
 {
@@ -9492,6 +9718,16 @@ vld2q_s32 (const int32_t * __a)
   return __rv.__i;
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline float16x8x2_t __attribute__ ((__always_inline__))
+vld2q_f16 (const float16_t * __a)
+{
+  union { float16x8x2_t __i; __builtin_neon_oi __o; } __rv;
+  __rv.__o = __builtin_neon_vld2v8hf (__a);
+  return __rv.__i;
+}
+#endif
+
 __extension__ static __inline float32x4x2_t __attribute__ ((__always_inline__))
 vld2q_f32 (const float32_t * __a)
 {
@@ -9567,6 +9803,17 @@ vld2_lane_s32 (const int32_t * __a, int32x2x2_t __b, const int __c)
   return __rv.__i;
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline float16x4x2_t __attribute__ ((__always_inline__))
+vld2_lane_f16 (const float16_t * __a, float16x4x2_t __b, const int __c)
+{
+  union { float16x4x2_t __i; __builtin_neon_ti __o; } __bu = { __b };
+  union { float16x4x2_t __i; __builtin_neon_ti __o; } __rv;
+  __rv.__o = __builtin_neon_vld2_lanev4hf ( __a, __bu.__o, __c);
+  return __rv.__i;
+}
+#endif
+
 __extension__ static __inline float32x2x2_t __attribute__ ((__always_inline__))
 vld2_lane_f32 (const float32_t * __a, float32x2x2_t __b, const int __c)
 {
@@ -9639,6 +9886,17 @@ vld2q_lane_s32 (const int32_t * __a, int32x4x2_t __b, const int __c)
   return __rv.__i;
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline float16x8x2_t __attribute__ ((__always_inline__))
+vld2q_lane_f16 (const float16_t * __a, float16x8x2_t __b, const int __c)
+{
+  union { float16x8x2_t __i; __builtin_neon_oi __o; } __bu = { __b };
+  union { float16x8x2_t __i; __builtin_neon_oi __o; } __rv;
+  __rv.__o = __builtin_neon_vld2_lanev8hf (__a, __bu.__o, __c);
+  return __rv.__i;
+}
+#endif
+
 __extension__ static __inline float32x4x2_t __attribute__ ((__always_inline__))
 vld2q_lane_f32 (const float32_t * __a, float32x4x2_t __b, const int __c)
 {
@@ -9699,6 +9957,16 @@ vld2_dup_s32 (const int32_t * __a)
   return __rv.__i;
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline float16x4x2_t __attribute__ ((__always_inline__))
+vld2_dup_f16 (const float16_t * __a)
+{
+  union { float16x4x2_t __i; __builtin_neon_ti __o; } __rv;
+  __rv.__o = __builtin_neon_vld2_dupv4hf (__a);
+  return __rv.__i;
+}
+#endif
+
 __extension__ static __inline float32x2x2_t __attribute__ ((__always_inline__))
 vld2_dup_f32 (const float32_t * __a)
 {
@@ -9794,6 +10062,15 @@ vst2_s32 (int32_t * __a, int32x2x2_t __b)
   __builtin_neon_vst2v2si ((__builtin_neon_si *) __a, __bu.__o);
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline void __attribute__ ((__always_inline__))
+vst2_f16 (float16_t * __a, float16x4x2_t __b)
+{
+  union { float16x4x2_t __i; __builtin_neon_ti __o; } __bu = { __b };
+  __builtin_neon_vst2v4hf (__a, __bu.__o);
+}
+#endif
+
 __extension__ static __inline void __attribute__ ((__always_inline__))
 vst2_f32 (float32_t * __a, float32x2x2_t __b)
 {
@@ -9880,6 +10157,15 @@ vst2q_s32 (int32_t * __a, int32x4x2_t __b)
   __builtin_neon_vst2v4si ((__builtin_neon_si *) __a, __bu.__o);
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline void __attribute__ ((__always_inline__))
+vst2q_f16 (float16_t * __a, float16x8x2_t __b)
+{
+  union { float16x8x2_t __i; __builtin_neon_oi __o; } __bu = { __b };
+  __builtin_neon_vst2v8hf (__a, __bu.__o);
+}
+#endif
+
 __extension__ static __inline void __attribute__ ((__always_inline__))
 vst2q_f32 (float32_t * __a, float32x4x2_t __b)
 {
@@ -9943,6 +10229,15 @@ vst2_lane_s32 (int32_t * __a, int32x2x2_t __b, const int __c)
   __builtin_neon_vst2_lanev2si ((__builtin_neon_si *) __a, __bu.__o, __c);
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline void __attribute__ ((__always_inline__))
+vst2_lane_f16 (float16_t * __a, float16x4x2_t __b, const int __c)
+{
+  union { float16x4x2_t __i; __builtin_neon_ti __o; } __bu = { __b };
+  __builtin_neon_vst2_lanev4hf (__a, __bu.__o, __c);
+}
+#endif
+
 __extension__ static __inline void __attribute__ ((__always_inline__))
 vst2_lane_f32 (float32_t * __a, float32x2x2_t __b, const int __c)
 {
@@ -9999,6 +10294,15 @@ vst2q_lane_s32 (int32_t * __a, int32x4x2_t __b, const int __c)
   __builtin_neon_vst2_lanev4si ((__builtin_neon_si *) __a, __bu.__o, __c);
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline void __attribute__ ((__always_inline__))
+vst2q_lane_f16 (float16_t * __a, float16x8x2_t __b, const int __c)
+{
+  union { float16x8x2_t __i; __builtin_neon_oi __o; } __bu = { __b };
+  __builtin_neon_vst2_lanev8hf (__a, __bu.__o, __c);
+}
+#endif
+
 __extension__ static __inline void __attribute__ ((__always_inline__))
 vst2q_lane_f32 (float32_t * __a, float32x4x2_t __b, const int __c)
 {
@@ -10051,6 +10355,16 @@ vld3_s32 (const int32_t * __a)
   return __rv.__i;
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline float16x4x3_t __attribute__ ((__always_inline__))
+vld3_f16 (const float16_t * __a)
+{
+  union { float16x4x3_t __i; __builtin_neon_ei __o; } __rv;
+  __rv.__o = __builtin_neon_vld3v4hf (__a);
+  return __rv.__i;
+}
+#endif
+
 __extension__ static __inline float32x2x3_t __attribute__ ((__always_inline__))
 vld3_f32 (const float32_t * __a)
 {
@@ -10149,6 +10463,16 @@ vld3q_s32 (const int32_t * __a)
   return __rv.__i;
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline float16x8x3_t __attribute__ ((__always_inline__))
+vld3q_f16 (const float16_t * __a)
+{
+  union { float16x8x3_t __i; __builtin_neon_ci __o; } __rv;
+  __rv.__o = __builtin_neon_vld3v8hf (__a);
+  return __rv.__i;
+}
+#endif
+
 __extension__ static __inline float32x4x3_t __attribute__ ((__always_inline__))
 vld3q_f32 (const float32_t * __a)
 {
@@ -10224,6 +10548,17 @@ vld3_lane_s32 (const int32_t * __a, int32x2x3_t __b, const int __c)
   return __rv.__i;
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline float16x4x3_t __attribute__ ((__always_inline__))
+vld3_lane_f16 (const float16_t * __a, float16x4x3_t __b, const int __c)
+{
+  union { float16x4x3_t __i; __builtin_neon_ei __o; } __bu = { __b };
+  union { float16x4x3_t __i; __builtin_neon_ei __o; } __rv;
+  __rv.__o = __builtin_neon_vld3_lanev4hf (__a, __bu.__o, __c);
+  return __rv.__i;
+}
+#endif
+
 __extension__ static __inline float32x2x3_t __attribute__ ((__always_inline__))
 vld3_lane_f32 (const float32_t * __a, float32x2x3_t __b, const int __c)
 {
@@ -10296,6 +10631,17 @@ vld3q_lane_s32 (const int32_t * __a, int32x4x3_t __b, const int __c)
   return __rv.__i;
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline float16x8x3_t __attribute__ ((__always_inline__))
+vld3q_lane_f16 (const float16_t * __a, float16x8x3_t __b, const int __c)
+{
+  union { float16x8x3_t __i; __builtin_neon_ci __o; } __bu = { __b };
+  union { float16x8x3_t __i; __builtin_neon_ci __o; } __rv;
+  __rv.__o = __builtin_neon_vld3_lanev8hf (__a, __bu.__o, __c);
+  return __rv.__i;
+}
+#endif
+
 __extension__ static __inline float32x4x3_t __attribute__ ((__always_inline__))
 vld3q_lane_f32 (const float32_t * __a, float32x4x3_t __b, const int __c)
 {
@@ -10356,6 +10702,16 @@ vld3_dup_s32 (const int32_t * __a)
   return __rv.__i;
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline float16x4x3_t __attribute__ ((__always_inline__))
+vld3_dup_f16 (const float16_t * __a)
+{
+  union { float16x4x3_t __i; __builtin_neon_ei __o; } __rv;
+  __rv.__o = __builtin_neon_vld3_dupv4hf (__a);
+  return __rv.__i;
+}
+#endif
+
 __extension__ static __inline float32x2x3_t __attribute__ ((__always_inline__))
 vld3_dup_f32 (const float32_t * __a)
 {
@@ -10451,6 +10807,15 @@ vst3_s32 (int32_t * __a, int32x2x3_t __b)
   __builtin_neon_vst3v2si ((__builtin_neon_si *) __a, __bu.__o);
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline void __attribute__ ((__always_inline__))
+vst3_f16 (float16_t * __a, float16x4x3_t __b)
+{
+  union { float16x4x3_t __i; __builtin_neon_ei __o; } __bu = { __b };
+  __builtin_neon_vst3v4hf (__a, __bu.__o);
+}
+#endif
+
 __extension__ static __inline void __attribute__ ((__always_inline__))
 vst3_f32 (float32_t * __a, float32x2x3_t __b)
 {
@@ -10537,6 +10902,15 @@ vst3q_s32 (int32_t * __a, int32x4x3_t __b)
   __builtin_neon_vst3v4si ((__builtin_neon_si *) __a, __bu.__o);
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline void __attribute__ ((__always_inline__))
+vst3q_f16 (float16_t * __a, float16x8x3_t __b)
+{
+  union { float16x8x3_t __i; __builtin_neon_ci __o; } __bu = { __b };
+  __builtin_neon_vst3v8hf (__a, __bu.__o);
+}
+#endif
+
 __extension__ static __inline void __attribute__ ((__always_inline__))
 vst3q_f32 (float32_t * __a, float32x4x3_t __b)
 {
@@ -10600,6 +10974,15 @@ vst3_lane_s32 (int32_t * __a, int32x2x3_t __b, const int __c)
   __builtin_neon_vst3_lanev2si ((__builtin_neon_si *) __a, __bu.__o, __c);
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline void __attribute__ ((__always_inline__))
+vst3_lane_f16 (float16_t * __a, float16x4x3_t __b, const int __c)
+{
+  union { float16x4x3_t __i; __builtin_neon_ei __o; } __bu = { __b };
+  __builtin_neon_vst3_lanev4hf (__a, __bu.__o, __c);
+}
+#endif
+
 __extension__ static __inline void __attribute__ ((__always_inline__))
 vst3_lane_f32 (float32_t * __a, float32x2x3_t __b, const int __c)
 {
@@ -10656,6 +11039,15 @@ vst3q_lane_s32 (int32_t * __a, int32x4x3_t __b, const int __c)
   __builtin_neon_vst3_lanev4si ((__builtin_neon_si *) __a, __bu.__o, __c);
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline void __attribute__ ((__always_inline__))
+vst3q_lane_f16 (float16_t * __a, float16x8x3_t __b, const int __c)
+{
+  union { float16x8x3_t __i; __builtin_neon_ci __o; } __bu = { __b };
+  __builtin_neon_vst3_lanev8hf (__a, __bu.__o, __c);
+}
+#endif
+
 __extension__ static __inline void __attribute__ ((__always_inline__))
 vst3q_lane_f32 (float32_t * __a, float32x4x3_t __b, const int __c)
 {
@@ -10708,6 +11100,16 @@ vld4_s32 (const int32_t * __a)
   return __rv.__i;
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline float16x4x4_t __attribute__ ((__always_inline__))
+vld4_f16 (const float16_t * __a)
+{
+  union { float16x4x4_t __i; __builtin_neon_oi __o; } __rv;
+  __rv.__o = __builtin_neon_vld4v4hf (__a);
+  return __rv.__i;
+}
+#endif
+
 __extension__ static __inline float32x2x4_t __attribute__ ((__always_inline__))
 vld4_f32 (const float32_t * __a)
 {
@@ -10806,6 +11208,16 @@ vld4q_s32 (const int32_t * __a)
   return __rv.__i;
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline float16x8x4_t __attribute__ ((__always_inline__))
+vld4q_f16 (const float16_t * __a)
+{
+  union { float16x8x4_t __i; __builtin_neon_xi __o; } __rv;
+  __rv.__o = __builtin_neon_vld4v8hf (__a);
+  return __rv.__i;
+}
+#endif
+
 __extension__ static __inline float32x4x4_t __attribute__ ((__always_inline__))
 vld4q_f32 (const float32_t * __a)
 {
@@ -10881,6 +11293,18 @@ vld4_lane_s32 (const int32_t * __a, int32x2x4_t __b, const int __c)
   return __rv.__i;
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline float16x4x4_t __attribute__ ((__always_inline__))
+vld4_lane_f16 (const float16_t * __a, float16x4x4_t __b, const int __c)
+{
+  union { float16x4x4_t __i; __builtin_neon_oi __o; } __bu = { __b };
+  union { float16x4x4_t __i; __builtin_neon_oi __o; } __rv;
+  __rv.__o = __builtin_neon_vld4_lanev4hf (__a,
+					   __bu.__o, __c);
+  return __rv.__i;
+}
+#endif
+
 __extension__ static __inline float32x2x4_t __attribute__ ((__always_inline__))
 vld4_lane_f32 (const float32_t * __a, float32x2x4_t __b, const int __c)
 {
@@ -10953,6 +11377,18 @@ vld4q_lane_s32 (const int32_t * __a, int32x4x4_t __b, const int __c)
   return __rv.__i;
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline float16x8x4_t __attribute__ ((__always_inline__))
+vld4q_lane_f16 (const float16_t * __a, float16x8x4_t __b, const int __c)
+{
+  union { float16x8x4_t __i; __builtin_neon_xi __o; } __bu = { __b };
+  union { float16x8x4_t __i; __builtin_neon_xi __o; } __rv;
+  __rv.__o = __builtin_neon_vld4_lanev8hf (__a,
+					   __bu.__o, __c);
+  return __rv.__i;
+}
+#endif
+
 __extension__ static __inline float32x4x4_t __attribute__ ((__always_inline__))
 vld4q_lane_f32 (const float32_t * __a, float32x4x4_t __b, const int __c)
 {
@@ -11013,6 +11449,16 @@ vld4_dup_s32 (const int32_t * __a)
   return __rv.__i;
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline float16x4x4_t __attribute__ ((__always_inline__))
+vld4_dup_f16 (const float16_t * __a)
+{
+  union { float16x4x4_t __i; __builtin_neon_oi __o; } __rv;
+  __rv.__o = __builtin_neon_vld4_dupv4hf (__a);
+  return __rv.__i;
+}
+#endif
+
 __extension__ static __inline float32x2x4_t __attribute__ ((__always_inline__))
 vld4_dup_f32 (const float32_t * __a)
 {
@@ -11108,6 +11554,15 @@ vst4_s32 (int32_t * __a, int32x2x4_t __b)
   __builtin_neon_vst4v2si ((__builtin_neon_si *) __a, __bu.__o);
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline void __attribute__ ((__always_inline__))
+vst4_f16 (float16_t * __a, float16x4x4_t __b)
+{
+  union { float16x4x4_t __i; __builtin_neon_oi __o; } __bu = { __b };
+  __builtin_neon_vst4v4hf (__a, __bu.__o);
+}
+#endif
+
 __extension__ static __inline void __attribute__ ((__always_inline__))
 vst4_f32 (float32_t * __a, float32x2x4_t __b)
 {
@@ -11194,6 +11649,15 @@ vst4q_s32 (int32_t * __a, int32x4x4_t __b)
   __builtin_neon_vst4v4si ((__builtin_neon_si *) __a, __bu.__o);
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline void __attribute__ ((__always_inline__))
+vst4q_f16 (float16_t * __a, float16x8x4_t __b)
+{
+  union { float16x8x4_t __i; __builtin_neon_xi __o; } __bu = { __b };
+  __builtin_neon_vst4v8hf (__a, __bu.__o);
+}
+#endif
+
 __extension__ static __inline void __attribute__ ((__always_inline__))
 vst4q_f32 (float32_t * __a, float32x4x4_t __b)
 {
@@ -11257,6 +11721,15 @@ vst4_lane_s32 (int32_t * __a, int32x2x4_t __b, const int __c)
   __builtin_neon_vst4_lanev2si ((__builtin_neon_si *) __a, __bu.__o, __c);
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline void __attribute__ ((__always_inline__))
+vst4_lane_f16 (float16_t * __a, float16x4x4_t __b, const int __c)
+{
+  union { float16x4x4_t __i; __builtin_neon_oi __o; } __bu = { __b };
+  __builtin_neon_vst4_lanev4hf (__a, __bu.__o, __c);
+}
+#endif
+
 __extension__ static __inline void __attribute__ ((__always_inline__))
 vst4_lane_f32 (float32_t * __a, float32x2x4_t __b, const int __c)
 {
@@ -11313,6 +11786,15 @@ vst4q_lane_s32 (int32_t * __a, int32x4x4_t __b, const int __c)
   __builtin_neon_vst4_lanev4si ((__builtin_neon_si *) __a, __bu.__o, __c);
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline void __attribute__ ((__always_inline__))
+vst4q_lane_f16 (float16_t * __a, float16x8x4_t __b, const int __c)
+{
+  union { float16x8x4_t __i; __builtin_neon_xi __o; } __bu = { __b };
+  __builtin_neon_vst4_lanev8hf (__a, __bu.__o, __c);
+}
+#endif
+
 __extension__ static __inline void __attribute__ ((__always_inline__))
 vst4q_lane_f32 (float32_t * __a, float32x4x4_t __b, const int __c)
 {
@@ -11827,6 +12309,14 @@ vreinterpret_p8_p16 (poly16x4_t __a)
   return (poly8x8_t)__builtin_neon_vreinterpretv8qiv4hi ((int16x4_t) __a);
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline poly8x8_t __attribute__ ((__always_inline__))
+vreinterpret_p8_f16 (float16x4_t __a)
+{
+  return (poly8x8_t) __a;
+}
+#endif
+
 __extension__ static __inline poly8x8_t __attribute__ ((__always_inline__))
 vreinterpret_p8_f32 (float32x2_t __a)
 {
@@ -11895,6 +12385,14 @@ vreinterpret_p16_p8 (poly8x8_t __a)
   return (poly16x4_t)__builtin_neon_vreinterpretv4hiv8qi ((int8x8_t) __a);
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline poly16x4_t __attribute__ ((__always_inline__))
+vreinterpret_p16_f16 (float16x4_t __a)
+{
+  return (poly16x4_t) __a;
+}
+#endif
+
 __extension__ static __inline poly16x4_t __attribute__ ((__always_inline__))
 vreinterpret_p16_f32 (float32x2_t __a)
 {
@@ -11957,6 +12455,104 @@ vreinterpret_p16_u32 (uint32x2_t __a)
   return (poly16x4_t)__builtin_neon_vreinterpretv4hiv2si ((int32x2_t) __a);
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline float16x4_t __attribute__ ((__always_inline__))
+vreinterpret_f16_p8 (poly8x8_t __a)
+{
+  return (float16x4_t) __a;
+}
+#endif
+
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline float16x4_t __attribute__ ((__always_inline__))
+vreinterpret_f16_p16 (poly16x4_t __a)
+{
+  return (float16x4_t) __a;
+}
+#endif
+
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline float16x4_t __attribute__ ((__always_inline__))
+vreinterpret_f16_f32 (float32x2_t __a)
+{
+  return (float16x4_t) __a;
+}
+#endif
+
+#ifdef __ARM_FEATURE_CRYPTO
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline float16x4_t __attribute__ ((__always_inline__))
+vreinterpret_f16_p64 (poly64x1_t __a)
+{
+  return (float16x4_t) __a;
+}
+#endif
+#endif
+
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline float16x4_t __attribute__ ((__always_inline__))
+vreinterpret_f16_s64 (int64x1_t __a)
+{
+  return (float16x4_t) __a;
+}
+#endif
+
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline float16x4_t __attribute__ ((__always_inline__))
+vreinterpret_f16_u64 (uint64x1_t __a)
+{
+  return (float16x4_t) __a;
+}
+#endif
+
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline float16x4_t __attribute__ ((__always_inline__))
+vreinterpret_f16_s8 (int8x8_t __a)
+{
+  return (float16x4_t) __a;
+}
+#endif
+
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline float16x4_t __attribute__ ((__always_inline__))
+vreinterpret_f16_s16 (int16x4_t __a)
+{
+  return (float16x4_t) __a;
+}
+#endif
+
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline float16x4_t __attribute__ ((__always_inline__))
+vreinterpret_f16_s32 (int32x2_t __a)
+{
+  return (float16x4_t) __a;
+}
+#endif
+
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline float16x4_t __attribute__ ((__always_inline__))
+vreinterpret_f16_u8 (uint8x8_t __a)
+{
+  return (float16x4_t) __a;
+}
+#endif
+
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline float16x4_t __attribute__ ((__always_inline__))
+vreinterpret_f16_u16 (uint16x4_t __a)
+{
+  return (float16x4_t) __a;
+}
+#endif
+
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline float16x4_t __attribute__ ((__always_inline__))
+vreinterpret_f16_u32 (uint32x2_t __a)
+{
+  return (float16x4_t) __a;
+}
+#endif
+
 __extension__ static __inline float32x2_t __attribute__ ((__always_inline__))
 vreinterpret_f32_p8 (poly8x8_t __a)
 {
@@ -11969,6 +12565,14 @@ vreinterpret_f32_p16 (poly16x4_t __a)
   return (float32x2_t)__builtin_neon_vreinterpretv2sfv4hi ((int16x4_t) __a);
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline float32x2_t __attribute__ ((__always_inline__))
+vreinterpret_f32_f16 (float16x4_t __a)
+{
+  return (float32x2_t) __a;
+}
+#endif
+
 #ifdef __ARM_FEATURE_CRYPTO
 __extension__ static __inline float32x2_t __attribute__ ((__always_inline__))
 vreinterpret_f32_p64 (poly64x1_t __a)
@@ -12041,6 +12645,17 @@ vreinterpret_p64_p16 (poly16x4_t __a)
 }
 
 #endif
+
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+#ifdef __ARM_FEATURE_CRYPTO
+__extension__ static __inline poly64x1_t __attribute__ ((__always_inline__))
+vreinterpret_p64_f16 (float16x4_t __a)
+{
+  return (poly64x1_t) __a;
+}
+#endif
+#endif
+
 #ifdef __ARM_FEATURE_CRYPTO
 __extension__ static __inline poly64x1_t __attribute__ ((__always_inline__))
 vreinterpret_p64_f32 (float32x2_t __a)
@@ -12125,6 +12740,14 @@ vreinterpret_s64_p16 (poly16x4_t __a)
   return (int64x1_t)__builtin_neon_vreinterpretdiv4hi ((int16x4_t) __a);
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline int64x1_t __attribute__ ((__always_inline__))
+vreinterpret_s64_f16 (float16x4_t __a)
+{
+  return (int64x1_t) __a;
+}
+#endif
+
 __extension__ static __inline int64x1_t __attribute__ ((__always_inline__))
 vreinterpret_s64_f32 (float32x2_t __a)
 {
@@ -12193,6 +12816,14 @@ vreinterpret_u64_p16 (poly16x4_t __a)
   return (uint64x1_t)__builtin_neon_vreinterpretdiv4hi ((int16x4_t) __a);
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline uint64x1_t __attribute__ ((__always_inline__))
+vreinterpret_u64_f16 (float16x4_t __a)
+{
+  return (uint64x1_t) __a;
+}
+#endif
+
 __extension__ static __inline uint64x1_t __attribute__ ((__always_inline__))
 vreinterpret_u64_f32 (float32x2_t __a)
 {
@@ -12261,6 +12892,14 @@ vreinterpret_s8_p16 (poly16x4_t __a)
   return (int8x8_t)__builtin_neon_vreinterpretv8qiv4hi ((int16x4_t) __a);
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline int8x8_t __attribute__ ((__always_inline__))
+vreinterpret_s8_f16 (float16x4_t __a)
+{
+  return (int8x8_t) __a;
+}
+#endif
+
 __extension__ static __inline int8x8_t __attribute__ ((__always_inline__))
 vreinterpret_s8_f32 (float32x2_t __a)
 {
@@ -12329,6 +12968,14 @@ vreinterpret_s16_p16 (poly16x4_t __a)
   return (int16x4_t)__builtin_neon_vreinterpretv4hiv4hi ((int16x4_t) __a);
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline int16x4_t __attribute__ ((__always_inline__))
+vreinterpret_s16_f16 (float16x4_t __a)
+{
+  return (int16x4_t) __a;
+}
+#endif
+
 __extension__ static __inline int16x4_t __attribute__ ((__always_inline__))
 vreinterpret_s16_f32 (float32x2_t __a)
 {
@@ -12397,6 +13044,14 @@ vreinterpret_s32_p16 (poly16x4_t __a)
   return (int32x2_t)__builtin_neon_vreinterpretv2siv4hi ((int16x4_t) __a);
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline int32x2_t __attribute__ ((__always_inline__))
+vreinterpret_s32_f16 (float16x4_t __a)
+{
+  return (int32x2_t) __a;
+}
+#endif
+
 __extension__ static __inline int32x2_t __attribute__ ((__always_inline__))
 vreinterpret_s32_f32 (float32x2_t __a)
 {
@@ -12465,6 +13120,14 @@ vreinterpret_u8_p16 (poly16x4_t __a)
   return (uint8x8_t)__builtin_neon_vreinterpretv8qiv4hi ((int16x4_t) __a);
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline uint8x8_t __attribute__ ((__always_inline__))
+vreinterpret_u8_f16 (float16x4_t __a)
+{
+  return (uint8x8_t) __a;
+}
+#endif
+
 __extension__ static __inline uint8x8_t __attribute__ ((__always_inline__))
 vreinterpret_u8_f32 (float32x2_t __a)
 {
@@ -12533,6 +13196,14 @@ vreinterpret_u16_p16 (poly16x4_t __a)
   return (uint16x4_t)__builtin_neon_vreinterpretv4hiv4hi ((int16x4_t) __a);
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline uint16x4_t __attribute__ ((__always_inline__))
+vreinterpret_u16_f16 (float16x4_t __a)
+{
+  return (uint16x4_t) __a;
+}
+#endif
+
 __extension__ static __inline uint16x4_t __attribute__ ((__always_inline__))
 vreinterpret_u16_f32 (float32x2_t __a)
 {
@@ -12601,6 +13272,14 @@ vreinterpret_u32_p16 (poly16x4_t __a)
   return (uint32x2_t)__builtin_neon_vreinterpretv2siv4hi ((int16x4_t) __a);
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline uint32x2_t __attribute__ ((__always_inline__))
+vreinterpret_u32_f16 (float16x4_t __a)
+{
+  return (uint32x2_t) __a;
+}
+#endif
+
 __extension__ static __inline uint32x2_t __attribute__ ((__always_inline__))
 vreinterpret_u32_f32 (float32x2_t __a)
 {
@@ -12663,6 +13342,14 @@ vreinterpretq_p8_p16 (poly16x8_t __a)
   return (poly8x16_t)__builtin_neon_vreinterpretv16qiv8hi ((int16x8_t) __a);
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline poly8x16_t __attribute__ ((__always_inline__))
+vreinterpretq_p8_f16 (float16x8_t __a)
+{
+  return (poly8x16_t) __a;
+}
+#endif
+
 __extension__ static __inline poly8x16_t __attribute__ ((__always_inline__))
 vreinterpretq_p8_f32 (float32x4_t __a)
 {
@@ -12739,6 +13426,14 @@ vreinterpretq_p16_p8 (poly8x16_t __a)
   return (poly16x8_t)__builtin_neon_vreinterpretv8hiv16qi ((int8x16_t) __a);
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline poly16x8_t __attribute__ ((__always_inline__))
+vreinterpretq_p16_f16 (float16x8_t __a)
+{
+  return (poly16x8_t) __a;
+}
+#endif
+
 __extension__ static __inline poly16x8_t __attribute__ ((__always_inline__))
 vreinterpretq_p16_f32 (float32x4_t __a)
 {
@@ -12809,6 +13504,114 @@ vreinterpretq_p16_u32 (uint32x4_t __a)
   return (poly16x8_t)__builtin_neon_vreinterpretv8hiv4si ((int32x4_t) __a);
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline float16x8_t __attribute__ ((__always_inline__))
+vreinterpretq_f16_p8 (poly8x16_t __a)
+{
+  return (float16x8_t) __a;
+}
+#endif
+
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline float16x8_t __attribute__ ((__always_inline__))
+vreinterpretq_f16_p16 (poly16x8_t __a)
+{
+  return (float16x8_t) __a;
+}
+#endif
+
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline float16x8_t __attribute__ ((__always_inline__))
+vreinterpretq_f16_f32 (float32x4_t __a)
+{
+  return (float16x8_t) __a;
+}
+#endif
+
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+#ifdef __ARM_FEATURE_CRYPTO
+__extension__ static __inline float16x8_t __attribute__ ((__always_inline__))
+vreinterpretq_f16_p64 (poly64x2_t __a)
+{
+  return (float16x8_t) __a;
+}
+#endif
+#endif
+
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+#ifdef __ARM_FEATURE_CRYPTO
+__extension__ static __inline float16x8_t __attribute__ ((__always_inline__))
+vreinterpretq_f16_p128 (poly128_t __a)
+{
+  return (float16x8_t) __a;
+}
+#endif
+#endif
+
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline float16x8_t __attribute__ ((__always_inline__))
+vreinterpretq_f16_s64 (int64x2_t __a)
+{
+  return (float16x8_t) __a;
+}
+#endif
+
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline float16x8_t __attribute__ ((__always_inline__))
+vreinterpretq_f16_u64 (uint64x2_t __a)
+{
+  return (float16x8_t) __a;
+}
+#endif
+
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline float16x8_t __attribute__ ((__always_inline__))
+vreinterpretq_f16_s8 (int8x16_t __a)
+{
+  return (float16x8_t) __a;
+}
+#endif
+
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline float16x8_t __attribute__ ((__always_inline__))
+vreinterpretq_f16_s16 (int16x8_t __a)
+{
+  return (float16x8_t) __a;
+}
+#endif
+
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline float16x8_t __attribute__ ((__always_inline__))
+vreinterpretq_f16_s32 (int32x4_t __a)
+{
+  return (float16x8_t) __a;
+}
+#endif
+
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline float16x8_t __attribute__ ((__always_inline__))
+vreinterpretq_f16_u8 (uint8x16_t __a)
+{
+  return (float16x8_t) __a;
+}
+#endif
+
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline float16x8_t __attribute__ ((__always_inline__))
+vreinterpretq_f16_u16 (uint16x8_t __a)
+{
+  return (float16x8_t) __a;
+}
+#endif
+
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline float16x8_t __attribute__ ((__always_inline__))
+vreinterpretq_f16_u32 (uint32x4_t __a)
+{
+  return (float16x8_t) __a;
+}
+#endif
+
 __extension__ static __inline float32x4_t __attribute__ ((__always_inline__))
 vreinterpretq_f32_p8 (poly8x16_t __a)
 {
@@ -12821,6 +13624,14 @@ vreinterpretq_f32_p16 (poly16x8_t __a)
   return (float32x4_t)__builtin_neon_vreinterpretv4sfv8hi ((int16x8_t) __a);
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline float32x4_t __attribute__ ((__always_inline__))
+vreinterpretq_f32_f16 (float16x8_t __a)
+{
+  return (float32x4_t) __a;
+}
+#endif
+
 #ifdef __ARM_FEATURE_CRYPTO
 __extension__ static __inline float32x4_t __attribute__ ((__always_inline__))
 vreinterpretq_f32_p64 (poly64x2_t __a)
@@ -12901,6 +13712,17 @@ vreinterpretq_p64_p16 (poly16x8_t __a)
 }
 
 #endif
+
+#ifdef __ARM_FEATURE_CRYPTO
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline poly64x2_t __attribute__ ((__always_inline__))
+vreinterpretq_p64_f16 (float16x8_t __a)
+{
+  return (poly64x2_t) __a;
+}
+#endif
+#endif
+
 #ifdef __ARM_FEATURE_CRYPTO
 __extension__ static __inline poly64x2_t __attribute__ ((__always_inline__))
 vreinterpretq_p64_f32 (float32x4_t __a)
@@ -12995,8 +13817,18 @@ vreinterpretq_p128_p16 (poly16x8_t __a)
 {
   return (poly128_t)__builtin_neon_vreinterprettiv8hi ((int16x8_t) __a);
 }
+#endif
 
+#ifdef __ARM_FEATURE_CRYPTO
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline poly128_t __attribute__ ((__always_inline__))
+vreinterpretq_p128_f16 (float16x8_t __a)
+{
+  return (poly128_t) __a;
+}
 #endif
+#endif
+
 #ifdef __ARM_FEATURE_CRYPTO
 __extension__ static __inline poly128_t __attribute__ ((__always_inline__))
 vreinterpretq_p128_f32 (float32x4_t __a)
@@ -13089,6 +13921,14 @@ vreinterpretq_s64_p16 (poly16x8_t __a)
   return (int64x2_t)__builtin_neon_vreinterpretv2div8hi ((int16x8_t) __a);
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline int64x2_t __attribute__ ((__always_inline__))
+vreinterpretq_s64_f16 (float16x8_t __a)
+{
+  return (int64x2_t) __a;
+}
+#endif
+
 __extension__ static __inline int64x2_t __attribute__ ((__always_inline__))
 vreinterpretq_s64_f32 (float32x4_t __a)
 {
@@ -13165,6 +14005,14 @@ vreinterpretq_u64_p16 (poly16x8_t __a)
   return (uint64x2_t)__builtin_neon_vreinterpretv2div8hi ((int16x8_t) __a);
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline uint64x2_t __attribute__ ((__always_inline__))
+vreinterpretq_u64_f16 (float16x8_t __a)
+{
+  return (uint64x2_t) __a;
+}
+#endif
+
 __extension__ static __inline uint64x2_t __attribute__ ((__always_inline__))
 vreinterpretq_u64_f32 (float32x4_t __a)
 {
@@ -13241,6 +14089,14 @@ vreinterpretq_s8_p16 (poly16x8_t __a)
   return (int8x16_t)__builtin_neon_vreinterpretv16qiv8hi ((int16x8_t) __a);
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline int8x16_t __attribute__ ((__always_inline__))
+vreinterpretq_s8_f16 (float16x8_t __a)
+{
+  return (int8x16_t) __a;
+}
+#endif
+
 __extension__ static __inline int8x16_t __attribute__ ((__always_inline__))
 vreinterpretq_s8_f32 (float32x4_t __a)
 {
@@ -13317,6 +14173,14 @@ vreinterpretq_s16_p16 (poly16x8_t __a)
   return (int16x8_t)__builtin_neon_vreinterpretv8hiv8hi ((int16x8_t) __a);
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline int16x8_t __attribute__ ((__always_inline__))
+vreinterpretq_s16_f16 (float16x8_t __a)
+{
+  return (int16x8_t) __a;
+}
+#endif
+
 __extension__ static __inline int16x8_t __attribute__ ((__always_inline__))
 vreinterpretq_s16_f32 (float32x4_t __a)
 {
@@ -13393,6 +14257,14 @@ vreinterpretq_s32_p16 (poly16x8_t __a)
   return (int32x4_t)__builtin_neon_vreinterpretv4siv8hi ((int16x8_t) __a);
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline int32x4_t __attribute__ ((__always_inline__))
+vreinterpretq_s32_f16 (float16x8_t __a)
+{
+  return (int32x4_t)__builtin_neon_vreinterpretv4siv8hi ((int16x8_t) __a);
+}
+#endif
+
 __extension__ static __inline int32x4_t __attribute__ ((__always_inline__))
 vreinterpretq_s32_f32 (float32x4_t __a)
 {
@@ -13469,6 +14341,14 @@ vreinterpretq_u8_p16 (poly16x8_t __a)
   return (uint8x16_t)__builtin_neon_vreinterpretv16qiv8hi ((int16x8_t) __a);
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline uint8x16_t __attribute__ ((__always_inline__))
+vreinterpretq_u8_f16 (float16x8_t __a)
+{
+  return (uint8x16_t) __a;
+}
+#endif
+
 __extension__ static __inline uint8x16_t __attribute__ ((__always_inline__))
 vreinterpretq_u8_f32 (float32x4_t __a)
 {
@@ -13545,6 +14425,14 @@ vreinterpretq_u16_p16 (poly16x8_t __a)
   return (uint16x8_t)__builtin_neon_vreinterpretv8hiv8hi ((int16x8_t) __a);
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline uint16x8_t __attribute__ ((__always_inline__))
+vreinterpretq_u16_f16 (float16x8_t __a)
+{
+  return (uint16x8_t) __a;
+}
+#endif
+
 __extension__ static __inline uint16x8_t __attribute__ ((__always_inline__))
 vreinterpretq_u16_f32 (float32x4_t __a)
 {
@@ -13621,6 +14509,14 @@ vreinterpretq_u32_p16 (poly16x8_t __a)
   return (uint32x4_t)__builtin_neon_vreinterpretv4siv8hi ((int16x8_t) __a);
 }
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+__extension__ static __inline uint32x4_t __attribute__ ((__always_inline__))
+vreinterpretq_u32_f16 (float16x8_t __a)
+{
+  return (uint32x4_t) __a;
+}
+#endif
+
 __extension__ static __inline uint32x4_t __attribute__ ((__always_inline__))
 vreinterpretq_u32_f32 (float32x4_t __a)
 {
--- a/src/gcc/config/arm/arm_neon_builtins.def
+++ b/src/gcc/config/arm/arm_neon_builtins.def
@@ -67,28 +67,28 @@ VAR8 (BINOP, vqshls, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)
 VAR8 (BINOP, vqshlu, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)
 VAR8 (BINOP, vqrshls, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)
 VAR8 (BINOP, vqrshlu, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)
-VAR8 (GETLANE, vshrs_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)
-VAR8 (GETLANE, vshru_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)
-VAR8 (GETLANE, vrshrs_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)
-VAR8 (GETLANE, vrshru_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)
-VAR3 (GETLANE, vshrn_n, v8hi, v4si, v2di)
-VAR3 (GETLANE, vrshrn_n, v8hi, v4si, v2di)
-VAR3 (GETLANE, vqshrns_n, v8hi, v4si, v2di)
-VAR3 (GETLANE, vqshrnu_n, v8hi, v4si, v2di)
-VAR3 (GETLANE, vqrshrns_n, v8hi, v4si, v2di)
-VAR3 (GETLANE, vqrshrnu_n, v8hi, v4si, v2di)
-VAR3 (GETLANE, vqshrun_n, v8hi, v4si, v2di)
-VAR3 (GETLANE, vqrshrun_n, v8hi, v4si, v2di)
-VAR8 (GETLANE, vshl_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)
-VAR8 (GETLANE, vqshl_s_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)
-VAR8 (GETLANE, vqshl_u_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)
-VAR8 (GETLANE, vqshlu_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)
-VAR3 (GETLANE, vshlls_n, v8qi, v4hi, v2si)
-VAR3 (GETLANE, vshllu_n, v8qi, v4hi, v2si)
-VAR8 (SETLANE, vsras_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)
-VAR8 (SETLANE, vsrau_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)
-VAR8 (SETLANE, vrsras_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)
-VAR8 (SETLANE, vrsrau_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)
+VAR8 (BINOP_IMM, vshrs_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)
+VAR8 (BINOP_IMM, vshru_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)
+VAR8 (BINOP_IMM, vrshrs_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)
+VAR8 (BINOP_IMM, vrshru_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)
+VAR3 (BINOP_IMM, vshrn_n, v8hi, v4si, v2di)
+VAR3 (BINOP_IMM, vrshrn_n, v8hi, v4si, v2di)
+VAR3 (BINOP_IMM, vqshrns_n, v8hi, v4si, v2di)
+VAR3 (BINOP_IMM, vqshrnu_n, v8hi, v4si, v2di)
+VAR3 (BINOP_IMM, vqrshrns_n, v8hi, v4si, v2di)
+VAR3 (BINOP_IMM, vqrshrnu_n, v8hi, v4si, v2di)
+VAR3 (BINOP_IMM, vqshrun_n, v8hi, v4si, v2di)
+VAR3 (BINOP_IMM, vqrshrun_n, v8hi, v4si, v2di)
+VAR8 (BINOP_IMM, vshl_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)
+VAR8 (BINOP_IMM, vqshl_s_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)
+VAR8 (BINOP_IMM, vqshl_u_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)
+VAR8 (BINOP_IMM, vqshlu_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)
+VAR3 (BINOP_IMM, vshlls_n, v8qi, v4hi, v2si)
+VAR3 (BINOP_IMM, vshllu_n, v8qi, v4hi, v2si)
+VAR8 (TERNOP_IMM, vsras_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)
+VAR8 (TERNOP_IMM, vsrau_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)
+VAR8 (TERNOP_IMM, vrsras_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)
+VAR8 (TERNOP_IMM, vrsrau_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)
 VAR2 (BINOP, vsub, v2sf, v4sf)
 VAR3 (BINOP, vsubls, v8qi, v4hi, v2si)
 VAR3 (BINOP, vsublu, v8qi, v4hi, v2si)
@@ -140,8 +140,8 @@ VAR6 (BINOP, vpadals, v8qi, v4hi, v2si, v16qi, v8hi, v4si)
 VAR6 (BINOP, vpadalu, v8qi, v4hi, v2si, v16qi, v8hi, v4si)
 VAR2 (BINOP, vrecps, v2sf, v4sf)
 VAR2 (BINOP, vrsqrts, v2sf, v4sf)
-VAR8 (SETLANE, vsri_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)
-VAR8 (SETLANE, vsli_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)
+VAR8 (TERNOP_IMM, vsri_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)
+VAR8 (TERNOP_IMM, vsli_n, v8qi, v4hi, v2si, di, v16qi, v8hi, v4si, v2di)
 VAR8 (UNOP, vabs, v8qi, v4hi, v2si, v2sf, v16qi, v8hi, v4si, v4sf)
 VAR6 (UNOP, vqabs, v8qi, v4hi, v2si, v16qi, v8hi, v4si)
 VAR8 (UNOP, vneg, v8qi, v4hi, v2si, v2sf, v16qi, v8hi, v4si, v4sf)
@@ -162,11 +162,11 @@ VAR10 (SETLANE, vset_lane,
 VAR5 (UNOP, vcreate, v8qi, v4hi, v2si, v2sf, di)
 VAR10 (UNOP, vdup_n,
 	 v8qi, v4hi, v2si, v2sf, di, v16qi, v8hi, v4si, v4sf, v2di)
-VAR10 (BINOP, vdup_lane,
+VAR10 (GETLANE, vdup_lane,
 	 v8qi, v4hi, v2si, v2sf, di, v16qi, v8hi, v4si, v4sf, v2di)
-VAR5 (COMBINE, vcombine, v8qi, v4hi, v2si, v2sf, di)
-VAR5 (UNOP, vget_high, v16qi, v8hi, v4si, v4sf, v2di)
-VAR5 (UNOP, vget_low, v16qi, v8hi, v4si, v4sf, v2di)
+VAR6 (COMBINE, vcombine, v8qi, v4hi, v4hf, v2si, v2sf, di)
+VAR6 (UNOP, vget_high, v16qi, v8hi, v8hf, v4si, v4sf, v2di)
+VAR6 (UNOP, vget_low, v16qi, v8hi, v8hf, v4si, v4sf, v2di)
 VAR3 (UNOP, vmovn, v8hi, v4si, v2di)
 VAR3 (UNOP, vqmovns, v8hi, v4si, v2di)
 VAR3 (UNOP, vqmovnu, v8hi, v4si, v2di)
@@ -174,23 +174,23 @@ VAR3 (UNOP, vqmovun, v8hi, v4si, v2di)
 VAR3 (UNOP, vmovls, v8qi, v4hi, v2si)
 VAR3 (UNOP, vmovlu, v8qi, v4hi, v2si)
 VAR6 (SETLANE, vmul_lane, v4hi, v2si, v2sf, v8hi, v4si, v4sf)
-VAR6 (LANEMAC, vmla_lane, v4hi, v2si, v2sf, v8hi, v4si, v4sf)
-VAR2 (LANEMAC, vmlals_lane, v4hi, v2si)
-VAR2 (LANEMAC, vmlalu_lane, v4hi, v2si)
-VAR2 (LANEMAC, vqdmlal_lane, v4hi, v2si)
-VAR6 (LANEMAC, vmls_lane, v4hi, v2si, v2sf, v8hi, v4si, v4sf)
-VAR2 (LANEMAC, vmlsls_lane, v4hi, v2si)
-VAR2 (LANEMAC, vmlslu_lane, v4hi, v2si)
-VAR2 (LANEMAC, vqdmlsl_lane, v4hi, v2si)
+VAR6 (MAC_LANE, vmla_lane, v4hi, v2si, v2sf, v8hi, v4si, v4sf)
+VAR2 (MAC_LANE, vmlals_lane, v4hi, v2si)
+VAR2 (MAC_LANE, vmlalu_lane, v4hi, v2si)
+VAR2 (MAC_LANE, vqdmlal_lane, v4hi, v2si)
+VAR6 (MAC_LANE, vmls_lane, v4hi, v2si, v2sf, v8hi, v4si, v4sf)
+VAR2 (MAC_LANE, vmlsls_lane, v4hi, v2si)
+VAR2 (MAC_LANE, vmlslu_lane, v4hi, v2si)
+VAR2 (MAC_LANE, vqdmlsl_lane, v4hi, v2si)
 VAR6 (BINOP, vmul_n, v4hi, v2si, v2sf, v8hi, v4si, v4sf)
-VAR6 (LANEMAC, vmla_n, v4hi, v2si, v2sf, v8hi, v4si, v4sf)
-VAR2 (LANEMAC, vmlals_n, v4hi, v2si)
-VAR2 (LANEMAC, vmlalu_n, v4hi, v2si)
-VAR2 (LANEMAC, vqdmlal_n, v4hi, v2si)
-VAR6 (LANEMAC, vmls_n, v4hi, v2si, v2sf, v8hi, v4si, v4sf)
-VAR2 (LANEMAC, vmlsls_n, v4hi, v2si)
-VAR2 (LANEMAC, vmlslu_n, v4hi, v2si)
-VAR2 (LANEMAC, vqdmlsl_n, v4hi, v2si)
+VAR6 (MAC_N, vmla_n, v4hi, v2si, v2sf, v8hi, v4si, v4sf)
+VAR2 (MAC_N, vmlals_n, v4hi, v2si)
+VAR2 (MAC_N, vmlalu_n, v4hi, v2si)
+VAR2 (MAC_N, vqdmlal_n, v4hi, v2si)
+VAR6 (MAC_N, vmls_n, v4hi, v2si, v2sf, v8hi, v4si, v4sf)
+VAR2 (MAC_N, vmlsls_n, v4hi, v2si)
+VAR2 (MAC_N, vmlslu_n, v4hi, v2si)
+VAR2 (MAC_N, vqdmlsl_n, v4hi, v2si)
 VAR10 (SETLANE, vext,
 	 v8qi, v4hi, v2si, v2sf, di, v16qi, v8hi, v4si, v4sf, v2di)
 VAR8 (UNOP, vrev64, v8qi, v4hi, v2si, v2sf, v16qi, v8hi, v4si, v4sf)
@@ -242,40 +242,40 @@ VAR6 (UNOP, vreinterpretv4si, v16qi, v8hi, v4si, v4sf, v2di, ti)
 VAR6 (UNOP, vreinterpretv4sf, v16qi, v8hi, v4si, v4sf, v2di, ti)
 VAR6 (UNOP, vreinterpretv2di, v16qi, v8hi, v4si, v4sf, v2di, ti)
 VAR6 (UNOP, vreinterpretti, v16qi, v8hi, v4si, v4sf, v2di, ti)
-VAR10 (LOAD1, vld1,
-        v8qi, v4hi, v2si, v2sf, di, v16qi, v8hi, v4si, v4sf, v2di)
+VAR12 (LOAD1, vld1,
+        v8qi, v4hi, v4hf, v2si, v2sf, di, v16qi, v8hi, v8hf, v4si, v4sf, v2di)
 VAR10 (LOAD1LANE, vld1_lane,
 	v8qi, v4hi, v2si, v2sf, di, v16qi, v8hi, v4si, v4sf, v2di)
 VAR10 (LOAD1, vld1_dup,
 	v8qi, v4hi, v2si, v2sf, di, v16qi, v8hi, v4si, v4sf, v2di)
-VAR10 (STORE1, vst1,
-	v8qi, v4hi, v2si, v2sf, di, v16qi, v8hi, v4si, v4sf, v2di)
-VAR10 (STORE1LANE, vst1_lane,
-	v8qi, v4hi, v2si, v2sf, di, v16qi, v8hi, v4si, v4sf, v2di)
-VAR9 (LOAD1, vld2,
-	v8qi, v4hi, v2si, v2sf, di, v16qi, v8hi, v4si, v4sf)
-VAR7 (LOAD1LANE, vld2_lane,
-	v8qi, v4hi, v2si, v2sf, v8hi, v4si, v4sf)
-VAR5 (LOAD1, vld2_dup, v8qi, v4hi, v2si, v2sf, di)
-VAR9 (STORE1, vst2,
-	v8qi, v4hi, v2si, v2sf, di, v16qi, v8hi, v4si, v4sf)
-VAR7 (STORE1LANE, vst2_lane,
-	v8qi, v4hi, v2si, v2sf, v8hi, v4si, v4sf)
-VAR9 (LOAD1, vld3,
-	v8qi, v4hi, v2si, v2sf, di, v16qi, v8hi, v4si, v4sf)
-VAR7 (LOAD1LANE, vld3_lane,
-	v8qi, v4hi, v2si, v2sf, v8hi, v4si, v4sf)
-VAR5 (LOAD1, vld3_dup, v8qi, v4hi, v2si, v2sf, di)
-VAR9 (STORE1, vst3,
-	v8qi, v4hi, v2si, v2sf, di, v16qi, v8hi, v4si, v4sf)
-VAR7 (STORE1LANE, vst3_lane,
-	v8qi, v4hi, v2si, v2sf, v8hi, v4si, v4sf)
-VAR9 (LOAD1, vld4,
-	v8qi, v4hi, v2si, v2sf, di, v16qi, v8hi, v4si, v4sf)
-VAR7 (LOAD1LANE, vld4_lane,
-	v8qi, v4hi, v2si, v2sf, v8hi, v4si, v4sf)
-VAR5 (LOAD1, vld4_dup, v8qi, v4hi, v2si, v2sf, di)
-VAR9 (STORE1, vst4,
-	v8qi, v4hi, v2si, v2sf, di, v16qi, v8hi, v4si, v4sf)
-VAR7 (STORE1LANE, vst4_lane,
-	v8qi, v4hi, v2si, v2sf, v8hi, v4si, v4sf)
+VAR12 (STORE1, vst1,
+	v8qi, v4hi, v4hf, v2si, v2sf, di, v16qi, v8hi, v8hf, v4si, v4sf, v2di)
+VAR12 (STORE1LANE, vst1_lane,
+	v8qi, v4hi, v4hf, v2si, v2sf, di, v16qi, v8hi, v8hf, v4si, v4sf, v2di)
+VAR11 (LOAD1, vld2,
+	v8qi, v4hi, v4hf, v2si, v2sf, di, v16qi, v8hi, v8hf, v4si, v4sf)
+VAR9 (LOAD1LANE, vld2_lane,
+	v8qi, v4hi, v4hf, v2si, v2sf, v8hi, v8hf, v4si, v4sf)
+VAR6 (LOAD1, vld2_dup, v8qi, v4hi, v4hf, v2si, v2sf, di)
+VAR11 (STORE1, vst2,
+	v8qi, v4hi, v4hf, v2si, v2sf, di, v16qi, v8hi, v8hf, v4si, v4sf)
+VAR9 (STORE1LANE, vst2_lane,
+	v8qi, v4hi, v4hf, v2si, v2sf, v8hi, v8hf, v4si, v4sf)
+VAR11 (LOAD1, vld3,
+	v8qi, v4hi, v4hf, v2si, v2sf, di, v16qi, v8hi, v8hf, v4si, v4sf)
+VAR9 (LOAD1LANE, vld3_lane,
+	v8qi, v4hi, v4hf, v2si, v2sf, v8hi, v8hf, v4si, v4sf)
+VAR6 (LOAD1, vld3_dup, v8qi, v4hi, v4hf, v2si, v2sf, di)
+VAR11 (STORE1, vst3,
+	v8qi, v4hi, v4hf, v2si, v2sf, di, v16qi, v8hi, v8hf, v4si, v4sf)
+VAR9 (STORE1LANE, vst3_lane,
+	v8qi, v4hi, v4hf, v2si, v2sf, v8hi, v8hf, v4si, v4sf)
+VAR11 (LOAD1, vld4,
+	v8qi, v4hi, v4hf, v2si, v2sf, di, v16qi, v8hi, v8hf, v4si, v4sf)
+VAR9 (LOAD1LANE, vld4_lane,
+	v8qi, v4hi, v4hf, v2si, v2sf, v8hi, v8hf, v4si, v4sf)
+VAR6 (LOAD1, vld4_dup, v8qi, v4hi, v4hf, v2si, v2sf, di)
+VAR11 (STORE1, vst4,
+	v8qi, v4hi, v4hf, v2si, v2sf, di, v16qi, v8hi, v8hf, v4si, v4sf)
+VAR9 (STORE1LANE, vst4_lane,
+	v8qi, v4hi, v4hf, v2si, v2sf, v8hi, v8hf, v4si, v4sf)
--- a/src/gcc/config/arm/cortex-a53.md
+++ b/src/gcc/config/arm/cortex-a53.md
@@ -325,7 +325,7 @@
 
 (define_insn_reservation "cortex_a53_f_load_2reg" 5
   (and (eq_attr "tune" "cortexa53")
-       (eq_attr "type" "neon_load2_2reg_q"))
+       (eq_attr "type" "neon_ldp, neon_ldp_q, neon_load2_2reg_q"))
   "(cortex_a53_slot_any+cortex_a53_ls)*2")
 
 (define_insn_reservation "cortex_a53_f_loadq" 5
@@ -360,7 +360,7 @@
 ;; Crude Advanced SIMD approximation.
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 
-(define_insn_reservation "cortex_53_advsimd" 4
+(define_insn_reservation "cortex_a53_advsimd" 4
   (and (eq_attr "tune" "cortexa53")
        (eq_attr "is_neon_type" "yes"))
   "cortex_a53_simd0")
--- a/src/gcc/config/arm/cortex-a57.md
+++ b/src/gcc/config/arm/cortex-a57.md
@@ -202,7 +202,8 @@
 	  (eq_attr "type" "neon_load1_3reg, neon_load1_3reg_q,\
 			   neon_load1_4reg, neon_load1_4reg_q")
 	    (const_string "neon_load_b")
-	  (eq_attr "type" "neon_load1_one_lane, neon_load1_one_lane_q,\
+	  (eq_attr "type" "neon_ldp, neon_ldp_q,\
+			   neon_load1_one_lane, neon_load1_one_lane_q,\
 			   neon_load1_all_lanes, neon_load1_all_lanes_q,\
 			   neon_load2_2reg, neon_load2_2reg_q,\
 			   neon_load2_all_lanes, neon_load2_all_lanes_q")
@@ -224,7 +225,8 @@
 	    (const_string "neon_store_a")
 	  (eq_attr "type" "neon_store1_2reg, neon_store1_1reg_q")
 	    (const_string "neon_store_b")
-	  (eq_attr "type" "neon_store1_3reg, neon_store1_3reg_q,\
+	  (eq_attr "type" "neon_stp, neon_stp_q,\
+			   neon_store1_3reg, neon_store1_3reg_q,\
 			   neon_store3_3reg, neon_store3_3reg_q,\
 			   neon_store2_4reg, neon_store2_4reg_q,\
 			   neon_store4_4reg, neon_store4_4reg_q,\
--- a/src/gcc/config/arm/driver-arm.c
+++ b/src/gcc/config/arm/driver-arm.c
@@ -35,6 +35,9 @@ static struct vendor_cpu arm_cpu_table[] = {
     {"0xb02", "armv6k", "mpcore"},
     {"0xb36", "armv6j", "arm1136j-s"},
     {"0xb56", "armv6t2", "arm1156t2-s"},
+    /* armv6kz is the correct spelling for ARMv6KZ but may not be supported in
+       the version of binutils used.  The incorrect spelling is supported in
+       legacy and current binutils so that is used instead.  */
     {"0xb76", "armv6zk", "arm1176jz-s"},
     {"0xc05", "armv7-a", "cortex-a5"},
     {"0xc07", "armv7ve", "cortex-a7"},
--- a/src/gcc/config/arm/elf.h
+++ b/src/gcc/config/arm/elf.h
@@ -120,7 +120,6 @@
   { "marm", "mlittle-endian", "mfloat-abi=soft", "mno-thumb-interwork", "fno-leading-underscore" }
 #endif
 
-#define TARGET_ASM_FILE_START_APP_OFF true
 #define TARGET_ASM_FILE_START_FILE_DIRECTIVE true
 
 
--- a/src/gcc/config/arm/iterators.md
+++ b/src/gcc/config/arm/iterators.md
@@ -65,20 +65,32 @@
 ;; Integer modes supported by Neon and IWMMXT, except V2DI
 (define_mode_iterator VINTW [V2SI V4HI V8QI V4SI V8HI V16QI])
 
-;; Double-width vector modes.
+;; Double-width vector modes, on which we support arithmetic (no HF!)
 (define_mode_iterator VD [V8QI V4HI V2SI V2SF])
 
+;; Double-width vector modes plus 64-bit elements for vreinterpret + vcreate.
+(define_mode_iterator VD_RE [V8QI V4HI V2SI V2SF DI])
+
 ;; Double-width vector modes plus 64-bit elements.
-(define_mode_iterator VDX [V8QI V4HI V2SI V2SF DI])
+(define_mode_iterator VDX [V8QI V4HI V4HF V2SI V2SF DI])
+
+;; Double-width vector modes, with V4HF - for vldN_lane and vstN_lane.
+(define_mode_iterator VD_LANE [V8QI V4HI V4HF V2SI V2SF])
 
 ;; Double-width vector modes without floating-point elements.
 (define_mode_iterator VDI [V8QI V4HI V2SI])
 
-;; Quad-width vector modes.
+;; Quad-width vector modes supporting arithmetic (no HF!).
 (define_mode_iterator VQ [V16QI V8HI V4SI V4SF])
 
+;; Quad-width vector modes, including V8HF.
+(define_mode_iterator VQ2 [V16QI V8HI V8HF V4SI V4SF])
+
+;; Quad-width vector modes with 16- or 32-bit elements
+(define_mode_iterator VQ_HS [V8HI V8HF V4SI V4SF])
+
 ;; Quad-width vector modes plus 64-bit elements.
-(define_mode_iterator VQX [V16QI V8HI V4SI V4SF V2DI])
+(define_mode_iterator VQX [V16QI V8HI V8HF V4SI V4SF V2DI])
 
 ;; Quad-width vector modes without floating-point elements.
 (define_mode_iterator VQI [V16QI V8HI V4SI])
@@ -111,7 +123,8 @@
 (define_mode_iterator VDQI [V8QI V16QI V4HI V8HI V2SI V4SI V2DI])
 
 ;; Vector modes, including 64-bit integer elements.
-(define_mode_iterator VDQX [V8QI V16QI V4HI V8HI V2SI V4SI V2SF V4SF DI V2DI])
+(define_mode_iterator VDQX [V8QI V16QI V4HI V8HI V2SI V4SI
+			    V4HF V8HF V2SF V4SF DI V2DI])
 
 ;; Vector modes including 64-bit integer elements, but no floats.
 (define_mode_iterator VDQIX [V8QI V16QI V4HI V8HI V2SI V4SI DI V2DI])
@@ -181,39 +194,53 @@
 ;; compare a second time.
 (define_code_iterator LTUGEU [ltu geu])
 
+;; The signed gt, ge comparisons
+(define_code_iterator GTGE [gt ge])
+
+;; The unsigned gt, ge comparisons
+(define_code_iterator GTUGEU [gtu geu])
+
+;; Comparisons for vc<cmp>
+(define_code_iterator COMPARISONS [eq gt ge le lt])
+
 ;; A list of ...
-(define_code_iterator ior_xor [ior xor])
+(define_code_iterator IOR_XOR [ior xor])
 
 ;; Operations on two halves of a quadword vector.
-(define_code_iterator vqh_ops [plus smin smax umin umax])
+(define_code_iterator VQH_OPS [plus smin smax umin umax])
 
 ;; Operations on two halves of a quadword vector,
 ;; without unsigned variants (for use with *SFmode pattern).
-(define_code_iterator vqhs_ops [plus smin smax])
+(define_code_iterator VQHS_OPS [plus smin smax])
 
 ;; A list of widening operators
 (define_code_iterator SE [sign_extend zero_extend])
 
 ;; Right shifts
-(define_code_iterator rshifts [ashiftrt lshiftrt])
+(define_code_iterator RSHIFTS [ashiftrt lshiftrt])
 
 ;; Iterator for integer conversions
 (define_code_iterator FIXUORS [fix unsigned_fix])
 
 ;; Binary operators whose second operand can be shifted.
-(define_code_iterator shiftable_ops [plus minus ior xor and])
+(define_code_iterator SHIFTABLE_OPS [plus minus ior xor and])
 
-;; plus and minus are the only shiftable_ops for which Thumb2 allows
+;; plus and minus are the only SHIFTABLE_OPS for which Thumb2 allows
 ;; a stack pointer opoerand.  The minus operation is a candidate for an rsub
 ;; and hence only plus is supported.
 (define_code_attr t2_binop0
   [(plus "rk") (minus "r") (ior "r") (xor "r") (and "r")])
 
-;; The instruction to use when a shiftable_ops has a shift operation as
+;; The instruction to use when a SHIFTABLE_OPS has a shift operation as
 ;; its first operand.
 (define_code_attr arith_shift_insn
   [(plus "add") (minus "rsb") (ior "orr") (xor "eor") (and "and")])
 
+(define_code_attr cmp_op [(eq "eq") (gt "gt") (ge "ge") (lt "lt") (le "le")
+                          (gtu "gt") (geu "ge")])
+
+(define_code_attr cmp_type [(eq "i") (gt "s") (ge "s") (lt "s") (le "s")])
+
 ;;----------------------------------------------------------------------------
 ;; Int iterators
 ;;----------------------------------------------------------------------------
@@ -221,6 +248,10 @@
 (define_int_iterator VRINT [UNSPEC_VRINTZ UNSPEC_VRINTP UNSPEC_VRINTM
                             UNSPEC_VRINTR UNSPEC_VRINTX UNSPEC_VRINTA])
 
+(define_int_iterator NEON_VCMP [UNSPEC_VCEQ UNSPEC_VCGT UNSPEC_VCGE UNSPEC_VCLT UNSPEC_VCLE])
+
+(define_int_iterator NEON_VACMP [UNSPEC_VCAGE UNSPEC_VCAGT])
+
 (define_int_iterator VCVT [UNSPEC_VRINTP UNSPEC_VRINTM UNSPEC_VRINTA])
 
 (define_int_iterator NEON_VRINT [UNSPEC_NVRINTP UNSPEC_NVRINTZ UNSPEC_NVRINTM
@@ -348,7 +379,8 @@
 
 ;; Define element mode for each vector mode.
 (define_mode_attr V_elem [(V8QI "QI") (V16QI "QI")
-              (V4HI "HI") (V8HI "HI")
+			  (V4HI "HI") (V8HI "HI")
+			  (V4HF "HF") (V8HF "HF")
                           (V2SI "SI") (V4SI "SI")
                           (V2SF "SF") (V4SF "SF")
                           (DI "DI")   (V2DI "DI")])
@@ -365,6 +397,7 @@
 ;; size for structure lane/dup loads and stores.
 (define_mode_attr V_two_elem [(V8QI "HI")   (V16QI "HI")
                               (V4HI "SI")   (V8HI "SI")
+                              (V4HF "SF")   (V8HF "SF")
                               (V2SI "V2SI") (V4SI "V2SI")
                               (V2SF "V2SF") (V4SF "V2SF")
                               (DI "V2DI")   (V2DI "V2DI")])
@@ -372,6 +405,7 @@
 ;; Similar, for three elements.
 (define_mode_attr V_three_elem [(V8QI "BLK") (V16QI "BLK")
                                 (V4HI "BLK") (V8HI "BLK")
+                                (V4HF "BLK") (V8HF "BLK")
                                 (V2SI "BLK") (V4SI "BLK")
                                 (V2SF "BLK") (V4SF "BLK")
                                 (DI "EI")    (V2DI "EI")])
@@ -379,6 +413,7 @@
 ;; Similar, for four elements.
 (define_mode_attr V_four_elem [(V8QI "SI")   (V16QI "SI")
                                (V4HI "V4HI") (V8HI "V4HI")
+                               (V4HF "V4HF") (V8HF "V4HF")
                                (V2SI "V4SI") (V4SI "V4SI")
                                (V2SF "V4SF") (V4SF "V4SF")
                                (DI "OI")     (V2DI "OI")])
@@ -403,7 +438,8 @@
 
 ;; Modes with half the number of equal-sized elements.
 (define_mode_attr V_HALF [(V16QI "V8QI") (V8HI "V4HI")
-              (V4SI  "V2SI") (V4SF "V2SF") (V2DF "DF")
+			  (V8HF "V4HF") (V4SI  "V2SI")
+			  (V4SF "V2SF") (V2DF "DF")
                           (V2DI "DI")])
 
 ;; Same, but lower-case.
@@ -413,8 +449,9 @@
 
 ;; Modes with twice the number of equal-sized elements.
 (define_mode_attr V_DOUBLE [(V8QI "V16QI") (V4HI "V8HI")
-                (V2SI "V4SI") (V2SF "V4SF") (DF "V2DF")
-                            (DI "V2DI")])
+			    (V2SI "V4SI") (V4HF "V8HF")
+			    (V2SF "V4SF") (DF "V2DF")
+			    (DI "V2DI")])
 
 ;; Same, but lower-case.
 (define_mode_attr V_double [(V8QI "v16qi") (V4HI "v8hi")
@@ -436,8 +473,9 @@
 
 ;; Mode of result of comparison operations (and bit-select operand 1).
 (define_mode_attr V_cmp_result [(V8QI "V8QI") (V16QI "V16QI")
-                    (V4HI "V4HI") (V8HI  "V8HI")
+				(V4HI "V4HI") (V8HI  "V8HI")
                                 (V2SI "V2SI") (V4SI  "V4SI")
+				(V4HF "V4HI") (V8HF  "V8HI")
                                 (V2SF "V2SI") (V4SF  "V4SI")
                                 (DI   "DI")   (V2DI  "V2DI")])
 
@@ -474,12 +512,14 @@
 (define_mode_attr V_uf_sclr [(V8QI "u8")  (V16QI "u8")
                  (V4HI "u16") (V8HI "u16")
                              (V2SI "32") (V4SI "32")
+                             (V4HF "u16") (V8HF "u16")
                              (V2SF "32") (V4SF "32")])
 
 (define_mode_attr V_sz_elem [(V8QI "8")  (V16QI "8")
                  (V4HI "16") (V8HI  "16")
                              (V2SI "32") (V4SI  "32")
                              (DI   "64") (V2DI  "64")
+			     (V4HF "16") (V8HF "16")
                  (V2SF "32") (V4SF  "32")])
 
 (define_mode_attr V_elem_ch [(V8QI "b")  (V16QI "b")
@@ -546,6 +586,7 @@
                             (DI   "true") (V2DI  "false")])
 
 (define_mode_attr V_mode_nunits [(V8QI "8") (V16QI "16")
+				 (V4HF "4") (V8HF "8")
                                  (V4HI "4") (V8HI "8")
                                  (V2SI "2") (V4SI "4")
                                  (V2SF "2") (V4SF "4")
@@ -589,6 +630,7 @@
 (define_mode_attr q [(V8QI "") (V16QI "_q")
                      (V4HI "") (V8HI "_q")
                      (V2SI "") (V4SI "_q")
+		     (V4HF "") (V8HF "_q")
                      (V2SF "") (V4SF "_q")
                      (DI "")   (V2DI "_q")
                      (DF "")   (V2DF "_q")])
@@ -677,6 +719,11 @@
 
 ])
 
+(define_int_attr cmp_op_unsp [(UNSPEC_VCEQ "eq") (UNSPEC_VCGT "gt")
+                              (UNSPEC_VCGE "ge") (UNSPEC_VCLE "le")
+                              (UNSPEC_VCLT "lt") (UNSPEC_VCAGE "ge")
+                              (UNSPEC_VCAGT "gt")])
+
 (define_int_attr r [
   (UNSPEC_VRHADD_S "r") (UNSPEC_VRHADD_U "r")
   (UNSPEC_VHADD_S "") (UNSPEC_VHADD_U "")
@@ -774,7 +821,7 @@
                           (UNSPEC_SHA256H2 "V4SI") (UNSPEC_SHA256SU1 "V4SI")])
 
 ;; Both kinds of return insn.
-(define_code_iterator returns [return simple_return])
+(define_code_iterator RETURNS [return simple_return])
 (define_code_attr return_str [(return "") (simple_return "simple_")])
 (define_code_attr return_simple_p [(return "false") (simple_return "true")])
 (define_code_attr return_cond_false [(return " && USE_RETURN_INSN (FALSE)")
--- a/src/gcc/config/arm/iwmmxt.md
+++ b/src/gcc/config/arm/iwmmxt.md
@@ -107,8 +107,8 @@
 )
 
 (define_insn "*iwmmxt_arm_movdi"
-  [(set (match_operand:DI 0 "nonimmediate_di_operand" "=r, r, r, r, m,y,y,yr,y,yrUy,*w, r,*w,*w, *Uv")
-        (match_operand:DI 1 "di_operand"              "rDa,Db,Dc,mi,r,y,yr,y,yrUy,y, r,*w,*w,*Uvi,*w"))]
+  [(set (match_operand:DI 0 "nonimmediate_di_operand" "=r, r, r, r, m,y,y,r, y,Uy,*w, r,*w,*w, *Uv")
+        (match_operand:DI 1 "di_operand"              "rDa,Db,Dc,mi,r,y,r,y,Uy,y,  r,*w,*w,*Uvi,*w"))]
   "TARGET_REALLY_IWMMXT
    && (   register_operand (operands[0], DImode)
        || register_operand (operands[1], DImode))"
--- a/src/gcc/config/arm/linux-eabi.h
+++ b/src/gcc/config/arm/linux-eabi.h
@@ -77,6 +77,23 @@
     %{mfloat-abi=soft*:" GLIBC_DYNAMIC_LINKER_SOFT_FLOAT "} \
     %{!mfloat-abi=*:" GLIBC_DYNAMIC_LINKER_DEFAULT "}"
 
+/* For ARM musl currently supports four dynamic linkers:
+   - ld-musl-arm.so.1 - for the EABI-derived soft-float ABI
+   - ld-musl-armhf.so.1 - for the EABI-derived hard-float ABI
+   - ld-musl-armeb.so.1 - for the EABI-derived soft-float ABI, EB
+   - ld-musl-armebhf.so.1 - for the EABI-derived hard-float ABI, EB
+   musl does not support the legacy OABI mode.
+   All the dynamic linkers live in /lib.
+   We default to soft-float, EL. */
+#undef  MUSL_DYNAMIC_LINKER
+#if TARGET_BIG_ENDIAN_DEFAULT
+#define MUSL_DYNAMIC_LINKER_E "%{mlittle-endian:;:eb}"
+#else
+#define MUSL_DYNAMIC_LINKER_E "%{mbig-endian:eb}"
+#endif
+#define MUSL_DYNAMIC_LINKER \
+  "/lib/ld-musl-arm" MUSL_DYNAMIC_LINKER_E "%{mfloat-abi=hard:hf}.so.1"
+
 /* At this point, bpabi.h will have clobbered LINK_SPEC.  We want to
    use the GNU/Linux version, not the generic BPABI version.  */
 #undef  LINK_SPEC
@@ -107,6 +124,7 @@
 
 #undef	ENDFILE_SPEC
 #define ENDFILE_SPEC \
+  "%{Ofast|ffast-math|funsafe-math-optimizations:crtfastmath.o%s} "	\
   LINUX_OR_ANDROID_LD (GNU_USER_TARGET_ENDFILE_SPEC, ANDROID_ENDFILE_SPEC)
 
 /* Use the default LIBGCC_SPEC, not the version in linux-elf.h, as we
--- a/src/gcc/config/arm/neon-testgen.ml
+++ b/src/gcc/config/arm/neon-testgen.ml
@@ -138,7 +138,6 @@ let emit_epilogue chan features regexps =
      else
        ()
     );
-    Printf.fprintf chan "/* { dg-final { cleanup-saved-temps } } */\n"
 
 (* Check a list of C types to determine which ones are pointers and which
    ones are const.  *)
--- a/src/gcc/config/arm/neon.md
+++ b/src/gcc/config/arm/neon.md
@@ -320,11 +320,11 @@
   [(set_attr "type" "neon_load1_all_lanes<q>,neon_from_gp<q>")])
 
 (define_insn "vec_set<mode>_internal"
-  [(set (match_operand:VQ 0 "s_register_operand" "=w,w")
-        (vec_merge:VQ
-          (vec_duplicate:VQ
+  [(set (match_operand:VQ2 0 "s_register_operand" "=w,w")
+        (vec_merge:VQ2
+          (vec_duplicate:VQ2
             (match_operand:<V_elem> 1 "nonimmediate_operand" "Um,r"))
-          (match_operand:VQ 3 "s_register_operand" "0,0")
+          (match_operand:VQ2 3 "s_register_operand" "0,0")
           (match_operand:SI 2 "immediate_operand" "i,i")))]
   "TARGET_NEON"
 {
@@ -407,7 +407,7 @@
 (define_insn "vec_extract<mode>"
   [(set (match_operand:<V_elem> 0 "nonimmediate_operand" "=Um,r")
 	(vec_select:<V_elem>
-          (match_operand:VQ 1 "s_register_operand" "w,w")
+          (match_operand:VQ2 1 "s_register_operand" "w,w")
           (parallel [(match_operand:SI 2 "immediate_operand" "i,i")])))]
   "TARGET_NEON"
 {
@@ -1114,7 +1114,7 @@
 ;; lshrdi3_neon
 (define_insn_and_split "<shift>di3_neon"
   [(set (match_operand:DI 0 "s_register_operand"	     "= w, w,?&r,?r,?w,?w")
-	(rshifts:DI (match_operand:DI 1 "s_register_operand" " 0w, w, 0r, r,0w, w")
+	(RSHIFTS:DI (match_operand:DI 1 "s_register_operand" " 0w, w, 0r, r,0w, w")
 		    (match_operand:SI 2 "reg_or_int_operand" "  r, i,  r, i, r, i")))
    (clobber (match_scratch:SI 3				     "=2r, X, &r, X,2r, X"))
    (clobber (match_scratch:SI 4				     "= X, X, &r, X, X, X"))
@@ -1194,71 +1194,6 @@
   [(set_attr "type" "neon_add_widen")]
 )
 
-;; VEXT can be used to synthesize coarse whole-vector shifts with 8-bit
-;; shift-count granularity. That's good enough for the middle-end's current
-;; needs.
-
-;; Note that it's not safe to perform such an operation in big-endian mode,
-;; due to element-ordering issues.
-
-(define_expand "vec_shr_<mode>"
-  [(match_operand:VDQ 0 "s_register_operand" "")
-   (match_operand:VDQ 1 "s_register_operand" "")
-   (match_operand:SI 2 "const_multiple_of_8_operand" "")]
-  "TARGET_NEON && !BYTES_BIG_ENDIAN"
-{
-  rtx zero_reg;
-  HOST_WIDE_INT num_bits = INTVAL (operands[2]);
-  const int width = GET_MODE_BITSIZE (<MODE>mode);
-  const machine_mode bvecmode = (width == 128) ? V16QImode : V8QImode;
-  rtx (*gen_ext) (rtx, rtx, rtx, rtx) =
-    (width == 128) ? gen_neon_vextv16qi : gen_neon_vextv8qi;
-
-  if (num_bits == width)
-    {
-      emit_move_insn (operands[0], operands[1]);
-      DONE;
-    }
-
-  zero_reg = force_reg (bvecmode, CONST0_RTX (bvecmode));
-  operands[0] = gen_lowpart (bvecmode, operands[0]);
-  operands[1] = gen_lowpart (bvecmode, operands[1]);
-
-  emit_insn (gen_ext (operands[0], operands[1], zero_reg,
-		      GEN_INT (num_bits / BITS_PER_UNIT)));
-  DONE;
-})
-
-(define_expand "vec_shl_<mode>"
-  [(match_operand:VDQ 0 "s_register_operand" "")
-   (match_operand:VDQ 1 "s_register_operand" "")
-   (match_operand:SI 2 "const_multiple_of_8_operand" "")]
-  "TARGET_NEON && !BYTES_BIG_ENDIAN"
-{
-  rtx zero_reg;
-  HOST_WIDE_INT num_bits = INTVAL (operands[2]);
-  const int width = GET_MODE_BITSIZE (<MODE>mode);
-  const machine_mode bvecmode = (width == 128) ? V16QImode : V8QImode;
-  rtx (*gen_ext) (rtx, rtx, rtx, rtx) =
-    (width == 128) ? gen_neon_vextv16qi : gen_neon_vextv8qi;
-
-  if (num_bits == 0)
-    {
-      emit_move_insn (operands[0], CONST0_RTX (<MODE>mode));
-      DONE;
-    }
-
-  num_bits = width - num_bits;
-
-  zero_reg = force_reg (bvecmode, CONST0_RTX (bvecmode));
-  operands[0] = gen_lowpart (bvecmode, operands[0]);
-  operands[1] = gen_lowpart (bvecmode, operands[1]);
-
-  emit_insn (gen_ext (operands[0], zero_reg, operands[1],
-		      GEN_INT (num_bits / BITS_PER_UNIT)));
-  DONE;
-})
-
 ;; Helpers for quad-word reduction operations
 
 ; Add (or smin, smax...) the low N/2 elements of the N-element vector
@@ -1267,7 +1202,7 @@
 
 (define_insn "quad_halves_<code>v4si"
   [(set (match_operand:V2SI 0 "s_register_operand" "=w")
-        (vqh_ops:V2SI
+        (VQH_OPS:V2SI
           (vec_select:V2SI (match_operand:V4SI 1 "s_register_operand" "w")
                            (parallel [(const_int 0) (const_int 1)]))
           (vec_select:V2SI (match_dup 1)
@@ -1280,7 +1215,7 @@
 
 (define_insn "quad_halves_<code>v4sf"
   [(set (match_operand:V2SF 0 "s_register_operand" "=w")
-        (vqhs_ops:V2SF
+        (VQHS_OPS:V2SF
           (vec_select:V2SF (match_operand:V4SF 1 "s_register_operand" "w")
                            (parallel [(const_int 0) (const_int 1)]))
           (vec_select:V2SF (match_dup 1)
@@ -1293,7 +1228,7 @@
 
 (define_insn "quad_halves_<code>v8hi"
   [(set (match_operand:V4HI 0 "s_register_operand" "+w")
-        (vqh_ops:V4HI
+        (VQH_OPS:V4HI
           (vec_select:V4HI (match_operand:V8HI 1 "s_register_operand" "w")
                            (parallel [(const_int 0) (const_int 1)
 				      (const_int 2) (const_int 3)]))
@@ -1308,7 +1243,7 @@
 
 (define_insn "quad_halves_<code>v16qi"
   [(set (match_operand:V8QI 0 "s_register_operand" "+w")
-        (vqh_ops:V8QI
+        (VQH_OPS:V8QI
           (vec_select:V8QI (match_operand:V16QI 1 "s_register_operand" "w")
                            (parallel [(const_int 0) (const_int 1)
 				      (const_int 2) (const_int 3)
@@ -2200,134 +2135,140 @@
   [(set_attr "type" "neon_sub_halve_narrow_q")]
 )
 
-(define_insn "neon_vceq<mode>"
-  [(set (match_operand:<V_cmp_result> 0 "s_register_operand" "=w,w")
-        (unspec:<V_cmp_result>
-	  [(match_operand:VDQW 1 "s_register_operand" "w,w")
-	   (match_operand:VDQW 2 "reg_or_zero_operand" "w,Dz")]
-          UNSPEC_VCEQ))]
+;; These may expand to an UNSPEC pattern when a floating point mode is used
+;; without unsafe math optimizations.
+(define_expand "neon_vc<cmp_op><mode>"
+  [(match_operand:<V_cmp_result> 0 "s_register_operand" "=w,w")
+     (neg:<V_cmp_result>
+       (COMPARISONS:VDQW (match_operand:VDQW 1 "s_register_operand" "w,w")
+                         (match_operand:VDQW 2 "reg_or_zero_operand" "w,Dz")))]
   "TARGET_NEON"
-  "@
-  vceq.<V_if_elem>\t%<V_reg>0, %<V_reg>1, %<V_reg>2
-  vceq.<V_if_elem>\t%<V_reg>0, %<V_reg>1, #0"
-  [(set (attr "type")
-      (if_then_else (match_test "<Is_float_mode>")
-                    (const_string "neon_fp_compare_s<q>")
-                    (if_then_else (match_operand 2 "zero_operand")
-                      (const_string "neon_compare_zero<q>")
-                      (const_string "neon_compare<q>"))))]
+  {
+    /* For FP comparisons use UNSPECS unless -funsafe-math-optimizations
+       are enabled.  */
+    if (GET_MODE_CLASS (<MODE>mode) == MODE_VECTOR_FLOAT
+        && !flag_unsafe_math_optimizations)
+      {
+        /* We don't just emit a gen_neon_vc<cmp_op><mode>_insn_unspec because
+           we define gen_neon_vceq<mode>_insn_unspec only for float modes
+           whereas this expander iterates over the integer modes as well,
+           but we will never expand to UNSPECs for the integer comparisons.  */
+        switch (<MODE>mode)
+          {
+            case V2SFmode:
+              emit_insn (gen_neon_vc<cmp_op>v2sf_insn_unspec (operands[0],
+                                                              operands[1],
+                                                              operands[2]));
+              break;
+            case V4SFmode:
+              emit_insn (gen_neon_vc<cmp_op>v4sf_insn_unspec (operands[0],
+                                                              operands[1],
+                                                              operands[2]));
+              break;
+            default:
+              gcc_unreachable ();
+          }
+      }
+    else
+      emit_insn (gen_neon_vc<cmp_op><mode>_insn (operands[0],
+                                                 operands[1],
+                                                 operands[2]));
+    DONE;
+  }
 )
 
-(define_insn "neon_vcge<mode>"
+(define_insn "neon_vc<cmp_op><mode>_insn"
   [(set (match_operand:<V_cmp_result> 0 "s_register_operand" "=w,w")
-        (unspec:<V_cmp_result>
-	  [(match_operand:VDQW 1 "s_register_operand" "w,w")
-	   (match_operand:VDQW 2 "reg_or_zero_operand" "w,Dz")]
-          UNSPEC_VCGE))]
-  "TARGET_NEON"
-  "@
-  vcge.<V_s_elem>\t%<V_reg>0, %<V_reg>1, %<V_reg>2
-  vcge.<V_s_elem>\t%<V_reg>0, %<V_reg>1, #0"
+        (neg:<V_cmp_result>
+          (COMPARISONS:<V_cmp_result>
+            (match_operand:VDQW 1 "s_register_operand" "w,w")
+            (match_operand:VDQW 2 "reg_or_zero_operand" "w,Dz"))))]
+  "TARGET_NEON && !(GET_MODE_CLASS (<MODE>mode) == MODE_VECTOR_FLOAT
+                    && !flag_unsafe_math_optimizations)"
+  {
+    char pattern[100];
+    sprintf (pattern, "vc<cmp_op>.%s%%#<V_sz_elem>\t%%<V_reg>0,"
+                      " %%<V_reg>1, %s",
+                       GET_MODE_CLASS (<MODE>mode) == MODE_VECTOR_FLOAT
+                         ? "f" : "<cmp_type>",
+                       which_alternative == 0
+                         ? "%<V_reg>2" : "#0");
+    output_asm_insn (pattern, operands);
+    return "";
+  }
   [(set (attr "type")
-     (if_then_else (match_test "<Is_float_mode>")
-                   (const_string "neon_fp_compare_s<q>")
-                    (if_then_else (match_operand 2 "zero_operand")
+        (if_then_else (match_operand 2 "zero_operand")
                       (const_string "neon_compare_zero<q>")
-                      (const_string "neon_compare<q>"))))]
-)
-
-(define_insn "neon_vcgeu<mode>"
-  [(set (match_operand:<V_cmp_result> 0 "s_register_operand" "=w")
-        (unspec:<V_cmp_result>
-	  [(match_operand:VDQIW 1 "s_register_operand" "w")
-	   (match_operand:VDQIW 2 "s_register_operand" "w")]
-          UNSPEC_VCGEU))]
-  "TARGET_NEON"
-  "vcge.u%#<V_sz_elem>\t%<V_reg>0, %<V_reg>1, %<V_reg>2"
-  [(set_attr "type" "neon_compare<q>")]
+                      (const_string "neon_compare<q>")))]
 )
 
-(define_insn "neon_vcgt<mode>"
+(define_insn "neon_vc<cmp_op_unsp><mode>_insn_unspec"
   [(set (match_operand:<V_cmp_result> 0 "s_register_operand" "=w,w")
         (unspec:<V_cmp_result>
-	  [(match_operand:VDQW 1 "s_register_operand" "w,w")
-	   (match_operand:VDQW 2 "reg_or_zero_operand" "w,Dz")]
-          UNSPEC_VCGT))]
+	  [(match_operand:VCVTF 1 "s_register_operand" "w,w")
+	   (match_operand:VCVTF 2 "reg_or_zero_operand" "w,Dz")]
+          NEON_VCMP))]
   "TARGET_NEON"
-  "@
-  vcgt.<V_s_elem>\t%<V_reg>0, %<V_reg>1, %<V_reg>2
-  vcgt.<V_s_elem>\t%<V_reg>0, %<V_reg>1, #0"
-  [(set (attr "type")
-     (if_then_else (match_test "<Is_float_mode>")
-                   (const_string "neon_fp_compare_s<q>")
-                    (if_then_else (match_operand 2 "zero_operand")
-                      (const_string "neon_compare_zero<q>")
-                      (const_string "neon_compare<q>"))))]
+  {
+    char pattern[100];
+    sprintf (pattern, "vc<cmp_op_unsp>.f%%#<V_sz_elem>\t%%<V_reg>0,"
+                       " %%<V_reg>1, %s",
+                       which_alternative == 0
+                         ? "%<V_reg>2" : "#0");
+    output_asm_insn (pattern, operands);
+    return "";
+}
+  [(set_attr "type" "neon_fp_compare_s<q>")]
 )
 
-(define_insn "neon_vcgtu<mode>"
+(define_insn "neon_vc<cmp_op>u<mode>"
   [(set (match_operand:<V_cmp_result> 0 "s_register_operand" "=w")
-        (unspec:<V_cmp_result>
-	  [(match_operand:VDQIW 1 "s_register_operand" "w")
-	   (match_operand:VDQIW 2 "s_register_operand" "w")]
-          UNSPEC_VCGTU))]
+        (neg:<V_cmp_result>
+          (GTUGEU:<V_cmp_result>
+	    (match_operand:VDQIW 1 "s_register_operand" "w")
+	    (match_operand:VDQIW 2 "s_register_operand" "w"))))]
   "TARGET_NEON"
-  "vcgt.u%#<V_sz_elem>\t%<V_reg>0, %<V_reg>1, %<V_reg>2"
+  "vc<cmp_op>.u%#<V_sz_elem>\t%<V_reg>0, %<V_reg>1, %<V_reg>2"
   [(set_attr "type" "neon_compare<q>")]
 )
 
-;; VCLE and VCLT only support comparisons with immediate zero (register
-;; variants are VCGE and VCGT with operands reversed).
-
-(define_insn "neon_vcle<mode>"
-  [(set (match_operand:<V_cmp_result> 0 "s_register_operand" "=w")
-        (unspec:<V_cmp_result>
-	  [(match_operand:VDQW 1 "s_register_operand" "w")
-	   (match_operand:VDQW 2 "zero_operand" "Dz")]
-          UNSPEC_VCLE))]
+(define_expand "neon_vca<cmp_op><mode>"
+  [(set (match_operand:<V_cmp_result> 0 "s_register_operand")
+        (neg:<V_cmp_result>
+          (GTGE:<V_cmp_result>
+            (abs:VCVTF (match_operand:VCVTF 1 "s_register_operand"))
+            (abs:VCVTF (match_operand:VCVTF 2 "s_register_operand")))))]
   "TARGET_NEON"
-  "vcle.<V_s_elem>\t%<V_reg>0, %<V_reg>1, #0"
-  [(set (attr "type")
-      (if_then_else (match_test "<Is_float_mode>")
-                    (const_string "neon_fp_compare_s<q>")
-                    (if_then_else (match_operand 2 "zero_operand")
-                      (const_string "neon_compare_zero<q>")
-                      (const_string "neon_compare<q>"))))]
-)
-
-(define_insn "neon_vclt<mode>"
-  [(set (match_operand:<V_cmp_result> 0 "s_register_operand" "=w")
-        (unspec:<V_cmp_result>
-	  [(match_operand:VDQW 1 "s_register_operand" "w")
-	   (match_operand:VDQW 2 "zero_operand" "Dz")]
-          UNSPEC_VCLT))]
-  "TARGET_NEON"
-  "vclt.<V_s_elem>\t%<V_reg>0, %<V_reg>1, #0"
-  [(set (attr "type")
-      (if_then_else (match_test "<Is_float_mode>")
-                    (const_string "neon_fp_compare_s<q>")
-                    (if_then_else (match_operand 2 "zero_operand")
-                      (const_string "neon_compare_zero<q>")
-                      (const_string "neon_compare<q>"))))]
+  {
+    if (flag_unsafe_math_optimizations)
+      emit_insn (gen_neon_vca<cmp_op><mode>_insn (operands[0], operands[1],
+                                                  operands[2]));
+    else
+      emit_insn (gen_neon_vca<cmp_op><mode>_insn_unspec (operands[0],
+                                                         operands[1],
+                                                         operands[2]));
+    DONE;
+  }
 )
 
-(define_insn "neon_vcage<mode>"
+(define_insn "neon_vca<cmp_op><mode>_insn"
   [(set (match_operand:<V_cmp_result> 0 "s_register_operand" "=w")
-        (unspec:<V_cmp_result> [(match_operand:VCVTF 1 "s_register_operand" "w")
-		                (match_operand:VCVTF 2 "s_register_operand" "w")]
-                               UNSPEC_VCAGE))]
-  "TARGET_NEON"
-  "vacge.<V_if_elem>\t%<V_reg>0, %<V_reg>1, %<V_reg>2"
+        (neg:<V_cmp_result>
+          (GTGE:<V_cmp_result>
+            (abs:VCVTF (match_operand:VCVTF 1 "s_register_operand" "w"))
+            (abs:VCVTF (match_operand:VCVTF 2 "s_register_operand" "w")))))]
+  "TARGET_NEON && flag_unsafe_math_optimizations"
+  "vac<cmp_op>.<V_if_elem>\t%<V_reg>0, %<V_reg>1, %<V_reg>2"
   [(set_attr "type" "neon_fp_compare_s<q>")]
 )
 
-(define_insn "neon_vcagt<mode>"
+(define_insn "neon_vca<cmp_op_unsp><mode>_insn_unspec"
   [(set (match_operand:<V_cmp_result> 0 "s_register_operand" "=w")
         (unspec:<V_cmp_result> [(match_operand:VCVTF 1 "s_register_operand" "w")
 		                (match_operand:VCVTF 2 "s_register_operand" "w")]
-                               UNSPEC_VCAGT))]
+                               NEON_VACMP))]
   "TARGET_NEON"
-  "vacgt.<V_if_elem>\t%<V_reg>0, %<V_reg>1, %<V_reg>2"
+  "vac<cmp_op_unsp>.<V_if_elem>\t%<V_reg>0, %<V_reg>1, %<V_reg>2"
   [(set_attr "type" "neon_fp_compare_s<q>")]
 )
 
@@ -2666,7 +2607,7 @@
   [(set (match_operand:SI 0 "s_register_operand" "=r")
 	(sign_extend:SI
 	  (vec_select:<V_elem>
-	    (match_operand:VQ 1 "s_register_operand" "w")
+	    (match_operand:VQ2 1 "s_register_operand" "w")
 	    (parallel [(match_operand:SI 2 "immediate_operand" "i")]))))]
   "TARGET_NEON"
 {
@@ -2693,7 +2634,7 @@
   [(set (match_operand:SI 0 "s_register_operand" "=r")
 	(zero_extend:SI
 	  (vec_select:<V_elem>
-	    (match_operand:VQ 1 "s_register_operand" "w")
+	    (match_operand:VQ2 1 "s_register_operand" "w")
 	    (parallel [(match_operand:SI 2 "immediate_operand" "i")]))))]
   "TARGET_NEON"
 {
@@ -2722,8 +2663,6 @@
    (match_operand:SI 2 "immediate_operand" "")]
   "TARGET_NEON"
 {
-  neon_lane_bounds (operands[2], 0, GET_MODE_NUNITS (<MODE>mode));
-
   if (BYTES_BIG_ENDIAN)
     {
       /* The intrinsics are defined in terms of a model where the
@@ -2753,8 +2692,6 @@
    (match_operand:SI 2 "immediate_operand" "")]
   "TARGET_NEON"
 {
-  neon_lane_bounds (operands[2], 0, GET_MODE_NUNITS (<MODE>mode));
-
   if (BYTES_BIG_ENDIAN)
     {
       /* The intrinsics are defined in terms of a model where the
@@ -2784,7 +2721,6 @@
    (match_operand:SI 2 "immediate_operand" "")]
   "TARGET_NEON"
 {
-  neon_lane_bounds (operands[2], 0, 1);
   emit_move_insn (operands[0], operands[1]);
   DONE;
 })
@@ -2795,18 +2731,26 @@
    (match_operand:SI 2 "immediate_operand" "")]
   "TARGET_NEON"
 {
-  switch (INTVAL (operands[2]))
+  int lane;
+
+if (BYTES_BIG_ENDIAN)
     {
-    case 0:
-      emit_move_insn (operands[0], gen_lowpart (DImode, operands[1]));
-      break;
-    case 1:
-      emit_move_insn (operands[0], gen_highpart (DImode, operands[1]));
-      break;
-    default:
-      neon_lane_bounds (operands[2], 0, 1);
-      FAIL;
+      /* The intrinsics are defined in terms of a model where the
+	 element ordering in memory is vldm order, whereas the generic
+	 RTL is defined in terms of a model where the element ordering
+	 in memory is array order.  Convert the lane number to conform
+	 to this model.  */
+      unsigned int elt = INTVAL (operands[2]);
+      unsigned int reg_nelts = 2;
+      elt ^= reg_nelts - 1;
+      operands[2] = GEN_INT (elt);
     }
+
+  lane = INTVAL (operands[2]);
+  gcc_assert ((lane ==0) || (lane == 1));
+  emit_move_insn (operands[0], lane == 0
+				? gen_lowpart (DImode, operands[1])
+				: gen_highpart (DImode, operands[1]));
   DONE;
 })
 
@@ -2818,7 +2762,6 @@
   "TARGET_NEON"
 {
   unsigned int elt = INTVAL (operands[3]);
-  neon_lane_bounds (operands[3], 0, GET_MODE_NUNITS (<MODE>mode));
 
   if (BYTES_BIG_ENDIAN)
     {
@@ -2841,13 +2784,12 @@
    (match_operand:SI 3 "immediate_operand" "i")]
   "TARGET_NEON"
 {
-  neon_lane_bounds (operands[3], 0, 1);
   emit_move_insn (operands[0], operands[1]);
   DONE;
 })
 
 (define_expand "neon_vcreate<mode>"
-  [(match_operand:VDX 0 "s_register_operand" "")
+  [(match_operand:VD_RE 0 "s_register_operand" "")
    (match_operand:DI 1 "general_operand" "")]
   "TARGET_NEON"
 {
@@ -2923,7 +2865,6 @@
    (match_operand:SI 2 "immediate_operand" "i")]
   "TARGET_NEON"
 {
-  neon_lane_bounds (operands[2], 0, GET_MODE_NUNITS (<V_double_vector_mode>mode));
   if (BYTES_BIG_ENDIAN)
     {
       unsigned int elt = INTVAL (operands[2]);
@@ -2944,7 +2885,6 @@
    (match_operand:SI 2 "immediate_operand" "i")]
   "TARGET_NEON"
 {
-  neon_lane_bounds (operands[2], 0, 1);
   emit_move_insn (operands[0], operands[1]);
   DONE;
 })
@@ -2956,7 +2896,6 @@
    (match_operand:SI 2 "immediate_operand" "i")]
   "TARGET_NEON"
 {
-  neon_lane_bounds (operands[2], 0, 1);
   emit_insn (gen_neon_vdup_nv2di (operands[0], operands[1]));
   DONE;
 })
@@ -3156,7 +3095,6 @@
                     UNSPEC_VMUL_LANE))]
   "TARGET_NEON"
 {
-  neon_lane_bounds (operands[3], 0, GET_MODE_NUNITS (<MODE>mode));
   return "vmul.<V_if_elem>\t%P0, %P1, %P2[%c3]";
 }
   [(set (attr "type")
@@ -3174,7 +3112,6 @@
                     UNSPEC_VMUL_LANE))]
   "TARGET_NEON"
 {
-  neon_lane_bounds (operands[3], 0, GET_MODE_NUNITS (<V_HALF>mode));
   return "vmul.<V_if_elem>\t%q0, %q1, %P2[%c3]";
 }
   [(set (attr "type")
@@ -3192,7 +3129,6 @@
                           VMULL_LANE))]
   "TARGET_NEON"
 {
-  neon_lane_bounds (operands[3], 0, GET_MODE_NUNITS (<MODE>mode));
   return "vmull.<sup>%#<V_sz_elem>\t%q0, %P1, %P2[%c3]";
 }
   [(set_attr "type" "neon_mul_<V_elem_ch>_scalar_long")]
@@ -3207,7 +3143,6 @@
                           UNSPEC_VQDMULL_LANE))]
   "TARGET_NEON"
 {
-  neon_lane_bounds (operands[3], 0, GET_MODE_NUNITS (<MODE>mode));
   return "vqdmull.<V_s_elem>\t%q0, %P1, %P2[%c3]";
 }
   [(set_attr "type" "neon_sat_mul_<V_elem_ch>_scalar_long")]
@@ -3222,7 +3157,6 @@
                       VQDMULH_LANE))]
   "TARGET_NEON"
 {
-  neon_lane_bounds (operands[3], 0, GET_MODE_NUNITS (<MODE>mode));
   return "vq<r>dmulh.<V_s_elem>\t%q0, %q1, %P2[%c3]";
 }
   [(set_attr "type" "neon_sat_mul_<V_elem_ch>_scalar_q")]
@@ -3237,7 +3171,6 @@
                       VQDMULH_LANE))]
   "TARGET_NEON"
 {
-  neon_lane_bounds (operands[3], 0, GET_MODE_NUNITS (<MODE>mode));
   return "vq<r>dmulh.<V_s_elem>\t%P0, %P1, %P2[%c3]";
 }
   [(set_attr "type" "neon_sat_mul_<V_elem_ch>_scalar_q")]
@@ -3253,7 +3186,6 @@
                      UNSPEC_VMLA_LANE))]
   "TARGET_NEON"
 {
-  neon_lane_bounds (operands[4], 0, GET_MODE_NUNITS (<MODE>mode));
   return "vmla.<V_if_elem>\t%P0, %P2, %P3[%c4]";
 }
   [(set (attr "type")
@@ -3272,7 +3204,6 @@
                      UNSPEC_VMLA_LANE))]
   "TARGET_NEON"
 {
-  neon_lane_bounds (operands[4], 0, GET_MODE_NUNITS (<MODE>mode));
   return "vmla.<V_if_elem>\t%q0, %q2, %P3[%c4]";
 }
   [(set (attr "type")
@@ -3291,7 +3222,6 @@
                           VMLAL_LANE))]
   "TARGET_NEON"
 {
-  neon_lane_bounds (operands[4], 0, GET_MODE_NUNITS (<MODE>mode));
   return "vmlal.<sup>%#<V_sz_elem>\t%q0, %P2, %P3[%c4]";
 }
   [(set_attr "type" "neon_mla_<V_elem_ch>_scalar_long")]
@@ -3307,7 +3237,6 @@
                           UNSPEC_VQDMLAL_LANE))]
   "TARGET_NEON"
 {
-  neon_lane_bounds (operands[4], 0, GET_MODE_NUNITS (<MODE>mode));
   return "vqdmlal.<V_s_elem>\t%q0, %P2, %P3[%c4]";
 }
   [(set_attr "type" "neon_sat_mla_<V_elem_ch>_scalar_long")]
@@ -3323,7 +3252,6 @@
                     UNSPEC_VMLS_LANE))]
   "TARGET_NEON"
 {
-  neon_lane_bounds (operands[4], 0, GET_MODE_NUNITS (<MODE>mode));
   return "vmls.<V_if_elem>\t%P0, %P2, %P3[%c4]";
 }
   [(set (attr "type")
@@ -3342,7 +3270,6 @@
                     UNSPEC_VMLS_LANE))]
   "TARGET_NEON"
 {
-  neon_lane_bounds (operands[4], 0, GET_MODE_NUNITS (<MODE>mode));
   return "vmls.<V_if_elem>\t%q0, %q2, %P3[%c4]";
 }
   [(set (attr "type")
@@ -3361,7 +3288,6 @@
                           VMLSL_LANE))]
   "TARGET_NEON"
 {
-  neon_lane_bounds (operands[4], 0, GET_MODE_NUNITS (<MODE>mode));
   return "vmlsl.<sup>%#<V_sz_elem>\t%q0, %P2, %P3[%c4]";
 }
   [(set_attr "type" "neon_mla_<V_elem_ch>_scalar_long")]
@@ -3377,7 +3303,6 @@
                           UNSPEC_VQDMLSL_LANE))]
   "TARGET_NEON"
 {
-  neon_lane_bounds (operands[4], 0, GET_MODE_NUNITS (<MODE>mode));
   return "vqdmlsl.<V_s_elem>\t%q0, %P2, %P3[%c4]";
 }
   [(set_attr "type" "neon_sat_mla_<V_elem_ch>_scalar_long")]
@@ -4149,11 +4074,11 @@
 
 ;; Note: Different operand numbering to handle tied registers correctly.
 (define_insn "*neon_vtrn<mode>_insn"
-  [(set (match_operand:VDQW 0 "s_register_operand" "=w")
+  [(set (match_operand:VDQW 0 "s_register_operand" "=&w")
         (unspec:VDQW [(match_operand:VDQW 1 "s_register_operand" "0")
                       (match_operand:VDQW 3 "s_register_operand" "2")]
                      UNSPEC_VTRN1))
-   (set (match_operand:VDQW 2 "s_register_operand" "=w")
+   (set (match_operand:VDQW 2 "s_register_operand" "=&w")
          (unspec:VDQW [(match_dup 1) (match_dup 3)]
                      UNSPEC_VTRN2))]
   "TARGET_NEON"
@@ -4175,11 +4100,11 @@
 
 ;; Note: Different operand numbering to handle tied registers correctly.
 (define_insn "*neon_vzip<mode>_insn"
-  [(set (match_operand:VDQW 0 "s_register_operand" "=w")
+  [(set (match_operand:VDQW 0 "s_register_operand" "=&w")
         (unspec:VDQW [(match_operand:VDQW 1 "s_register_operand" "0")
                       (match_operand:VDQW 3 "s_register_operand" "2")]
                      UNSPEC_VZIP1))
-   (set (match_operand:VDQW 2 "s_register_operand" "=w")
+   (set (match_operand:VDQW 2 "s_register_operand" "=&w")
         (unspec:VDQW [(match_dup 1) (match_dup 3)]
                      UNSPEC_VZIP2))]
   "TARGET_NEON"
@@ -4201,11 +4126,11 @@
 
 ;; Note: Different operand numbering to handle tied registers correctly.
 (define_insn "*neon_vuzp<mode>_insn"
-  [(set (match_operand:VDQW 0 "s_register_operand" "=w")
+  [(set (match_operand:VDQW 0 "s_register_operand" "=&w")
         (unspec:VDQW [(match_operand:VDQW 1 "s_register_operand" "0")
                       (match_operand:VDQW 3 "s_register_operand" "2")]
                      UNSPEC_VUZP1))
-   (set (match_operand:VDQW 2 "s_register_operand" "=w")
+   (set (match_operand:VDQW 2 "s_register_operand" "=&w")
         (unspec:VDQW [(match_dup 1) (match_dup 3)]
                      UNSPEC_VUZP2))]
   "TARGET_NEON"
@@ -4215,7 +4140,7 @@
 
 (define_expand "neon_vreinterpretv8qi<mode>"
   [(match_operand:V8QI 0 "s_register_operand" "")
-   (match_operand:VDX 1 "s_register_operand" "")]
+   (match_operand:VD_RE 1 "s_register_operand" "")]
   "TARGET_NEON"
 {
   neon_reinterpret (operands[0], operands[1]);
@@ -4224,7 +4149,7 @@
 
 (define_expand "neon_vreinterpretv4hi<mode>"
   [(match_operand:V4HI 0 "s_register_operand" "")
-   (match_operand:VDX 1 "s_register_operand" "")]
+   (match_operand:VD_RE 1 "s_register_operand" "")]
   "TARGET_NEON"
 {
   neon_reinterpret (operands[0], operands[1]);
@@ -4233,7 +4158,7 @@
 
 (define_expand "neon_vreinterpretv2si<mode>"
   [(match_operand:V2SI 0 "s_register_operand" "")
-   (match_operand:VDX 1 "s_register_operand" "")]
+   (match_operand:VD_RE 1 "s_register_operand" "")]
   "TARGET_NEON"
 {
   neon_reinterpret (operands[0], operands[1]);
@@ -4242,7 +4167,7 @@
 
 (define_expand "neon_vreinterpretv2sf<mode>"
   [(match_operand:V2SF 0 "s_register_operand" "")
-   (match_operand:VDX 1 "s_register_operand" "")]
+   (match_operand:VD_RE 1 "s_register_operand" "")]
   "TARGET_NEON"
 {
   neon_reinterpret (operands[0], operands[1]);
@@ -4251,7 +4176,7 @@
 
 (define_expand "neon_vreinterpretdi<mode>"
   [(match_operand:DI 0 "s_register_operand" "")
-   (match_operand:VDX 1 "s_register_operand" "")]
+   (match_operand:VD_RE 1 "s_register_operand" "")]
   "TARGET_NEON"
 {
   neon_reinterpret (operands[0], operands[1]);
@@ -4510,14 +4435,14 @@
 (define_expand "vec_load_lanesoi<mode>"
   [(set (match_operand:OI 0 "s_register_operand")
         (unspec:OI [(match_operand:OI 1 "neon_struct_operand")
-                    (unspec:VQ [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
+                    (unspec:VQ2 [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
 		   UNSPEC_VLD2))]
   "TARGET_NEON")
 
 (define_insn "neon_vld2<mode>"
   [(set (match_operand:OI 0 "s_register_operand" "=w")
         (unspec:OI [(match_operand:OI 1 "neon_struct_operand" "Um")
-                    (unspec:VQ [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
+                    (unspec:VQ2 [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
                    UNSPEC_VLD2))]
   "TARGET_NEON"
   "vld2.<V_sz_elem>\t%h0, %A1"
@@ -4528,7 +4453,7 @@
         (unspec:TI [(match_operand:<V_two_elem> 1 "neon_struct_operand" "Um")
                     (match_operand:TI 2 "s_register_operand" "0")
                     (match_operand:SI 3 "immediate_operand" "i")
-                    (unspec:VD [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
+                    (unspec:VD_LANE [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
                    UNSPEC_VLD2_LANE))]
   "TARGET_NEON"
 {
@@ -4553,7 +4478,7 @@
         (unspec:OI [(match_operand:<V_two_elem> 1 "neon_struct_operand" "Um")
                     (match_operand:OI 2 "s_register_operand" "0")
                     (match_operand:SI 3 "immediate_operand" "i")
-                    (unspec:VMQ [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
+                    (unspec:VQ_HS [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
                    UNSPEC_VLD2_LANE))]
   "TARGET_NEON"
 {
@@ -4624,14 +4549,14 @@
 (define_expand "vec_store_lanesoi<mode>"
   [(set (match_operand:OI 0 "neon_struct_operand")
 	(unspec:OI [(match_operand:OI 1 "s_register_operand")
-                    (unspec:VQ [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
+                    (unspec:VQ2 [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
                    UNSPEC_VST2))]
   "TARGET_NEON")
 
 (define_insn "neon_vst2<mode>"
   [(set (match_operand:OI 0 "neon_struct_operand" "=Um")
 	(unspec:OI [(match_operand:OI 1 "s_register_operand" "w")
-		    (unspec:VQ [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
+		    (unspec:VQ2 [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
 		   UNSPEC_VST2))]
   "TARGET_NEON"
   "vst2.<V_sz_elem>\t%h1, %A0"
@@ -4643,7 +4568,7 @@
 	(unspec:<V_two_elem>
 	  [(match_operand:TI 1 "s_register_operand" "w")
 	   (match_operand:SI 2 "immediate_operand" "i")
-	   (unspec:VD [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
+	   (unspec:VD_LANE [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
 	  UNSPEC_VST2_LANE))]
   "TARGET_NEON"
 {
@@ -4668,7 +4593,7 @@
         (unspec:<V_two_elem>
            [(match_operand:OI 1 "s_register_operand" "w")
             (match_operand:SI 2 "immediate_operand" "i")
-            (unspec:VMQ [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
+            (unspec:VQ_HS [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
            UNSPEC_VST2_LANE))]
   "TARGET_NEON"
 {
@@ -4721,7 +4646,7 @@
 (define_expand "vec_load_lanesci<mode>"
   [(match_operand:CI 0 "s_register_operand")
    (match_operand:CI 1 "neon_struct_operand")
-   (unspec:VQ [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
+   (unspec:VQ2 [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
   "TARGET_NEON"
 {
   emit_insn (gen_neon_vld3<mode> (operands[0], operands[1]));
@@ -4731,7 +4656,7 @@
 (define_expand "neon_vld3<mode>"
   [(match_operand:CI 0 "s_register_operand")
    (match_operand:CI 1 "neon_struct_operand")
-   (unspec:VQ [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
+   (unspec:VQ2 [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
   "TARGET_NEON"
 {
   rtx mem;
@@ -4746,7 +4671,7 @@
 (define_insn "neon_vld3qa<mode>"
   [(set (match_operand:CI 0 "s_register_operand" "=w")
         (unspec:CI [(match_operand:EI 1 "neon_struct_operand" "Um")
-                    (unspec:VQ [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
+                    (unspec:VQ2 [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
                    UNSPEC_VLD3A))]
   "TARGET_NEON"
 {
@@ -4766,7 +4691,7 @@
   [(set (match_operand:CI 0 "s_register_operand" "=w")
         (unspec:CI [(match_operand:EI 1 "neon_struct_operand" "Um")
                     (match_operand:CI 2 "s_register_operand" "0")
-                    (unspec:VQ [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
+                    (unspec:VQ2 [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
                    UNSPEC_VLD3B))]
   "TARGET_NEON"
 {
@@ -4787,7 +4712,7 @@
         (unspec:EI [(match_operand:<V_three_elem> 1 "neon_struct_operand" "Um")
                     (match_operand:EI 2 "s_register_operand" "0")
                     (match_operand:SI 3 "immediate_operand" "i")
-                    (unspec:VD [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
+                    (unspec:VD_LANE [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
                    UNSPEC_VLD3_LANE))]
   "TARGET_NEON"
 {
@@ -4814,7 +4739,7 @@
         (unspec:CI [(match_operand:<V_three_elem> 1 "neon_struct_operand" "Um")
                     (match_operand:CI 2 "s_register_operand" "0")
                     (match_operand:SI 3 "immediate_operand" "i")
-                    (unspec:VMQ [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
+                    (unspec:VQ_HS [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
                    UNSPEC_VLD3_LANE))]
   "TARGET_NEON"
 {
@@ -4894,7 +4819,7 @@
 (define_expand "vec_store_lanesci<mode>"
   [(match_operand:CI 0 "neon_struct_operand")
    (match_operand:CI 1 "s_register_operand")
-   (unspec:VQ [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
+   (unspec:VQ2 [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
   "TARGET_NEON"
 {
   emit_insn (gen_neon_vst3<mode> (operands[0], operands[1]));
@@ -4904,7 +4829,7 @@
 (define_expand "neon_vst3<mode>"
   [(match_operand:CI 0 "neon_struct_operand")
    (match_operand:CI 1 "s_register_operand")
-   (unspec:VQ [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
+   (unspec:VQ2 [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
   "TARGET_NEON"
 {
   rtx mem;
@@ -4919,7 +4844,7 @@
 (define_insn "neon_vst3qa<mode>"
   [(set (match_operand:EI 0 "neon_struct_operand" "=Um")
         (unspec:EI [(match_operand:CI 1 "s_register_operand" "w")
-                    (unspec:VQ [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
+                    (unspec:VQ2 [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
                    UNSPEC_VST3A))]
   "TARGET_NEON"
 {
@@ -4938,7 +4863,7 @@
 (define_insn "neon_vst3qb<mode>"
   [(set (match_operand:EI 0 "neon_struct_operand" "=Um")
         (unspec:EI [(match_operand:CI 1 "s_register_operand" "w")
-                    (unspec:VQ [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
+                    (unspec:VQ2 [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
                    UNSPEC_VST3B))]
   "TARGET_NEON"
 {
@@ -4959,7 +4884,7 @@
         (unspec:<V_three_elem>
            [(match_operand:EI 1 "s_register_operand" "w")
             (match_operand:SI 2 "immediate_operand" "i")
-            (unspec:VD [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
+            (unspec:VD_LANE [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
            UNSPEC_VST3_LANE))]
   "TARGET_NEON"
 {
@@ -4986,7 +4911,7 @@
         (unspec:<V_three_elem>
            [(match_operand:CI 1 "s_register_operand" "w")
             (match_operand:SI 2 "immediate_operand" "i")
-            (unspec:VMQ [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
+            (unspec:VQ_HS [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
            UNSPEC_VST3_LANE))]
   "TARGET_NEON"
 {
@@ -5041,7 +4966,7 @@
 (define_expand "vec_load_lanesxi<mode>"
   [(match_operand:XI 0 "s_register_operand")
    (match_operand:XI 1 "neon_struct_operand")
-   (unspec:VQ [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
+   (unspec:VQ2 [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
   "TARGET_NEON"
 {
   emit_insn (gen_neon_vld4<mode> (operands[0], operands[1]));
@@ -5051,7 +4976,7 @@
 (define_expand "neon_vld4<mode>"
   [(match_operand:XI 0 "s_register_operand")
    (match_operand:XI 1 "neon_struct_operand")
-   (unspec:VQ [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
+   (unspec:VQ2 [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
   "TARGET_NEON"
 {
   rtx mem;
@@ -5066,7 +4991,7 @@
 (define_insn "neon_vld4qa<mode>"
   [(set (match_operand:XI 0 "s_register_operand" "=w")
         (unspec:XI [(match_operand:OI 1 "neon_struct_operand" "Um")
-                    (unspec:VQ [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
+                    (unspec:VQ2 [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
                    UNSPEC_VLD4A))]
   "TARGET_NEON"
 {
@@ -5087,7 +5012,7 @@
   [(set (match_operand:XI 0 "s_register_operand" "=w")
         (unspec:XI [(match_operand:OI 1 "neon_struct_operand" "Um")
                     (match_operand:XI 2 "s_register_operand" "0")
-                    (unspec:VQ [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
+                    (unspec:VQ2 [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
                    UNSPEC_VLD4B))]
   "TARGET_NEON"
 {
@@ -5109,7 +5034,7 @@
         (unspec:OI [(match_operand:<V_four_elem> 1 "neon_struct_operand" "Um")
                     (match_operand:OI 2 "s_register_operand" "0")
                     (match_operand:SI 3 "immediate_operand" "i")
-                    (unspec:VD [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
+                    (unspec:VD_LANE [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
                    UNSPEC_VLD4_LANE))]
   "TARGET_NEON"
 {
@@ -5137,7 +5062,7 @@
         (unspec:XI [(match_operand:<V_four_elem> 1 "neon_struct_operand" "Um")
                     (match_operand:XI 2 "s_register_operand" "0")
                     (match_operand:SI 3 "immediate_operand" "i")
-                    (unspec:VMQ [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
+                    (unspec:VQ_HS [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
                    UNSPEC_VLD4_LANE))]
   "TARGET_NEON"
 {
@@ -5222,7 +5147,7 @@
 (define_expand "vec_store_lanesxi<mode>"
   [(match_operand:XI 0 "neon_struct_operand")
    (match_operand:XI 1 "s_register_operand")
-   (unspec:VQ [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
+   (unspec:VQ2 [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
   "TARGET_NEON"
 {
   emit_insn (gen_neon_vst4<mode> (operands[0], operands[1]));
@@ -5232,7 +5157,7 @@
 (define_expand "neon_vst4<mode>"
   [(match_operand:XI 0 "neon_struct_operand")
    (match_operand:XI 1 "s_register_operand")
-   (unspec:VQ [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
+   (unspec:VQ2 [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
   "TARGET_NEON"
 {
   rtx mem;
@@ -5247,7 +5172,7 @@
 (define_insn "neon_vst4qa<mode>"
   [(set (match_operand:OI 0 "neon_struct_operand" "=Um")
         (unspec:OI [(match_operand:XI 1 "s_register_operand" "w")
-                    (unspec:VQ [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
+                    (unspec:VQ2 [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
                    UNSPEC_VST4A))]
   "TARGET_NEON"
 {
@@ -5267,7 +5192,7 @@
 (define_insn "neon_vst4qb<mode>"
   [(set (match_operand:OI 0 "neon_struct_operand" "=Um")
         (unspec:OI [(match_operand:XI 1 "s_register_operand" "w")
-                    (unspec:VQ [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
+                    (unspec:VQ2 [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
                    UNSPEC_VST4B))]
   "TARGET_NEON"
 {
@@ -5289,7 +5214,7 @@
         (unspec:<V_four_elem>
            [(match_operand:OI 1 "s_register_operand" "w")
             (match_operand:SI 2 "immediate_operand" "i")
-            (unspec:VD [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
+            (unspec:VD_LANE [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
            UNSPEC_VST4_LANE))]
   "TARGET_NEON"
 {
@@ -5317,7 +5242,7 @@
         (unspec:<V_four_elem>
            [(match_operand:XI 1 "s_register_operand" "w")
             (match_operand:SI 2 "immediate_operand" "i")
-            (unspec:VMQ [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
+            (unspec:VQ_HS [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
            UNSPEC_VST4_LANE))]
   "TARGET_NEON"
 {
--- a/src/gcc/config/arm/sync.md
+++ b/src/gcc/config/arm/sync.md
@@ -50,14 +50,11 @@
   {
     if (TARGET_HAVE_DMB)
       {
-	/* Note we issue a system level barrier. We should consider issuing
-	   a inner shareabilty zone barrier here instead, ie. "DMB ISH".  */
-	/* ??? Differentiate based on SEQ_CST vs less strict?  */
-	return "dmb\tsy";
+	return "dmb\\tish";
       }
 
     if (TARGET_HAVE_DMB_MCR)
-      return "mcr\tp15, 0, r0, c7, c10, 5";
+      return "mcr\\tp15, 0, r0, c7, c10, 5";
 
     gcc_unreachable ();
   }
--- a/src/gcc/config/arm/thumb2.md
+++ b/src/gcc/config/arm/thumb2.md
@@ -300,7 +300,7 @@
    ldr%?\\t%0, %1
    str%?\\t%1, %0
    str%?\\t%1, %0"
-  [(set_attr "type" "mov_reg,alu_imm,alu_imm,alu_imm,mov_imm,load1,load1,store1,store1")
+  [(set_attr "type" "mov_reg,mov_imm,mov_imm,mvn_imm,mov_imm,load1,load1,store1,store1")
    (set_attr "length" "2,4,2,4,4,4,4,4,4")
    (set_attr "predicable" "yes")
    (set_attr "predicable_short_it" "yes,no,yes,no,no,no,no,no,no")
@@ -486,12 +486,12 @@
 )
 
 (define_insn_and_split "*thumb2_movsicc_insn"
-  [(set (match_operand:SI 0 "s_register_operand" "=l,l,r,r,r,r,r,r,r,r,r")
+  [(set (match_operand:SI 0 "s_register_operand" "=l,l,r,r,r,r,r,r,r,r,r,r")
 	(if_then_else:SI
 	 (match_operator 3 "arm_comparison_operator"
 	  [(match_operand 4 "cc_register" "") (const_int 0)])
-	 (match_operand:SI 1 "arm_not_operand" "0 ,lPy,0 ,0,rI,K,rI,rI,K ,K,r")
-	 (match_operand:SI 2 "arm_not_operand" "lPy,0 ,rI,K,0 ,0,rI,K ,rI,K,r")))]
+	 (match_operand:SI 1 "arm_not_operand" "0 ,lPy,0 ,0,rI,K,I ,r,rI,K ,K,r")
+	 (match_operand:SI 2 "arm_not_operand" "lPy,0 ,rI,K,0 ,0,rI,I,K ,rI,K,r")))]
   "TARGET_THUMB2"
   "@
    it\\t%D3\;mov%D3\\t%0, %2
@@ -504,12 +504,14 @@
    #
    #
    #
+   #
    #"
    ; alt 6: ite\\t%d3\;mov%d3\\t%0, %1\;mov%D3\\t%0, %2
-   ; alt 7: ite\\t%d3\;mov%d3\\t%0, %1\;mvn%D3\\t%0, #%B2
-   ; alt 8: ite\\t%d3\;mvn%d3\\t%0, #%B1\;mov%D3\\t%0, %2
-   ; alt 9: ite\\t%d3\;mvn%d3\\t%0, #%B1\;mvn%D3\\t%0, #%B2
-   ; alt 10: ite\\t%d3\;mov%d3\\t%0, %1\;mov%D3\\t%0, %2
+   ; alt 7: ite\\t%d3\;mov%d3\\t%0, %1\;mov%D3\\t%0, %2
+   ; alt 8: ite\\t%d3\;mov%d3\\t%0, %1\;mvn%D3\\t%0, #%B2
+   ; alt 9: ite\\t%d3\;mvn%d3\\t%0, #%B1\;mov%D3\\t%0, %2
+   ; alt 10: ite\\t%d3\;mvn%d3\\t%0, #%B1\;mvn%D3\\t%0, #%B2
+   ; alt 11: ite\\t%d3\;mov%d3\\t%0, %1\;mov%D3\\t%0, %2
   "&& reload_completed"
   [(const_int 0)]
   {
@@ -540,10 +542,30 @@
                                                operands[2])));
     DONE;
   }
-  [(set_attr "length" "4,4,6,6,6,6,10,10,10,10,6")
-   (set_attr "enabled_for_depr_it" "yes,yes,no,no,no,no,no,no,no,no,yes")
+  [(set_attr "length" "4,4,6,6,6,6,10,8,10,10,10,6")
+   (set_attr "enabled_for_depr_it" "yes,yes,no,no,no,no,no,no,no,no,no,yes")
    (set_attr "conds" "use")
-   (set_attr "type" "multiple")]
+   (set_attr_alternative "type"
+                         [(if_then_else (match_operand 2 "const_int_operand" "")
+                                        (const_string "mov_imm")
+                                        (const_string "mov_reg"))
+                          (if_then_else (match_operand 1 "const_int_operand" "")
+                                        (const_string "mov_imm")
+                                        (const_string "mov_reg"))
+                          (if_then_else (match_operand 2 "const_int_operand" "")
+                                        (const_string "mov_imm")
+                                        (const_string "mov_reg"))
+                          (const_string "mvn_imm")
+                          (if_then_else (match_operand 1 "const_int_operand" "")
+                                        (const_string "mov_imm")
+                                        (const_string "mov_reg"))
+                          (const_string "mvn_imm")
+                          (const_string "multiple")
+                          (const_string "multiple")
+                          (const_string "multiple")
+                          (const_string "multiple")
+                          (const_string "multiple")
+                          (const_string "multiple")])]
 )
 
 (define_insn "*thumb2_movsfcc_soft_insn"
@@ -1182,7 +1204,11 @@
   "
   [(set_attr "predicable" "yes")
    (set_attr "length" "2")
-   (set_attr "type" "alu_sreg")]
+   (set_attr_alternative "type"
+                         [(if_then_else (match_operand 2 "const_int_operand" "")
+                                        (const_string "alu_imm")
+                                        (const_string "alu_sreg"))
+                          (const_string "alu_imm")])]
 )
 
 (define_insn "*thumb2_subsi_short"
@@ -1247,14 +1273,21 @@
   "
   [(set_attr "conds" "set")
    (set_attr "length" "2,2,4")
-   (set_attr "type" "alu_sreg")]
+   (set_attr_alternative "type"
+                         [(if_then_else (match_operand 2 "const_int_operand" "")
+                                        (const_string "alus_imm")
+                                        (const_string "alus_sreg"))
+                          (const_string "alus_imm")
+                          (if_then_else (match_operand 2 "const_int_operand" "")
+                                        (const_string "alus_imm")
+                                        (const_string "alus_sreg"))])]
 )
 
 (define_insn "*thumb2_addsi3_compare0_scratch"
   [(set (reg:CC_NOOV CC_REGNUM)
 	(compare:CC_NOOV
-	  (plus:SI (match_operand:SI 0 "s_register_operand" "l,l,  r,r")
-		   (match_operand:SI 1 "arm_add_operand"    "Pv,l,IL,r"))
+	  (plus:SI (match_operand:SI 0 "s_register_operand" "l,  r")
+		   (match_operand:SI 1 "arm_add_operand"    "lPv,rIL"))
 	  (const_int 0)))]
   "TARGET_THUMB2"
   "*
@@ -1271,8 +1304,10 @@
       return \"cmn\\t%0, %1\";
   "
   [(set_attr "conds" "set")
-   (set_attr "length" "2,2,4,4")
-   (set_attr "type" "alus_imm,alus_sreg,alus_imm,alus_sreg")]
+   (set_attr "length" "2,4")
+   (set (attr "type") (if_then_else (match_operand 1 "const_int_operand" "")
+                                    (const_string "alus_imm")
+                                    (const_string "alus_sreg")))]
 )
 
 (define_insn "*thumb2_mulsi_short"
--- a/src/gcc/config/arm/types.md
+++ b/src/gcc/config/arm/types.md
@@ -375,6 +375,8 @@
 ; neon_from_gp
 ; neon_from_gp_q
 ; neon_ldr
+; neon_ldp
+; neon_ldp_q
 ; neon_load1_1reg
 ; neon_load1_1reg_q
 ; neon_load1_2reg
@@ -408,6 +410,8 @@
 ; neon_load4_one_lane
 ; neon_load4_one_lane_q
 ; neon_str
+; neon_stp
+; neon_stp_q
 ; neon_store1_1reg
 ; neon_store1_1reg_q
 ; neon_store1_2reg
@@ -887,6 +891,8 @@
   neon_from_gp_q,\
 \
   neon_ldr,\
+  neon_ldp,\
+  neon_ldp_q,\
   neon_load1_1reg,\
   neon_load1_1reg_q,\
   neon_load1_2reg,\
@@ -924,6 +930,8 @@
   neon_load4_one_lane_q,\
 \
   neon_str,\
+  neon_stp,\
+  neon_stp_q,\
   neon_store1_1reg,\
   neon_store1_1reg_q,\
   neon_store1_2reg,\
@@ -1126,7 +1134,8 @@
           neon_sat_mla_s_long, neon_sat_mla_h_scalar_long,\
           neon_sat_mla_s_scalar_long,\
           neon_to_gp, neon_to_gp_q, neon_from_gp, neon_from_gp_q,\
-          neon_ldr, neon_load1_1reg, neon_load1_1reg_q, neon_load1_2reg,\
+	   neon_ldr, neon_ldp, neon_ldp_q,\
+	   neon_load1_1reg, neon_load1_1reg_q, neon_load1_2reg,\
           neon_load1_2reg_q, neon_load1_3reg, neon_load1_3reg_q,\
           neon_load1_4reg, neon_load1_4reg_q, neon_load1_all_lanes,\
           neon_load1_all_lanes_q, neon_load1_one_lane, neon_load1_one_lane_q,\
@@ -1137,7 +1146,8 @@
           neon_load3_all_lanes_q, neon_load3_one_lane, neon_load3_one_lane_q,\
           neon_load4_4reg, neon_load4_4reg_q, neon_load4_all_lanes,\
           neon_load4_all_lanes_q, neon_load4_one_lane, neon_load4_one_lane_q,\
-          neon_str, neon_store1_1reg, neon_store1_1reg_q, neon_store1_2reg,\
+	   neon_str, neon_stp, neon_stp_q,\
+	   neon_store1_1reg, neon_store1_1reg_q, neon_store1_2reg,\
           neon_store1_2reg_q, neon_store1_3reg, neon_store1_3reg_q,\
           neon_store1_4reg, neon_store1_4reg_q, neon_store1_one_lane,\
           neon_store1_one_lane_q, neon_store2_2reg, neon_store2_2reg_q,\
@@ -1146,10 +1156,12 @@
           neon_store3_one_lane, neon_store3_one_lane_q, neon_store4_4reg,\
           neon_store4_4reg_q, neon_store4_one_lane, neon_store4_one_lane_q,\
           neon_fp_abd_s, neon_fp_abd_s_q, neon_fp_abd_d, neon_fp_abd_d_q,\
+          neon_fp_abs_s, neon_fp_abs_s_q, neon_fp_abs_d, neon_fp_abs_d_q,\
           neon_fp_addsub_s, neon_fp_addsub_s_q, neon_fp_addsub_d,\
           neon_fp_addsub_d_q, neon_fp_compare_s, neon_fp_compare_s_q,\
           neon_fp_compare_d, neon_fp_compare_d_q, neon_fp_minmax_s,\
           neon_fp_minmax_s_q, neon_fp_minmax_d, neon_fp_minmax_d_q,\
+          neon_fp_neg_s, neon_fp_neg_s_q, neon_fp_neg_d, neon_fp_neg_d_q,\
           neon_fp_reduc_add_s, neon_fp_reduc_add_s_q, neon_fp_reduc_add_d,\
           neon_fp_reduc_add_d_q, neon_fp_reduc_minmax_s,
           neon_fp_reduc_minmax_s_q, neon_fp_reduc_minmax_d,\
@@ -1157,6 +1169,8 @@
           neon_fp_cvt_narrow_s_q, neon_fp_cvt_narrow_d_q,\
           neon_fp_cvt_widen_h, neon_fp_cvt_widen_s, neon_fp_to_int_s,\
           neon_fp_to_int_s_q, neon_int_to_fp_s, neon_int_to_fp_s_q,\
+          neon_fp_to_int_d, neon_fp_to_int_d_q,\
+          neon_int_to_fp_d, neon_int_to_fp_d_q,\
           neon_fp_round_s, neon_fp_round_s_q, neon_fp_recpe_s,\
           neon_fp_recpe_s_q,\
           neon_fp_recpe_d, neon_fp_recpe_d_q, neon_fp_recps_s,\
--- a/src/gcc/config/arm/unknown-elf.h
+++ b/src/gcc/config/arm/unknown-elf.h
@@ -32,7 +32,9 @@
 #define UNKNOWN_ELF_STARTFILE_SPEC	" crti%O%s crtbegin%O%s crt0%O%s"
 
 #undef  STARTFILE_SPEC
-#define STARTFILE_SPEC	UNKNOWN_ELF_STARTFILE_SPEC
+#define STARTFILE_SPEC	\
+  "%{Ofast|ffast-math|funsafe-math-optimizations:crtfastmath.o%s} "	\
+  UNKNOWN_ELF_STARTFILE_SPEC
 
 #define UNKNOWN_ELF_ENDFILE_SPEC	"crtend%O%s crtn%O%s"
 
@@ -80,7 +82,9 @@
 									\
       ASM_OUTPUT_ALIGN (FILE, floor_log2 (ALIGN / BITS_PER_UNIT));	\
       ASM_OUTPUT_LABEL (FILE, NAME);					\
-      fprintf (FILE, "\t.space\t%d\n", SIZE ? (int)(SIZE) : 1);		\
+      fprintf (FILE, "\t.space\t%d\n", SIZE ? (int) SIZE : 1);		\
+      fprintf (FILE, "\t.size\t%s, %d\n",				\
+	       NAME, SIZE ? (int) SIZE : 1);				\
     }									\
   while (0)
 
--- a/src/gcc/config/arm/vxworks.h
+++ b/src/gcc/config/arm/vxworks.h
@@ -40,7 +40,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
       builtin_define ("CPU=ARMARCH5");		\
     else if (arm_arch4)				\
       {						\
-	if (thumb_code)				\
+	if (TARGET_THUMB)			\
 	  builtin_define ("CPU=ARMARCH4_T");	\
 	else					\
 	  builtin_define ("CPU=ARMARCH4");	\
--- a/src/gcc/config/c6x/c6x.c
+++ b/src/gcc/config/c6x/c6x.c
@@ -3532,7 +3532,7 @@ try_rename_operands (rtx_insn *head, rtx_insn *tail, unit_req_table reqs,
   best_reg =
     find_rename_reg (this_head, super_class, &unavailable, old_reg, true);
 
-  regrename_do_replace (this_head, best_reg);
+  gcc_assert (regrename_do_replace (this_head, best_reg));
 
   count_unit_reqs (new_reqs, head, PREV_INSN (tail));
   merge_unit_reqs (new_reqs);
@@ -3545,7 +3545,7 @@ try_rename_operands (rtx_insn *head, rtx_insn *tail, unit_req_table reqs,
 	       unit_req_imbalance (reqs), unit_req_imbalance (new_reqs));
     }
   if (unit_req_imbalance (new_reqs) > unit_req_imbalance (reqs))
-    regrename_do_replace (this_head, old_reg);
+    gcc_assert (regrename_do_replace (this_head, old_reg));
   else
     memcpy (reqs, new_reqs, sizeof (unit_req_table));
 
--- a/src/gcc/config/glibc-stdint.h
+++ b/src/gcc/config/glibc-stdint.h
@@ -22,6 +22,12 @@ a copy of the GCC Runtime Library Exception along with this program;
 see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 <http://www.gnu.org/licenses/>.  */
 
+/* Systems using musl libc should use this header and make sure
+   OPTION_MUSL is defined correctly before using the TYPE macros. */
+#ifndef OPTION_MUSL
+#define OPTION_MUSL 0
+#endif
+
 #define SIG_ATOMIC_TYPE "int"
 
 #define INT8_TYPE "signed char"
@@ -43,12 +49,12 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #define UINT_LEAST64_TYPE (LONG_TYPE_SIZE == 64 ? "long unsigned int" : "long long unsigned int")
 
 #define INT_FAST8_TYPE "signed char"
-#define INT_FAST16_TYPE (LONG_TYPE_SIZE == 64 ? "long int" : "int")
-#define INT_FAST32_TYPE (LONG_TYPE_SIZE == 64 ? "long int" : "int")
+#define INT_FAST16_TYPE (LONG_TYPE_SIZE == 64 && !OPTION_MUSL ? "long int" : "int")
+#define INT_FAST32_TYPE (LONG_TYPE_SIZE == 64 && !OPTION_MUSL ? "long int" : "int")
 #define INT_FAST64_TYPE (LONG_TYPE_SIZE == 64 ? "long int" : "long long int")
 #define UINT_FAST8_TYPE "unsigned char"
-#define UINT_FAST16_TYPE (LONG_TYPE_SIZE == 64 ? "long unsigned int" : "unsigned int")
-#define UINT_FAST32_TYPE (LONG_TYPE_SIZE == 64 ? "long unsigned int" : "unsigned int")
+#define UINT_FAST16_TYPE (LONG_TYPE_SIZE == 64 && !OPTION_MUSL ? "long unsigned int" : "unsigned int")
+#define UINT_FAST32_TYPE (LONG_TYPE_SIZE == 64 && !OPTION_MUSL ? "long unsigned int" : "unsigned int")
 #define UINT_FAST64_TYPE (LONG_TYPE_SIZE == 64 ? "long unsigned int" : "long long unsigned int")
 
 #define INTPTR_TYPE (LONG_TYPE_SIZE == 64 ? "long int" : "int")
--- a/src/gcc/config/linux.h
+++ b/src/gcc/config/linux.h
@@ -32,10 +32,14 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #define OPTION_GLIBC  (DEFAULT_LIBC == LIBC_GLIBC)
 #define OPTION_UCLIBC (DEFAULT_LIBC == LIBC_UCLIBC)
 #define OPTION_BIONIC (DEFAULT_LIBC == LIBC_BIONIC)
+#undef OPTION_MUSL
+#define OPTION_MUSL   (DEFAULT_LIBC == LIBC_MUSL)
 #else
 #define OPTION_GLIBC  (linux_libc == LIBC_GLIBC)
 #define OPTION_UCLIBC (linux_libc == LIBC_UCLIBC)
 #define OPTION_BIONIC (linux_libc == LIBC_BIONIC)
+#undef OPTION_MUSL
+#define OPTION_MUSL   (linux_libc == LIBC_MUSL)
 #endif
 
 #define GNU_USER_TARGET_OS_CPP_BUILTINS()			\
@@ -50,21 +54,25 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
     } while (0)
 
 /* Determine which dynamic linker to use depending on whether GLIBC or
-   uClibc or Bionic is the default C library and whether
-   -muclibc or -mglibc or -mbionic has been passed to change the default.  */
+   uClibc or Bionic or musl is the default C library and whether
+   -muclibc or -mglibc or -mbionic or -mmusl has been passed to change
+   the default.  */
 
-#define CHOOSE_DYNAMIC_LINKER1(LIBC1, LIBC2, LIBC3, LD1, LD2, LD3)	\
-  "%{" LIBC2 ":" LD2 ";:%{" LIBC3 ":" LD3 ";:" LD1 "}}"
+#define CHOOSE_DYNAMIC_LINKER1(LIBC1, LIBC2, LIBC3, LIBC4, LD1, LD2, LD3, LD4)	\
+  "%{" LIBC2 ":" LD2 ";:%{" LIBC3 ":" LD3 ";:%{" LIBC4 ":" LD4 ";:" LD1 "}}}"
 
 #if DEFAULT_LIBC == LIBC_GLIBC
-#define CHOOSE_DYNAMIC_LINKER(G, U, B) \
-  CHOOSE_DYNAMIC_LINKER1 ("mglibc", "muclibc", "mbionic", G, U, B)
+#define CHOOSE_DYNAMIC_LINKER(G, U, B, M) \
+  CHOOSE_DYNAMIC_LINKER1 ("mglibc", "muclibc", "mbionic", "mmusl", G, U, B, M)
 #elif DEFAULT_LIBC == LIBC_UCLIBC
-#define CHOOSE_DYNAMIC_LINKER(G, U, B) \
-  CHOOSE_DYNAMIC_LINKER1 ("muclibc", "mglibc", "mbionic", U, G, B)
+#define CHOOSE_DYNAMIC_LINKER(G, U, B, M) \
+  CHOOSE_DYNAMIC_LINKER1 ("muclibc", "mglibc", "mbionic", "mmusl", U, G, B, M)
 #elif DEFAULT_LIBC == LIBC_BIONIC
-#define CHOOSE_DYNAMIC_LINKER(G, U, B) \
-  CHOOSE_DYNAMIC_LINKER1 ("mbionic", "mglibc", "muclibc", B, G, U)
+#define CHOOSE_DYNAMIC_LINKER(G, U, B, M) \
+  CHOOSE_DYNAMIC_LINKER1 ("mbionic", "mglibc", "muclibc", "mmusl", B, G, U, M)
+#elif DEFAULT_LIBC == LIBC_MUSL
+#define CHOOSE_DYNAMIC_LINKER(G, U, B, M) \
+  CHOOSE_DYNAMIC_LINKER1 ("mmusl", "mglibc", "muclibc", "mbionic", M, G, U, B)
 #else
 #error "Unsupported DEFAULT_LIBC"
 #endif /* DEFAULT_LIBC */
@@ -81,24 +89,100 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #define BIONIC_DYNAMIC_LINKER32 "/system/bin/linker"
 #define BIONIC_DYNAMIC_LINKER64 "/system/bin/linker64"
 #define BIONIC_DYNAMIC_LINKERX32 "/system/bin/linkerx32"
+/* Should be redefined for each target that supports musl.  */
+#define MUSL_DYNAMIC_LINKER "/dev/null"
+#define MUSL_DYNAMIC_LINKER32 "/dev/null"
+#define MUSL_DYNAMIC_LINKER64 "/dev/null"
+#define MUSL_DYNAMIC_LINKERX32 "/dev/null"
 
 #define GNU_USER_DYNAMIC_LINKER						\
   CHOOSE_DYNAMIC_LINKER (GLIBC_DYNAMIC_LINKER, UCLIBC_DYNAMIC_LINKER,	\
-			 BIONIC_DYNAMIC_LINKER)
+			 BIONIC_DYNAMIC_LINKER, MUSL_DYNAMIC_LINKER)
 #define GNU_USER_DYNAMIC_LINKER32					\
   CHOOSE_DYNAMIC_LINKER (GLIBC_DYNAMIC_LINKER32, UCLIBC_DYNAMIC_LINKER32, \
-			 BIONIC_DYNAMIC_LINKER32)
+			 BIONIC_DYNAMIC_LINKER32, MUSL_DYNAMIC_LINKER32)
 #define GNU_USER_DYNAMIC_LINKER64					\
   CHOOSE_DYNAMIC_LINKER (GLIBC_DYNAMIC_LINKER64, UCLIBC_DYNAMIC_LINKER64, \
-			 BIONIC_DYNAMIC_LINKER64)
+			 BIONIC_DYNAMIC_LINKER64, MUSL_DYNAMIC_LINKER64)
 #define GNU_USER_DYNAMIC_LINKERX32					\
   CHOOSE_DYNAMIC_LINKER (GLIBC_DYNAMIC_LINKERX32, UCLIBC_DYNAMIC_LINKERX32, \
-			 BIONIC_DYNAMIC_LINKERX32)
+			 BIONIC_DYNAMIC_LINKERX32, MUSL_DYNAMIC_LINKERX32)
 
 /* Whether we have Bionic libc runtime */
 #undef TARGET_HAS_BIONIC
 #define TARGET_HAS_BIONIC (OPTION_BIONIC)
 
+/* musl avoids problematic includes by rearranging the include directories.
+ * Unfortunately, this is mostly duplicated from cppdefault.c */
+#if DEFAULT_LIBC == LIBC_MUSL
+#define INCLUDE_DEFAULTS_MUSL_GPP			\
+    { GPLUSPLUS_INCLUDE_DIR, "G++", 1, 1,		\
+      GPLUSPLUS_INCLUDE_DIR_ADD_SYSROOT, 0 },		\
+    { GPLUSPLUS_TOOL_INCLUDE_DIR, "G++", 1, 1,		\
+      GPLUSPLUS_INCLUDE_DIR_ADD_SYSROOT, 1 },		\
+    { GPLUSPLUS_BACKWARD_INCLUDE_DIR, "G++", 1, 1,	\
+      GPLUSPLUS_INCLUDE_DIR_ADD_SYSROOT, 0 },
+
+#ifdef LOCAL_INCLUDE_DIR
+#define INCLUDE_DEFAULTS_MUSL_LOCAL			\
+    { LOCAL_INCLUDE_DIR, 0, 0, 1, 1, 2 },		\
+    { LOCAL_INCLUDE_DIR, 0, 0, 1, 1, 0 },
+#else
+#define INCLUDE_DEFAULTS_MUSL_LOCAL
+#endif
+
+#ifdef PREFIX_INCLUDE_DIR
+#define INCLUDE_DEFAULTS_MUSL_PREFIX			\
+    { PREFIX_INCLUDE_DIR, 0, 0, 1, 0, 0},
+#else
+#define INCLUDE_DEFAULTS_MUSL_PREFIX
+#endif
+
+#ifdef CROSS_INCLUDE_DIR
+#define INCLUDE_DEFAULTS_MUSL_CROSS			\
+    { CROSS_INCLUDE_DIR, "GCC", 0, 0, 0, 0},
+#else
+#define INCLUDE_DEFAULTS_MUSL_CROSS
+#endif
+
+#ifdef TOOL_INCLUDE_DIR
+#define INCLUDE_DEFAULTS_MUSL_TOOL			\
+    { TOOL_INCLUDE_DIR, "BINUTILS", 0, 1, 0, 0},
+#else
+#define INCLUDE_DEFAULTS_MUSL_TOOL
+#endif
+
+#ifdef NATIVE_SYSTEM_HEADER_DIR
+#define INCLUDE_DEFAULTS_MUSL_NATIVE			\
+    { NATIVE_SYSTEM_HEADER_DIR, 0, 0, 0, 1, 2 },	\
+    { NATIVE_SYSTEM_HEADER_DIR, 0, 0, 0, 1, 0 },
+#else
+#define INCLUDE_DEFAULTS_MUSL_NATIVE
+#endif
+
+#if defined (CROSS_DIRECTORY_STRUCTURE) && !defined (TARGET_SYSTEM_ROOT)
+# undef INCLUDE_DEFAULTS_MUSL_LOCAL
+# define INCLUDE_DEFAULTS_MUSL_LOCAL
+# undef INCLUDE_DEFAULTS_MUSL_NATIVE
+# define INCLUDE_DEFAULTS_MUSL_NATIVE
+#else
+# undef INCLUDE_DEFAULTS_MUSL_CROSS
+# define INCLUDE_DEFAULTS_MUSL_CROSS
+#endif
+
+#undef INCLUDE_DEFAULTS
+#define INCLUDE_DEFAULTS				\
+  {							\
+    INCLUDE_DEFAULTS_MUSL_GPP				\
+    INCLUDE_DEFAULTS_MUSL_PREFIX			\
+    INCLUDE_DEFAULTS_MUSL_CROSS				\
+    INCLUDE_DEFAULTS_MUSL_TOOL				\
+    INCLUDE_DEFAULTS_MUSL_NATIVE			\
+    { GCC_INCLUDE_DIR, "GCC", 0, 1, 0, 0 },		\
+    { 0, 0, 0, 0, 0, 0 }				\
+  }
+#endif
+
 #if (DEFAULT_LIBC == LIBC_UCLIBC) && defined (SINGLE_LIBC) /* uClinux */
 /* This is a *uclinux* target.  We don't define below macros to normal linux
    versions, because doing so would require *uclinux* targets to include
--- a/src/gcc/config/linux.opt
+++ b/src/gcc/config/linux.opt
@@ -28,5 +28,9 @@ Target Report RejectNegative Var(linux_libc,LIBC_GLIBC) Negative(muclibc)
 Use GNU C library
 
 muclibc
-Target Report RejectNegative Var(linux_libc,LIBC_UCLIBC) Negative(mbionic)
+Target Report RejectNegative Var(linux_libc,LIBC_UCLIBC) Negative(mmusl)
 Use uClibc C library
+
+mmusl
+Target Report RejectNegative Var(linux_libc,LIBC_MUSL) Negative(mbionic)
+Use musl C library
--- a/src/gcc/config/mips/linux.h
+++ b/src/gcc/config/mips/linux.h
@@ -37,7 +37,13 @@ along with GCC; see the file COPYING3.  If not see
 #define UCLIBC_DYNAMIC_LINKERN32 \
   "%{mnan=2008:/lib32/ld-uClibc-mipsn8.so.0;:/lib32/ld-uClibc.so.0}"
 
+#undef MUSL_DYNAMIC_LINKER32
+#define MUSL_DYNAMIC_LINKER32 "/lib/ld-musl-mips%{EL:el}%{msoft-float:-sf}.so.1"
+#undef MUSL_DYNAMIC_LINKER64
+#define MUSL_DYNAMIC_LINKER64 "/lib/ld-musl-mips64%{EL:el}%{msoft-float:-sf}.so.1"
+#define MUSL_DYNAMIC_LINKERN32 "/lib/ld-musl-mipsn32%{EL:el}%{msoft-float:-sf}.so.1"
+
 #define BIONIC_DYNAMIC_LINKERN32 "/system/bin/linker32"
 #define GNU_USER_DYNAMIC_LINKERN32 \
   CHOOSE_DYNAMIC_LINKER (GLIBC_DYNAMIC_LINKERN32, UCLIBC_DYNAMIC_LINKERN32, \
-                         BIONIC_DYNAMIC_LINKERN32)
+                         BIONIC_DYNAMIC_LINKERN32, MUSL_DYNAMIC_LINKERN32)
--- a/src/gcc/config/rs6000/linux.h
+++ b/src/gcc/config/rs6000/linux.h
@@ -30,10 +30,14 @@
 #define OPTION_GLIBC  (DEFAULT_LIBC == LIBC_GLIBC)
 #define OPTION_UCLIBC (DEFAULT_LIBC == LIBC_UCLIBC)
 #define OPTION_BIONIC (DEFAULT_LIBC == LIBC_BIONIC)
+#undef OPTION_MUSL
+#define OPTION_MUSL   (DEFAULT_LIBC == LIBC_MUSL)
 #else
 #define OPTION_GLIBC  (linux_libc == LIBC_GLIBC)
 #define OPTION_UCLIBC (linux_libc == LIBC_UCLIBC)
 #define OPTION_BIONIC (linux_libc == LIBC_BIONIC)
+#undef OPTION_MUSL
+#define OPTION_MUSL   (linux_libc == LIBC_MUSL)
 #endif
 
 /* Determine what functions are present at the runtime;
--- a/src/gcc/config/rs6000/linux64.h
+++ b/src/gcc/config/rs6000/linux64.h
@@ -299,10 +299,14 @@ extern int dot_symbols;
 #define OPTION_GLIBC  (DEFAULT_LIBC == LIBC_GLIBC)
 #define OPTION_UCLIBC (DEFAULT_LIBC == LIBC_UCLIBC)
 #define OPTION_BIONIC (DEFAULT_LIBC == LIBC_BIONIC)
+#undef OPTION_MUSL
+#define OPTION_MUSL   (DEFAULT_LIBC == LIBC_MUSL)
 #else
 #define OPTION_GLIBC  (linux_libc == LIBC_GLIBC)
 #define OPTION_UCLIBC (linux_libc == LIBC_UCLIBC)
 #define OPTION_BIONIC (linux_libc == LIBC_BIONIC)
+#undef OPTION_MUSL
+#define OPTION_MUSL   (linux_libc == LIBC_MUSL)
 #endif
 
 /* Determine what functions are present at the runtime;
--- a/src/gcc/configure
+++ b/src/gcc/configure
@@ -767,10 +767,6 @@ REPORT_BUGS_TEXI
 REPORT_BUGS_TO
 PKGVERSION
 CONFIGURE_SPECS
-CROSS_SYSTEM_HEADER_DIR
-TARGET_SYSTEM_ROOT_DEFINE
-TARGET_SYSTEM_ROOT
-SYSROOT_CFLAGS_FOR_TARGET
 enable_shared
 enable_fixed_point
 enable_decimal_float
@@ -809,6 +805,10 @@ LDFLAGS
 CFLAGS
 CC
 GENINSRC
+CROSS_SYSTEM_HEADER_DIR
+TARGET_SYSTEM_ROOT_DEFINE
+TARGET_SYSTEM_ROOT
+SYSROOT_CFLAGS_FOR_TARGET
 target_subdir
 host_subdir
 build_subdir
@@ -870,6 +870,9 @@ ac_user_opts='
 enable_option_checking
 with_build_libsubdir
 with_local_prefix
+with_native_system_header_dir
+with_build_sysroot
+with_sysroot
 with_gxx_include_dir
 with_cpp_install_dir
 enable_generated_files_in_srcdir
@@ -896,9 +899,6 @@ enable_tls
 enable_objc_gc
 with_dwarf2
 enable_shared
-with_native_system_header_dir
-with_build_sysroot
-with_sysroot
 with_specs
 with_pkgversion
 with_bugurl
@@ -1680,6 +1680,12 @@ Optional Packages:
   --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
   --with-build-libsubdir=DIR  Directory where to find libraries for build system
   --with-local-prefix=DIR specifies directory to put local include
+  --with-native-system-header-dir=dir
+                          use dir as the directory to look for standard
+                          system header files in.  Defaults to /usr/include.
+  --with-build-sysroot=sysroot
+                          use sysroot as the system root during the build
+  --with-sysroot[=DIR]    search for usr/lib, usr/include, et al, within DIR
   --with-gxx-include-dir=DIR
                           specifies directory to put g++ header files
   --with-cpp-install-dir=DIR
@@ -1692,14 +1698,9 @@ Optional Packages:
   --with-as               arrange to use the specified as (full pathname)
   --with-stabs            arrange to use stabs instead of host debug format
   --with-dwarf2           force the default debug format to be DWARF 2
-  --with-native-system-header-dir=dir
-                          use dir as the directory to look for standard
-                          system header files in.  Defaults to /usr/include.
-  --with-build-sysroot=sysroot
-                          use sysroot as the system root during the build
-  --with-sysroot[=DIR]    search for usr/lib, usr/include, et al, within DIR
   --with-specs=SPECS      add SPECS to driver command-line processing
-  --with-pkgversion=PKG   Use PKG in the version string in place of "GCC"
+  --with-pkgversion=PKG   Use PKG in the version string in place of "Linaro
+                          GCC `cat $srcdir/LINARO-VERSION`"
   --with-bugurl=URL       Direct users to URL to report a bug
   --with-multilib-list    select multilibs (AArch64, SH and x86-64 only)
   --with-gnu-ld           assume the C compiler uses GNU ld default=no
@@ -3339,6 +3340,83 @@ if test x$local_prefix = x; then
 	local_prefix=/usr/local
 fi
 
+
+# Check whether --with-native-system-header-dir was given.
+if test "${with_native_system_header_dir+set}" = set; then :
+  withval=$with_native_system_header_dir;
+ case ${with_native_system_header_dir} in
+ yes|no) as_fn_error "bad value ${withval} given for --with-native-system-header-dir" "$LINENO" 5 ;;
+ /* | [A-Za-z]:[\\/]*) ;;
+ *) as_fn_error "--with-native-system-header-dir argument ${withval} must be an absolute directory" "$LINENO" 5 ;;
+ esac
+ configured_native_system_header_dir="${withval}"
+
+else
+  configured_native_system_header_dir=
+fi
+
+
+
+# Check whether --with-build-sysroot was given.
+if test "${with_build_sysroot+set}" = set; then :
+  withval=$with_build_sysroot; if test x"$withval" != x ; then
+     SYSROOT_CFLAGS_FOR_TARGET="--sysroot=$withval"
+   fi
+else
+  SYSROOT_CFLAGS_FOR_TARGET=
+fi
+
+
+
+if test "x$prefix" = xNONE; then
+ test_prefix=/usr/local
+else
+ test_prefix=$prefix
+fi
+if test "x$exec_prefix" = xNONE; then
+ test_exec_prefix=$test_prefix
+else
+ test_exec_prefix=$exec_prefix
+fi
+
+
+# Check whether --with-sysroot was given.
+if test "${with_sysroot+set}" = set; then :
+  withval=$with_sysroot;
+ case ${with_sysroot} in
+ /) ;;
+ */) with_sysroot=`echo $with_sysroot | sed 's,/$,,'` ;;
+ esac
+ case ${with_sysroot} in
+ yes) TARGET_SYSTEM_ROOT='${exec_prefix}/${target_noncanonical}/sys-root' ;;
+ *) TARGET_SYSTEM_ROOT=$with_sysroot ;;
+ esac
+
+ TARGET_SYSTEM_ROOT_DEFINE='-DTARGET_SYSTEM_ROOT=\"$(TARGET_SYSTEM_ROOT)\"'
+ CROSS_SYSTEM_HEADER_DIR='$(TARGET_SYSTEM_ROOT)$${sysroot_headers_suffix}$(NATIVE_SYSTEM_HEADER_DIR)'
+
+ case ${TARGET_SYSTEM_ROOT} in
+ "${test_prefix}"|"${test_prefix}/"*|\
+ "${test_exec_prefix}"|"${test_exec_prefix}/"*|\
+ '${prefix}'|'${prefix}/'*|\
+ '${exec_prefix}'|'${exec_prefix}/'*)
+   t="$TARGET_SYSTEM_ROOT_DEFINE -DTARGET_SYSTEM_ROOT_RELOCATABLE"
+   TARGET_SYSTEM_ROOT_DEFINE="$t"
+   ;;
+ esac
+
+else
+
+ TARGET_SYSTEM_ROOT=
+ TARGET_SYSTEM_ROOT_DEFINE=
+ CROSS_SYSTEM_HEADER_DIR='$(gcc_tooldir)/sys-include'
+
+fi
+
+
+
+
+
 # Don't set gcc_gxx_include_dir to gxx_include_dir since that's only
 # passed in by the toplevel make and thus we'd get different behavior
 # depending on where we built the sources.
@@ -3372,7 +3450,9 @@ gcc_gxx_include_dir_add_sysroot=0
 if test "${with_sysroot+set}" = set; then
   gcc_gxx_without_sysroot=`expr "${gcc_gxx_include_dir}" : "${with_sysroot}"'\(.*\)'`
   if test "${gcc_gxx_without_sysroot}"; then
-    gcc_gxx_include_dir="${gcc_gxx_without_sysroot}"
+    if test x${with_sysroot} != x/; then
+      gcc_gxx_include_dir="${gcc_gxx_without_sysroot}"
+    fi
     gcc_gxx_include_dir_add_sysroot=1
   fi
 fi
@@ -7269,79 +7349,6 @@ fi
 
 
 
-# Check whether --with-native-system-header-dir was given.
-if test "${with_native_system_header_dir+set}" = set; then :
-  withval=$with_native_system_header_dir;
- case ${with_native_system_header_dir} in
- yes|no) as_fn_error "bad value ${withval} given for --with-native-system-header-dir" "$LINENO" 5 ;;
- /* | [A-Za-z]:[\\/]*) ;;
- *) as_fn_error "--with-native-system-header-dir argument ${withval} must be an absolute directory" "$LINENO" 5 ;;
- esac
- configured_native_system_header_dir="${withval}"
-
-else
-  configured_native_system_header_dir=
-fi
-
-
-
-# Check whether --with-build-sysroot was given.
-if test "${with_build_sysroot+set}" = set; then :
-  withval=$with_build_sysroot; if test x"$withval" != x ; then
-     SYSROOT_CFLAGS_FOR_TARGET="--sysroot=$withval"
-   fi
-else
-  SYSROOT_CFLAGS_FOR_TARGET=
-fi
-
-
-
-if test "x$prefix" = xNONE; then
- test_prefix=/usr/local
-else
- test_prefix=$prefix
-fi
-if test "x$exec_prefix" = xNONE; then
- test_exec_prefix=$test_prefix
-else
- test_exec_prefix=$exec_prefix
-fi
-
-
-# Check whether --with-sysroot was given.
-if test "${with_sysroot+set}" = set; then :
-  withval=$with_sysroot;
- case ${with_sysroot} in
- yes) TARGET_SYSTEM_ROOT='${exec_prefix}/${target_noncanonical}/sys-root' ;;
- *) TARGET_SYSTEM_ROOT=$with_sysroot ;;
- esac
-
- TARGET_SYSTEM_ROOT_DEFINE='-DTARGET_SYSTEM_ROOT=\"$(TARGET_SYSTEM_ROOT)\"'
- CROSS_SYSTEM_HEADER_DIR='$(TARGET_SYSTEM_ROOT)$${sysroot_headers_suffix}$(NATIVE_SYSTEM_HEADER_DIR)'
-
- case ${TARGET_SYSTEM_ROOT} in
- "${test_prefix}"|"${test_prefix}/"*|\
- "${test_exec_prefix}"|"${test_exec_prefix}/"*|\
- '${prefix}'|'${prefix}/'*|\
- '${exec_prefix}'|'${exec_prefix}/'*)
-   t="$TARGET_SYSTEM_ROOT_DEFINE -DTARGET_SYSTEM_ROOT_RELOCATABLE"
-   TARGET_SYSTEM_ROOT_DEFINE="$t"
-   ;;
- esac
-
-else
-
- TARGET_SYSTEM_ROOT=
- TARGET_SYSTEM_ROOT_DEFINE=
- CROSS_SYSTEM_HEADER_DIR='$(gcc_tooldir)/sys-include'
-
-fi
-
-
-
-
-
-
 # Check whether --with-specs was given.
 if test "${with_specs+set}" = set; then :
   withval=$with_specs; CONFIGURE_SPECS=$withval
@@ -7362,7 +7369,7 @@ if test "${with_pkgversion+set}" = set; then :
       *)   PKGVERSION="($withval) " ;;
      esac
 else
-  PKGVERSION="(GCC) "
+  PKGVERSION="(Linaro GCC `cat $srcdir/LINARO-VERSION`) "
 
 fi
 
@@ -18162,7 +18169,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 18165 "configure"
+#line 18172 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -18268,7 +18275,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 18271 "configure"
+#line 18278 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -27802,6 +27809,9 @@ if test "${gcc_cv_libc_provides_ssp+set}" = set; then :
 else
   gcc_cv_libc_provides_ssp=no
     case "$target" in
+       *-*-musl*)
+	 # All versions of musl provide stack protector
+	 gcc_cv_libc_provides_ssp=yes;;
        *-*-linux* | *-*-kfreebsd*-gnu | *-*-knetbsd*-gnu)
       # glibc 2.4 and later provides __stack_chk_fail and
       # either __stack_chk_guard, or TLS access to stack guard canary.
@@ -27834,6 +27844,7 @@ fi
 	 # <http://gcc.gnu.org/ml/gcc/2008-10/msg00130.html>) and for now
 	 # simply assert that glibc does provide this, which is true for all
 	 # realistically usable GNU/Hurd configurations.
+	 # All supported versions of musl provide it as well
 	 gcc_cv_libc_provides_ssp=yes;;
        *-*-darwin* | *-*-freebsd*)
 	 ac_fn_c_check_func "$LINENO" "__stack_chk_fail" "ac_cv_func___stack_chk_fail"
@@ -27930,6 +27941,9 @@ case "$target" in
       gcc_cv_target_dl_iterate_phdr=no
     fi
     ;;
+  *-linux-musl*)
+    gcc_cv_target_dl_iterate_phdr=yes
+    ;;
 esac
 
 if test x$gcc_cv_target_dl_iterate_phdr = xyes; then
--- a/src/gcc/configure.ac
+++ b/src/gcc/configure.ac
@@ -121,6 +121,73 @@ if test x$local_prefix = x; then
 	local_prefix=/usr/local
 fi
 
+AC_ARG_WITH([native-system-header-dir],
+  [  --with-native-system-header-dir=dir
+                          use dir as the directory to look for standard
+                          system header files in.  Defaults to /usr/include.],
+[
+ case ${with_native_system_header_dir} in
+ yes|no) AC_MSG_ERROR([bad value ${withval} given for --with-native-system-header-dir]) ;;
+ /* | [[A-Za-z]]:[[\\/]]*) ;;
+ *) AC_MSG_ERROR([--with-native-system-header-dir argument ${withval} must be an absolute directory]) ;;
+ esac
+ configured_native_system_header_dir="${withval}"
+], [configured_native_system_header_dir=])
+
+AC_ARG_WITH(build-sysroot, 
+  [AS_HELP_STRING([--with-build-sysroot=sysroot],
+                  [use sysroot as the system root during the build])],
+  [if test x"$withval" != x ; then
+     SYSROOT_CFLAGS_FOR_TARGET="--sysroot=$withval"
+   fi],
+  [SYSROOT_CFLAGS_FOR_TARGET=])
+AC_SUBST(SYSROOT_CFLAGS_FOR_TARGET)
+
+if test "x$prefix" = xNONE; then
+ test_prefix=/usr/local
+else
+ test_prefix=$prefix
+fi
+if test "x$exec_prefix" = xNONE; then
+ test_exec_prefix=$test_prefix
+else
+ test_exec_prefix=$exec_prefix
+fi
+
+AC_ARG_WITH(sysroot,
+[AS_HELP_STRING([[--with-sysroot[=DIR]]],
+		[search for usr/lib, usr/include, et al, within DIR])],
+[
+ case ${with_sysroot} in
+ /) ;;
+ */) with_sysroot=`echo $with_sysroot | sed 's,/$,,'` ;;
+ esac
+ case ${with_sysroot} in
+ yes) TARGET_SYSTEM_ROOT='${exec_prefix}/${target_noncanonical}/sys-root' ;;
+ *) TARGET_SYSTEM_ROOT=$with_sysroot ;;
+ esac
+   
+ TARGET_SYSTEM_ROOT_DEFINE='-DTARGET_SYSTEM_ROOT=\"$(TARGET_SYSTEM_ROOT)\"'
+ CROSS_SYSTEM_HEADER_DIR='$(TARGET_SYSTEM_ROOT)$${sysroot_headers_suffix}$(NATIVE_SYSTEM_HEADER_DIR)'
+	
+ case ${TARGET_SYSTEM_ROOT} in
+ "${test_prefix}"|"${test_prefix}/"*|\
+ "${test_exec_prefix}"|"${test_exec_prefix}/"*|\
+ '${prefix}'|'${prefix}/'*|\
+ '${exec_prefix}'|'${exec_prefix}/'*)
+   t="$TARGET_SYSTEM_ROOT_DEFINE -DTARGET_SYSTEM_ROOT_RELOCATABLE"
+   TARGET_SYSTEM_ROOT_DEFINE="$t"
+   ;;
+ esac
+], [
+ TARGET_SYSTEM_ROOT=
+ TARGET_SYSTEM_ROOT_DEFINE=
+ CROSS_SYSTEM_HEADER_DIR='$(gcc_tooldir)/sys-include'
+])
+AC_SUBST(TARGET_SYSTEM_ROOT)
+AC_SUBST(TARGET_SYSTEM_ROOT_DEFINE)
+AC_SUBST(CROSS_SYSTEM_HEADER_DIR)
+
 # Don't set gcc_gxx_include_dir to gxx_include_dir since that's only
 # passed in by the toplevel make and thus we'd get different behavior
 # depending on where we built the sources.
@@ -152,7 +219,9 @@ gcc_gxx_include_dir_add_sysroot=0
 if test "${with_sysroot+set}" = set; then
   gcc_gxx_without_sysroot=`expr "${gcc_gxx_include_dir}" : "${with_sysroot}"'\(.*\)'`
   if test "${gcc_gxx_without_sysroot}"; then
-    gcc_gxx_include_dir="${gcc_gxx_without_sysroot}"
+    if test x${with_sysroot} != x/; then
+      gcc_gxx_include_dir="${gcc_gxx_without_sysroot}"
+    fi
     gcc_gxx_include_dir_add_sysroot=1
   fi
 fi
@@ -791,69 +860,6 @@ AC_ARG_ENABLE(shared,
 ], [enable_shared=yes])
 AC_SUBST(enable_shared)
 
-AC_ARG_WITH([native-system-header-dir],
-  [  --with-native-system-header-dir=dir
-                          use dir as the directory to look for standard
-                          system header files in.  Defaults to /usr/include.],
-[
- case ${with_native_system_header_dir} in
- yes|no) AC_MSG_ERROR([bad value ${withval} given for --with-native-system-header-dir]) ;;
- /* | [[A-Za-z]]:[[\\/]]*) ;;
- *) AC_MSG_ERROR([--with-native-system-header-dir argument ${withval} must be an absolute directory]) ;;
- esac
- configured_native_system_header_dir="${withval}"
-], [configured_native_system_header_dir=])
-
-AC_ARG_WITH(build-sysroot, 
-  [AS_HELP_STRING([--with-build-sysroot=sysroot],
-                  [use sysroot as the system root during the build])],
-  [if test x"$withval" != x ; then
-     SYSROOT_CFLAGS_FOR_TARGET="--sysroot=$withval"
-   fi],
-  [SYSROOT_CFLAGS_FOR_TARGET=])
-AC_SUBST(SYSROOT_CFLAGS_FOR_TARGET)
-
-if test "x$prefix" = xNONE; then
- test_prefix=/usr/local
-else
- test_prefix=$prefix
-fi
-if test "x$exec_prefix" = xNONE; then
- test_exec_prefix=$test_prefix
-else
- test_exec_prefix=$exec_prefix
-fi
-
-AC_ARG_WITH(sysroot,
-[AS_HELP_STRING([[--with-sysroot[=DIR]]],
-		[search for usr/lib, usr/include, et al, within DIR])],
-[
- case ${with_sysroot} in
- yes) TARGET_SYSTEM_ROOT='${exec_prefix}/${target_noncanonical}/sys-root' ;;
- *) TARGET_SYSTEM_ROOT=$with_sysroot ;;
- esac
-   
- TARGET_SYSTEM_ROOT_DEFINE='-DTARGET_SYSTEM_ROOT=\"$(TARGET_SYSTEM_ROOT)\"'
- CROSS_SYSTEM_HEADER_DIR='$(TARGET_SYSTEM_ROOT)$${sysroot_headers_suffix}$(NATIVE_SYSTEM_HEADER_DIR)'
-	
- case ${TARGET_SYSTEM_ROOT} in
- "${test_prefix}"|"${test_prefix}/"*|\
- "${test_exec_prefix}"|"${test_exec_prefix}/"*|\
- '${prefix}'|'${prefix}/'*|\
- '${exec_prefix}'|'${exec_prefix}/'*)
-   t="$TARGET_SYSTEM_ROOT_DEFINE -DTARGET_SYSTEM_ROOT_RELOCATABLE"
-   TARGET_SYSTEM_ROOT_DEFINE="$t"
-   ;;
- esac
-], [
- TARGET_SYSTEM_ROOT=
- TARGET_SYSTEM_ROOT_DEFINE=
- CROSS_SYSTEM_HEADER_DIR='$(gcc_tooldir)/sys-include'
-])
-AC_SUBST(TARGET_SYSTEM_ROOT)
-AC_SUBST(TARGET_SYSTEM_ROOT_DEFINE)
-AC_SUBST(CROSS_SYSTEM_HEADER_DIR)
-
 AC_ARG_WITH(specs,
   [AS_HELP_STRING([--with-specs=SPECS],
                   [add SPECS to driver command-line processing])],
@@ -862,7 +868,7 @@ AC_ARG_WITH(specs,
 )
 AC_SUBST(CONFIGURE_SPECS)
 
-ACX_PKGVERSION([GCC])
+ACX_PKGVERSION([Linaro GCC `cat $srcdir/LINARO-VERSION`])
 ACX_BUGURL([http://gcc.gnu.org/bugs.html])
 
 # Sanity check enable_languages in case someone does not run the toplevel
@@ -5282,6 +5288,9 @@ AC_CACHE_CHECK(__stack_chk_fail in target C library,
       gcc_cv_libc_provides_ssp,
       [gcc_cv_libc_provides_ssp=no
     case "$target" in
+       *-*-musl*)
+	 # All versions of musl provide stack protector
+	 gcc_cv_libc_provides_ssp=yes;;
        *-*-linux* | *-*-kfreebsd*-gnu | *-*-knetbsd*-gnu)
       # glibc 2.4 and later provides __stack_chk_fail and
       # either __stack_chk_guard, or TLS access to stack guard canary.
@@ -5308,6 +5317,7 @@ AC_CACHE_CHECK(__stack_chk_fail in target C library,
 	 # <http://gcc.gnu.org/ml/gcc/2008-10/msg00130.html>) and for now
 	 # simply assert that glibc does provide this, which is true for all
 	 # realistically usable GNU/Hurd configurations.
+	 # All supported versions of musl provide it as well
 	 gcc_cv_libc_provides_ssp=yes;;
        *-*-darwin* | *-*-freebsd*)
 	 AC_CHECK_FUNC(__stack_chk_fail,[gcc_cv_libc_provides_ssp=yes],
@@ -5381,6 +5391,9 @@ case "$target" in
       gcc_cv_target_dl_iterate_phdr=no
     fi
     ;;
+  *-linux-musl*)
+    gcc_cv_target_dl_iterate_phdr=yes
+    ;;
 esac
 GCC_TARGET_TEMPLATE([TARGET_DL_ITERATE_PHDR])
 if test x$gcc_cv_target_dl_iterate_phdr = xyes; then
--- a/src/gcc/cp/Make-lang.in
+++ b/src/gcc/cp/Make-lang.in
@@ -155,7 +155,7 @@ check-c++-subtargets : check-g++-subtargets
 # List of targets that can use the generic check- rule and its // variant.
 lang_checks += check-g++
 lang_checks_parallelized += check-g++
-# For description see comment above check_gcc_parallelize in gcc/Makefile.in.
+# For description see the check_$lang_parallelize comment in gcc/Makefile.in.
 check_g++_parallelize = 10000
 #
 # Install hooks:
@@ -221,6 +221,7 @@ c++.mostlyclean:
 	-rm -f doc/g++.1
 	-rm -f cp/*$(objext)
 	-rm -f cp/*$(coverageexts)
+	-rm -f xg++$(exeext) g++-cross$(exeext) cc1plus$(exeext)
 c++.clean:
 c++.distclean:
 	-rm -f cp/config.status cp/Makefile
--- a/src/gcc/cppbuiltin.c
+++ b/src/gcc/cppbuiltin.c
@@ -62,18 +62,41 @@ parse_basever (int *major, int *minor, int *patchlevel)
     *patchlevel = s_patchlevel;
 }
 
+/* Parse a LINAROVER version string of the format "M.m-year.month[-spin][~dev]"
+   to create Linaro release number YYYYMM and spin version.  */
+static void
+parse_linarover (int *release, int *spin)
+{
+  static int s_year = -1, s_month, s_spin;
+
+  if (s_year == -1)
+    if (sscanf (LINAROVER, "%*[^-]-%d.%d-%d", &s_year, &s_month, &s_spin) != 3)
+      {
+	sscanf (LINAROVER, "%*[^-]-%d.%d", &s_year, &s_month);
+	s_spin = 0;
+      }
+
+  if (release)
+    *release = s_year * 100 + s_month;
+
+  if (spin)
+    *spin = s_spin;
+}
 
 /* Define __GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__ and __VERSION__.  */
 static void
 define__GNUC__ (cpp_reader *pfile)
 {
-  int major, minor, patchlevel;
+  int major, minor, patchlevel, linaro_release, linaro_spin;
 
   parse_basever (&major, &minor, &patchlevel);
+  parse_linarover (&linaro_release, &linaro_spin);
   cpp_define_formatted (pfile, "__GNUC__=%d", major);
   cpp_define_formatted (pfile, "__GNUC_MINOR__=%d", minor);
   cpp_define_formatted (pfile, "__GNUC_PATCHLEVEL__=%d", patchlevel);
   cpp_define_formatted (pfile, "__VERSION__=\"%s\"", version_string);
+  cpp_define_formatted (pfile, "__LINARO_RELEASE__=%d", linaro_release);
+  cpp_define_formatted (pfile, "__LINARO_SPIN__=%d", linaro_spin);
   cpp_define_formatted (pfile, "__ATOMIC_RELAXED=%d", MEMMODEL_RELAXED);
   cpp_define_formatted (pfile, "__ATOMIC_SEQ_CST=%d", MEMMODEL_SEQ_CST);
   cpp_define_formatted (pfile, "__ATOMIC_ACQUIRE=%d", MEMMODEL_ACQUIRE);
--- a/src/gcc/cprop.c
+++ b/src/gcc/cprop.c
@@ -285,6 +285,15 @@ cprop_constant_p (const_rtx x)
   return CONSTANT_P (x) && (GET_CODE (x) != CONST || shared_const_p (x));
 }
 
+/* Determine whether the rtx X should be treated as a register that can
+   be propagated.  Any pseudo-register is fine.  */
+
+static bool
+cprop_reg_p (const_rtx x)
+{
+  return REG_P (x) && !HARD_REGISTER_P (x);
+}
+
 /* Scan SET present in INSN and add an entry to the hash TABLE.
    IMPLICIT is true if it's an implicit set, false otherwise.  */
 
@@ -295,8 +304,7 @@ hash_scan_set (rtx set, rtx_insn *insn, struct hash_table_d *table,
   rtx src = SET_SRC (set);
   rtx dest = SET_DEST (set);
 
-  if (REG_P (dest)
-      && ! HARD_REGISTER_P (dest)
+  if (cprop_reg_p (dest)
       && reg_available_p (dest, insn)
       && can_copy_p (GET_MODE (dest)))
     {
@@ -321,9 +329,8 @@ hash_scan_set (rtx set, rtx_insn *insn, struct hash_table_d *table,
 	src = XEXP (note, 0), set = gen_rtx_SET (VOIDmode, dest, src);
 
       /* Record sets for constant/copy propagation.  */
-      if ((REG_P (src)
+      if ((cprop_reg_p (src)
 	   && src != dest
-	   && ! HARD_REGISTER_P (src)
 	   && reg_available_p (src, insn))
 	  || cprop_constant_p (src))
 	insert_set_in_table (dest, src, insn, table, implicit);
@@ -758,12 +765,37 @@ try_replace_reg (rtx from, rtx to, rtx_insn *insn)
   int success = 0;
   rtx set = single_set (insn);
 
+  bool check_rtx_costs = true;
+  bool speed = optimize_bb_for_speed_p (BLOCK_FOR_INSN (insn));
+  int old_cost = set ? set_rtx_cost (set, speed) : 0;
+
+  if ((note != 0
+      && REG_NOTE_KIND (note) == REG_EQUAL
+      && (GET_CODE (XEXP (note, 0)) == CONST
+	  || CONSTANT_P (XEXP (note, 0))))
+      || (set && CONSTANT_P (SET_SRC (set))))
+    check_rtx_costs = false;
+
   /* Usually we substitute easy stuff, so we won't copy everything.
      We however need to take care to not duplicate non-trivial CONST
      expressions.  */
   to = copy_rtx (to);
 
   validate_replace_src_group (from, to, insn);
+
+  /* If TO is a constant, check the cost of the set after propagation
+     to the cost of the set before the propagation.  If the cost is
+     higher, then do not replace FROM with TO.  */
+
+  if (check_rtx_costs
+      && CONSTANT_P (to)
+      && (set_rtx_cost (set, speed) > old_cost))
+    {
+      cancel_changes (0);
+      return false;
+    }
+
+
   if (num_changes_pending () && apply_change_group ())
     success = 1;
 
@@ -821,15 +853,15 @@ try_replace_reg (rtx from, rtx to, rtx_insn *insn)
   return success;
 }
 
-/* Find a set of REGNOs that are available on entry to INSN's block.  Return
-   NULL no such set is found.  */
+/* Find a set of REGNOs that are available on entry to INSN's block.  If found,
+   SET_RET[0] will be assigned a set with a register source and SET_RET[1] a
+   set with a constant source.  If not found the corresponding entry is set to
+   NULL.  */
 
-static struct cprop_expr *
-find_avail_set (int regno, rtx_insn *insn)
+static void
+find_avail_set (int regno, rtx_insn *insn, struct cprop_expr *set_ret[2])
 {
-  /* SET1 contains the last set found that can be returned to the caller for
-     use in a substitution.  */
-  struct cprop_expr *set1 = 0;
+  set_ret[0] = set_ret[1] = NULL;
 
   /* Loops are not possible here.  To get a loop we would need two sets
      available at the start of the block containing INSN.  i.e. we would
@@ -869,8 +901,10 @@ find_avail_set (int regno, rtx_insn *insn)
          If the source operand changed, we may still use it for the next
          iteration of this loop, but we may not use it for substitutions.  */
 
-      if (cprop_constant_p (src) || reg_not_set_p (src, insn))
-	set1 = set;
+      if (cprop_constant_p (src))
+	set_ret[1] = set;
+      else if (reg_not_set_p (src, insn))
+	set_ret[0] = set;
 
       /* If the source of the set is anything except a register, then
 	 we have reached the end of the copy chain.  */
@@ -881,10 +915,6 @@ find_avail_set (int regno, rtx_insn *insn)
 	 and see if we have an available copy into SRC.  */
       regno = REGNO (src);
     }
-
-  /* SET1 holds the last set that was available and anticipatable at
-     INSN.  */
-  return set1;
 }
 
 /* Subroutine of cprop_insn that tries to propagate constants into
@@ -1050,40 +1080,40 @@ cprop_insn (rtx_insn *insn)
   int changed = 0, changed_this_round;
   rtx note;
 
-retry:
-  changed_this_round = 0;
-  reg_use_count = 0;
-  note_uses (&PATTERN (insn), find_used_regs, NULL);
-
-  /* We may win even when propagating constants into notes.  */
-  note = find_reg_equal_equiv_note (insn);
-  if (note)
-    find_used_regs (&XEXP (note, 0), NULL);
-
-  for (i = 0; i < reg_use_count; i++)
+  do
     {
-      rtx reg_used = reg_use_table[i];
-      unsigned int regno = REGNO (reg_used);
-      rtx src;
-      struct cprop_expr *set;
+      changed_this_round = 0;
+      reg_use_count = 0;
+      note_uses (&PATTERN (insn), find_used_regs, NULL);
 
-      /* If the register has already been set in this block, there's
-	 nothing we can do.  */
-      if (! reg_not_set_p (reg_used, insn))
-	continue;
+      /* We may win even when propagating constants into notes.  */
+      note = find_reg_equal_equiv_note (insn);
+      if (note)
+	find_used_regs (&XEXP (note, 0), NULL);
 
-      /* Find an assignment that sets reg_used and is available
-	 at the start of the block.  */
-      set = find_avail_set (regno, insn);
-      if (! set)
-	continue;
+      for (i = 0; i < reg_use_count; i++)
+	{
+	  rtx reg_used = reg_use_table[i];
+	  unsigned int regno = REGNO (reg_used);
+	  rtx src_cst = NULL, src_reg = NULL;
+	  struct cprop_expr *set[2];
 
-      src = set->src;
+	  /* If the register has already been set in this block, there's
+	     nothing we can do.  */
+	  if (! reg_not_set_p (reg_used, insn))
+	    continue;
 
-      /* Constant propagation.  */
-      if (cprop_constant_p (src))
-	{
-          if (constprop_register (reg_used, src, insn))
+	  /* Find an assignment that sets reg_used and is available
+	     at the start of the block.  */
+	  find_avail_set (regno, insn, set);
+	  if (set[0])
+	    src_reg = set[0]->src;
+	  if (set[1])
+	    src_cst = set[1]->src;
+
+	  /* Constant propagation.  */
+	  if (src_cst && cprop_constant_p (src_cst)
+	      && constprop_register (reg_used, src_cst, insn))
 	    {
 	      changed_this_round = changed = 1;
 	      global_const_prop_count++;
@@ -1093,18 +1123,16 @@ retry:
 			   "GLOBAL CONST-PROP: Replacing reg %d in ", regno);
 		  fprintf (dump_file, "insn %d with constant ",
 			   INSN_UID (insn));
-		  print_rtl (dump_file, src);
+		  print_rtl (dump_file, src_cst);
 		  fprintf (dump_file, "\n");
 		}
 	      if (insn->deleted ())
 		return 1;
 	    }
-	}
-      else if (REG_P (src)
-	       && REGNO (src) >= FIRST_PSEUDO_REGISTER
-	       && REGNO (src) != regno)
-	{
-	  if (try_replace_reg (reg_used, src, insn))
+	  /* Copy propagation.  */
+	  else if (src_reg && cprop_reg_p (src_reg)
+		   && REGNO (src_reg) != regno
+		   && try_replace_reg (reg_used, src_reg, insn))
 	    {
 	      changed_this_round = changed = 1;
 	      global_copy_prop_count++;
@@ -1113,7 +1141,7 @@ retry:
 		  fprintf (dump_file,
 			   "GLOBAL COPY-PROP: Replacing reg %d in insn %d",
 			   regno, INSN_UID (insn));
-		  fprintf (dump_file, " with reg %d\n", REGNO (src));
+		  fprintf (dump_file, " with reg %d\n", REGNO (src_reg));
 		}
 
 	      /* The original insn setting reg_used may or may not now be
@@ -1123,12 +1151,10 @@ retry:
 		 and made things worse.  */
 	    }
 	}
-
-      /* If try_replace_reg simplified the insn, the regs found
-	 by find_used_regs may not be valid anymore.  Start over.  */
-      if (changed_this_round)
-	goto retry;
     }
+  /* If try_replace_reg simplified the insn, the regs found by find_used_regs
+     may not be valid anymore.  Start over.  */
+  while (changed_this_round);
 
   if (changed && DEBUG_INSN_P (insn))
     return 0;
@@ -1191,7 +1217,7 @@ do_local_cprop (rtx x, rtx_insn *insn)
   /* Rule out USE instructions and ASM statements as we don't want to
      change the hard registers mentioned.  */
   if (REG_P (x)
-      && (REGNO (x) >= FIRST_PSEUDO_REGISTER
+      && (cprop_reg_p (x)
           || (GET_CODE (PATTERN (insn)) != USE
 	      && asm_noperands (PATTERN (insn)) < 0)))
     {
@@ -1207,7 +1233,7 @@ do_local_cprop (rtx x, rtx_insn *insn)
 
 	  if (cprop_constant_p (this_rtx))
 	    newcnst = this_rtx;
-	  if (REG_P (this_rtx) && REGNO (this_rtx) >= FIRST_PSEUDO_REGISTER
+	  if (cprop_reg_p (this_rtx)
 	      /* Don't copy propagate if it has attached REG_EQUIV note.
 		 At this point this only function parameters should have
 		 REG_EQUIV notes and if the argument slot is used somewhere
@@ -1328,9 +1354,8 @@ implicit_set_cond_p (const_rtx cond)
   if (GET_CODE (cond) != EQ && GET_CODE (cond) != NE)
     return false;
 
-  /* The first operand of COND must be a pseudo-reg.  */
-  if (! REG_P (XEXP (cond, 0))
-      || HARD_REGISTER_P (XEXP (cond, 0)))
+  /* The first operand of COND must be a register we can propagate.  */
+  if (!cprop_reg_p (XEXP (cond, 0)))
     return false;
 
   /* The second operand of COND must be a suitable constant.  */
--- a/src/gcc/cse.c
+++ b/src/gcc/cse.c
@@ -4540,14 +4540,50 @@ cse_insn (rtx_insn *insn)
   canonicalize_insn (insn, &sets, n_sets);
 
   /* If this insn has a REG_EQUAL note, store the equivalent value in SRC_EQV,
-     if different, or if the DEST is a STRICT_LOW_PART.  The latter condition
-     is necessary because SRC_EQV is handled specially for this case, and if
-     it isn't set, then there will be no equivalence for the destination.  */
+     if different, or if the DEST is a STRICT_LOW_PART/ZERO_EXTRACT.  The
+     latter condition is necessary because SRC_EQV is handled specially for
+     this case, and if it isn't set, then there will be no equivalence
+     for the destination.  */
   if (n_sets == 1 && REG_NOTES (insn) != 0
-      && (tem = find_reg_note (insn, REG_EQUAL, NULL_RTX)) != 0
-      && (! rtx_equal_p (XEXP (tem, 0), SET_SRC (sets[0].rtl))
-	  || GET_CODE (SET_DEST (sets[0].rtl)) == STRICT_LOW_PART))
-    src_eqv = copy_rtx (XEXP (tem, 0));
+      && (tem = find_reg_note (insn, REG_EQUAL, NULL_RTX)) != 0)
+    {
+
+      if (GET_CODE (SET_DEST (sets[0].rtl)) != ZERO_EXTRACT
+	  && (! rtx_equal_p (XEXP (tem, 0), SET_SRC (sets[0].rtl))
+	      || GET_CODE (SET_DEST (sets[0].rtl)) == STRICT_LOW_PART))
+	src_eqv = copy_rtx (XEXP (tem, 0));
+      /* If DEST is of the form ZERO_EXTACT, as in:
+	 (set (zero_extract:SI (reg:SI 119)
+		  (const_int 16 [0x10])
+		  (const_int 16 [0x10]))
+	      (const_int 51154 [0xc7d2]))
+	 REG_EQUAL note will specify the value of register (reg:SI 119) at this
+	 point.  Note that this is different from SRC_EQV. We can however
+	 calculate SRC_EQV with the position and width of ZERO_EXTRACT.  */
+      else if (GET_CODE (SET_DEST (sets[0].rtl)) == ZERO_EXTRACT
+	       && CONST_INT_P (XEXP (tem, 0))
+	       && CONST_INT_P (XEXP (SET_DEST (sets[0].rtl), 1))
+	       && CONST_INT_P (XEXP (SET_DEST (sets[0].rtl), 2)))
+	{
+	  rtx dest_reg = XEXP (SET_DEST (sets[0].rtl), 0);
+	  rtx width = XEXP (SET_DEST (sets[0].rtl), 1);
+	  rtx pos = XEXP (SET_DEST (sets[0].rtl), 2);
+	  HOST_WIDE_INT val = INTVAL (XEXP (tem, 0));
+	  HOST_WIDE_INT mask;
+	  unsigned int shift;
+	  if (BITS_BIG_ENDIAN)
+	    shift = GET_MODE_PRECISION (GET_MODE (dest_reg))
+	      - INTVAL (pos) - INTVAL (width);
+	  else
+	    shift = INTVAL (pos);
+	  if (INTVAL (width) == HOST_BITS_PER_WIDE_INT)
+	    mask = ~(HOST_WIDE_INT) 0;
+	  else
+	    mask = ((HOST_WIDE_INT) 1 << INTVAL (width)) - 1;
+	  val = (val >> shift) & mask;
+	  src_eqv = GEN_INT (val);
+	}
+    }
 
   /* Set sets[i].src_elt to the class each source belongs to.
      Detect assignments from or to volatile things
--- a/src/gcc/df-core.c
+++ b/src/gcc/df-core.c
@@ -642,7 +642,6 @@ void
 df_finish_pass (bool verify ATTRIBUTE_UNUSED)
 {
   int i;
-  int removed = 0;
 
 #ifdef ENABLE_DF_CHECKING
   int saved_flags;
@@ -658,21 +657,15 @@ df_finish_pass (bool verify ATTRIBUTE_UNUSED)
   saved_flags = df->changeable_flags;
 #endif
 
-  for (i = 0; i < df->num_problems_defined; i++)
+  /* We iterate over problems by index as each problem removed will
+     lead to problems_in_order to be reordered.  */
+  for (i = 0; i < DF_LAST_PROBLEM_PLUS1; i++)
     {
-      struct dataflow *dflow = df->problems_in_order[i];
-      struct df_problem *problem = dflow->problem;
+      struct dataflow *dflow = df->problems_by_index[i];
 
-      if (dflow->optional_p)
-	{
-	  gcc_assert (problem->remove_problem_fun);
-	  (problem->remove_problem_fun) ();
-	  df->problems_in_order[i] = NULL;
-	  df->problems_by_index[problem->id] = NULL;
-	  removed++;
-	}
+      if (dflow && dflow->optional_p)
+	df_remove_problem (dflow);
     }
-  df->num_problems_defined -= removed;
 
   /* Clear all of the flags.  */
   df->changeable_flags = 0;
--- a/src/gcc/emit-rtl.c
+++ b/src/gcc/emit-rtl.c
@@ -5234,7 +5234,8 @@ set_for_reg_notes (rtx insn)
   reg = SET_DEST (pat);
 
   /* Notes apply to the contents of a STRICT_LOW_PART.  */
-  if (GET_CODE (reg) == STRICT_LOW_PART)
+  if (GET_CODE (reg) == STRICT_LOW_PART
+      || GET_CODE (reg) == ZERO_EXTRACT)
     reg = XEXP (reg, 0);
 
   /* Check that we have a register.  */
--- a/src/gcc/expmed.c
+++ b/src/gcc/expmed.c
@@ -2664,14 +2664,28 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,
       m = exact_log2 (-orig_t + 1);
       if (m >= 0 && m < maxm)
 	{
-	  op_cost = shiftsub1_cost (speed, mode, m);
+	  op_cost = add_cost (speed, mode) + shift_cost (speed, mode, m);
+	  /* If the target has a cheap shift-and-subtract insn use
+	     that in preference to a shift insn followed by a sub insn.
+	     Assume that the shift-and-sub is "atomic" with a latency
+	     equal to it's cost, otherwise assume that on superscalar
+	     hardware the shift may be executed concurrently with the
+	     earlier steps in the algorithm.  */
+	  if (shiftsub1_cost (speed, mode, m) <= op_cost)
+	    {
+	      op_cost = shiftsub1_cost (speed, mode, m);
+	      op_latency = op_cost;
+	    }
+	  else
+	    op_latency = add_cost (speed, mode);
+
 	  new_limit.cost = best_cost.cost - op_cost;
-	  new_limit.latency = best_cost.latency - op_cost;
+	  new_limit.latency = best_cost.latency - op_latency;
 	  synth_mult (alg_in, (unsigned HOST_WIDE_INT) (-orig_t + 1) >> m,
 		      &new_limit, mode);
 
 	  alg_in->cost.cost += op_cost;
-	  alg_in->cost.latency += op_cost;
+	  alg_in->cost.latency += op_latency;
 	  if (CHEAPER_MULT_COST (&alg_in->cost, &best_cost))
 	    {
 	      best_cost = alg_in->cost;
@@ -2704,20 +2718,12 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,
       if (t % d == 0 && t > d && m < maxm
 	  && (!cache_hit || cache_alg == alg_add_factor))
 	{
-	  /* If the target has a cheap shift-and-add instruction use
-	     that in preference to a shift insn followed by an add insn.
-	     Assume that the shift-and-add is "atomic" with a latency
-	     equal to its cost, otherwise assume that on superscalar
-	     hardware the shift may be executed concurrently with the
-	     earlier steps in the algorithm.  */
 	  op_cost = add_cost (speed, mode) + shift_cost (speed, mode, m);
-	  if (shiftadd_cost (speed, mode, m) < op_cost)
-	    {
-	      op_cost = shiftadd_cost (speed, mode, m);
-	      op_latency = op_cost;
-	    }
-	  else
-	    op_latency = add_cost (speed, mode);
+	  if (shiftadd_cost (speed, mode, m) <= op_cost)
+	    op_cost = shiftadd_cost (speed, mode, m);
+
+	  op_latency = op_cost;
+
 
 	  new_limit.cost = best_cost.cost - op_cost;
 	  new_limit.latency = best_cost.latency - op_latency;
@@ -2742,20 +2748,11 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,
       if (t % d == 0 && t > d && m < maxm
 	  && (!cache_hit || cache_alg == alg_sub_factor))
 	{
-	  /* If the target has a cheap shift-and-subtract insn use
-	     that in preference to a shift insn followed by a sub insn.
-	     Assume that the shift-and-sub is "atomic" with a latency
-	     equal to it's cost, otherwise assume that on superscalar
-	     hardware the shift may be executed concurrently with the
-	     earlier steps in the algorithm.  */
 	  op_cost = add_cost (speed, mode) + shift_cost (speed, mode, m);
-	  if (shiftsub0_cost (speed, mode, m) < op_cost)
-	    {
-	      op_cost = shiftsub0_cost (speed, mode, m);
-	      op_latency = op_cost;
-	    }
-	  else
-	    op_latency = add_cost (speed, mode);
+	  if (shiftsub0_cost (speed, mode, m) <= op_cost)
+	    op_cost = shiftsub0_cost (speed, mode, m);
+
+	  op_latency = op_cost;
 
 	  new_limit.cost = best_cost.cost - op_cost;
 	  new_limit.latency = best_cost.latency - op_latency;
--- a/src/gcc/expr.c
+++ b/src/gcc/expr.c
@@ -7725,15 +7725,7 @@ expand_expr_addr_expr_1 (tree exp, rtx target, machine_mode tmode,
 	     marked TREE_ADDRESSABLE, which will be either a front-end
 	     or a tree optimizer bug.  */
 
-	  if (TREE_ADDRESSABLE (exp)
-	      && ! MEM_P (result)
-	      && ! targetm.calls.allocate_stack_slots_for_args ())
-	    {
-	      error ("local frame unavailable (naked function?)");
-	      return result;
-	    }
-	  else
-	    gcc_assert (MEM_P (result));
+	  gcc_assert (MEM_P (result));
 	  result = XEXP (result, 0);
 
 	  /* ??? Is this needed anymore?  */
@@ -8985,23 +8977,134 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,
 
     case LSHIFT_EXPR:
     case RSHIFT_EXPR:
-      /* If this is a fixed-point operation, then we cannot use the code
-	 below because "expand_shift" doesn't support sat/no-sat fixed-point
-         shifts.   */
-      if (ALL_FIXED_POINT_MODE_P (mode))
-	goto binop;
+      {
+	/* If this is a fixed-point operation, then we cannot use the code
+	   below because "expand_shift" doesn't support sat/no-sat fixed-point
+	   shifts.  */
+	if (ALL_FIXED_POINT_MODE_P (mode))
+	  goto binop;
+
+	if (! safe_from_p (subtarget, treeop1, 1))
+	  subtarget = 0;
+	if (modifier == EXPAND_STACK_PARM)
+	  target = 0;
+	op0 = expand_expr (treeop0, subtarget,
+			   VOIDmode, EXPAND_NORMAL);
+
+	/* Left shift optimization when shifting across word_size boundary.
+
+	   If mode == GET_MODE_WIDER_MODE (word_mode), then normally there isn't
+	   native instruction to support this wide mode left shift.  Given below
+	   scenario:
+
+	    Type A = (Type) B  << C
+
+	    |<		 T	    >|
+	    | dest_high  |  dest_low |
+
+			 | word_size |
+
+	   If the shift amount C caused we shift B to across the word size
+	   boundary, i.e part of B shifted into high half of destination
+	   register, and part of B remains in the low half, then GCC will use
+	   the following left shift expand logic:
+
+	   1. Initialize dest_low to B.
+	   2. Initialize every bit of dest_high to the sign bit of B.
+	   3. Logic left shift dest_low by C bit to finalize dest_low.
+	      The value of dest_low before this shift is kept in a temp D.
+	   4. Logic left shift dest_high by C.
+	   5. Logic right shift D by (word_size - C).
+	   6. Or the result of 4 and 5 to finalize dest_high.
+
+	   While, by checking gimple statements, if operand B is coming from
+	   signed extension, then we can simplify above expand logic into:
+
+	      1. dest_high = src_low >> (word_size - C).
+	      2. dest_low = src_low << C.
+
+	   We can use one arithmetic right shift to finish all the purpose of
+	   steps 2, 4, 5, 6, thus we reduce the steps needed from 6 into 2.  */
+
+	temp = NULL_RTX;
+	if (code == LSHIFT_EXPR
+	    && target
+	    && REG_P (target)
+	    && ! unsignedp
+	    && mode == GET_MODE_WIDER_MODE (word_mode)
+	    && GET_MODE_SIZE (mode) == 2 * GET_MODE_SIZE (word_mode)
+	    && TREE_CONSTANT (treeop1)
+	    && TREE_CODE (treeop0) == SSA_NAME)
+	  {
+	    gimple def = SSA_NAME_DEF_STMT (treeop0);
+	    if (is_gimple_assign (def)
+		&& gimple_assign_rhs_code (def) == NOP_EXPR)
+	      {
+		machine_mode rmode = TYPE_MODE
+		  (TREE_TYPE (gimple_assign_rhs1 (def)));
 
-      if (! safe_from_p (subtarget, treeop1, 1))
-	subtarget = 0;
-      if (modifier == EXPAND_STACK_PARM)
-	target = 0;
-      op0 = expand_expr (treeop0, subtarget,
-			 VOIDmode, EXPAND_NORMAL);
-      temp = expand_variable_shift (code, mode, op0, treeop1, target,
-				    unsignedp);
-      if (code == LSHIFT_EXPR)
-	temp = REDUCE_BIT_FIELD (temp);
-      return temp;
+		if (GET_MODE_SIZE (rmode) < GET_MODE_SIZE (mode)
+		    && TREE_INT_CST_LOW (treeop1) < GET_MODE_BITSIZE (word_mode)
+		    && ((TREE_INT_CST_LOW (treeop1) + GET_MODE_BITSIZE (rmode))
+			>= GET_MODE_BITSIZE (word_mode)))
+		  {
+		    rtx_insn *seq, *seq_old;
+		    unsigned int high_off = subreg_highpart_offset (word_mode,
+								    mode);
+		    rtx low = lowpart_subreg (word_mode, op0, mode);
+		    rtx dest_low = lowpart_subreg (word_mode, target, mode);
+		    rtx dest_high = simplify_gen_subreg (word_mode, target,
+							 mode, high_off);
+		    HOST_WIDE_INT ramount = (BITS_PER_WORD
+					     - TREE_INT_CST_LOW (treeop1));
+		    tree rshift = build_int_cst (TREE_TYPE (treeop1), ramount);
+
+		    start_sequence ();
+		    /* dest_high = src_low >> (word_size - C).  */
+		    temp = expand_variable_shift (RSHIFT_EXPR, word_mode, low,
+						  rshift, dest_high, unsignedp);
+		    if (temp != dest_high)
+		      emit_move_insn (dest_high, temp);
+
+		    /* dest_low = src_low << C.  */
+		    temp = expand_variable_shift (LSHIFT_EXPR, word_mode, low,
+						  treeop1, dest_low, unsignedp);
+		    if (temp != dest_low)
+		      emit_move_insn (dest_low, temp);
+
+		    seq = get_insns ();
+		    end_sequence ();
+		    temp = target ;
+
+		    if (have_insn_for (ASHIFT, mode))
+		      {
+			bool speed_p = optimize_insn_for_speed_p ();
+			start_sequence ();
+			rtx ret_old = expand_variable_shift (code, mode, op0,
+							     treeop1, target,
+							     unsignedp);
+
+			seq_old = get_insns ();
+			end_sequence ();
+			if (seq_cost (seq, speed_p)
+			    >= seq_cost (seq_old, speed_p))
+			  {
+			    seq = seq_old;
+			    temp = ret_old;
+			  }
+		      }
+		      emit_insn (seq);
+		  }
+	      }
+	  }
+
+	if (temp == NULL_RTX)
+	  temp = expand_variable_shift (code, mode, op0, treeop1, target,
+					unsignedp);
+	if (code == LSHIFT_EXPR)
+	  temp = REDUCE_BIT_FIELD (temp);
+	return temp;
+      }
 
       /* Could determine the answer when only additive constants differ.  Also,
 	 the addition of one can be handled by changing the condition.  */
--- a/src/gcc/fold-const.c
+++ b/src/gcc/fold-const.c
@@ -7603,7 +7603,6 @@ native_interpret_real (tree type, const unsigned char *ptr, int len)
 {
   machine_mode mode = TYPE_MODE (type);
   int total_bytes = GET_MODE_SIZE (mode);
-  int byte, offset, word, words, bitpos;
   unsigned char value;
   /* There are always 32 bits in each long, no matter the size of
      the hosts long.  We handle floating point representations with
@@ -7614,16 +7613,18 @@ native_interpret_real (tree type, const unsigned char *ptr, int len)
   total_bytes = GET_MODE_SIZE (TYPE_MODE (type));
   if (total_bytes > len || total_bytes > 24)
     return NULL_TREE;
-  words = (32 / BITS_PER_UNIT) / UNITS_PER_WORD;
+  int words = (32 / BITS_PER_UNIT) / UNITS_PER_WORD;
 
   memset (tmp, 0, sizeof (tmp));
-  for (bitpos = 0; bitpos < total_bytes * BITS_PER_UNIT;
+  for (int bitpos = 0; bitpos < total_bytes * BITS_PER_UNIT;
        bitpos += BITS_PER_UNIT)
     {
-      byte = (bitpos / BITS_PER_UNIT) & 3;
+      /* Both OFFSET and BYTE index within a long;
+	 bitpos indexes the whole float.  */
+      int offset, byte = (bitpos / BITS_PER_UNIT) & 3;
       if (UNITS_PER_WORD < 4)
 	{
-	  word = byte / UNITS_PER_WORD;
+	  int word = byte / UNITS_PER_WORD;
 	  if (WORDS_BIG_ENDIAN)
 	    word = (words - 1) - word;
 	  offset = word * UNITS_PER_WORD;
@@ -7633,7 +7634,16 @@ native_interpret_real (tree type, const unsigned char *ptr, int len)
 	    offset += byte % UNITS_PER_WORD;
 	}
       else
-	offset = BYTES_BIG_ENDIAN ? 3 - byte : byte;
+	{
+	  offset = byte;
+	  if (BYTES_BIG_ENDIAN)
+	    {
+	      /* Reverse bytes within each long, or within the entire float
+		 if it's smaller than a long (for HFmode).  */
+	      offset = MIN (3, total_bytes - 1) - offset;
+	      gcc_assert (offset >= 0);
+	    }
+	}
       value = ptr[offset + ((bitpos / BITS_PER_UNIT) & ~3)];
 
       tmp[bitpos / 32] |= (unsigned long)value << (bitpos & 31);
--- a/src/gcc/fortran/Make-lang.in
+++ b/src/gcc/fortran/Make-lang.in
@@ -167,7 +167,7 @@ check-f95-subtargets : check-gfortran-subtargets
 check-fortran-subtargets : check-gfortran-subtargets
 lang_checks += check-gfortran
 lang_checks_parallelized += check-gfortran
-# For description see comment above check_gcc_parallelize in gcc/Makefile.in.
+# For description see the check_$lang_parallelize comment in gcc/Makefile.in.
 check_gfortran_parallelize = 10000
 
 # GFORTRAN documentation.
@@ -275,7 +275,7 @@ fortran.uninstall:
 # We just have to delete files specific to us.
 
 fortran.mostlyclean:
-	-rm -f f951$(exeext)
+	-rm -f gfortran$(exeext) gfortran-cross$(exeext) f951$(exeext)
 	-rm -f fortran/*.o
 
 fortran.clean:
--- a/src/gcc/function.c
+++ b/src/gcc/function.c
@@ -227,6 +227,7 @@ free_after_compilation (struct function *f)
   f->eh = NULL;
   f->machine = NULL;
   f->cfg = NULL;
+  f->curr_properties &= ~PROP_cfg;
 
   regno_reg_rtx = NULL;
 }
@@ -2121,9 +2122,6 @@ aggregate_value_p (const_tree exp, const_tree fntype)
 bool
 use_register_for_decl (const_tree decl)
 {
-  if (!targetm.calls.allocate_stack_slots_for_args ())
-    return true;
-
   /* Honor volatile.  */
   if (TREE_SIDE_EFFECTS (decl))
     return false;
@@ -2151,6 +2149,9 @@ use_register_for_decl (const_tree decl)
   if (flag_float_store && FLOAT_TYPE_P (TREE_TYPE (decl)))
     return false;
 
+  if (!targetm.calls.allocate_stack_slots_for_args ())
+    return true;
+
   /* If we're not interested in tracking debugging information for
      this decl, then we can certainly put it in a register.  */
   if (DECL_IGNORED_P (decl))
--- a/src/gcc/genmatch.c
+++ b/src/gcc/genmatch.c
@@ -2922,7 +2922,12 @@ parser::parse_operation ()
 
   user_id *p = dyn_cast<user_id *> (op);
   if (p && p->is_oper_list)
-    record_operlist (id_tok->src_loc, p);
+    {
+      if (active_fors.length() == 0)
+	record_operlist (id_tok->src_loc, p);
+      else
+	fatal_at (id_tok, "operator-list %s cannot be exapnded inside 'for'", id);
+    }
   return op;
 }
 
@@ -3338,8 +3343,13 @@ parser::parse_for (source_location)
 		      "others with arity %d", oper, idb->nargs, arity);
 
 	  user_id *p = dyn_cast<user_id *> (idb);
-	  if (p && p->is_oper_list)
-	    op->substitutes.safe_splice (p->substitutes);
+	  if (p)
+	    {
+	      if (p->is_oper_list)
+		op->substitutes.safe_splice (p->substitutes);
+	      else
+		fatal_at (token, "iterator cannot be used as operator-list");
+	    }
 	  else 
 	    op->substitutes.safe_push (idb);
 	}
@@ -3436,6 +3446,11 @@ parser::parse_operator_list (source_location)
 	op->substitutes.safe_push (idb);
     }
 
+  // Check that there is no junk after id-list
+  token = peek();
+  if (token->type != CPP_CLOSE_PAREN)
+    fatal_at (token, "expected identifier got %s", cpp_type2name (token->type, 0));
+
   if (op->substitutes.length () == 0)
     fatal_at (token, "operator-list cannot be empty");
 
--- a/src/gcc/genpreds.c
+++ b/src/gcc/genpreds.c
@@ -640,12 +640,14 @@ struct constraint_data
   const char *regclass;  /* for register constraints */
   rtx exp;               /* for other constraints */
   unsigned int lineno;   /* line of definition */
-  unsigned int is_register  : 1;
-  unsigned int is_const_int : 1;
-  unsigned int is_const_dbl : 1;
-  unsigned int is_extra     : 1;
-  unsigned int is_memory    : 1;
-  unsigned int is_address   : 1;
+  unsigned int is_register	: 1;
+  unsigned int is_const_int	: 1;
+  unsigned int is_const_dbl	: 1;
+  unsigned int is_extra		: 1;
+  unsigned int is_memory	: 1;
+  unsigned int is_address	: 1;
+  unsigned int maybe_allows_reg : 1;
+  unsigned int maybe_allows_mem : 1;
 };
 
 /* Overview of all constraints beginning with a given letter.  */
@@ -691,6 +693,9 @@ static unsigned int satisfied_start;
 static unsigned int const_int_start, const_int_end;
 static unsigned int memory_start, memory_end;
 static unsigned int address_start, address_end;
+static unsigned int maybe_allows_none_start, maybe_allows_none_end;
+static unsigned int maybe_allows_reg_start, maybe_allows_reg_end;
+static unsigned int maybe_allows_mem_start, maybe_allows_mem_end;
 
 /* Convert NAME, which contains angle brackets and/or underscores, to
    a string that can be used as part of a C identifier.  The string
@@ -711,6 +716,34 @@ mangle (const char *name)
   return XOBFINISH (rtl_obstack, const char *);
 }
 
+/* Return a bitmask, bit 1 if EXP maybe allows a REG/SUBREG, 2 if EXP
+   maybe allows a MEM.  Bits should be clear only when we are sure it
+   will not allow a REG/SUBREG or a MEM.  */
+static int
+compute_maybe_allows (rtx exp)
+{
+  switch (GET_CODE (exp))
+    {
+    case IF_THEN_ELSE:
+      /* Conservative answer is like IOR, of the THEN and ELSE branches.  */
+      return compute_maybe_allows (XEXP (exp, 1))
+	     | compute_maybe_allows (XEXP (exp, 2));
+    case AND:
+      return compute_maybe_allows (XEXP (exp, 0))
+	     & compute_maybe_allows (XEXP (exp, 1));
+    case IOR:
+      return compute_maybe_allows (XEXP (exp, 0))
+	     | compute_maybe_allows (XEXP (exp, 1));
+    case MATCH_CODE:
+      if (*XSTR (exp, 1) == '\0')
+	return (strstr (XSTR (exp, 0), "reg") != NULL ? 1 : 0)
+	       | (strstr (XSTR (exp, 0), "mem") != NULL ? 2 : 0);
+      /* FALLTHRU */
+    default:
+      return 3;
+    }
+}
+
 /* Add one constraint, of any sort, to the tables.  NAME is its name;
    REGCLASS is the register class, if any; EXP is the expression to
    test, if any;  IS_MEMORY and IS_ADDRESS indicate memory and address
@@ -866,6 +899,11 @@ add_constraint (const char *name, const char *regclass,
   c->is_extra = !(regclass || is_const_int || is_const_dbl);
   c->is_memory = is_memory;
   c->is_address = is_address;
+  int maybe_allows = 3;
+  if (exp)
+    maybe_allows = compute_maybe_allows (exp);
+  c->maybe_allows_reg = (maybe_allows & 1) != 0;
+  c->maybe_allows_mem = (maybe_allows & 2) != 0;
 
   c->next_this_letter = *slot;
   *slot = c;
@@ -940,8 +978,30 @@ choose_enum_order (void)
       enum_order[next++] = c;
   address_end = next;
 
+  maybe_allows_none_start = next;
+  FOR_ALL_CONSTRAINTS (c)
+    if (!c->is_register && !c->is_const_int && !c->is_memory && !c->is_address
+	&& !c->maybe_allows_reg && !c->maybe_allows_mem)
+      enum_order[next++] = c;
+  maybe_allows_none_end = next;
+
+  maybe_allows_reg_start = next;
+  FOR_ALL_CONSTRAINTS (c)
+    if (!c->is_register && !c->is_const_int && !c->is_memory && !c->is_address
+	&& c->maybe_allows_reg && !c->maybe_allows_mem)
+      enum_order[next++] = c;
+  maybe_allows_reg_end = next;
+
+  maybe_allows_mem_start = next;
+  FOR_ALL_CONSTRAINTS (c)
+    if (!c->is_register && !c->is_const_int && !c->is_memory && !c->is_address
+	&& !c->maybe_allows_reg && c->maybe_allows_mem)
+      enum_order[next++] = c;
+  maybe_allows_mem_end = next;
+
   FOR_ALL_CONSTRAINTS (c)
-    if (!c->is_register && !c->is_const_int && !c->is_memory && !c->is_address)
+    if (!c->is_register && !c->is_const_int && !c->is_memory && !c->is_address
+	&& c->maybe_allows_reg && c->maybe_allows_mem)
       enum_order[next++] = c;
   gcc_assert (next == num_constraints);
 }
@@ -1229,6 +1289,41 @@ write_range_function (const char *name, unsigned int start, unsigned int end)
 	    "}\n\n", name);
 }
 
+/* Write a definition for insn_extra_constraint_allows_reg_mem function.  */
+static void
+write_allows_reg_mem_function (void)
+{
+  printf ("static inline void\n"
+	  "insn_extra_constraint_allows_reg_mem (enum constraint_num c,\n"
+	  "\t\t\t\t      bool *allows_reg, bool *allows_mem)\n"
+	  "{\n");
+  if (maybe_allows_none_start != maybe_allows_none_end)
+    printf ("  if (c >= CONSTRAINT_%s && c <= CONSTRAINT_%s)\n"
+	    "    return;\n",
+	    enum_order[maybe_allows_none_start]->c_name,
+	    enum_order[maybe_allows_none_end - 1]->c_name);
+  if (maybe_allows_reg_start != maybe_allows_reg_end)
+    printf ("  if (c >= CONSTRAINT_%s && c <= CONSTRAINT_%s)\n"
+	    "    {\n"
+	    "      *allows_reg = true;\n"
+	    "      return;\n"
+	    "    }\n",
+	    enum_order[maybe_allows_reg_start]->c_name,
+	    enum_order[maybe_allows_reg_end - 1]->c_name);
+  if (maybe_allows_mem_start != maybe_allows_mem_end)
+    printf ("  if (c >= CONSTRAINT_%s && c <= CONSTRAINT_%s)\n"
+	    "    {\n"
+	    "      *allows_mem = true;\n"
+	    "      return;\n"
+	    "    }\n",
+	    enum_order[maybe_allows_mem_start]->c_name,
+	    enum_order[maybe_allows_mem_end - 1]->c_name);
+  printf ("  (void) c;\n"
+	  "  *allows_reg = true;\n"
+	  "  *allows_mem = true;\n"
+	  "}\n\n");
+}
+
 /* VEC is a list of key/value pairs, with the keys being lower bounds
    of a range.  Output a decision tree that handles the keys covered by
    [VEC[START], VEC[END]), returning FALLBACK for keys lower then VEC[START]'s.
@@ -1326,6 +1421,7 @@ write_tm_preds_h (void)
 			    memory_start, memory_end);
       write_range_function ("insn_extra_address_constraint",
 			    address_start, address_end);
+      write_allows_reg_mem_function ();
 
       if (constraint_max_namelen > 1)
         {
--- a/src/gcc/go/Make-lang.in
+++ b/src/gcc/go/Make-lang.in
@@ -197,6 +197,7 @@ go.uninstall:
 go.mostlyclean:
 	-rm -f go/*$(objext)
 	-rm -f go/*$(coverageexts)
+	-rm -f gccgo$(exeext) gccgo-cross$(exeext) go1$(exeext)
 go.clean:
 go.distclean:
 go.maintainer-clean:
--- a/src/gcc/haifa-sched.c
+++ b/src/gcc/haifa-sched.c
@@ -5553,6 +5553,35 @@ insn_finishes_cycle_p (rtx_insn *insn)
   return false;
 }
 
+/* Helper for autopref_multipass_init.  Given a SET in PAT and whether
+   we're expecting a memory WRITE or not, check that the insn is relevant to
+   the autoprefetcher modelling code.  Return true iff that is the case.
+   If it is relevant, record the base register of the memory op in BASE and
+   the offset in OFFSET.  */
+
+static bool
+analyze_set_insn_for_autopref (rtx pat, bool write, rtx *base, int *offset)
+{
+  if (GET_CODE (pat) != SET)
+    return false;
+
+  rtx mem = write ? SET_DEST (pat) : SET_SRC (pat);
+  if (!MEM_P (mem))
+    return false;
+
+  struct address_info info;
+  decompose_mem_address (&info, mem);
+
+  /* TODO: Currently only (base+const) addressing is supported.  */
+  if (info.base == NULL || !REG_P (*info.base)
+      || (info.disp != NULL && !CONST_INT_P (*info.disp)))
+    return false;
+
+  *base = *info.base;
+  *offset = info.disp ? INTVAL (*info.disp) : 0;
+  return true;
+}
+
 /* Functions to model cache auto-prefetcher.
 
    Some of the CPUs have cache auto-prefetcher, which /seems/ to initiate
@@ -5577,30 +5606,139 @@ autopref_multipass_init (const rtx_insn *insn, int write)
 
   gcc_assert (data->status == AUTOPREF_MULTIPASS_DATA_UNINITIALIZED);
   data->base = NULL_RTX;
-  data->offset = 0;
+  data->min_offset = 0;
+  data->max_offset = 0;
+  data->multi_mem_insn_p = false;
   /* Set insn entry initialized, but not relevant for auto-prefetcher.  */
   data->status = AUTOPREF_MULTIPASS_DATA_IRRELEVANT;
 
+  rtx pat = PATTERN (insn);
+
+  /* We have a multi-set insn like a load-multiple or store-multiple.
+     We care about these as long as all the memory ops inside the PARALLEL
+     have the same base register.  We care about the minimum and maximum
+     offsets from that base but don't check for the order of those offsets
+     within the PARALLEL insn itself.  */
+  if (GET_CODE (pat) == PARALLEL)
+    {
+      int n_elems = XVECLEN (pat, 0);
+
+      int i = 0;
+      rtx prev_base = NULL_RTX;
+      int min_offset;
+      int max_offset;
+
+      for (i = 0; i < n_elems; i++)
+	{
+	  rtx set = XVECEXP (pat, 0, i);
+	  if (GET_CODE (set) != SET)
+	    return;
+
+	  rtx base = NULL_RTX;
+	  int offset = 0;
+	  if (!analyze_set_insn_for_autopref (set, write, &base, &offset))
+	    return;
+
+	  if (i == 0)
+	    {
+	      prev_base = base;
+	      min_offset = offset;
+	      max_offset = offset;
+	    }
+	  /* Ensure that all memory operations in the PARALLEL use the same
+	     base register.  */
+	  else if (REGNO (base) != REGNO (prev_base))
+	    return;
+	  else
+	    {
+	      min_offset = MIN (min_offset, offset);
+	      max_offset = MAX (max_offset, offset);
+	    }
+	}
+
+      /* If we reached here then we have a valid PARALLEL of multiple memory
+	 ops with prev_base as the base and min_offset and max_offset
+	 containing the offsets range.  */
+      gcc_assert (prev_base);
+      data->base = prev_base;
+      data->min_offset = min_offset;
+      data->max_offset = max_offset;
+      data->multi_mem_insn_p = true;
+      data->status = AUTOPREF_MULTIPASS_DATA_NORMAL;
+
+      return;
+    }
+
+  /* Otherwise this is a single set memory operation.  */
   rtx set = single_set (insn);
   if (set == NULL_RTX)
     return;
 
-  rtx mem = write ? SET_DEST (set) : SET_SRC (set);
-  if (!MEM_P (mem))
+  if (!analyze_set_insn_for_autopref (set, write, &data->base,
+				       &data->min_offset))
     return;
 
-  struct address_info info;
-  decompose_mem_address (&info, mem);
+  /* This insn is relevant for the auto-prefetcher.
+     The base and offset fields will have been filled in the
+     analyze_set_insn_for_autopref call above.  */
+  data->status = AUTOPREF_MULTIPASS_DATA_NORMAL;
+}
 
-  /* TODO: Currently only (base+const) addressing is supported.  */
-  if (info.base == NULL || !REG_P (*info.base)
-      || (info.disp != NULL && !CONST_INT_P (*info.disp)))
-    return;
 
-  /* This insn is relevant for auto-prefetcher.  */
-  data->base = *info.base;
-  data->offset = info.disp ? INTVAL (*info.disp) : 0;
-  data->status = AUTOPREF_MULTIPASS_DATA_NORMAL;
+/* Helper for autopref_rank_for_schedule.  Given the data of two
+   insns relevant to the auto-prefetcher modelling code DATA1 and DATA2
+   return their comparison result.  Return 0 if there is no sensible
+   ranking order for the two insns.  */
+
+static int
+autopref_rank_data (autopref_multipass_data_t data1,
+		     autopref_multipass_data_t data2)
+{
+  /* Simple case when both insns are simple single memory ops.  */
+  if (!data1->multi_mem_insn_p && !data2->multi_mem_insn_p)
+    return data1->min_offset - data2->min_offset;
+
+  /* Two load/store multiple insns.  Return 0 if the offset ranges
+     overlap and the difference between the minimum offsets otherwise.  */
+  else if (data1->multi_mem_insn_p && data2->multi_mem_insn_p)
+    {
+      int min1 = data1->min_offset;
+      int max1 = data1->max_offset;
+      int min2 = data2->min_offset;
+      int max2 = data2->max_offset;
+
+      if (max1 < min2 || min1 > max2)
+	return min1 - min2;
+      else
+	return 0;
+    }
+
+  /* The other two cases is a pair of a load/store multiple and
+     a simple memory op.  Return 0 if the single op's offset is within the
+     range of the multi-op insn and the difference between the single offset
+     and the minimum offset of the multi-set insn otherwise.  */
+  else if (data1->multi_mem_insn_p && !data2->multi_mem_insn_p)
+    {
+      int max1 = data1->max_offset;
+      int min1 = data1->min_offset;
+
+      if (data2->min_offset >= min1
+	  && data2->min_offset <= max1)
+	return 0;
+      else
+	return min1 - data2->min_offset;
+    }
+  else
+    {
+      int max2 = data2->max_offset;
+      int min2 = data2->min_offset;
+
+      if (data1->min_offset >= min2
+	  && data1->min_offset <= max2)
+	return 0;
+      else
+	return data1->min_offset - min2;
+    }
 }
 
 /* Helper function for rank_for_schedule sorting.  */
@@ -5627,7 +5765,7 @@ autopref_rank_for_schedule (const rtx_insn *insn1, const rtx_insn *insn2)
       if (!rtx_equal_p (data1->base, data2->base))
 	continue;
 
-      return data1->offset - data2->offset;
+      return autopref_rank_data (data1, data2);
     }
 
   return 0;
@@ -5653,7 +5791,7 @@ autopref_multipass_dfa_lookahead_guard_1 (const rtx_insn *insn1,
     return 0;
 
   if (rtx_equal_p (data1->base, data2->base)
-      && data1->offset > data2->offset)
+      && autopref_rank_data (data1, data2) > 0)
     {
       if (sched_verbose >= 2)
 	{
--- a/src/gcc/ifcvt.c
+++ b/src/gcc/ifcvt.c
@@ -1046,7 +1046,7 @@ cc_in_cond (rtx cond)
 
 /* Return sequence of instructions generated by if conversion.  This
    function calls end_sequence() to end the current stream, ensures
-   that are instructions are unshared, recognizable non-jump insns.
+   that the instructions are unshared, recognizable non-jump insns.
    On failure, this function returns a NULL_RTX.  */
 
 static rtx_insn *
@@ -1175,24 +1175,45 @@ noce_try_store_flag (struct noce_if_info *if_info)
     }
 }
 
-/* Convert "if (test) x = a; else x = b", for A and B constant.  */
+/* Convert "if (test) x = a; else x = b", for A and B constant.
+   Also allow A = y + c1, B = y + c2, with a common y between A
+   and B.  */
 
 static int
 noce_try_store_flag_constants (struct noce_if_info *if_info)
 {
   rtx target;
   rtx_insn *seq;
-  int reversep;
+  bool reversep;
   HOST_WIDE_INT itrue, ifalse, diff, tmp;
-  int normalize, can_reverse;
-  machine_mode mode;
+  int normalize;
+  bool can_reverse;
+  machine_mode mode = GET_MODE (if_info->x);;
+  rtx common = NULL_RTX;
+
+  rtx a = if_info->a;
+  rtx b = if_info->b;
 
-  if (CONST_INT_P (if_info->a)
-      && CONST_INT_P (if_info->b))
+  /* Handle cases like x := test ? y + 3 : y + 4.  */
+  if (GET_CODE (a) == PLUS
+      && GET_CODE (b) == PLUS
+      && CONST_INT_P (XEXP (a, 1))
+      && CONST_INT_P (XEXP (b, 1))
+      && rtx_equal_p (XEXP (a, 0), XEXP (b, 0))
+      && noce_operand_ok (XEXP (a, 0))
+      && if_info->branch_cost >= 2)
     {
-      mode = GET_MODE (if_info->x);
-      ifalse = INTVAL (if_info->a);
-      itrue = INTVAL (if_info->b);
+      common = XEXP (a, 0);
+      a = XEXP (a, 1);
+      b = XEXP (b, 1);
+    }
+
+  if (CONST_INT_P (a)
+      && CONST_INT_P (b))
+    {
+      ifalse = INTVAL (a);
+      itrue = INTVAL (b);
+      bool subtract_flag_p = false;
 
       diff = (unsigned HOST_WIDE_INT) itrue - ifalse;
       /* Make sure we can represent the difference between the two values.  */
@@ -1205,26 +1226,71 @@ noce_try_store_flag_constants (struct noce_if_info *if_info)
       can_reverse = (reversed_comparison_code (if_info->cond, if_info->jump)
 		     != UNKNOWN);
 
-      reversep = 0;
+      reversep = false;
       if (diff == STORE_FLAG_VALUE || diff == -STORE_FLAG_VALUE)
-	normalize = 0;
+	{
+	  normalize = 0;
+	  /* We could collapse these cases but it is easier to follow the
+	     diff/STORE_FLAG_VALUE combinations when they are listed
+	     explicitly.  */
+
+	  /* test ? 3 : 4
+	     => 4 + (test != 0).  */
+	  if (diff < 0 && STORE_FLAG_VALUE < 0)
+	      reversep = false;
+	  /* test ? 4 : 3
+	     => can_reverse  | 4 + (test == 0)
+		!can_reverse | 3 - (test != 0).  */
+	  else if (diff > 0 && STORE_FLAG_VALUE < 0)
+	    {
+	      reversep = can_reverse;
+	      subtract_flag_p = !can_reverse;
+	      /* If we need to subtract the flag and we have PLUS-immediate
+		 A and B then it is unlikely to be beneficial to play tricks
+		 here.  */
+	      if (subtract_flag_p && common)
+		return FALSE;
+	    }
+	  /* test ? 3 : 4
+	     => can_reverse  | 3 + (test == 0)
+		!can_reverse | 4 - (test != 0).  */
+	  else if (diff < 0 && STORE_FLAG_VALUE > 0)
+	    {
+	      reversep = can_reverse;
+	      subtract_flag_p = !can_reverse;
+	      /* If we need to subtract the flag and we have PLUS-immediate
+		 A and B then it is unlikely to be beneficial to play tricks
+		 here.  */
+	      if (subtract_flag_p && common)
+		return FALSE;
+	    }
+	  /* test ? 4 : 3
+	     => 4 + (test != 0).  */
+	  else if (diff > 0 && STORE_FLAG_VALUE > 0)
+	    reversep = false;
+	  else
+	    gcc_unreachable ();
+	}
       else if (ifalse == 0 && exact_log2 (itrue) >= 0
 	       && (STORE_FLAG_VALUE == 1
 		   || if_info->branch_cost >= 2))
 	normalize = 1;
       else if (itrue == 0 && exact_log2 (ifalse) >= 0 && can_reverse
 	       && (STORE_FLAG_VALUE == 1 || if_info->branch_cost >= 2))
-	normalize = 1, reversep = 1;
+	{
+	  normalize = 1;
+	  reversep = true;
+	}
       else if (itrue == -1
 	       && (STORE_FLAG_VALUE == -1
 		   || if_info->branch_cost >= 2))
 	normalize = -1;
       else if (ifalse == -1 && can_reverse
 	       && (STORE_FLAG_VALUE == -1 || if_info->branch_cost >= 2))
-	normalize = -1, reversep = 1;
-      else if ((if_info->branch_cost >= 2 && STORE_FLAG_VALUE == -1)
-	       || if_info->branch_cost >= 3)
-	normalize = -1;
+	{
+	  normalize = -1;
+	  reversep = true;
+	}
       else
 	return FALSE;
 
@@ -1235,6 +1301,15 @@ noce_try_store_flag_constants (struct noce_if_info *if_info)
 	}
 
       start_sequence ();
+
+      /* If we have x := test ? x + 3 : x + 4 then move the original
+	 x out of the way while we store flags.  */
+      if (common && rtx_equal_p (common, if_info->x))
+	{
+	  common = gen_reg_rtx (mode);
+	  noce_emit_move_insn (common, if_info->x);
+	}
+
       target = noce_emit_store_flag (if_info, if_info->x, reversep, normalize);
       if (! target)
 	{
@@ -1246,13 +1321,27 @@ noce_try_store_flag_constants (struct noce_if_info *if_info)
 	 =>   x = 3 + (test == 0);  */
       if (diff == STORE_FLAG_VALUE || diff == -STORE_FLAG_VALUE)
 	{
-	  target = expand_simple_binop (mode,
-					(diff == STORE_FLAG_VALUE
-					 ? PLUS : MINUS),
+	  /* Add the common part now.  This may allow combine to merge this
+	     with the store flag operation earlier into some sort of conditional
+	     increment/decrement if the target allows it.  */
+	  if (common)
+	    target = expand_simple_binop (mode, PLUS,
+					   target, common,
+					   target, 0, OPTAB_WIDEN);
+
+	  /* Always use ifalse here.  It should have been swapped with itrue
+	     when appropriate when reversep is true.  */
+	  target = expand_simple_binop (mode, subtract_flag_p ? MINUS : PLUS,
 					gen_int_mode (ifalse, mode), target,
 					if_info->x, 0, OPTAB_WIDEN);
 	}
-
+      /* Other cases are not beneficial when the original A and B are PLUS
+	 expressions.  */
+      else if (common)
+	{
+	  end_sequence ();
+	  return FALSE;
+	}
       /* if (test) x = 8; else x = 0;
 	 =>   x = (test != 0) << 3;  */
       else if (ifalse == 0 && (tmp = exact_log2 (itrue)) >= 0)
@@ -1270,18 +1359,10 @@ noce_try_store_flag_constants (struct noce_if_info *if_info)
 					target, gen_int_mode (ifalse, mode),
 					if_info->x, 0, OPTAB_WIDEN);
 	}
-
-      /* if (test) x = a; else x = b;
-	 =>   x = (-(test != 0) & (b - a)) + a;  */
       else
 	{
-	  target = expand_simple_binop (mode, AND,
-					target, gen_int_mode (diff, mode),
-					if_info->x, 0, OPTAB_WIDEN);
-	  if (target)
-	    target = expand_simple_binop (mode, PLUS,
-					  target, gen_int_mode (ifalse, mode),
-					  if_info->x, 0, OPTAB_WIDEN);
+	  end_sequence ();
+	  return FALSE;
 	}
 
       if (! target)
@@ -1606,11 +1687,67 @@ noce_try_cmove (struct noce_if_info *if_info)
 				   INSN_LOCATION (if_info->insn_a));
 	  return TRUE;
 	}
-      else
+      /* If both a and b are constants try a last-ditch transformation:
+	 if (test) x = a; else x = b;
+	 =>   x = (-(test != 0) & (b - a)) + a;
+	 Try this only if the target-specific expansion above has failed.
+	 The target-specific expander may want to generate sequences that
+	 we don't know about, so give them a chance before trying this
+	 approach.  */
+      else if (!targetm.have_conditional_execution ()
+		&& CONST_INT_P (if_info->a) && CONST_INT_P (if_info->b)
+		&& ((if_info->branch_cost >= 2 && STORE_FLAG_VALUE == -1)
+		    || if_info->branch_cost >= 3))
 	{
-	  end_sequence ();
-	  return FALSE;
+	  machine_mode mode = GET_MODE (if_info->x);
+	  HOST_WIDE_INT ifalse = INTVAL (if_info->a);
+	  HOST_WIDE_INT itrue = INTVAL (if_info->b);
+	  rtx target = noce_emit_store_flag (if_info, if_info->x, false, -1);
+	  if (!target)
+	    {
+	      end_sequence ();
+	      return FALSE;
+	    }
+
+	  HOST_WIDE_INT diff = (unsigned HOST_WIDE_INT) itrue - ifalse;
+	  /* Make sure we can represent the difference
+	     between the two values.  */
+	  if ((diff > 0)
+	      != ((ifalse < 0) != (itrue < 0) ? ifalse < 0 : ifalse < itrue))
+	    {
+	      end_sequence ();
+	      return FALSE;
+	    }
+
+	  diff = trunc_int_for_mode (diff, mode);
+	  target = expand_simple_binop (mode, AND,
+					target, gen_int_mode (diff, mode),
+					if_info->x, 0, OPTAB_WIDEN);
+	  if (target)
+	    target = expand_simple_binop (mode, PLUS,
+					  target, gen_int_mode (ifalse, mode),
+					  if_info->x, 0, OPTAB_WIDEN);
+	  if (target)
+	    {
+	      if (target != if_info->x)
+		noce_emit_move_insn (if_info->x, target);
+
+	      seq = end_ifcvt_sequence (if_info);
+	      if (!seq)
+		return FALSE;
+
+	      emit_insn_before_setloc (seq, if_info->jump,
+				   INSN_LOCATION (if_info->insn_a));
+	      return TRUE;
+	    }
+	  else
+	    {
+	      end_sequence ();
+	      return FALSE;
+	    }
 	}
+      else
+	end_sequence ();
     }
 
   return FALSE;
@@ -2766,13 +2903,14 @@ noce_process_if_block (struct noce_if_info *if_info)
     goto success;
   if (noce_try_abs (if_info))
     goto success;
+  if (!targetm.have_conditional_execution ()
+      && noce_try_store_flag_constants (if_info))
+    goto success;
   if (HAVE_conditional_move
       && noce_try_cmove (if_info))
     goto success;
   if (! targetm.have_conditional_execution ())
     {
-      if (noce_try_store_flag_constants (if_info))
-	goto success;
       if (noce_try_addcc (if_info))
 	goto success;
       if (noce_try_store_flag_mask (if_info))
--- a/src/gcc/ira-color.c
+++ b/src/gcc/ira-color.c
@@ -1331,10 +1331,12 @@ get_next_update_cost (ira_allocno_t *allocno, ira_allocno_t *from, int *divisor)
   return true;
 }
 
-/* Increase costs of HARD_REGNO by UPDATE_COST for ALLOCNO.  Return
-   true if we really modified the cost.  */
+/* Increase costs of HARD_REGNO by UPDATE_COST and conflict cost by
+   UPDATE_CONFLICT_COST for ALLOCNO.  Return true if we really
+   modified the cost.  */
 static bool
-update_allocno_cost (ira_allocno_t allocno, int hard_regno, int update_cost)
+update_allocno_cost (ira_allocno_t allocno, int hard_regno,
+		     int update_cost, int update_conflict_cost)
 {
   int i;
   enum reg_class aclass = ALLOCNO_CLASS (allocno);
@@ -1350,7 +1352,7 @@ update_allocno_cost (ira_allocno_t allocno, int hard_regno, int update_cost)
     (&ALLOCNO_UPDATED_CONFLICT_HARD_REG_COSTS (allocno),
      aclass, 0, ALLOCNO_CONFLICT_HARD_REG_COSTS (allocno));
   ALLOCNO_UPDATED_HARD_REG_COSTS (allocno)[i] += update_cost;
-  ALLOCNO_UPDATED_CONFLICT_HARD_REG_COSTS (allocno)[i] += update_cost;
+  ALLOCNO_UPDATED_CONFLICT_HARD_REG_COSTS (allocno)[i] += update_conflict_cost;
   return true;
 }
 
@@ -1362,7 +1364,7 @@ static void
 update_costs_from_allocno (ira_allocno_t allocno, int hard_regno,
 			   int divisor, bool decr_p, bool record_p)
 {
-  int cost, update_cost;
+  int cost, update_cost, update_conflict_cost;
   machine_mode mode;
   enum reg_class rclass, aclass;
   ira_allocno_t another_allocno, from = NULL;
@@ -1403,11 +1405,20 @@ update_costs_from_allocno (ira_allocno_t allocno, int hard_regno,
 	  if (decr_p)
 	    cost = -cost;
 
-	  update_cost = cp->freq * cost / divisor;
+	  update_conflict_cost = update_cost = cp->freq * cost / divisor;
+
+	  if (ALLOCNO_COLOR_DATA (another_allocno) != NULL
+	      && (ALLOCNO_COLOR_DATA (allocno)->first_thread_allocno
+		  != ALLOCNO_COLOR_DATA (another_allocno)->first_thread_allocno))
+	    /* Decrease conflict cost of ANOTHER_ALLOCNO if it is not
+	       in the same allocation thread.  */
+	    update_conflict_cost /= COST_HOP_DIVISOR;
+
 	  if (update_cost == 0)
 	    continue;
 
-	  if (! update_allocno_cost (another_allocno, hard_regno, update_cost))
+	  if (! update_allocno_cost (another_allocno, hard_regno,
+				     update_cost, update_conflict_cost))
 	    continue;
 	  queue_update_cost (another_allocno, allocno, divisor * COST_HOP_DIVISOR);
 	  if (record_p && ALLOCNO_COLOR_DATA (another_allocno) != NULL)
--- a/src/gcc/ira-costs.c
+++ b/src/gcc/ira-costs.c
@@ -1380,8 +1380,6 @@ record_operand_costs (rtx_insn *insn, enum reg_class *pref)
       rtx dest = SET_DEST (set);
       rtx src = SET_SRC (set);
 
-      dest = SET_DEST (set);
-      src = SET_SRC (set);
       if (GET_CODE (dest) == SUBREG
 	  && (GET_MODE_SIZE (GET_MODE (dest))
 	      == GET_MODE_SIZE (GET_MODE (SUBREG_REG (dest)))))
--- a/src/gcc/jit/Make-lang.in
+++ b/src/gcc/jit/Make-lang.in
@@ -285,6 +285,10 @@ jit.uninstall:
 # We just have to delete files specific to us.
 
 jit.mostlyclean:
+	-rm -f $(LIBGCCJIT_FILENAME) $(LIBGCCJIT_SYMLINK)
+	-rm -f $(LIBGCCJIT_LINKER_NAME_SYMLINK) $(FULL_DRIVER_NAME)
+	-rm -f $(LIBGCCJIT_SONAME)
+	-rm -f $(jit_OBJS)
 
 jit.clean:
 
--- a/src/gcc/loop-invariant.c
+++ b/src/gcc/loop-invariant.c
@@ -696,6 +696,8 @@ find_defs (struct loop *loop)
   df_remove_problem (df_chain);
   df_process_deferred_rescans ();
   df_chain_add_problem (DF_UD_CHAIN);
+  df_live_add_problem ();
+  df_live_set_all_dirty ();
   df_set_flags (DF_RD_PRUNE_DEAD_DEFS);
   df_analyze_loop (loop);
   check_invariant_table_size ();
@@ -740,8 +742,11 @@ create_new_invariant (struct def *def, rtx_insn *insn, bitmap depends_on,
 	 enough to not regress 410.bwaves either (by still moving reg+reg
 	 invariants).
 	 See http://gcc.gnu.org/ml/gcc-patches/2009-10/msg01210.html .  */
-      inv->cheap_address = address_cost (SET_SRC (set), word_mode,
-					 ADDR_SPACE_GENERIC, speed) < 3;
+      if (SCALAR_INT_MODE_P (GET_MODE (SET_DEST (set))))
+	inv->cheap_address = address_cost (SET_SRC (set), word_mode,
+					   ADDR_SPACE_GENERIC, speed) < 3;
+      else
+	inv->cheap_address = false;
     }
   else
     {
@@ -1174,6 +1179,7 @@ get_inv_cost (struct invariant *inv, int *comp_cost, unsigned *regs_needed,
     }
 
   if (!inv->cheap_address
+      || inv->def->n_uses == 0
       || inv->def->n_addr_uses < inv->def->n_uses)
     (*comp_cost) += inv->cost * inv->eqno;
 
@@ -1512,6 +1518,79 @@ replace_uses (struct invariant *inv, rtx reg, bool in_group)
   return 1;
 }
 
+/* Whether invariant INV setting REG can be moved out of LOOP, at the end of
+   the block preceding its header.  */
+
+static bool
+can_move_invariant_reg (struct loop *loop, struct invariant *inv, rtx reg)
+{
+  df_ref def, use;
+  unsigned int dest_regno, defs_in_loop_count = 0;
+  rtx_insn *insn = inv->insn;
+  basic_block bb = BLOCK_FOR_INSN (inv->insn);
+
+  /* We ignore hard register and memory access for cost and complexity reasons.
+     Hard register are few at this stage and expensive to consider as they
+     require building a separate data flow.  Memory access would require using
+     df_simulate_* and can_move_insns_across functions and is more complex.  */
+  if (!REG_P (reg) || HARD_REGISTER_P (reg))
+    return false;
+
+  /* Check whether the set is always executed.  We could omit this condition if
+     we know that the register is unused outside of the loop, but it does not
+     seem worth finding out.  */
+  if (!inv->always_executed)
+    return false;
+
+  /* Check that all uses that would be dominated by def are already dominated
+     by it.  */
+  dest_regno = REGNO (reg);
+  for (use = DF_REG_USE_CHAIN (dest_regno); use; use = DF_REF_NEXT_REG (use))
+    {
+      rtx_insn *use_insn;
+      basic_block use_bb;
+
+      use_insn = DF_REF_INSN (use);
+      use_bb = BLOCK_FOR_INSN (use_insn);
+
+      /* Ignore instruction considered for moving.  */
+      if (use_insn == insn)
+	continue;
+
+      /* Don't consider uses outside loop.  */
+      if (!flow_bb_inside_loop_p (loop, use_bb))
+	continue;
+
+      /* Don't move if a use is not dominated by def in insn.  */
+      if (use_bb == bb && DF_INSN_LUID (insn) >= DF_INSN_LUID (use_insn))
+	return false;
+      if (!dominated_by_p (CDI_DOMINATORS, use_bb, bb))
+	return false;
+    }
+
+  /* Check for other defs.  Any other def in the loop might reach a use
+     currently reached by the def in insn.  */
+  for (def = DF_REG_DEF_CHAIN (dest_regno); def; def = DF_REF_NEXT_REG (def))
+    {
+      basic_block def_bb = DF_REF_BB (def);
+
+      /* Defs in exit block cannot reach a use they weren't already.  */
+      if (single_succ_p (def_bb))
+	{
+	  basic_block def_bb_succ;
+
+	  def_bb_succ = single_succ (def_bb);
+	  if (!flow_bb_inside_loop_p (loop, def_bb_succ))
+	    continue;
+	}
+
+      if (++defs_in_loop_count > 1)
+	return false;
+    }
+
+  return true;
+}
+
 /* Move invariant INVNO out of the LOOP.  Returns true if this succeeds, false
    otherwise.  */
 
@@ -1545,11 +1624,8 @@ move_invariant_reg (struct loop *loop, unsigned invno)
 	    }
 	}
 
-      /* Move the set out of the loop.  If the set is always executed (we could
-	 omit this condition if we know that the register is unused outside of
-	 the loop, but it does not seem worth finding out) and it has no uses
-	 that would not be dominated by it, we may just move it (TODO).
-	 Otherwise we need to create a temporary register.  */
+      /* If possible, just move the set out of the loop.  Otherwise, we
+	 need to create a temporary register.  */
       set = single_set (inv->insn);
       reg = dest = SET_DEST (set);
       if (GET_CODE (reg) == SUBREG)
@@ -1557,20 +1633,27 @@ move_invariant_reg (struct loop *loop, unsigned invno)
       if (REG_P (reg))
 	regno = REGNO (reg);
 
-      reg = gen_reg_rtx_and_attrs (dest);
+      if (!can_move_invariant_reg (loop, inv, dest))
+	{
+	  reg = gen_reg_rtx_and_attrs (dest);
 
-      /* Try replacing the destination by a new pseudoregister.  */
-      validate_change (inv->insn, &SET_DEST (set), reg, true);
+	  /* Try replacing the destination by a new pseudoregister.  */
+	  validate_change (inv->insn, &SET_DEST (set), reg, true);
 
-      /* As well as all the dominated uses.  */
-      replace_uses (inv, reg, true);
+	  /* As well as all the dominated uses.  */
+	  replace_uses (inv, reg, true);
 
-      /* And validate all the changes.  */
-      if (!apply_change_group ())
-	goto fail;
+	  /* And validate all the changes.  */
+	  if (!apply_change_group ())
+	    goto fail;
 
-      emit_insn_after (gen_move_insn (dest, reg), inv->insn);
+	  emit_insn_after (gen_move_insn (dest, reg), inv->insn);
+	}
+      else if (dump_file)
+	fprintf (dump_file, "Invariant %d moved without introducing a new "
+			    "temporary register\n", invno);
       reorder_insns (inv->insn, inv->insn, BB_END (preheader));
+      df_recompute_luids (preheader);
 
       /* If there is a REG_EQUAL note on the insn we just moved, and the
 	 insn is in a basic block that is not always executed or the note
--- a/src/gcc/lra-constraints.c
+++ b/src/gcc/lra-constraints.c
@@ -867,10 +867,11 @@ narrow_reload_pseudo_class (rtx reg, enum reg_class cl)
    numbers with end marker -1) with reg class GOAL_CLASS.  Add input
    and output reloads correspondingly to the lists *BEFORE and *AFTER.
    OUT might be negative.  In this case we generate input reloads for
-   matched input operands INS.  */
+   matched input operands INS.  EARLY_CLOBBER_P is a flag that the
+   output operand is early clobbered for chosen alternative.  */
 static void
 match_reload (signed char out, signed char *ins, enum reg_class goal_class,
-	      rtx_insn **before, rtx_insn **after)
+	      rtx_insn **before, rtx_insn **after, bool early_clobber_p)
 {
   int i, in;
   rtx new_in_reg, new_out_reg, reg, clobber;
@@ -940,20 +941,34 @@ match_reload (signed char out, signed char *ins, enum reg_class goal_class,
 	 they live in the same place.  When we create a pseudo we
 	 assign value of original pseudo (if any) from which we
 	 created the new pseudo.  If we create the pseudo from the
-	 input pseudo, the new pseudo will no conflict with the input
-	 pseudo which is wrong when the input pseudo lives after the
-	 insn and as the new pseudo value is changed by the insn
-	 output.  Therefore we create the new pseudo from the output.
+	 input pseudo, the new pseudo will have no conflict with the
+	 input pseudo which is wrong when the input pseudo lives after
+	 the insn and as the new pseudo value is changed by the insn
+	 output.  Therefore we create the new pseudo from the output
+	 except the case when we have single matched dying input
+	 pseudo.
 
 	 We cannot reuse the current output register because we might
 	 have a situation like "a <- a op b", where the constraints
 	 force the second input operand ("b") to match the output
 	 operand ("a").  "b" must then be copied into a new register
-	 so that it doesn't clobber the current value of "a".  */
+	 so that it doesn't clobber the current value of "a".
+
+	 We can not use the same value if the output pseudo is
+	 early clobbered or the input pseudo is mentioned in the
+	 output, e.g. as an address part in memory, because
+	 output reload will actually extend the pseudo liveness.
+	 We don't care about eliminable hard regs here as we are
+	 interesting only in pseudos.  */
 
       new_in_reg = new_out_reg
-	= lra_create_new_reg_with_unique_value (outmode, out_rtx,
-						goal_class, "");
+	= (! early_clobber_p && ins[1] < 0 && REG_P (in_rtx)
+	   && (int) REGNO (in_rtx) < lra_new_regno_start
+	   && find_regno_note (curr_insn, REG_DEAD, REGNO (in_rtx))
+	   && (out < 0 || regno_use_in (REGNO (in_rtx), out_rtx) == NULL_RTX)
+	   ? lra_create_new_reg (inmode, in_rtx, goal_class, "")
+	   : lra_create_new_reg_with_unique_value (outmode, out_rtx,
+						   goal_class, ""));
     }
   /* In operand can be got from transformations before processing insn
      constraints.  One example of such transformations is subreg
@@ -1656,8 +1671,7 @@ prohibited_class_reg_set_mode_p (enum reg_class rclass,
 {
   HARD_REG_SET temp;
   
-  // ??? Is this assert right
-  // lra_assert (hard_reg_set_subset_p (set, reg_class_contents[rclass]));
+  lra_assert (hard_reg_set_subset_p (reg_class_contents[rclass], set));
   COPY_HARD_REG_SET (temp, set);
   AND_COMPL_HARD_REG_SET (temp, lra_no_alloc_regs);
   return (hard_reg_set_subset_p
@@ -3877,13 +3891,18 @@ curr_insn_transform (bool check_only_p)
 	  match_inputs[0] = i;
 	  match_inputs[1] = -1;
 	  match_reload (goal_alt_matched[i][0], match_inputs,
-			goal_alt[i], &before, &after);
+			goal_alt[i], &before, &after,
+			curr_static_id->operand_alternative
+			[goal_alt_number * n_operands + goal_alt_matched[i][0]]
+			.earlyclobber);
 	}
       else if (curr_static_id->operand[i].type == OP_OUT
 	       && (curr_static_id->operand[goal_alt_matched[i][0]].type
 		   == OP_IN))
 	/* Generate reloads for output and matched inputs.  */
-	match_reload (i, goal_alt_matched[i], goal_alt[i], &before, &after);
+	match_reload (i, goal_alt_matched[i], goal_alt[i], &before, &after,
+		      curr_static_id->operand_alternative
+		      [goal_alt_number * n_operands + i].earlyclobber);
       else if (curr_static_id->operand[i].type == OP_IN
 	       && (curr_static_id->operand[goal_alt_matched[i][0]].type
 		   == OP_IN))
@@ -3893,7 +3912,7 @@ curr_insn_transform (bool check_only_p)
 	  for (j = 0; (k = goal_alt_matched[i][j]) >= 0; j++)
 	    match_inputs[j + 1] = k;
 	  match_inputs[j + 1] = -1;
-	  match_reload (-1, match_inputs, goal_alt[i], &before, &after);
+	  match_reload (-1, match_inputs, goal_alt[i], &before, &after, false);
 	}
       else
 	/* We must generate code in any case when function
--- a/src/gcc/lra-lives.c
+++ b/src/gcc/lra-lives.c
@@ -777,28 +777,33 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)
 	  lra_hard_reg_usage[reg->regno] += freq;
 
       call_p = CALL_P (curr_insn);
+      src_regno = (set != NULL_RTX && REG_P (SET_SRC (set))
+		   ? REGNO (SET_SRC (set)) : -1);
+      dst_regno = (set != NULL_RTX && REG_P (SET_DEST (set))
+		   ? REGNO (SET_DEST (set)) : -1);
       if (complete_info_p
-	  && set != NULL_RTX
-	  && REG_P (SET_DEST (set)) && REG_P (SET_SRC (set))
+	  && src_regno >= 0 && dst_regno >= 0
 	  /* Check that source regno does not conflict with
 	     destination regno to exclude most impossible
 	     preferences.  */
-	  && ((((src_regno = REGNO (SET_SRC (set))) >= FIRST_PSEUDO_REGISTER
-		&& ! sparseset_bit_p (pseudos_live, src_regno))
+	  && (((src_regno >= FIRST_PSEUDO_REGISTER
+		&& (! sparseset_bit_p (pseudos_live, src_regno)
+		    || (dst_regno >= FIRST_PSEUDO_REGISTER
+			&& lra_reg_val_equal_p (src_regno,
+						lra_reg_info[dst_regno].val,
+						lra_reg_info[dst_regno].offset))))
 	       || (src_regno < FIRST_PSEUDO_REGISTER
 		   && ! TEST_HARD_REG_BIT (hard_regs_live, src_regno)))
 	      /* It might be 'inheritance pseudo <- reload pseudo'.  */
 	      || (src_regno >= lra_constraint_new_regno_start
-		  && ((int) REGNO (SET_DEST (set))
-		      >= lra_constraint_new_regno_start)
+		  && dst_regno >= lra_constraint_new_regno_start
 		  /* Remember to skip special cases where src/dest regnos are
 		     the same, e.g. insn SET pattern has matching constraints
 		     like =r,0.  */
-		  && src_regno != (int) REGNO (SET_DEST (set)))))
+		  && src_regno != dst_regno)))
 	{
 	  int hard_regno = -1, regno = -1;
 
-	  dst_regno = REGNO (SET_DEST (set));
 	  if (dst_regno >= lra_constraint_new_regno_start
 	      && src_regno >= lra_constraint_new_regno_start)
 	    {
--- a/src/gcc/objc/Make-lang.in
+++ b/src/gcc/objc/Make-lang.in
@@ -114,6 +114,7 @@ objc.uninstall:
 objc.mostlyclean:
 	-rm -f objc/*$(objext) objc/xforward objc/fflags
 	-rm -f objc/*$(coverageexts)
+	-rm -f cc1obj$(exeext)
 objc.clean: objc.mostlyclean
 	-rm -rf objc-headers
 objc.distclean:
--- a/src/gcc/objcp/Make-lang.in
+++ b/src/gcc/objcp/Make-lang.in
@@ -142,6 +142,7 @@ obj-c++.uninstall:
 obj-c++.mostlyclean:
 	-rm -f objcp/*$(objext)
 	-rm -f objcp/*$(coverageexts)
+	-rm -f cc1objplus$(exeext)
 obj-c++.clean: obj-c++.mostlyclean
 obj-c++.distclean:
 	-rm -f objcp/config.status objcp/Makefile
--- a/src/gcc/optabs.c
+++ b/src/gcc/optabs.c
@@ -6544,18 +6544,28 @@ vector_compare_rtx (enum tree_code tcode, tree t_op0, tree t_op1,
 {
   struct expand_operand ops[2];
   rtx rtx_op0, rtx_op1;
+  machine_mode m0, m1;
   enum rtx_code rcode = get_rtx_code (tcode, unsignedp);
 
   gcc_assert (TREE_CODE_CLASS (tcode) == tcc_comparison);
 
-  /* Expand operands.  */
+  /* Expand operands.  For vector types with scalar modes, e.g. where int64x1_t
+     has mode DImode, this can produce a constant RTX of mode VOIDmode; in such
+     cases, use the original mode.  */
   rtx_op0 = expand_expr (t_op0, NULL_RTX, TYPE_MODE (TREE_TYPE (t_op0)),
 			 EXPAND_STACK_PARM);
+  m0 = GET_MODE (rtx_op0);
+  if (m0 == VOIDmode)
+    m0 = TYPE_MODE (TREE_TYPE (t_op0));
+
   rtx_op1 = expand_expr (t_op1, NULL_RTX, TYPE_MODE (TREE_TYPE (t_op1)),
 			 EXPAND_STACK_PARM);
+  m1 = GET_MODE (rtx_op1);
+  if (m1 == VOIDmode)
+    m1 = TYPE_MODE (TREE_TYPE (t_op1));
 
-  create_input_operand (&ops[0], rtx_op0, GET_MODE (rtx_op0));
-  create_input_operand (&ops[1], rtx_op1, GET_MODE (rtx_op1));
+  create_input_operand (&ops[0], rtx_op0, m0);
+  create_input_operand (&ops[1], rtx_op1, m1);
   if (!maybe_legitimize_operands (icode, 4, 2, ops))
     gcc_unreachable ();
   return gen_rtx_fmt_ee (rcode, VOIDmode, ops[0].value, ops[1].value);
--- a/src/gcc/params.def
+++ b/src/gcc/params.def
@@ -262,6 +262,14 @@ DEFPARAM(PARAM_MAX_HOIST_DEPTH,
 	 "Maximum depth of search in the dominator tree for expressions to hoist",
 	 30, 0, 0)
 
+
+/* When synthesizing expnonentiation by a real constant operations using square
+   roots, this controls how deep sqrt chains we are willing to generate.  */
+DEFPARAM(PARAM_MAX_POW_SQRT_DEPTH,
+	 "max-pow-sqrt-depth",
+	 "Maximum depth of sqrt chains to use when synthesizing exponentiation by a real constant",
+	 5, 1, 32)
+
 /* This parameter limits the number of insns in a loop that will be unrolled,
    and by how much the loop is unrolled.
 
--- a/src/gcc/passes.def
+++ b/src/gcc/passes.def
@@ -247,6 +247,7 @@ along with GCC; see the file COPYING3.  If not see
 	  PUSH_INSERT_PASSES_WITHIN (pass_parallelize_loops)
 	      NEXT_PASS (pass_expand_omp_ssa);
 	  POP_INSERT_PASSES ()
+	  NEXT_PASS (pass_ch_vect);
 	  NEXT_PASS (pass_if_conversion);
 	  /* pass_vectorize must immediately follow pass_if_conversion.
 	     Please do not add any other passes in between.  */
--- a/src/gcc/read-md.c
+++ b/src/gcc/read-md.c
@@ -388,20 +388,31 @@ read_name (struct md_name *name)
 {
   int c;
   size_t i;
+  int angle_bracket_depth;
 
   c = read_skip_spaces ();
 
   i = 0;
+  angle_bracket_depth = 0;
   while (1)
     {
+      if (c == '<')
+	angle_bracket_depth++;
+
+      if ((c == '>') && (angle_bracket_depth > 0))
+	  angle_bracket_depth--;
+
       if (c == ' ' || c == '\n' || c == '\t' || c == '\f' || c == '\r'
 	  || c == EOF)
 	break;
-      if (c == ':' || c == ')' || c == ']' || c == '"' || c == '/'
-	  || c == '(' || c == '[')
+      if (angle_bracket_depth == 0)
 	{
-	  unread_char (c);
-	  break;
+	  if (c == ':' || c == ')' || c == ']'
+	      || c == '"' || c == '/' || c == '(' || c == '[')
+	    {
+	      unread_char (c);
+	      break;
+	    }
 	}
 
       if (i == sizeof (name->buffer) - 1)
--- a/src/gcc/regrename.c
+++ b/src/gcc/regrename.c
@@ -505,12 +505,20 @@ rename_chains (void)
 	  continue;
 	}
 
-      if (dump_file)
-	fprintf (dump_file, ", renamed as %s\n", reg_names[best_new_reg]);
-
-      regrename_do_replace (this_head, best_new_reg);
-      tick[best_new_reg] = ++this_tick;
-      df_set_regs_ever_live (best_new_reg, true);
+      if (regrename_do_replace (this_head, best_new_reg))
+	{
+	  if (dump_file)
+	    fprintf (dump_file, ", renamed as %s\n", reg_names[best_new_reg]);
+	  tick[best_new_reg] = ++this_tick;
+	  df_set_regs_ever_live (best_new_reg, true);
+	}
+      else
+	{
+	  if (dump_file)
+	    fprintf (dump_file, ", renaming as %s failed\n",
+		     reg_names[best_new_reg]);
+	  tick[reg] = ++this_tick;
+	}
     }
 }
 
@@ -936,7 +944,13 @@ regrename_analyze (bitmap bb_mask)
     bb->aux = NULL;
 }
 
-void
+/* Attempt to replace all uses of the register in the chain beginning with
+   HEAD with REG.  Returns true on success and false if the replacement is
+   rejected because the insns would not validate.  The latter can happen
+   e.g. if a match_parallel predicate enforces restrictions on register
+   numbering in its subpatterns.  */
+
+bool
 regrename_do_replace (struct du_head *head, int reg)
 {
   struct du_chain *chain;
@@ -950,22 +964,26 @@ regrename_do_replace (struct du_head *head, int reg)
       int reg_ptr = REG_POINTER (*chain->loc);
 
       if (DEBUG_INSN_P (chain->insn) && REGNO (*chain->loc) != base_regno)
-	INSN_VAR_LOCATION_LOC (chain->insn) = gen_rtx_UNKNOWN_VAR_LOC ();
+	validate_change (chain->insn, &(INSN_VAR_LOCATION_LOC (chain->insn)),
+			 gen_rtx_UNKNOWN_VAR_LOC (), true);
       else
 	{
-	  *chain->loc = gen_raw_REG (GET_MODE (*chain->loc), reg);
+	  validate_change (chain->insn, chain->loc, 
+			   gen_raw_REG (GET_MODE (*chain->loc), reg), true);
 	  if (regno >= FIRST_PSEUDO_REGISTER)
 	    ORIGINAL_REGNO (*chain->loc) = regno;
 	  REG_ATTRS (*chain->loc) = attr;
 	  REG_POINTER (*chain->loc) = reg_ptr;
 	}
-
-      df_insn_rescan (chain->insn);
     }
 
+  if (!apply_change_group ())
+    return false;
+
   mode = GET_MODE (*head->first->loc);
   head->regno = reg;
   head->nregs = hard_regno_nregs[reg][mode];
+  return true;
 }
 
 
--- a/src/gcc/regrename.h
+++ b/src/gcc/regrename.h
@@ -91,6 +91,6 @@ extern void regrename_analyze (bitmap);
 extern du_head_p regrename_chain_from_id (unsigned int);
 extern int find_rename_reg (du_head_p, enum reg_class, HARD_REG_SET *, int,
 			    bool);
-extern void regrename_do_replace (du_head_p, int);
+extern bool regrename_do_replace (du_head_p, int);
 
 #endif
--- a/src/gcc/rtlanal.c
+++ b/src/gcc/rtlanal.c
@@ -104,7 +104,10 @@ generic_subrtx_iterator <T>::add_single_to_queue (array_type &array,
 	  return base;
 	}
       gcc_checking_assert (i == LOCAL_ELEMS);
-      vec_safe_grow (array.heap, i + 1);
+      /* A previous iteration might also have moved from the stack to the
+	 heap, in which case the heap array will already be big enough.  */
+      if (vec_safe_length (array.heap) <= i)
+	vec_safe_grow (array.heap, i + 1);
       base = array.heap->address ();
       memcpy (base, array.stack, sizeof (array.stack));
       base[LOCAL_ELEMS] = x;
--- a/src/gcc/sched-deps.c
+++ b/src/gcc/sched-deps.c
@@ -2856,7 +2856,7 @@ sched_analyze_2 (struct deps_desc *deps, rtx x, rtx_insn *insn)
     sched_deps_info->finish_rhs ();
 }
 
-/* Try to group two fuseable insns together to prevent scheduler
+/* Try to group two fusible insns together to prevent scheduler
    from scheduling them apart.  */
 
 static void
--- a/src/gcc/sched-int.h
+++ b/src/gcc/sched-int.h
@@ -811,8 +811,17 @@ struct autopref_multipass_data_
 {
   /* Base part of memory address.  */
   rtx base;
-  /* Memory offset.  */
-  int offset;
+
+  /* Memory offsets from the base.  For single simple sets
+     only min_offset is valid.  For multi-set insns min_offset
+     and max_offset record the minimum and maximum offsets from the same
+     base among the sets inside the PARALLEL.  */
+  int min_offset;
+  int max_offset;
+
+  /* True if this is a load/store-multiple instruction.  */
+  bool multi_mem_insn_p;
+
   /* Entry status.  */
   enum autopref_multipass_data_status status;
 };
--- a/src/gcc/simplify-rtx.c
+++ b/src/gcc/simplify-rtx.c
@@ -978,6 +978,32 @@ simplify_unary_operation_1 (enum rtx_code code, machine_mode mode, rtx op)
       if (GET_CODE (op) == NEG)
 	return XEXP (op, 0);
 
+      /* (neg (x ? (neg y) : y)) == !x ? (neg y) : y.
+	 If comparison is not reversible use
+	 x ? y : (neg y).  */
+      if (GET_CODE (op) == IF_THEN_ELSE)
+	{
+	  rtx cond = XEXP (op, 0);
+	  rtx true_rtx = XEXP (op, 1);
+	  rtx false_rtx = XEXP (op, 2);
+
+	  if ((GET_CODE (true_rtx) == NEG
+	       && rtx_equal_p (XEXP (true_rtx, 0), false_rtx))
+	       || (GET_CODE (false_rtx) == NEG
+		   && rtx_equal_p (XEXP (false_rtx, 0), true_rtx)))
+	    {
+	      if (reversed_comparison_code (cond, NULL_RTX) != UNKNOWN)
+		temp = reversed_comparison (cond, mode);
+	      else
+		{
+		  temp = cond;
+		  std::swap (true_rtx, false_rtx);
+		}
+	      return simplify_gen_ternary (IF_THEN_ELSE, mode,
+					    mode, temp, true_rtx, false_rtx);
+	    }
+	}
+
       /* (neg (plus X 1)) can become (not X).  */
       if (GET_CODE (op) == PLUS
 	  && XEXP (op, 1) == const1_rtx)
@@ -1171,7 +1197,7 @@ simplify_unary_operation_1 (enum rtx_code code, machine_mode mode, rtx op)
          = (float_truncate:SF foo:DF).
 
          (float_truncate:DF (float_extend:XF foo:SF))
-         = (float_extend:SF foo:DF).  */
+         = (float_extend:DF foo:SF).  */
       if ((GET_CODE (op) == FLOAT_TRUNCATE
 	   && flag_unsafe_math_optimizations)
 	  || GET_CODE (op) == FLOAT_EXTEND)
@@ -1183,14 +1209,14 @@ simplify_unary_operation_1 (enum rtx_code code, machine_mode mode, rtx op)
 				   XEXP (op, 0), mode);
 
       /*  (float_truncate (float x)) is (float x)  */
-      if (GET_CODE (op) == FLOAT
+      if ((GET_CODE (op) == FLOAT || GET_CODE (op) == UNSIGNED_FLOAT)
 	  && (flag_unsafe_math_optimizations
 	      || (SCALAR_FLOAT_MODE_P (GET_MODE (op))
 		  && ((unsigned)significand_size (GET_MODE (op))
 		      >= (GET_MODE_PRECISION (GET_MODE (XEXP (op, 0)))
 			  - num_sign_bit_copies (XEXP (op, 0),
 						 GET_MODE (XEXP (op, 0))))))))
-	return simplify_gen_unary (FLOAT, mode,
+	return simplify_gen_unary (GET_CODE (op), mode,
 				   XEXP (op, 0),
 				   GET_MODE (XEXP (op, 0)));
 
@@ -1221,7 +1247,7 @@ simplify_unary_operation_1 (enum rtx_code code, machine_mode mode, rtx op)
 	  rounding can't happen.
           */
       if (GET_CODE (op) == FLOAT_EXTEND
-	  || (GET_CODE (op) == FLOAT
+	  || ((GET_CODE (op) == FLOAT || GET_CODE (op) == UNSIGNED_FLOAT)
 	      && SCALAR_FLOAT_MODE_P (GET_MODE (op))
 	      && ((unsigned)significand_size (GET_MODE (op))
 		  >= (GET_MODE_PRECISION (GET_MODE (XEXP (op, 0)))
--- a/src/gcc/stmt.c
+++ b/src/gcc/stmt.c
@@ -342,13 +342,7 @@ parse_output_constraint (const char **constraint_p, int operand_num,
 	else if (insn_extra_memory_constraint (cn))
 	  *allows_mem = true;
 	else
-	  {
-	    /* Otherwise we can't assume anything about the nature of
-	       the constraint except that it isn't purely registers.
-	       Treat it like "g" and hope for the best.  */
-	    *allows_reg = true;
-	    *allows_mem = true;
-	  }
+	  insn_extra_constraint_allows_reg_mem (cn, allows_reg, allows_mem);
 	break;
       }
 
@@ -465,13 +459,7 @@ parse_input_constraint (const char **constraint_p, int input_num,
 	else if (insn_extra_memory_constraint (cn))
 	  *allows_mem = true;
 	else
-	  {
-	    /* Otherwise we can't assume anything about the nature of
-	       the constraint except that it isn't purely registers.
-	       Treat it like "g" and hope for the best.  */
-	    *allows_reg = true;
-	    *allows_mem = true;
-	  }
+	  insn_extra_constraint_allows_reg_mem (cn, allows_reg, allows_mem);
 	break;
       }
 
--- a/src/gcc/target.def
+++ b/src/gcc/target.def
@@ -1975,7 +1975,7 @@ merging.",
 DEFHOOKPOD
 (attribute_table,
  "If defined, this target hook points to an array of @samp{struct\n\
-attribute_spec} (defined in @file{tree.h}) specifying the machine\n\
+attribute_spec} (defined in @file{tree-core.h}) specifying the machine\n\
 specific attributes for this target and some of the restrictions on the\n\
 entities to which these attributes are applied and the arguments they\n\
 take.",
--- a/src/gcc/testsuite/c-c++-common/Wsizeof-pointer-memaccess1.c
+++ b/src/gcc/testsuite/c-c++-common/Wsizeof-pointer-memaccess1.c
@@ -1,6 +1,7 @@
 /* Test -Wsizeof-pointer-memaccess warnings.  */
 /* { dg-do compile } */
 /* { dg-options "-Wall -Wno-sizeof-array-argument" } */
+/* { dg-options "-Wall -Wno-sizeof-array-argument -Wno-c++-compat" { target c } } */
 
 typedef __SIZE_TYPE__ size_t;
 #ifdef __cplusplus
--- a/src/gcc/testsuite/c-c++-common/Wsizeof-pointer-memaccess2.c
+++ b/src/gcc/testsuite/c-c++-common/Wsizeof-pointer-memaccess2.c
@@ -1,6 +1,7 @@
 /* Test -Wsizeof-pointer-memaccess warnings.  */
 /* { dg-do compile } */
 /* { dg-options "-Wall -O2 -Wno-sizeof-array-argument" } */
+/* { dg-options "-Wall -O2 -Wno-sizeof-array-argument -Wno-c++-compat" {target c} } */
 
 #define bos(ptr) __builtin_object_size (ptr, 1)
 #define bos0(ptr) __builtin_object_size (ptr, 0)
--- a/src/gcc/testsuite/c-c++-common/asan/aggressive-opts.c
+++ b/src/gcc/testsuite/c-c++-common/asan/aggressive-opts.c
@@ -25,4 +25,3 @@ Perl_do_sv_dump()
 }
 
 /* { dg-final { scan-tree-dump-times "ASAN_CHECK" 2 "asan1" } } */
-/* { dg-final { cleanup-tree-dump "asan1" } } */
--- a/src/gcc/testsuite/c-c++-common/asan/inc.c
+++ b/src/gcc/testsuite/c-c++-common/asan/inc.c
@@ -18,4 +18,3 @@ main ()
 
 /* { dg-final { scan-tree-dump-times "ASAN_" 1 "asan0" } }  */
 /* { dg-final { scan-tree-dump "ASAN_CHECK \\(.*, 4\\);" "asan0" } }  */
-/* { dg-final { cleanup-tree-dump "asan0" } } */
--- a/src/gcc/testsuite/c-c++-common/asan/no-asan-check-glob.c
+++ b/src/gcc/testsuite/c-c++-common/asan/no-asan-check-glob.c
@@ -10,4 +10,3 @@ int foo ()
 }
 
 /* { dg-final { scan-tree-dump-times "ASAN_CHECK" 0 "asan1" } } */
-/* { dg-final { cleanup-tree-dump "asan1" } } */
--- a/src/gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-1.c
+++ b/src/gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-1.c
@@ -57,4 +57,3 @@ main ()
 
 /* { dg-final { scan-tree-dump-times "__builtin___asan_report_store1" 3 "sanopt" } } */
 /* { dg-final { scan-tree-dump-not "__builtin___asan_report_load1" "sanopt" } } */
-/* { dg-final { cleanup-tree-dump "sanopt" } } */
--- a/src/gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-10.c
+++ b/src/gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-10.c
@@ -15,4 +15,3 @@ foo ()
 }
 
 /* { dg-final { scan-tree-dump-times "__builtin___asan_report_store4" 1 "sanopt" } } */
-/* { dg-final { cleanup-tree-dump "sanopt" } } */
--- a/src/gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-11.c
+++ b/src/gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-11.c
@@ -17,4 +17,3 @@ foo ()
 
 /* { dg-final { scan-tree-dump-not "& 7" "sanopt" } } */
 /* { dg-final { scan-tree-dump-not "__builtin___asan_report_store" "sanopt" } } */
-/* { dg-final { cleanup-tree-dump "sanopt" } } */
--- a/src/gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-12.c
+++ b/src/gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-12.c
@@ -13,4 +13,3 @@ foo (char *p)
 }
 
 /* { dg-final { scan-tree-dump-times "__builtin___asan_report_store1" 1 "sanopt" } } */
-/* { dg-final { cleanup-tree-dump "sanopt" } } */
--- a/src/gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-13.c
+++ b/src/gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-13.c
@@ -12,4 +12,3 @@ foo (char *p)
 }
 
 /* { dg-final { scan-tree-dump-times "__builtin___asan_report_store1" 1 "sanopt" } } */
-/* { dg-final { cleanup-tree-dump "sanopt" } } */
--- a/src/gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-14.c
+++ b/src/gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-14.c
@@ -12,4 +12,3 @@ foo (char *p)
 }
 
 /* { dg-final { scan-tree-dump-not "__builtin___asan_report_store1" "sanopt" } } */
-/* { dg-final { cleanup-tree-dump "sanopt" } } */
--- a/src/gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-15.c
+++ b/src/gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-15.c
@@ -13,4 +13,3 @@ foo (char *p)
 }
 
 /* { dg-final { scan-tree-dump-times "__builtin___asan_report_store1" 1 "sanopt" } } */
-/* { dg-final { cleanup-tree-dump "sanopt" } } */
--- a/src/gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-3.c
+++ b/src/gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-3.c
@@ -15,4 +15,3 @@ foo (__INT32_TYPE__ *p)
 /* { dg-final { scan-tree-dump-times "__builtin___asan_report" 2 "sanopt" } } */
 /* { dg-final { scan-tree-dump-times "__builtin___asan_report_load1" 1 "sanopt" } } */
 /* { dg-final { scan-tree-dump-times "__builtin___asan_report_store" 1 "sanopt" } } */
-/* { dg-final { cleanup-tree-dump "sanopt" } } */
--- a/src/gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-4.c
+++ b/src/gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-4.c
@@ -14,4 +14,3 @@ foo  (int *a, char *b, char *c)
 /* { dg-final { scan-tree-dump-times "& 7" 2 "sanopt" } } */
 /* { dg-final { scan-tree-dump-times "__builtin___asan_report_load1" 1 "sanopt" } } */
 /* { dg-final { scan-tree-dump-times "__builtin___asan_report_load4" 1 "sanopt" } } */
-/* { dg-final { cleanup-tree-dump "sanopt" } } */
--- a/src/gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-5.c
+++ b/src/gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-5.c
@@ -13,4 +13,3 @@ foo  (int *a, char *b, char *c)
 
 /* { dg-final { scan-tree-dump-times "& 7" 1 "sanopt" } } */
 /* { dg-final { scan-tree-dump-times "__builtin___asan_report_load4" 1 "sanopt" } } */
-/* { dg-final { cleanup-tree-dump "sanopt" } } */
--- a/src/gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-6.c
+++ b/src/gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-6.c
@@ -16,4 +16,3 @@ foo  (int *a, char *b, char *c)
 /* { dg-final { scan-tree-dump-times "& 7" 4 "sanopt" } } */
 /* { dg-final { scan-tree-dump-times "__builtin___asan_report_load1" 2 "sanopt" } } */
 /* { dg-final { scan-tree-dump-times "__builtin___asan_report_load4" 2 "sanopt" } } */
-/* { dg-final { cleanup-tree-dump "sanopt" } } */
--- a/src/gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-7.c
+++ b/src/gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-7.c
@@ -20,4 +20,3 @@ foo  (int *a, char *b, char *c)
 
 /* { dg-final { scan-tree-dump-not "& 7" "sanopt" } } */
 /* { dg-final { scan-tree-dump-not "__builtin___asan_report_load4" "sanopt" } } */
-/* { dg-final { cleanup-tree-dump "sanopt" } } */
--- a/src/gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-8.c
+++ b/src/gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-8.c
@@ -17,4 +17,3 @@ foo  (int *a, char *b, char *c)
 /* { dg-final { scan-tree-dump-times "& 7" 4 "sanopt" } } */
 /* { dg-final { scan-tree-dump-times "__builtin___asan_report_load1" 2 "sanopt" } } */
 /* { dg-final { scan-tree-dump-times "__builtin___asan_report_load4" 2 "sanopt" } } */
-/* { dg-final { cleanup-tree-dump "sanopt" } } */
--- a/src/gcc/testsuite/c-c++-common/asan/red-align-1.c
+++ b/src/gcc/testsuite/c-c++-common/asan/red-align-1.c
@@ -17,4 +17,3 @@ int foo (struct st * s_p)
 }
 
 /* { dg-final { scan-tree-dump-times "& 7" 0 "sanopt" } } */
-/* { dg-final { cleanup-tree-dump "sanopt" } } */
--- a/src/gcc/testsuite/c-c++-common/asan/red-align-2.c
+++ b/src/gcc/testsuite/c-c++-common/asan/red-align-2.c
@@ -17,4 +17,3 @@ int foo (struct st * s_p)
 }
 
 /* { dg-final { scan-tree-dump-times "& 7" 1 "sanopt" } } */
-/* { dg-final { cleanup-tree-dump "sanopt" } } */
--- a/src/gcc/testsuite/c-c++-common/asan/shadow-offset-1.c
+++ b/src/gcc/testsuite/c-c++-common/asan/shadow-offset-1.c
@@ -8,4 +8,3 @@ int f (int *p)
 }
 
 /* { dg-final { scan-tree-dump "12345" "sanopt" }  } */
-/* { dg-final { cleanup-tree-dump "sanopt" } } */
--- a/src/gcc/testsuite/c-c++-common/cilk-plus/PS/clauses2.c
+++ b/src/gcc/testsuite/c-c++-common/cilk-plus/PS/clauses2.c
@@ -15,4 +15,3 @@ void foo()
 /* { dg-final { scan-tree-dump-times "linear\\(j:4\\)" 1 "original" } } */
 /* { dg-final { scan-tree-dump-times "linear\\(k:1\\)" 1 "original" } } */
 /* { dg-final { scan-tree-dump-times "safelen\\(4\\)" 1 "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/c-c++-common/cilk-plus/PS/safelen.c
+++ b/src/gcc/testsuite/c-c++-common/cilk-plus/PS/safelen.c
@@ -11,4 +11,3 @@ void foo()
 }
 
 /* { dg-final { scan-tree-dump-times "safelen\\(8\\)" 1 "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/c-c++-common/cilk-plus/PS/vectorlength-3.c
+++ b/src/gcc/testsuite/c-c++-common/cilk-plus/PS/vectorlength-3.c
@@ -11,4 +11,3 @@ foo (int *a, int *b, int *c)
     a[i] = b[i] * c[i];
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/c-c++-common/cpp/pr63831-2.c
+++ b/src/gcc/testsuite/c-c++-common/cpp/pr63831-2.c
@@ -4,4 +4,3 @@
 
 #include "pr63831-1.c"
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/c-c++-common/fold-bitand-4.c
+++ b/src/gcc/testsuite/c-c++-common/fold-bitand-4.c
@@ -42,4 +42,3 @@ int f5 (int i)
 /* { dg-final { scan-tree-dump-times "\& 15" 1 "original" } } */
 /* { dg-final { scan-tree-dump-times "return \[^\n0-9\]*0;" 2 "original" } } */
 /* { dg-final { scan-tree-dump-times "\& 7" 1 "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/c-c++-common/fold-divmul-1.c
+++ b/src/gcc/testsuite/c-c++-common/fold-divmul-1.c
@@ -8,4 +8,3 @@ fx (int *b, int *e)
 }
 
 /* { dg-final { scan-tree-dump-not "/\\\[ex\\\]" "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/c-c++-common/goacc/acc_on_device-2-off.c
+++ b/src/gcc/testsuite/c-c++-common/goacc/acc_on_device-2-off.c
@@ -22,4 +22,3 @@ f (void)
 /* Without -fopenacc, we're expecting one call.
    { dg-final { scan-rtl-dump-times "\\\(call \[^\\n\]* acc_on_device" 1 "expand" } } */
 
-/* { dg-final { cleanup-rtl-dump "expand" } } */
--- a/src/gcc/testsuite/c-c++-common/goacc/acc_on_device-2.c
+++ b/src/gcc/testsuite/c-c++-common/goacc/acc_on_device-2.c
@@ -34,4 +34,3 @@ f (void)
 
    { dg-final { scan-rtl-dump-times "\\\(call \[^\\n\]* acc_on_device" 0 "expand" { xfail { c || c++ } } } } */
 
-/* { dg-final { cleanup-rtl-dump "expand" } } */
--- a/src/gcc/testsuite/c-c++-common/goacc/loop-private-1.c
+++ b/src/gcc/testsuite/c-c++-common/goacc/loop-private-1.c
@@ -11,4 +11,3 @@ f (int i, int j)
 }
 
 /* { dg-final { scan-tree-dump-times "#pragma acc loop collapse\\(2\\) private\\(j\\) private\\(i\\)" 1 "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/c-c++-common/goacc/pcopy.c
+++ b/src/gcc/testsuite/c-c++-common/goacc/pcopy.c
@@ -8,4 +8,3 @@ f (char *cp)
 }
 
 /* { dg-final { scan-tree-dump-times "#pragma acc parallel map\\(tofrom:\\*\\(cp \\+ 3\\) \\\[len: 5]\\) map\\(alloc:cp \\\[pointer assign, bias: 3]\\)" 1 "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/c-c++-common/goacc/pcopyin.c
+++ b/src/gcc/testsuite/c-c++-common/goacc/pcopyin.c
@@ -8,4 +8,3 @@ f (char *cp)
 }
 
 /* { dg-final { scan-tree-dump-times "#pragma acc parallel map\\(to:\\*\\(cp \\+ 4\\) \\\[len: 6]\\) map\\(alloc:cp \\\[pointer assign, bias: 4]\\)" 1 "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/c-c++-common/goacc/pcopyout.c
+++ b/src/gcc/testsuite/c-c++-common/goacc/pcopyout.c
@@ -8,4 +8,3 @@ f (char *cp)
 }
 
 /* { dg-final { scan-tree-dump-times "#pragma acc parallel map\\(from:\\*\\(cp \\+ 5\\) \\\[len: 7]\\) map\\(alloc:cp \\\[pointer assign, bias: 5]\\)" 1 "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/c-c++-common/goacc/pcreate.c
+++ b/src/gcc/testsuite/c-c++-common/goacc/pcreate.c
@@ -8,4 +8,3 @@ f (char *cp)
 }
 
 /* { dg-final { scan-tree-dump-times "#pragma acc parallel map\\(alloc:\\*\\(cp \\+ 6\\) \\\[len: 8]\\) map\\(alloc:cp \\\[pointer assign, bias: 6]\\)" 1 "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/c-c++-common/goacc/present-1.c
+++ b/src/gcc/testsuite/c-c++-common/goacc/present-1.c
@@ -8,4 +8,3 @@ f (char *cp)
 }
 
 /* { dg-final { scan-tree-dump-times "#pragma acc parallel map\\(force_present:\\*\\(cp \\+ 7\\) \\\[len: 9]\\) map\\(alloc:cp \\\[pointer assign, bias: 7]\\)" 1 "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/c-c++-common/gomp/atomic-10.c
+++ b/src/gcc/testsuite/c-c++-common/gomp/atomic-10.c
@@ -22,4 +22,3 @@ foo (void)
 }
 
 /* { dg-final { scan-tree-dump-times "__atomic_fetch_add" 4 "ompexp" } } */
-/* { dg-final { cleanup-tree-dump "ompexp" } } */
--- a/src/gcc/testsuite/c-c++-common/gomp/atomic-12.c
+++ b/src/gcc/testsuite/c-c++-common/gomp/atomic-12.c
@@ -4,7 +4,6 @@
 /* atomicvar should never be referenced in between the barrier and
    following #pragma omp atomic_load.  */
 /* { dg-final { scan-tree-dump-not "barrier\[^#\]*atomicvar" "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
 
 #ifdef __cplusplus
 bool atomicvar, c;
--- a/src/gcc/testsuite/c-c++-common/gomp/atomic-13.c
+++ b/src/gcc/testsuite/c-c++-common/gomp/atomic-13.c
@@ -4,6 +4,5 @@
 /* atomicvar should never be referenced in between the barrier and
    following #pragma omp atomic_load.  */
 /* { dg-final { scan-tree-dump-not "barrier\[^#\]*atomicvar" "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
 
 #include "atomic-12.c"
--- a/src/gcc/testsuite/c-c++-common/gomp/atomic-3.c
+++ b/src/gcc/testsuite/c-c++-common/gomp/atomic-3.c
@@ -11,4 +11,3 @@ void f1(void)
 }
 
 /* { dg-final { scan-tree-dump-times "xyzzy, 4" 1 "ompexp" } } */
-/* { dg-final { cleanup-tree-dump "ompexp" } } */
--- a/src/gcc/testsuite/c-c++-common/gomp/atomic-9.c
+++ b/src/gcc/testsuite/c-c++-common/gomp/atomic-9.c
@@ -11,4 +11,3 @@ void f1(void)
 }
 
 /* { dg-final { scan-tree-dump-times "__atomic_fetch_add" 1 "ompexp" } } */
-/* { dg-final { cleanup-tree-dump "ompexp" } } */
--- a/src/gcc/testsuite/c-c++-common/pr46562-2.c
+++ b/src/gcc/testsuite/c-c++-common/pr46562-2.c
@@ -10,4 +10,3 @@ int foo(void)
 }
 
 /* { dg-final { scan-tree-dump "return 0;" "fre1" } } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/c-c++-common/pr46562.c
+++ b/src/gcc/testsuite/c-c++-common/pr46562.c
@@ -10,4 +10,3 @@ int foo(void)
 }
 
 /* { dg-final { scan-tree-dump "return 0;" "ccp1" } } */
-/* { dg-final { cleanup-tree-dump "ccp1" } } */
--- a/src/gcc/testsuite/c-c++-common/pr56493.c
+++ b/src/gcc/testsuite/c-c++-common/pr56493.c
@@ -13,4 +13,3 @@ foo (void)
 
 /* Verify we narrow the addition from unsigned long long to unsigned int type.  */
 /* { dg-final { scan-tree-dump "  (\[a-zA-Z._0-9]*) = \\(unsigned int\\) \[^;\n\r]*;.*  (\[a-zA-Z._0-9]*) = \\(unsigned int\\) \[^;\n\r]*;.* = \\1 \\+ \\2;" "gimple" { target { ilp32 || lp64 } } } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/c-c++-common/pr58346-1.c
+++ b/src/gcc/testsuite/c-c++-common/pr58346-1.c
@@ -1,5 +1,6 @@
 /* PR c/58346 */
 /* { dg-do compile } */
+/* { dg-options "-Wno-c++-compat" { target c } } */
 
 struct U {
 #ifdef __cplusplus
--- a/src/gcc/testsuite/c-c++-common/raw-string-11.c
+++ b/src/gcc/testsuite/c-c++-common/raw-string-11.c
@@ -10,4 +10,3 @@ int main ()
 			   sizeof ("foo%sbar%sfred%sbob?""?""?""?""?"));
 }
 
-// { dg-final { cleanup-saved-temps } }
--- a/src/gcc/testsuite/c-c++-common/raw-string-18.c
+++ b/src/gcc/testsuite/c-c++-common/raw-string-18.c
@@ -18,4 +18,3 @@ main ()
 
 /* Verify call to foo is on line 15.  */
 /* { dg-final { scan-tree-dump "c:15:\[^\n\r\]*foo" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/c-c++-common/raw-string-19.c
+++ b/src/gcc/testsuite/c-c++-common/raw-string-19.c
@@ -18,5 +18,3 @@ main ()
 
 /* Verify call to foo is on line 15.  */
 /* { dg-final { scan-tree-dump "c:15:\[^\n\r\]*foo" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/c-c++-common/restrict-1.c
+++ b/src/gcc/testsuite/c-c++-common/restrict-1.c
@@ -17,4 +17,3 @@ int main()
 }
 
 /* { dg-final { scan-tree-dump-not "link_error" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/c-c++-common/restrict-2.c
+++ b/src/gcc/testsuite/c-c++-common/restrict-2.c
@@ -11,4 +11,3 @@ void foo (float * __restrict__ a, float * __restrict__ b, int n, int j)
 /* We should move the RHS of the store out of the loop.  */
 
 /* { dg-final { scan-tree-dump-times "Moving statement" 11 "lim1" } } */
-/* { dg-final { cleanup-tree-dump "lim1" } } */
--- a/src/gcc/testsuite/c-c++-common/restrict-4.c
+++ b/src/gcc/testsuite/c-c++-common/restrict-4.c
@@ -16,4 +16,3 @@ void bar(struct Foo f, int * __restrict__ q)
 }
 
 /* { dg-final { scan-tree-dump "Executing store motion" "lim1" } } */
-/* { dg-final { cleanup-tree-dump "lim1" } } */
--- a/src/gcc/testsuite/c-c++-common/rotate-1.c
+++ b/src/gcc/testsuite/c-c++-common/rotate-1.c
@@ -2,7 +2,6 @@
 /* { dg-do compile } */
 /* { dg-options "-O2 -fno-ipa-icf -fdump-tree-optimized" } */
 /* { dg-final { scan-tree-dump-times "r\[<>]\[<>]" 96 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
 unsigned int
 f1 (unsigned int x, unsigned int y)
--- a/src/gcc/testsuite/c-c++-common/rotate-2.c
+++ b/src/gcc/testsuite/c-c++-common/rotate-2.c
@@ -4,7 +4,6 @@
 /* Rotates should be recognized only in functions with | instead of + or ^,
    or in functions that have constant shift counts (unused attribute on y).  */
 /* { dg-final { scan-tree-dump-times "r\[<>]\[<>]" 48 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
 unsigned int
 f1 (unsigned int x, unsigned int y)
--- a/src/gcc/testsuite/c-c++-common/rotate-3.c
+++ b/src/gcc/testsuite/c-c++-common/rotate-3.c
@@ -2,7 +2,6 @@
 /* { dg-do compile } */
 /* { dg-options "-O2 -fno-ipa-icf -fdump-tree-optimized" } */
 /* { dg-final { scan-tree-dump-times "r\[<>]\[<>]" 96 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
 unsigned int
 f1 (unsigned int x, int y)
--- a/src/gcc/testsuite/c-c++-common/rotate-4.c
+++ b/src/gcc/testsuite/c-c++-common/rotate-4.c
@@ -4,7 +4,6 @@
 /* Rotates should be recognized only in functions with | instead of + or ^,
    or in functions that have constant shift counts (unused attribute on y).  */
 /* { dg-final { scan-tree-dump-times "r\[<>]\[<>]" 48 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
 unsigned int
 f1 (unsigned int x, int y)
--- a/src/gcc/testsuite/c-c++-common/tm/20100127.c
+++ b/src/gcc/testsuite/c-c++-common/tm/20100127.c
@@ -33,4 +33,3 @@ void test(void *data)
 }
 
 /* { dg-final { scan-tree-dump-times "_ITM_W.*nontrxn" 0 "tmmark" } } */
-/* { dg-final { cleanup-tree-dump "tmmark" } } */
--- a/src/gcc/testsuite/c-c++-common/tm/ipa-1.c
+++ b/src/gcc/testsuite/c-c++-common/tm/ipa-1.c
@@ -20,4 +20,3 @@ int set_remove(void)
 
 
 /* { dg-final { scan-ipa-dump-not "getTMCloneOrIrrevocable" "tmipa" } } */
-/* { dg-final { cleanup-ipa-dump "tmipa" } } */
--- a/src/gcc/testsuite/c-c++-common/tm/malloc.c
+++ b/src/gcc/testsuite/c-c++-common/tm/malloc.c
@@ -23,4 +23,3 @@ void foobar(void)
 /* { dg-final { scan-tree-dump-times "__builtin__ITM_malloc" 1 "tmmark" } } */
 /* { dg-final { scan-tree-dump-times "__builtin__ITM_calloc" 1 "tmmark" } } */
 /* { dg-final { scan-tree-dump-times "__builtin__ITM_free" 2 "tmmark" } } */
-/* { dg-final { cleanup-tree-dump "tmmark" } } */
--- a/src/gcc/testsuite/c-c++-common/tm/pr54893.c
+++ b/src/gcc/testsuite/c-c++-common/tm/pr54893.c
@@ -13,4 +13,3 @@ int main()
 }
 
 /* { dg-final { scan-ipa-dump "GTMA_DOES_GO_IRREVOCABLE" "tmipa" } } */
-/* { dg-final { cleanup-ipa-dump "tmipa" } } */
--- a/src/gcc/testsuite/c-c++-common/tm/trxn-expr-3.c
+++ b/src/gcc/testsuite/c-c++-common/tm/trxn-expr-3.c
@@ -11,4 +11,3 @@ int f2()
 
 /* { dg-final { scan-tree-dump-times "ITM_RU" 2 "tmmark" } } */
 /* { dg-final { scan-tree-dump-times "ITM_commitTransaction" 4 "tmmark" } } */
-/* { dg-final { cleanup-tree-dump "tmmark" } } */
--- a/src/gcc/testsuite/c-c++-common/tm/trxn-expr.c
+++ b/src/gcc/testsuite/c-c++-common/tm/trxn-expr.c
@@ -10,4 +10,3 @@ void foobar(void)
 
 /* { dg-final { scan-tree-dump-times "_ITM_RU.*york" 1 "tmmark" } } */
 /* { dg-final { scan-tree-dump-times "_ITM_RU" 1 "tmmark" } } */
-/* { dg-final { cleanup-tree-dump "tmmark" } } */
--- a/src/gcc/testsuite/c-c++-common/tm/wrap-1.c
+++ b/src/gcc/testsuite/c-c++-common/tm/wrap-1.c
@@ -7,4 +7,3 @@ void xyzzy(void) __attribute__((transaction_wrap (orig)));
 void foo() { __transaction_relaxed { orig (); } }
 
 /* { dg-final { scan-tree-dump-times "xyzzy" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/c-c++-common/transparent-union-1.c
+++ b/src/gcc/testsuite/c-c++-common/transparent-union-1.c
@@ -1,4 +1,5 @@
 /* PR c++/51228 */
+/* { dg-options "-Wno-c++-compat" { target c } } */
 
 typedef union {} U __attribute__((transparent_union)); /* { dg-warning "ignored" } */
 
--- a/src/gcc/testsuite/c-c++-common/ubsan/align-7.c
+++ b/src/gcc/testsuite/c-c++-common/ubsan/align-7.c
@@ -30,4 +30,3 @@ main ()
 
 /* { dg-output "\.c:16:\[0-9]*: \[^\n\r]*member access within misaligned address 0x\[0-9a-fA-F]* for type 'struct S', which requires \[48] byte alignment.*" } */
 /* { dg-final { scan-tree-dump-times "Optimizing" 4 "sanopt"} } */
-/* { dg-final { cleanup-tree-dump "sanopt" } } */
--- a/src/gcc/testsuite/c-c++-common/ubsan/align-8.c
+++ b/src/gcc/testsuite/c-c++-common/ubsan/align-8.c
@@ -29,4 +29,3 @@ main ()
 }
 
 /* { dg-final { scan-tree-dump-times "Optimizing" 4 "sanopt"} } */
-/* { dg-final { cleanup-tree-dump "sanopt" } } */
--- a/src/gcc/testsuite/c-c++-common/ubsan/pr63866.c
+++ b/src/gcc/testsuite/c-c++-common/ubsan/pr63866.c
@@ -8,4 +8,3 @@ foo (int x, int y)
   return x + y;
 }
 
-/* { dg-final { cleanup-ipa-dump "cgraph" } } */
--- a/src/gcc/testsuite/c-c++-common/ubsan/sanitize-all-2.c
+++ b/src/gcc/testsuite/c-c++-common/ubsan/sanitize-all-2.c
@@ -38,4 +38,3 @@ main ()
 
 /* { dg-final { scan-tree-dump-not "__ubsan_" "optimized" } } */
 /* { dg-final { scan-tree-dump-not "UBSAN_CHECK_" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/c-c++-common/ubsan/sanitize-all-3.c
+++ b/src/gcc/testsuite/c-c++-common/ubsan/sanitize-all-3.c
@@ -39,4 +39,3 @@ main ()
 /* { dg-final { scan-tree-dump "__ubsan_" "optimized" } } */
 /* { dg-final { scan-tree-dump-not "__ubsan_\[a-z_\]*_abort" "optimized" } } */
 /* { dg-final { scan-tree-dump "UBSAN_CHECK_" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/c-c++-common/ubsan/sanitize-all-4.c
+++ b/src/gcc/testsuite/c-c++-common/ubsan/sanitize-all-4.c
@@ -39,4 +39,3 @@ main ()
 /* { dg-final { scan-tree-dump "__ubsan_\[a-z_\]*_abort" "optimized" } } */
 /* { dg-final { scan-tree-dump-not "__ubsan_\[a-z_\]*\[^et\] " "optimized" } } */
 /* { dg-final { scan-tree-dump "UBSAN_CHECK_" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/c-c++-common/vector-scalar-2.c
+++ b/src/gcc/testsuite/c-c++-common/vector-scalar-2.c
@@ -11,4 +11,3 @@ void f (veci *a)
 }
 
 /* { dg-final { scan-tree-dump-times " \\\+ 1" 1 "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/g++.dg/abi/aarch64_guard1.C
+++ b/src/gcc/testsuite/g++.dg/abi/aarch64_guard1.C
@@ -13,4 +13,3 @@ int *foo ()
 }
 
 // { dg-final { scan-assembler _ZGVZ3foovE1x,8,8 } }
-// { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/g++.dg/abi/mangle-neon-aarch64.C
+++ b/src/gcc/testsuite/g++.dg/abi/mangle-neon-aarch64.C
@@ -13,6 +13,7 @@ void f3 (uint8x8_t a) {}
 void f4 (uint16x4_t a) {}
 void f5 (uint32x2_t a) {}
 void f23 (uint64x1_t a) {}
+void f61 (float16x4_t a) {}
 void f6 (float32x2_t a) {}
 void f7 (poly8x8_t a) {}
 void f8 (poly16x4_t a) {}
@@ -25,6 +26,7 @@ void f13 (uint8x16_t a) {}
 void f14 (uint16x8_t a) {}
 void f15 (uint32x4_t a) {}
 void f16 (uint64x2_t a) {}
+void f171 (float16x8_t a) {}
 void f17 (float32x4_t a) {}
 void f18 (float64x2_t a) {}
 void f19 (poly8x16_t a) {}
@@ -42,6 +44,7 @@ void g1 (int8x16_t, int8x16_t) {}
 // { dg-final { scan-assembler "_Z2f412__Uint16x4_t:" } }
 // { dg-final { scan-assembler "_Z2f512__Uint32x2_t:" } }
 // { dg-final { scan-assembler "_Z3f2312__Uint64x1_t:" } }
+// { dg-final { scan-assembler "_Z3f6113__Float16x4_t:" } }
 // { dg-final { scan-assembler "_Z2f613__Float32x2_t:" } }
 // { dg-final { scan-assembler "_Z2f711__Poly8x8_t:" } }
 // { dg-final { scan-assembler "_Z2f812__Poly16x4_t:" } }
@@ -53,6 +56,7 @@ void g1 (int8x16_t, int8x16_t) {}
 // { dg-final { scan-assembler "_Z3f1412__Uint16x8_t:" } }
 // { dg-final { scan-assembler "_Z3f1512__Uint32x4_t:" } }
 // { dg-final { scan-assembler "_Z3f1612__Uint64x2_t:" } }
+// { dg-final { scan-assembler "_Z4f17113__Float16x8_t:" } }
 // { dg-final { scan-assembler "_Z3f1713__Float32x4_t:" } }
 // { dg-final { scan-assembler "_Z3f1813__Float64x2_t:" } }
 // { dg-final { scan-assembler "_Z3f1912__Poly8x16_t:" } }
--- a/src/gcc/testsuite/g++.dg/cdce3.C
+++ b/src/gcc/testsuite/g++.dg/cdce3.C
@@ -4,8 +4,9 @@
 /* { dg-additional-options "-DLARGE_LONG_DOUBLE" { target large_long_double } } */
 /* { dg-additional-options "-DGNU_EXTENSION" { target pow10 } } */
 /* { dg-add-options ieee } */
+/* { dg-final { scan-tree-dump  "cdce3.C:91: note: function call is shrink-wrapped into error conditions\." "cdce" { target pow10 } } } */
 /* { dg-final { scan-tree-dump  "cdce3.C:92: note: function call is shrink-wrapped into error conditions\." "cdce" { target pow10 } } } */
-/* { dg-final { scan-tree-dump  "cdce3.C:93: note: function call is shrink-wrapped into error conditions\." "cdce" { target pow10 } } } */
+/* { dg-final { scan-tree-dump  "cdce3.C:94: note: function call is shrink-wrapped into error conditions\." "cdce" } } */
 /* { dg-final { scan-tree-dump  "cdce3.C:95: note: function call is shrink-wrapped into error conditions\." "cdce" } } */
 /* { dg-final { scan-tree-dump  "cdce3.C:96: note: function call is shrink-wrapped into error conditions\." "cdce" } } */
 /* { dg-final { scan-tree-dump  "cdce3.C:97: note: function call is shrink-wrapped into error conditions\." "cdce" } } */
@@ -19,8 +20,6 @@
 /* { dg-final { scan-tree-dump  "cdce3.C:105: note: function call is shrink-wrapped into error conditions\." "cdce" } } */
 /* { dg-final { scan-tree-dump  "cdce3.C:106: note: function call is shrink-wrapped into error conditions\." "cdce" } } */
 /* { dg-final { scan-tree-dump  "cdce3.C:107: note: function call is shrink-wrapped into error conditions\." "cdce" } } */
-/* { dg-final { scan-tree-dump  "cdce3.C:108: note: function call is shrink-wrapped into error conditions\." "cdce" } } */
-/* { dg-final { cleanup-tree-dump "cdce" } } */
 
 #include <stdlib.h>
 #include <math.h>
--- a/src/gcc/testsuite/g++.dg/compat/compat.exp
+++ b/src/gcc/testsuite/g++.dg/compat/compat.exp
@@ -78,6 +78,7 @@ proc compat-use-tst-compiler { } {
 	set ALWAYS_CXXFLAGS $save_always_cxxflags
 	set ld_library_path $save_ld_library_path
 	set_ld_library_path_env_vars
+	clear_effective_target_cache
     }
 }
 
--- a/src/gcc/testsuite/g++.dg/compat/struct-layout-1.exp
+++ b/src/gcc/testsuite/g++.dg/compat/struct-layout-1.exp
@@ -61,6 +61,7 @@ proc compat-use-alt-compiler { } {
 	set ld_library_path $alt_ld_library_path
 	set_ld_library_path_env_vars
 	restore_gcc_exec_prefix_env_var
+	clear_effective_target_cache
     }
 }
 
--- a/src/gcc/testsuite/g++.dg/cpp/paste2.C
+++ b/src/gcc/testsuite/g++.dg/cpp/paste2.C
@@ -1,7 +1,6 @@
 // PR preprocessor/57757
 // { dg-do compile { target c++11 } }
 // { dg-options "-save-temps" }
-// { dg-final cleanup-saved-temps }
 
 #define S(x) x
 extern S("C")void exit (int);
--- a/src/gcc/testsuite/g++.dg/cpp0x/constexpr-static.C
+++ b/src/gcc/testsuite/g++.dg/cpp0x/constexpr-static.C
@@ -12,7 +12,6 @@ struct A
 A a(42);	    // constexpr constructor allows constant initialization
 A ar[3] = { { 1 }, { 2 }, { 3 } };
 // { dg-final { scan-assembler-not "static_initialization" } }
-// { dg-final cleanup-saved-temps }
 
 int main()
 {
--- a/src/gcc/testsuite/g++.dg/cpp0x/constexpr-static3.C
+++ b/src/gcc/testsuite/g++.dg/cpp0x/constexpr-static3.C
@@ -1,7 +1,6 @@
 // Test for constant initialization of class with vtable
 // { dg-options "-save-temps" }
 // { dg-final { scan-assembler-not "static_initialization" } }
-// { dg-final cleanup-saved-temps }
 // { dg-do run { target c++11 } }
 
 int r = 1;
--- a/src/gcc/testsuite/g++.dg/cpp0x/gen-attrs-34.C
+++ b/src/gcc/testsuite/g++.dg/cpp0x/gen-attrs-34.C
@@ -16,4 +16,3 @@ unsigned int f4 ()
 // { dg-final { scan-tree-dump-times "= f1 \\(\\)" 1 "optimized" } }
 // { dg-final { scan-tree-dump-times "= f2 \\(\\)" 1 "optimized" } }
 // { dg-final { scan-tree-dump-times "= f3 \\(\\)" 1 "optimized" } }
-// { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/g++.dg/cpp0x/initlist-opt.C
+++ b/src/gcc/testsuite/g++.dg/cpp0x/initlist-opt.C
@@ -2,7 +2,6 @@
 // { dg-do compile { target c++11 } }
 // { dg-options "-O2 -fdump-tree-optimized" }
 // { dg-final { scan-tree-dump-not "_0" "optimized" } }
-// { dg-final { cleanup-tree-dump "optimized" } }
 
 #include <initializer_list>
 
--- a/src/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-decltype1.C
+++ b/src/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-decltype1.C
@@ -2,7 +2,6 @@
 // We force the gimple dump to trigger use of lang_decl_name.
 // { dg-do compile { target c++11 } }
 // { dg-options "-fdump-tree-gimple" }
-// { dg-final { cleanup-tree-dump "gimple" } }
 
 template < class T > void
 f (T t)
--- a/src/gcc/testsuite/g++.dg/cpp0x/stdint.C
+++ b/src/gcc/testsuite/g++.dg/cpp0x/stdint.C
@@ -1,6 +1,6 @@
 // PR c++/52764
-// { dg-require-effective-target stdint_types }
 // { dg-do compile { target c++11 } }
+// { dg-require-effective-target stdint_types }
 
 #include <stdint.h>
 
--- a/src/gcc/testsuite/g++.dg/eh/array1.C
+++ b/src/gcc/testsuite/g++.dg/eh/array1.C
@@ -14,4 +14,3 @@ void f()
 }
 
 // { dg-final { scan-tree-dump-times "catch" 1 "gimple" } }
-// { dg-final { cleanup-tree-dump "gimple" } }
--- a/src/gcc/testsuite/g++.dg/eh/builtin1.C
+++ b/src/gcc/testsuite/g++.dg/eh/builtin1.C
@@ -29,4 +29,3 @@ bar (int i)
 }
 
 /* { dg-final { scan-tree-dump-times "resx" 2 "eh" } } */
-/* { dg-final { cleanup-tree-dump "eh" } } */
--- a/src/gcc/testsuite/g++.dg/eh/builtin2.C
+++ b/src/gcc/testsuite/g++.dg/eh/builtin2.C
@@ -28,4 +28,3 @@ bar (int i)
 }
 
 /* { dg-final { scan-tree-dump-times "resx" 0 "eh" } } */
-/* { dg-final { cleanup-tree-dump "eh" } } */
--- a/src/gcc/testsuite/g++.dg/eh/builtin3.C
+++ b/src/gcc/testsuite/g++.dg/eh/builtin3.C
@@ -16,4 +16,3 @@ bar (int i)
 }
 
 /* { dg-final { scan-tree-dump-times "resx" 1 "eh" } } */
-/* { dg-final { cleanup-tree-dump "eh" } } */
--- a/src/gcc/testsuite/g++.dg/ext/altivec-10.C
+++ b/src/gcc/testsuite/g++.dg/ext/altivec-10.C
@@ -19,4 +19,3 @@ vector_float f1 = { 1.0, 2.0, 3.0, 4.0 };
 vector_float_foo = { 3.0, 4.0, 5.0, 6.0 };
 vector_float_bar_eq { 8.0, 7.0, 6.0, 5.0 };
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/g++.dg/ext/attrib34.C
+++ b/src/gcc/testsuite/g++.dg/ext/attrib34.C
@@ -16,4 +16,3 @@ unsigned int f4 ()
 // { dg-final { scan-tree-dump-times "= f1 \\(\\)" 1 "optimized" } }
 // { dg-final { scan-tree-dump-times "= f2 \\(\\)" 1 "optimized" } }
 // { dg-final { scan-tree-dump-times "= f3 \\(\\)" 1 "optimized" } }
-// { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/g++.dg/ext/builtin10.C
+++ b/src/gcc/testsuite/g++.dg/ext/builtin10.C
@@ -53,4 +53,3 @@ f4 (void)
 // { dg-final { scan-tree-dump-not "strrchr" "optimized" } }
 // { dg-final { scan-tree-dump-not "strpbrk" "optimized" } }
 // { dg-final { scan-tree-dump-not "strstr" "optimized" } }
-// { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/g++.dg/ext/label13a.C
+++ b/src/gcc/testsuite/g++.dg/ext/label13a.C
@@ -2,7 +2,6 @@
 // { dg-do run }
 // { dg-options "-save-temps" }
 // { dg-final { scan-assembler "_ZN1CC4Ev" } }
-// { dg-final cleanup-saved-temps }
 
 int i;
 struct A { A() {} };
--- a/src/gcc/testsuite/g++.dg/ext/pr56790-1.C
+++ b/src/gcc/testsuite/g++.dg/ext/pr56790-1.C
@@ -14,4 +14,3 @@ vec f (void)
 
 /* { dg-final { scan-tree-dump "{ 5, 13 }" "ccp1" } } */
 /* { dg-final { scan-tree-dump-not "VEC_COND_EXPR" "ccp1" } } */
-/* { dg-final { cleanup-tree-dump "ccp1" } } */
--- a/src/gcc/testsuite/g++.dg/ext/pr57735.C
+++ b/src/gcc/testsuite/g++.dg/ext/pr57735.C
@@ -1,4 +1,7 @@
 /* { dg-do compile { target arm*-*-* } } */
+/* { dg-require-effective-target arm_arch_v5te_ok } */
+/* { dg-require-effective-target arm_arm_ok } */
+/* { dg-skip-if "do not override -mfloat-abi" { *-*-* } { "-mfloat-abi=*" } {"-mfloat-abi=soft" } } */
 /* { dg-options "-march=armv5te -marm  -mtune=xscale -mfloat-abi=soft -O1" } */
 
 typedef unsigned int size_t;
--- a/src/gcc/testsuite/g++.dg/ext/vector21.C
+++ b/src/gcc/testsuite/g++.dg/ext/vector21.C
@@ -36,4 +36,3 @@ void j (vec *x, vec *y)
 /* { dg-final { scan-tree-dump "MIN_EXPR" "gimple" } } */
 /* { dg-final { scan-tree-dump "MAX_EXPR" "gimple" } } */
 /* { dg-final { scan-tree-dump-not "VEC_COND_EXPR" "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/g++.dg/ext/vector22.C
+++ b/src/gcc/testsuite/g++.dg/ext/vector22.C
@@ -19,4 +19,3 @@ void h(vec*a){
 
 /* { dg-final { scan-tree-dump-not "~" "gimple" } } */
 /* { dg-final { scan-tree-dump-not "VEC_COND_EXPR" "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/g++.dg/gomp/barrier-1.C
+++ b/src/gcc/testsuite/g++.dg/gomp/barrier-1.C
@@ -15,4 +15,3 @@ void f2(bool p)
 }
 
 /* { dg-final { scan-tree-dump-times "GOMP_barrier" 2 "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/g++.dg/gomp/block-0.C
+++ b/src/gcc/testsuite/g++.dg/gomp/block-0.C
@@ -32,4 +32,3 @@ void foo()
 }
 
 // { dg-final { scan-tree-dump-times "terminate" 10 "omplower" } }
-// { dg-final { cleanup-tree-dump "omplower" } }
--- a/src/gcc/testsuite/g++.dg/gomp/critical-1.C
+++ b/src/gcc/testsuite/g++.dg/gomp/critical-1.C
@@ -25,4 +25,3 @@ void foo (void)
 /* { dg-final { scan-tree-dump-times "GOMP_critical_end" 2 "omplower" } } */
 /* { dg-final { scan-tree-dump-times "GOMP_critical_name_start" 2 "omplower" } } */
 /* { dg-final { scan-tree-dump-times "GOMP_critical_name_end" 2 "omplower" } } */
-/* { dg-final { cleanup-tree-dump "omplower" } } */
--- a/src/gcc/testsuite/g++.dg/gomp/flush-1.C
+++ b/src/gcc/testsuite/g++.dg/gomp/flush-1.C
@@ -22,4 +22,3 @@ void f2(bool p)
 }
 
 /* { dg-final { scan-tree-dump-times "__sync_synchronize" 3 "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/g++.dg/gomp/for-10.C
+++ b/src/gcc/testsuite/g++.dg/gomp/for-10.C
@@ -14,4 +14,3 @@ void foo (int n)
 
 /* { dg-final { scan-tree-dump-times "GOMP_loop_ordered_runtime_start" 1 "ompexp" } } */
 /* { dg-final { scan-tree-dump-times "GOMP_loop_ordered_runtime_next" 1 "ompexp" } } */
-/* { dg-final { cleanup-tree-dump "ompexp" } } */
--- a/src/gcc/testsuite/g++.dg/gomp/for-13.C
+++ b/src/gcc/testsuite/g++.dg/gomp/for-13.C
@@ -15,4 +15,3 @@ void foo(void)
 }
 
 // { dg-final { scan-tree-dump-times "omp_data_o" 0 "lower" } }
-// { dg-final { cleanup-tree-dump "lower" } }
--- a/src/gcc/testsuite/g++.dg/gomp/for-4.C
+++ b/src/gcc/testsuite/g++.dg/gomp/for-4.C
@@ -14,4 +14,3 @@ void foo (int n)
 
 /* { dg-final { scan-tree-dump-times "GOMP_loop_dynamic_start" 1 "ompexp" } } */
 /* { dg-final { scan-tree-dump-times "GOMP_loop_dynamic_next" 1 "ompexp" } } */
-/* { dg-final { cleanup-tree-dump "ompexp" } } */
--- a/src/gcc/testsuite/g++.dg/gomp/for-5.C
+++ b/src/gcc/testsuite/g++.dg/gomp/for-5.C
@@ -14,4 +14,3 @@ void foo (int n)
 
 /* { dg-final { scan-tree-dump-times "GOMP_loop_guided_start" 1 "ompexp" } } */
 /* { dg-final { scan-tree-dump-times "GOMP_loop_guided_next" 1 "ompexp" } } */
-/* { dg-final { cleanup-tree-dump "ompexp" } } */
--- a/src/gcc/testsuite/g++.dg/gomp/for-6.C
+++ b/src/gcc/testsuite/g++.dg/gomp/for-6.C
@@ -14,4 +14,3 @@ void foo (int n)
 
 /* { dg-final { scan-tree-dump-times "GOMP_loop_runtime_start" 1 "ompexp" } } */
 /* { dg-final { scan-tree-dump-times "GOMP_loop_runtime_next" 1 "ompexp" } } */
-/* { dg-final { cleanup-tree-dump "ompexp" } } */
--- a/src/gcc/testsuite/g++.dg/gomp/for-7.C
+++ b/src/gcc/testsuite/g++.dg/gomp/for-7.C
@@ -14,4 +14,3 @@ void foo (int n)
 
 /* { dg-final { scan-tree-dump-times "GOMP_loop_ordered_static_start" 1 "ompexp" } } */
 /* { dg-final { scan-tree-dump-times "GOMP_loop_ordered_static_next" 1 "ompexp" } } */
-/* { dg-final { cleanup-tree-dump "ompexp" } } */
--- a/src/gcc/testsuite/g++.dg/gomp/for-8.C
+++ b/src/gcc/testsuite/g++.dg/gomp/for-8.C
@@ -14,4 +14,3 @@ void foo (int n)
 
 /* { dg-final { scan-tree-dump-times "GOMP_loop_ordered_dynamic_start" 1 "ompexp" } } */
 /* { dg-final { scan-tree-dump-times "GOMP_loop_ordered_dynamic_next" 1 "ompexp" } } */
-/* { dg-final { cleanup-tree-dump "ompexp" } } */
--- a/src/gcc/testsuite/g++.dg/gomp/for-9.C
+++ b/src/gcc/testsuite/g++.dg/gomp/for-9.C
@@ -14,4 +14,3 @@ void foo (int n)
 
 /* { dg-final { scan-tree-dump-times "GOMP_loop_ordered_guided_start" 1 "ompexp" } } */
 /* { dg-final { scan-tree-dump-times "GOMP_loop_ordered_guided_next" 1 "ompexp" } } */
-/* { dg-final { cleanup-tree-dump "ompexp" } } */
--- a/src/gcc/testsuite/g++.dg/gomp/macro-3.C
+++ b/src/gcc/testsuite/g++.dg/gomp/macro-3.C
@@ -23,4 +23,3 @@ foo (void)
 }
 
 // { dg-final { scan-tree-dump-times "#pragma omp parallel" 4 "omplower" } }
-// { dg-final { cleanup-tree-dump "omplower" } }
--- a/src/gcc/testsuite/g++.dg/gomp/master-3.C
+++ b/src/gcc/testsuite/g++.dg/gomp/master-3.C
@@ -10,4 +10,3 @@ void foo (void)
 }
 
 /* { dg-final { scan-tree-dump-times "omp_get_thread_num" 1 "omplower" } } */
-/* { dg-final { cleanup-tree-dump "omplower" } } */
--- a/src/gcc/testsuite/g++.dg/gomp/openmp-simd-1.C
+++ b/src/gcc/testsuite/g++.dg/gomp/openmp-simd-1.C
@@ -44,4 +44,3 @@ void foo(int n, float *a, float *b)
 /* { dg-final { scan-tree-dump-not "omp teams" "original" } } */
 /* { dg-final { scan-tree-dump-not "omp target" "original" } } */
 /* { dg-final { scan-tree-dump-not "omp parallel" "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/g++.dg/gomp/openmp-simd-2.C
+++ b/src/gcc/testsuite/g++.dg/gomp/openmp-simd-2.C
@@ -42,4 +42,3 @@ void bar(int n, float *a, float *b)
 /* { dg-final { scan-tree-dump-times "pragma omp simd safelen\\(64\\)" 1 "original" } } */
 /* { dg-final { scan-tree-dump-not "omp parallel" "original" } } */
 /* { dg-final { scan-tree-dump-not "omp for" "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/g++.dg/gomp/openmp-simd-3.C
+++ b/src/gcc/testsuite/g++.dg/gomp/openmp-simd-3.C
@@ -12,4 +12,3 @@ int main() {
 }
 
 /* { dg-final { scan-tree-dump-not "omp" "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/g++.dg/gomp/ordered-1.C
+++ b/src/gcc/testsuite/g++.dg/gomp/ordered-1.C
@@ -17,4 +17,3 @@ void foo (void)
 
 /* { dg-final { scan-tree-dump-times "GOMP_ordered_start" 2 "omplower" } } */
 /* { dg-final { scan-tree-dump-times "GOMP_ordered_end" 2 "omplower" } } */
-/* { dg-final { cleanup-tree-dump "omplower" } } */
--- a/src/gcc/testsuite/g++.dg/gomp/tls-wrap4.C
+++ b/src/gcc/testsuite/g++.dg/gomp/tls-wrap4.C
@@ -1,8 +1,8 @@
 // We don't need to call the wrapper through the PLT; we can use a separate
 // copy per shared object.
 
-// { dg-require-effective-target tls }
 // { dg-do compile { target c++11 } }
+// { dg-require-effective-target tls }
 // { dg-options "-fPIC" }
 // { dg-final { scan-assembler-not "_ZTW1i@PLT" { target i?86-*-* x86_64-*-* } } }
 
--- a/src/gcc/testsuite/g++.dg/gomp/tpl-barrier-1.C
+++ b/src/gcc/testsuite/g++.dg/gomp/tpl-barrier-1.C
@@ -22,4 +22,3 @@ void f3 ()
 }
 
 // { dg-final { scan-tree-dump-times "GOMP_barrier" 2 "gimple" } }
-// { dg-final { cleanup-tree-dump "gimple" } }
--- a/src/gcc/testsuite/g++.dg/gomp/tpl-master-1.C
+++ b/src/gcc/testsuite/g++.dg/gomp/tpl-master-1.C
@@ -27,4 +27,3 @@ void f3 ()
 
 // { dg-final { scan-tree-dump-times "#pragma omp ordered" 1 "gimple" } }
 // { dg-final { scan-tree-dump-times "#pragma omp master" 1 "gimple" } }
-// { dg-final { cleanup-tree-dump "gimple" } }
--- a/src/gcc/testsuite/g++.dg/inherit/covariant7.C
+++ b/src/gcc/testsuite/g++.dg/inherit/covariant7.C
@@ -48,4 +48,3 @@ struct c6 : c0, c3, c4
 // { dg-final { scan-tree-dump "84    .*c6::_ZTv0_n16_NV2c62f2Ev" "class" { target ilp32 } } }
 // { dg-final { scan-tree-dump "168   .*c6::_ZTv0_n32_NV2c62f2Ev" "class" { target lp64 } } }
 
-// { dg-final { cleanup-tree-dump "class" } }
--- a/src/gcc/testsuite/g++.dg/inherit/virtual11.C
+++ b/src/gcc/testsuite/g++.dg/inherit/virtual11.C
@@ -14,4 +14,3 @@ int foo (int a, int b) {
   return d.add(a, b);
 }
 // { dg-final { scan-tree-dump-not "OBJ_TYPE_REF" "gimple" } }
-// { dg-final { cleanup-tree-dump "gimple" } }
--- a/src/gcc/testsuite/g++.dg/init/array34.C
+++ b/src/gcc/testsuite/g++.dg/init/array34.C
@@ -3,7 +3,6 @@
 // that need extending.
 // { dg-options "-fdump-tree-gimple" }
 // { dg-final { scan-tree-dump-times "Class::Class" 1 "gimple" } }
-// { dg-final { cleanup-tree-dump "gimple" } }
 
 struct Class {
   Class();
--- a/src/gcc/testsuite/g++.dg/init/const7.C
+++ b/src/gcc/testsuite/g++.dg/init/const7.C
@@ -10,4 +10,3 @@ short offsets[1] = {
 void fn() { }
 
 // { dg-final { scan-tree-dump-not "initialization"  "gimple" } }
-// { dg-final { cleanup-tree-dump "gimple" } }
--- a/src/gcc/testsuite/g++.dg/init/new17.C
+++ b/src/gcc/testsuite/g++.dg/init/new17.C
@@ -34,4 +34,3 @@ void foo(Vector<float, 3> *m)
 }
 
 // { dg-final { scan-tree-dump-times "= 0\.0" 1 "optimized" } }
-// { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/g++.dg/init/new19.C
+++ b/src/gcc/testsuite/g++.dg/init/new19.C
@@ -70,4 +70,3 @@ int c::foo(int f1, int f2, int f3)
 }
 
 // { dg-final { scan-tree-dump "Replaced.*->ai\\\[0\\\]" "pre" } }
-// { dg-final { cleanup-tree-dump "pre" } }
--- a/src/gcc/testsuite/g++.dg/init/pr42556.C
+++ b/src/gcc/testsuite/g++.dg/init/pr42556.C
@@ -7,4 +7,3 @@ void foo (int a, int b, int c, int d)
 }
 
 // { dg-final { scan-tree-dump-not "v = {}"  "gimple" } }
-// { dg-final { cleanup-tree-dump "gimple" } }
--- a/src/gcc/testsuite/g++.dg/ipa/comdat.C
+++ b/src/gcc/testsuite/g++.dg/ipa/comdat.C
@@ -12,4 +12,3 @@ inline int t(void)
 }
 int (*f)()=t;
 /* { dg-final { scan-ipa-dump-times "Localizing symbol" 1 "comdats"  } } */
-/* { dg-final { cleanup-ipa-dump "comdats" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/devirt-1.C
+++ b/src/gcc/testsuite/g++.dg/ipa/devirt-1.C
@@ -58,5 +58,3 @@ int main (int argc, char *argv[])
 
 /* { dg-final { scan-ipa-dump "Discovered a virtual call to a known target.*B::foo"  "cp"  } } */
 /* { dg-final { scan-tree-dump-times "OBJ_TYPE_REF" 0 "optimized"} } */
-/* { dg-final { cleanup-ipa-dump "cp" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/devirt-10.C
+++ b/src/gcc/testsuite/g++.dg/ipa/devirt-10.C
@@ -28,5 +28,3 @@ void  OnPaint(wxPaintEvent & event) {
   wxBufferedPaintDC dc;
 }
 /* { dg-final { scan-ipa-dump-times "Discovered a virtual call to a known target" 2 "cp"  } } */
-/* { dg-final { cleanup-ipa-dump "inline" } } */
-/* { dg-final { cleanup-ipa-dump "cp" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/devirt-11.C
+++ b/src/gcc/testsuite/g++.dg/ipa/devirt-11.C
@@ -43,4 +43,3 @@ bar ()
   c + d;
 }
 /* { dg-final { scan-ipa-dump "Discovered a virtual call to a known target" "inline"  } } */
-/* { dg-final { cleanup-ipa-dump "inline" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/devirt-12.C
+++ b/src/gcc/testsuite/g++.dg/ipa/devirt-12.C
@@ -19,4 +19,3 @@ int main()
 }
 
 // { dg-final { scan-ipa-dump "Inlined 1 calls, eliminated 1 functions" "inline" } }
-// { dg-final { cleanup-ipa-dump "inline" } }
--- a/src/gcc/testsuite/g++.dg/ipa/devirt-13.C
+++ b/src/gcc/testsuite/g++.dg/ipa/devirt-13.C
@@ -17,4 +17,3 @@ main()
 }
 
 /* { dg-final { scan-tree-dump-times "OBJ_TYPE_REF" 0 "ssa"} } */
-/* { dg-final { cleanup-tree-dump "ssa" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/devirt-14.C
+++ b/src/gcc/testsuite/g++.dg/ipa/devirt-14.C
@@ -31,4 +31,3 @@ main()
 }
 
 /* { dg-final { scan-tree-dump-not "A::foo" "ssa"} } */
-/* { dg-final { cleanup-tree-dump "ssa" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/devirt-15.C
+++ b/src/gcc/testsuite/g++.dg/ipa/devirt-15.C
@@ -36,7 +36,5 @@ main()
 }
 
 /* { dg-final { scan-ipa-dump "speculatively devirtualizing call" "devirt"} } */
-/* { dg-final { cleanup-ipa-dump "devirt" } } */
 /* Match if (PROF_6 == foo) to verify that the speculation survived.  */
 /* { dg-final { scan-tree-dump "== foo" "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/devirt-16.C
+++ b/src/gcc/testsuite/g++.dg/ipa/devirt-16.C
@@ -35,4 +35,3 @@ main()
 /* { dg-final { scan-ipa-dump "builtin_unreachable" "whole-program"} } */
 /* { dg-final { scan-ipa-dump-not "A::foo" "whole-program"} } */
 /* { dg-final { scan-ipa-dump-not "A::foo" "whole-program"} } */
-/* { dg-final { cleanup-ipa-dump "whole-program" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/devirt-17.C
+++ b/src/gcc/testsuite/g++.dg/ipa/devirt-17.C
@@ -40,4 +40,3 @@ main()
 /* { dg-final { scan-ipa-dump-not "builtin_unreachable" "whole-program"} } */
 /* { dg-final { scan-ipa-dump "B::foo" "whole-program"} } */
 /* { dg-final { scan-ipa-dump-not "A::foo" "whole-program"} } */
-/* { dg-final { cleanup-ipa-dump "whole-program" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/devirt-18.C
+++ b/src/gcc/testsuite/g++.dg/ipa/devirt-18.C
@@ -34,4 +34,3 @@ main()
 /* { dg-final { scan-tree-dump-not "A::foo" "ssa"} } */
 /* { dg-final { scan-tree-dump-not "B::foo" "ssa"} } */
 /* { dg-final { scan-tree-dump "builtin_unreachable" "ssa"} } */
-/* { dg-final { cleanup-tree-dump "ssa" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/devirt-19.C
+++ b/src/gcc/testsuite/g++.dg/ipa/devirt-19.C
@@ -28,5 +28,4 @@ template <typename T, typename M> const M &C<T, M>::m_fn2(const T &) {
 
 void fn1() { b.m_fn2(0); }
 /* { dg-final { scan-ipa-dump-times "Discovered a virtual call to a known target" 1 "cp"  } } */
-/* { dg-final { cleanup-ipa-dump "cp" } } */
 
--- a/src/gcc/testsuite/g++.dg/ipa/devirt-2.C
+++ b/src/gcc/testsuite/g++.dg/ipa/devirt-2.C
@@ -59,4 +59,3 @@ int main (int argc, char *argv[])
 }
 
 /* { dg-final { scan-ipa-dump "Discovered a virtual call to a known target.*B::foo"  "cp"  } } */
-/* { dg-final { cleanup-ipa-dump "cp" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/devirt-20.C
+++ b/src/gcc/testsuite/g++.dg/ipa/devirt-20.C
@@ -28,4 +28,3 @@ main(void)
   return 0;
 }
 /* { dg-final { scan-tree-dump-not "abort" "release_ssa"  } } */
-/* { dg-final { cleanup-tree-dump "release_ssa" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/devirt-21.C
+++ b/src/gcc/testsuite/g++.dg/ipa/devirt-21.C
@@ -38,4 +38,3 @@ main()
   class C c;
 }
 /* { dg-final { scan-ipa-dump "Discovered a virtual call to" "cp" } } */
-/* { dg-final { cleanup-ipa-dump "cp" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/devirt-22.C
+++ b/src/gcc/testsuite/g++.dg/ipa/devirt-22.C
@@ -38,4 +38,3 @@ void update_sources() {
    vtbl store in destructor.  
    Previously we devirtualized to C::m_fn1 instead of B::m_fn1.  */
 /* { dg-final { scan-ipa-dump-times "Discovered a virtual call to a known target" 1 "cp"  } } */
-/* { dg-final { cleanup-ipa-dump "cp" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/devirt-23.C
+++ b/src/gcc/testsuite/g++.dg/ipa/devirt-23.C
@@ -46,4 +46,3 @@ main()
   class C c;
 }
 /* { dg-final { scan-ipa-dump "Discovered a virtual call to" "cp" { xfail *-*-* } } } */
-/* { dg-final { cleanup-ipa-dump "cp" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/devirt-24.C
+++ b/src/gcc/testsuite/g++.dg/ipa/devirt-24.C
@@ -37,6 +37,4 @@ C *b = new (C);
   }
 }
 /* { dg-final { scan-ipa-dump-times "Discovered a virtual call to a known target" 1 "inline" { xfail *-*-* } } } */
-/* { dg-final { cleanup-ipa-dump "inline" } } */
 /* { dg-final { scan-ipa-dump-times "Aggregate passed by reference" 1 "cp"  } } */
-/* { dg-final { cleanup-ipa-dump "cp" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/devirt-25.C
+++ b/src/gcc/testsuite/g++.dg/ipa/devirt-25.C
@@ -24,4 +24,3 @@ void dpr_run(ebs_Object& objectA) {
   dpr_run(jobL);
 }
 /* { dg-final { scan-ipa-dump "Type inconsistent devirtualization" "cp"  } } */
-/* { dg-final { cleanup-ipa-dump "cp" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/devirt-26.C
+++ b/src/gcc/testsuite/g++.dg/ipa/devirt-26.C
@@ -25,4 +25,3 @@ int test(void)
 /* The call to b->foo() is perfectly devirtualizable because C can not be in construction
    when &c was used.  */
 /* { dg-final { scan-tree-dump-not "OBJ_TYPE_REF" "ccp1"  } } */
-/* { dg-final { cleanup-tree-dump "ccp1" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/devirt-27.C
+++ b/src/gcc/testsuite/g++.dg/ipa/devirt-27.C
@@ -24,4 +24,3 @@ int test(void)
   return d->foo()+b->foo();
 }
 /* { dg-final { scan-tree-dump "OBJ_TYPE_REF" "optimized"  } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/devirt-28.C
+++ b/src/gcc/testsuite/g++.dg/ipa/devirt-28.C
@@ -14,4 +14,3 @@ void fn1(B* b) {
 // { dg-final { scan-assembler-not "_ZN1AD2Ev" } }
 // { dg-final { scan-assembler-not "_ZN1BD0Ev" } }
 // { dg-final { scan-ipa-dump "Target is artificial" "devirt" } }
-// { dg-final { cleanup-ipa-dump "devirt" } }
--- a/src/gcc/testsuite/g++.dg/ipa/devirt-3.C
+++ b/src/gcc/testsuite/g++.dg/ipa/devirt-3.C
@@ -66,5 +66,3 @@ int main (int argc, char *argv[])
 
 /* { dg-final { scan-ipa-dump "Discovered a virtual call to a known target.*B::foo"  "cp"  } } */
 /* { dg-final { scan-tree-dump-times "OBJ_TYPE_REF" 0 "optimized"} } */
-/* { dg-final { cleanup-ipa-dump "cp" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/devirt-30.C
+++ b/src/gcc/testsuite/g++.dg/ipa/devirt-30.C
@@ -22,4 +22,3 @@ void f(B* b)
 }
 
 // { dg-final { scan-ipa-dump-not "Speculatively devirtualizing" "devirt" } }
-// { dg-final { cleanup-ipa-dump "devirt" } }
--- a/src/gcc/testsuite/g++.dg/ipa/devirt-31.C
+++ b/src/gcc/testsuite/g++.dg/ipa/devirt-31.C
@@ -13,4 +13,3 @@ m()
   t();
 }
 // { dg-final { scan-tree-dump-not "OBJ_TYPE_REF" "ssa" } }
-// { dg-final { cleanup-tree-dump "ssa" } }
--- a/src/gcc/testsuite/g++.dg/ipa/devirt-32.C
+++ b/src/gcc/testsuite/g++.dg/ipa/devirt-32.C
@@ -20,4 +20,3 @@ int main()
   __builtin_printf("%d\n", o.obj()->val());
 }
 /* { dg-final { scan-ipa-dump-not "__builtin_unreachable"  "inline"  } } */
-/* { dg-final { cleanup-ipa-dump "inline" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/devirt-34.C
+++ b/src/gcc/testsuite/g++.dg/ipa/devirt-34.C
@@ -17,4 +17,3 @@ t(struct B *b)
 
 /* { dg-final { scan-ipa-dump "Speculative targets"  "devirt"  } } */
 /* { dg-final { scan-ipa-dump "1 speculatively devirtualized"  "devirt"  } } */
-/* { dg-final { cleanup-ipa-dump "devirt" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/devirt-35.C
+++ b/src/gcc/testsuite/g++.dg/ipa/devirt-35.C
@@ -18,6 +18,4 @@ m(struct B *b)
 /* { dg-final { scan-tree-dump "converting indirect call to function virtual int B::t"  "fre1"  } } */
 /* { dg-final { scan-ipa-dump "to virtual int B::t"  "devirt"  } } */
 /* { dg-final { scan-ipa-dump "1 speculatively devirtualized"  "devirt"  } } */
-/* { dg-final { cleanup-ipa-dump "devirt" } } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
 
--- a/src/gcc/testsuite/g++.dg/ipa/devirt-36.C
+++ b/src/gcc/testsuite/g++.dg/ipa/devirt-36.C
@@ -20,6 +20,4 @@ m(struct B *b)
 /* { dg-final { scan-tree-dump "converting indirect call to function virtual int B::t"  "fre1"  } } */
 /* { dg-final { scan-ipa-dump "to virtual int B::t"  "devirt"  } } */
 /* { dg-final { scan-ipa-dump "1 speculatively devirtualized"  "devirt"  } } */
-/* { dg-final { cleanup-ipa-dump "devirt" } } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
 
--- a/src/gcc/testsuite/g++.dg/ipa/devirt-37.C
+++ b/src/gcc/testsuite/g++.dg/ipa/devirt-37.C
@@ -34,4 +34,3 @@ t()
 /* { dg-final { scan-tree-dump "Checking vtbl store:"  "fre2"  } } */
 /* { dg-final { scan-tree-dump "Function call may change dynamic type:extcall"  "fre2"  } } */
 /* { dg-final { scan-tree-dump "converting indirect call to function virtual void"  "fre2"  } } */
-/* { dg-final { cleanup-tree-dump "fre2" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/devirt-38.C
+++ b/src/gcc/testsuite/g++.dg/ipa/devirt-38.C
@@ -28,4 +28,3 @@ void fn1 ()
       }
 }
 /* { dg-final { scan-tree-dump-not "OBJ_TYPE_REF" "ccp1"  } } */
-/* { dg-final { cleanup-tree-dump "ccp1" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/devirt-39.C
+++ b/src/gcc/testsuite/g++.dg/ipa/devirt-39.C
@@ -26,4 +26,3 @@ int main()
 
 /* { dg-final { scan-tree-dump-not "OBJ_TYPE_REF" "optimized"  } } */
 /* { dg-final { scan-assembler-not "_ZN3Foo5cloneEv" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/devirt-4.C
+++ b/src/gcc/testsuite/g++.dg/ipa/devirt-4.C
@@ -64,5 +64,3 @@ int main (int argc, char *argv[])
 
 /* { dg-final { scan-ipa-dump "Discovered a virtual call to a known target.*B::foo"  "cp"  } } */
 /* { dg-final { scan-tree-dump-times "OBJ_TYPE_REF" 0 "optimized"} } */
-/* { dg-final { cleanup-ipa-dump "cp" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/devirt-40.C
+++ b/src/gcc/testsuite/g++.dg/ipa/devirt-40.C
@@ -20,4 +20,3 @@ A::m_fn1 (UnicodeString &, int &p2, UErrorCode &) const
 }
 
 /* { dg-final { scan-tree-dump-not "\\n  OBJ_TYPE_REF" "fre2"  } } */
-/* { dg-final { cleanup-tree-dump "fre2" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/devirt-41.C
+++ b/src/gcc/testsuite/g++.dg/ipa/devirt-41.C
@@ -28,4 +28,3 @@ main()
    and from callstack we can tell that is is not in construction/destruction.  */
 /* { dg-final { scan-ipa-dump "Second type is base of first" "inline"  } } */
 /* { dg-final { scan-ipa-dump-times "Discovered a virtual call to a known target" 1 "inline"  } } */
-/* { dg-final { cleanup-ipa-dump "inline" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/devirt-42.C
+++ b/src/gcc/testsuite/g++.dg/ipa/devirt-42.C
@@ -34,5 +34,3 @@ main()
 /* { dg-final { scan-tree-dump-times "return 2" 3 "optimized"  } } */
 /* { dg-final { scan-tree-dump-not "OBJ_TYPE_REF" "optimized"  } } */
 
-/* { dg-final { cleanup-ipa-dump "inline" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/devirt-43.C
+++ b/src/gcc/testsuite/g++.dg/ipa/devirt-43.C
@@ -24,4 +24,3 @@ t(struct B *b)
    FIXME: We could most probably can devirtualize unconditonally because dereference of b in
    &b->a makes the type known.  GIMPLE does not represent this.  */
 /* { dg-final { scan-ipa-dump-times "Discovered a virtual call to a speculative target" 1 "inline" { xfail *-*-* } } } */
-/* { dg-final { cleanup-ipa-dump "inline" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/devirt-44.C
+++ b/src/gcc/testsuite/g++.dg/ipa/devirt-44.C
@@ -29,4 +29,3 @@ main()
 /* { dg-final { scan-ipa-dump "Second type is base of first" "inline"  } } */
 /* { dg-final { scan-ipa-dump-times "Discovered a virtual call to a known target\[^\\n\]*A::foo" 1 "inline"  } } */
 /* { dg-final { scan-ipa-dump-times "Discovered a virtual call to a known target\[^\\n\]*B::foo" 1 "inline"  } } */
-/* { dg-final { cleanup-ipa-dump "inline" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/devirt-45.C
+++ b/src/gcc/testsuite/g++.dg/ipa/devirt-45.C
@@ -39,4 +39,3 @@ main()
 /* One invocation is A::foo () other is B::foo () even though the type is destroyed and rebuilt in test() */
 /* { dg-final { scan-ipa-dump-times "Discovered a virtual call to a known target\[^\\n\]*A::foo" 1 "inline"  } } */
 /* { dg-final { scan-ipa-dump-times "Discovered a virtual call to a known target\[^\\n\]*B::foo" 1 "inline"  } } */
-/* { dg-final { cleanup-ipa-dump "inline" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/devirt-46.C
+++ b/src/gcc/testsuite/g++.dg/ipa/devirt-46.C
@@ -23,5 +23,3 @@ m()
 /* { dg-final { scan-ipa-dump-times "Discovered a virtual call to a known target\[^\\n\]*B::foo" 1 "inline"  } } */
 /* { dg-final { scan-tree-dump-not "OBJ_TYPE_REF" "optimized"  } } */
 /* { dg-final { scan-tree-dump-not "abort" "optimized"  } } */
-/* { dg-final { cleanup-ipa-dump "inline" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/devirt-47.C
+++ b/src/gcc/testsuite/g++.dg/ipa/devirt-47.C
@@ -27,5 +27,3 @@ m()
 /* { dg-final { scan-tree-dump-not "OBJ_TYPE_REF" "optimized"  } } */
 /* FIXME: We ought to inline thunk.  */
 /* { dg-final { scan-tree-dump "C::_ZThn" "optimized"  } } */
-/* { dg-final { cleanup-ipa-dump "inline" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/devirt-48.C
+++ b/src/gcc/testsuite/g++.dg/ipa/devirt-48.C
@@ -29,4 +29,3 @@ m()
 }
 
 /* { dg-final { scan-ipa-dump-times "Discovered a virtual call to a known target\[^\\n\]*__builtin_unreachable" 1 "inline"  } } */
-/* { dg-final { cleanup-ipa-dump "inline" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/devirt-5.C
+++ b/src/gcc/testsuite/g++.dg/ipa/devirt-5.C
@@ -75,5 +75,3 @@ int main (int argc, char *argv[])
 
 /* { dg-final { scan-ipa-dump "Discovered a virtual call to a known target.*B::foo"  "cp"  } } */
 /* { dg-final { scan-tree-dump-times "OBJ_TYPE_REF" 0 "optimized"} } */
-/* { dg-final { cleanup-ipa-dump "cp" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/devirt-7.C
+++ b/src/gcc/testsuite/g++.dg/ipa/devirt-7.C
@@ -85,4 +85,3 @@ int main (int argc, char *argv[])
 }
 
 /* { dg-final { scan-ipa-dump "Discovered a virtual call to a known target.*B::foo"  "cp"  } } */
-/* { dg-final { cleanup-ipa-dump "cp" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/devirt-9.C
+++ b/src/gcc/testsuite/g++.dg/ipa/devirt-9.C
@@ -30,4 +30,3 @@ bar ()
 /* We optimize out this call just after early passes.  Unfortunately
    this unreachable removal is not logged in dump file.  */
 /* { dg-final { scan-ipa-dump-not "OBJ_TYPE_REF" "whole-program" } } */
-/* { dg-final { cleanup-ipa-dump "whole-program" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/devirt-c-1.C
+++ b/src/gcc/testsuite/g++.dg/ipa/devirt-c-1.C
@@ -72,5 +72,3 @@ int main (int argc, char *argv[])
 
 /* { dg-final { scan-ipa-dump "Discovered a virtual call to a known target.*A::foo"  "cp"  } } */
 /* { dg-final { scan-tree-dump-times "OBJ_TYPE_REF" 0 "optimized"} } */
-/* { dg-final { cleanup-ipa-dump "cp" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/devirt-c-2.C
+++ b/src/gcc/testsuite/g++.dg/ipa/devirt-c-2.C
@@ -80,5 +80,3 @@ int main (int argc, char *argv[])
 
 /* { dg-final { scan-ipa-dump "Discovered a virtual call to a known target.*A::foo"  "cp"  } } */
 /* { dg-final { scan-tree-dump-times "OBJ_TYPE_REF" 0 "optimized"} } */
-/* { dg-final { cleanup-ipa-dump "cp" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/devirt-c-8.C
+++ b/src/gcc/testsuite/g++.dg/ipa/devirt-c-8.C
@@ -78,5 +78,3 @@ int main (int argc, char *argv[])
 
 /* { dg-final { scan-ipa-dump "Discovered a virtual call to a known target.*A::foo"  "cp"  } } */
 /* { dg-final { scan-tree-dump-times "OBJ_TYPE_REF" 0 "optimized"} } */
-/* { dg-final { cleanup-ipa-dump "cp" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/devirt-g-1.C
+++ b/src/gcc/testsuite/g++.dg/ipa/devirt-g-1.C
@@ -20,5 +20,3 @@ void bah() {foh(&r.s); }
 
 /* { dg-final { scan-ipa-dump "Discovered a virtual call to a known target.*S::xyzzy" "cp"  } } */
 /* { dg-final { scan-tree-dump-times "OBJ_TYPE_REF" 0 "optimized"} } */
-/* { dg-final { cleanup-ipa-dump "cp" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/iinline-1.C
+++ b/src/gcc/testsuite/g++.dg/ipa/iinline-1.C
@@ -46,4 +46,3 @@ int main (int argc, char *argv[])
 }
 
 /* { dg-final { scan-ipa-dump "String::funcOne\[^\\n\]*inline copy in int main"  "inline"  } } */
-/* { dg-final { cleanup-ipa-dump "inline" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/iinline-2.C
+++ b/src/gcc/testsuite/g++.dg/ipa/iinline-2.C
@@ -58,4 +58,3 @@ int main (int argc, char *argv[])
 }
 
 /* { dg-final { scan-ipa-dump "String::funcOne\[^\\n\]*inline copy in int main"  "inline"  } } */
-/* { dg-final { cleanup-ipa-dump "inline" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/imm-devirt-1.C
+++ b/src/gcc/testsuite/g++.dg/ipa/imm-devirt-1.C
@@ -64,4 +64,3 @@ int main (int argc, char *argv[])
 /* { dg-final { scan-tree-dump "Inlining int middleman_2" "einline"  } } */
 /* { dg-final { scan-tree-dump "B::foo \\(" "einline"  } } */
 /* { dg-final { scan-tree-dump-times "OBJ_TYPE_REF" 2 "einline"  } } */
-/* { dg-final { cleanup-tree-dump "einline" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/imm-devirt-2.C
+++ b/src/gcc/testsuite/g++.dg/ipa/imm-devirt-2.C
@@ -93,4 +93,3 @@ int main (int argc, char *argv[])
 
 /* We fold into thunk of C. Eventually we should inline the thunk.  */
 /* { dg-final { scan-tree-dump "C::_ZThn\[0-9\]+_N1C3fooEi \\(" "einline"  } } */
-/* { dg-final { cleanup-tree-dump "einline" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/inline-1.C
+++ b/src/gcc/testsuite/g++.dg/ipa/inline-1.C
@@ -33,4 +33,3 @@ int main(int argc, char **argv)
 
 /* { dg-final { scan-ipa-dump-times "Considering void inline_me\\(" 1 "inline"} } */
 /* { dg-final { scan-ipa-dump-times "Considering void inline_me_too\\(" 1 "inline"} } */
-/* { dg-final { cleanup-ipa-dump "inline" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/inline-2.C
+++ b/src/gcc/testsuite/g++.dg/ipa/inline-2.C
@@ -33,4 +33,3 @@ int main(int argc, char **argv)
 
 /* { dg-final { scan-ipa-dump-times "Considering void inline_me\\(" 1 "inline"} } */
 /* { dg-final { scan-ipa-dump-times "Considering void inline_me_too\\(" 1 "inline"} } */
-/* { dg-final { cleanup-ipa-dump "inline" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/inline-3.C
+++ b/src/gcc/testsuite/g++.dg/ipa/inline-3.C
@@ -26,4 +26,3 @@ int main(int argc, char **argv)
 
 /* { dg-final { scan-ipa-dump-times "Considering void inline_me\\(" 1 "inline"} } */
 /* { dg-final { scan-ipa-dump-times "Considering void inline_me_too\\(" 1 "inline"} } */
-/* { dg-final { cleanup-ipa-dump "inline" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/ipa-icf-1.C
+++ b/src/gcc/testsuite/g++.dg/ipa/ipa-icf-1.C
@@ -40,4 +40,3 @@ int main()
 
 /* { dg-final { scan-ipa-dump-not "Semantic equality hit:" "icf"  } } */
 /* { dg-final { scan-ipa-dump "Equal symbols: 0" "icf"  } } */
-/* { dg-final { cleanup-ipa-dump "icf" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/ipa-icf-2.C
+++ b/src/gcc/testsuite/g++.dg/ipa/ipa-icf-2.C
@@ -37,4 +37,3 @@ int main()
 
 /* { dg-final { scan-ipa-dump "Semantic equality hit:" "icf"  } } */
 /* { dg-final { scan-ipa-dump "Equal symbols: 1" "icf"  } } */
-/* { dg-final { cleanup-ipa-dump "icf" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/ipa-icf-3.C
+++ b/src/gcc/testsuite/g++.dg/ipa/ipa-icf-3.C
@@ -33,4 +33,3 @@ int main()
 /* { dg-final { scan-ipa-dump "Semantic equality hit:.*bar.*->.*foo.*" "icf"  } } */
 /* { dg-final { scan-ipa-dump "Semantic equality hit:.*nula.*->.*zero.*" "icf"  } } */
 /* { dg-final { scan-ipa-dump "Equal symbols: 2" "icf"  } } */
-/* { dg-final { cleanup-ipa-dump "icf" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/ipa-icf-4.C
+++ b/src/gcc/testsuite/g++.dg/ipa/ipa-icf-4.C
@@ -45,4 +45,3 @@ int main()
 
 /* { dg-final { scan-ipa-dump "\(Unified; Variable alias has been created\)|\(Symbol aliases are not supported by target\)" "icf"  } } */
 /* { dg-final { scan-ipa-dump "Equal symbols: \[67\]" "icf"  } } */
-/* { dg-final { cleanup-ipa-dump "icf" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/ipa-icf-5.C
+++ b/src/gcc/testsuite/g++.dg/ipa/ipa-icf-5.C
@@ -22,4 +22,3 @@ int main()
 }
 
 /* { dg-final { scan-ipa-dump "Equal symbols: 0" "icf"  } } */
-/* { dg-final { cleanup-ipa-dump "icf" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/ipa-icf-6.C
+++ b/src/gcc/testsuite/g++.dg/ipa/ipa-icf-6.C
@@ -34,4 +34,3 @@ main()
   return 0;
 }
 /* { dg-final { scan-ipa-dump-times "Unified; Wrapper has been created" 1 "icf"  } } */
-/* { dg-final { cleanup-ipa-dump "icf" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/ivinline-1.C
+++ b/src/gcc/testsuite/g++.dg/ipa/ivinline-1.C
@@ -61,4 +61,3 @@ int main (int argc, char *argv[])
 }
 
 /* { dg-final { scan-ipa-dump "B::foo\[^\\n\]*inline copy in int main"  "inline"  } } */
-/* { dg-final { cleanup-ipa-dump "inline" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/ivinline-2.C
+++ b/src/gcc/testsuite/g++.dg/ipa/ivinline-2.C
@@ -60,4 +60,3 @@ int main (int argc, char *argv[])
 }
 
 /* { dg-final { scan-ipa-dump "B::foo\[^\\n\]*inline copy in int main"  "inline"  } } */
-/* { dg-final { cleanup-ipa-dump "inline" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/ivinline-3.C
+++ b/src/gcc/testsuite/g++.dg/ipa/ivinline-3.C
@@ -61,4 +61,3 @@ int main (int argc, char *argv[])
 }
 
 /* { dg-final { scan-ipa-dump "B::foo\[^\\n\]*inline copy in int main"  "inline"  } } */
-/* { dg-final { cleanup-ipa-dump "inline" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/ivinline-4.C
+++ b/src/gcc/testsuite/g++.dg/ipa/ivinline-4.C
@@ -67,4 +67,3 @@ int main (int argc, char *argv[])
 }
 
 /* { dg-final { scan-ipa-dump "B::foo\[^\\n\]*inline copy in int main"  "inline"  } } */
-/* { dg-final { cleanup-ipa-dump "inline" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/ivinline-5.C
+++ b/src/gcc/testsuite/g++.dg/ipa/ivinline-5.C
@@ -52,4 +52,3 @@ int main (int argc, char *argv[])
 
 /* { dg-final { scan-ipa-dump "A::foo\[^\\n\]*inline copy in int main"  "inline"  } } */
 /* { dg-final { scan-ipa-dump "B::foo\[^\\n\]*inline copy in int main"  "inline"  } } */
-/* { dg-final { cleanup-ipa-dump "inline" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/ivinline-7.C
+++ b/src/gcc/testsuite/g++.dg/ipa/ivinline-7.C
@@ -77,4 +77,3 @@ int main (int argc, char *argv[])
 
 /* { dg-final { scan-ipa-dump "Discovered a virtual call to a known target.*B::.*foo"  "inline"  } } */
 /* { dg-final { scan-ipa-dump "B::foo\[^\\n\]*inline copy in int main"  "inline"  { xfail *-*-* } } } */
-/* { dg-final { cleanup-ipa-dump "inline" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/ivinline-8.C
+++ b/src/gcc/testsuite/g++.dg/ipa/ivinline-8.C
@@ -74,4 +74,3 @@ int main (int argc, char *argv[])
 
 /* { dg-final { scan-ipa-dump "B::foo\[^\\n\]*inline copy in int main" "inline"  } } */
 /* { dg-final { scan-ipa-dump "B::bar\[^\\n\]*inline copy in int main" "inline"  } } */
-/* { dg-final { cleanup-ipa-dump "inline" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/ivinline-9.C
+++ b/src/gcc/testsuite/g++.dg/ipa/ivinline-9.C
@@ -91,4 +91,3 @@ int main (int argc, char *argv[])
 
 /* { dg-final { scan-ipa-dump "Discovered a virtual call to a known target.*B::.*foo"  "inline"  } } */
 /* { dg-final { scan-ipa-dump "B::foo\[^\\n\]*inline copy in int main"  "inline"  { xfail *-*-* } } } */
-/* { dg-final { cleanup-ipa-dump "inline" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/pr60600.C
+++ b/src/gcc/testsuite/g++.dg/ipa/pr60600.C
@@ -32,4 +32,3 @@ void test(top& t)
 }
 
 /* { dg-final { scan-ipa-dump "Type inconsistent devirtualization" "cp" } } */
-/* { dg-final { cleanup-ipa-dump "cp" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/pr60640-4.C
+++ b/src/gcc/testsuite/g++.dg/ipa/pr60640-4.C
@@ -82,4 +82,3 @@ int main (int argc, char *argv[])
 }
 
 /* { dg-final { scan-ipa-dump-times "Thunk fixed offset" 2 "cp"} } */
-/* { dg-final { cleanup-ipa-dump "cp" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/pr63580.C
+++ b/src/gcc/testsuite/g++.dg/ipa/pr63580.C
@@ -23,4 +23,3 @@ foo (int p1, char p2, int p3, double p4)
 }
 
 /* { dg-final { scan-ipa-dump "Equal symbols: 1" "icf"  } } */
-/* { dg-final { cleanup-ipa-dump "icf" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/pr63595.C
+++ b/src/gcc/testsuite/g++.dg/ipa/pr63595.C
@@ -77,4 +77,3 @@ int main()
 }
 
 /* { dg-final { scan-ipa-dump "Equal symbols: 0" "icf"  } } */
-/* { dg-final { cleanup-ipa-dump "icf" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/pr63838.C
+++ b/src/gcc/testsuite/g++.dg/ipa/pr63838.C
@@ -3,7 +3,6 @@
 // { dg-options "-O2 -fdump-ipa-pure-const" }
 // { dg-final { scan-ipa-dump-not "Function found to be nothrow: void foo" "pure-const" } }
 // { dg-final { scan-ipa-dump-not "Function found to be nothrow: void bar" "pure-const" } }
-// { dg-final { cleanup-ipa-dump "pure-const" } }
 
 __attribute__((noinline, noclone)) static void bar (int);
 volatile int v;
--- a/src/gcc/testsuite/g++.dg/ipa/pr64049-1.C
+++ b/src/gcc/testsuite/g++.dg/ipa/pr64049-1.C
@@ -34,4 +34,3 @@ LocalizedTextSet (LocalizedTextStruct* pTarget, LocalizedTextStruct* pSource)
 }
 
 /* { dg-final { scan-ipa-dump-not "__builtin_unreachable" "inline" } } */
-/* { dg-final { cleanup-ipa-dump "inline" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/pr64146.C
+++ b/src/gcc/testsuite/g++.dg/ipa/pr64146.C
@@ -36,4 +36,3 @@ int main (int argc, char **argv)
 }
 
 /* { dg-final { scan-ipa-dump "Equal symbols: 1" "icf"  } } */
-/* { dg-final { cleanup-ipa-dump "icf" } } */
--- a/src/gcc/testsuite/g++.dg/ipa/type-inheritance-1.C
+++ b/src/gcc/testsuite/g++.dg/ipa/type-inheritance-1.C
@@ -25,4 +25,3 @@ int t(class A *a)
 }
 /* { dg-final { scan-ipa-dump "A::foo"  "visibility"  } } */
 /* { dg-final { scan-ipa-dump-not "A::bar"  "visibility"  } } */
-/* { dg-final { cleanup-ipa-dump "visibility" } } */
--- a/src/gcc/testsuite/g++.dg/opt/nothrow1.C
+++ b/src/gcc/testsuite/g++.dg/opt/nothrow1.C
@@ -22,4 +22,3 @@ int main()
 
 // The catch block should be optimized away.
 // { dg-final { scan-tree-dump-times "-42" 0 "optimized" } }
-// { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/g++.dg/opt/nrv12.C
+++ b/src/gcc/testsuite/g++.dg/opt/nrv12.C
@@ -21,4 +21,3 @@ P foo (P x)
 }
 
 /* { dg-final { scan-tree-dump-times "return slot optimization" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/g++.dg/opt/pr23372.C
+++ b/src/gcc/testsuite/g++.dg/opt/pr23372.C
@@ -12,4 +12,3 @@ struct A {
 void f(A);
 void g(A *a) { f(*a); }
 
-// { dg-final { cleanup-tree-dump gimple } }
--- a/src/gcc/testsuite/g++.dg/opt/pr30965.C
+++ b/src/gcc/testsuite/g++.dg/opt/pr30965.C
@@ -17,4 +17,3 @@ extern void assign( long& variable, long v )
 
 /* { dg-final { scan-tree-dump-times ";; Function" 2 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "variable_..D. = v_..D." 2 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/g++.dg/opt/value-init1.C
+++ b/src/gcc/testsuite/g++.dg/opt/value-init1.C
@@ -2,7 +2,6 @@
 // { dg-do compile { target c++11 } }
 // { dg-options "-fdump-tree-gimple" }
 // { dg-final { scan-tree-dump-times "i = 0" 0 "gimple" } }
-// { dg-final { cleanup-tree-dump "gimple" } }
 
 struct S { S () = default; S (int i); int i; };
 struct A { S s[100]; };
--- a/src/gcc/testsuite/g++.dg/other/empty-class.C
+++ b/src/gcc/testsuite/g++.dg/other/empty-class.C
@@ -14,4 +14,3 @@ obj funky(){
 }
 
 /* { dg-final { scan-tree-dump-times "return <retval>;" 1 "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/g++.dg/other/final1.C
+++ b/src/gcc/testsuite/g++.dg/other/final1.C
@@ -24,4 +24,3 @@ void fun(A* a, B* b)
 
 /* { dg-final { scan-tree-dump-times "A::foo" 2 "original"  } } */
 /* { dg-final { scan-tree-dump-times "B::foo" 2 "original"  } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/g++.dg/other/final2.C
+++ b/src/gcc/testsuite/g++.dg/other/final2.C
@@ -25,4 +25,3 @@ void fooF2(F2& a) { a(); int m = a; ++a; }
 // { dg-final { scan-tree-dump-times "F2::operator\\(\\)" 1 "original" } }
 // { dg-final { scan-tree-dump-times "F2::operator int" 1 "original" } }
 // { dg-final { scan-tree-dump-times "F2::operator\\+\\+" 1 "original" } }
-// { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/g++.dg/other/pr47218.C
+++ b/src/gcc/testsuite/g++.dg/other/pr47218.C
@@ -18,4 +18,3 @@ int main ()
   return 0;
 }
 
-// { dg-final { cleanup-saved-temps } }
--- a/src/gcc/testsuite/g++.dg/other/static11.C
+++ b/src/gcc/testsuite/g++.dg/other/static11.C
@@ -31,4 +31,3 @@ int main()
   return r;
 }
 
-// { dg-final { cleanup-rtl-dump "*" } }
--- a/src/gcc/testsuite/g++.dg/pch/pch.C
+++ b/src/gcc/testsuite/g++.dg/pch/pch.C
@@ -5,5 +5,4 @@ int main()
 {
   return 0;
 }
-
-// { dg-final { cleanup-saved-temps ".s" } }
+// { dg-keep-saved-temps ".s" }
--- a/src/gcc/testsuite/g++.dg/pr55513.C
+++ b/src/gcc/testsuite/g++.dg/pr55513.C
@@ -9,4 +9,3 @@ main ()
 }
 
 // { dg-final { scan-tree-dump-times "memcpy" 1 "gimple" } }
-// { dg-final { cleanup-tree-dump "gimple" } }
--- a/src/gcc/testsuite/g++.dg/pr55604.C
+++ b/src/gcc/testsuite/g++.dg/pr55604.C
@@ -8,4 +8,3 @@ main ()
   __builtin_printf ("%d %s\n", t, s);
 }
 
-/* { dg-final { cleanup-rtl-dump "reload" } } */
--- a/src/gcc/testsuite/g++.dg/pr58123.C
+++ b/src/gcc/testsuite/g++.dg/pr58123.C
@@ -15,4 +15,3 @@ int main() {
 }
 
 // { dg-final { scan-tree-dump-times "pr58123.C:13\.6\] try" 1 "gimple" } }
-// { dg-final { cleanup-tree-dump "gimple" } }
--- a/src/gcc/testsuite/g++.dg/pr64191.C
+++ b/src/gcc/testsuite/g++.dg/pr64191.C
@@ -22,4 +22,3 @@ void bar_dtor_loop(Bar* p, unsigned int n)
 
 // { dg-final { scan-tree-dump-times "CLOBBER" 1 "cddce1" } }
 // { dg-final { scan-tree-dump-times "if" 0 "cddce1" } }
-// { dg-final { cleanup-tree-dump "cddce1" } }
--- a/src/gcc/testsuite/g++.dg/predict-loop-exit-1.C
+++ b/src/gcc/testsuite/g++.dg/predict-loop-exit-1.C
@@ -10,4 +10,3 @@ void test() {
 }
 
 /* { dg-final { scan-tree-dump-times "loop exit heuristics:" 3 "profile_estimate"} } */
-/* { dg-final { cleanup-tree-dump "profile_estimate" } } */
--- a/src/gcc/testsuite/g++.dg/predict-loop-exit-2.C
+++ b/src/gcc/testsuite/g++.dg/predict-loop-exit-2.C
@@ -10,4 +10,3 @@ void test() {
 }
 
 /* { dg-final { scan-tree-dump-times "loop exit heuristics:" 2 "profile_estimate"} } */
-/* { dg-final { cleanup-tree-dump "profile_estimate" } } */
--- a/src/gcc/testsuite/g++.dg/predict-loop-exit-3.C
+++ b/src/gcc/testsuite/g++.dg/predict-loop-exit-3.C
@@ -10,4 +10,3 @@ void test() {
 }
 
 /* { dg-final { scan-tree-dump-times "loop exit heuristics:" 3 "profile_estimate"} } */
-/* { dg-final { cleanup-tree-dump "profile_estimate" } } */
--- a/src/gcc/testsuite/g++.dg/tls/thread_local-cse.C
+++ b/src/gcc/testsuite/g++.dg/tls/thread_local-cse.C
@@ -5,7 +5,6 @@
 // { dg-add-options tls }
 // { dg-require-effective-target tls_runtime }
 // { dg-final { scan-assembler-times "call *_ZTW2ir" 1 { xfail *-*-* } } }
-// { dg-final cleanup-saved-temps }
 
 // XFAILed until the back end supports a way to mark a function as cseable
 // though not pure.
--- a/src/gcc/testsuite/g++.dg/tm/attrib-2.C
+++ b/src/gcc/testsuite/g++.dg/tm/attrib-2.C
@@ -19,4 +19,3 @@ void Tcall::f() { }
 // { dg-final { scan-tree-dump-times "_ZN5Tcall1fEv" 1 "optimized" } }
 // { dg-final { scan-tree-dump-times "_ZGTtN5Tsafe1fEv" 1 "optimized" } }
 // { dg-final { scan-tree-dump-times "_ZGTtN5Tcall1fEv" 1 "optimized" } }
-// { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/g++.dg/tm/attrib-3.C
+++ b/src/gcc/testsuite/g++.dg/tm/attrib-3.C
@@ -30,4 +30,3 @@ void E::f() { }
 // { dg-final { scan-tree-dump-times "_ZGTtN1B1fEv" 1 "optimized" } }
 // { dg-final { scan-tree-dump-times "_ZN1E1fEv" 1 "optimized" } }
 // { dg-final { scan-tree-dump-times "_ZGTtN1E1fEv" 1 "optimized" } }
-// { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/g++.dg/tm/noexcept-1.C
+++ b/src/gcc/testsuite/g++.dg/tm/noexcept-1.C
@@ -34,5 +34,3 @@ int f3()
 
 /* { dg-final { scan-tree-dump-times "eh_must_not_throw" 6 "tmlower" } } */
 /* { dg-final { scan-tree-dump-times "ITM_RU" 6 "tmmark" } } */
-/* { dg-final { cleanup-tree-dump "tmmark" } } */
-/* { dg-final { cleanup-tree-dump "tmlower" } } */
--- a/src/gcc/testsuite/g++.dg/tm/noexcept-3.C
+++ b/src/gcc/testsuite/g++.dg/tm/noexcept-3.C
@@ -36,5 +36,3 @@ int f3()
 
 /* { dg-final { scan-tree-dump-times "eh_must_not_throw" 0 "tmlower" } } */
 /* { dg-final { scan-tree-dump-times "ITM_RU" 6 "tmmark" } } */
-/* { dg-final { cleanup-tree-dump "tmmark" } } */
-/* { dg-final { cleanup-tree-dump "tmlower" } } */
--- a/src/gcc/testsuite/g++.dg/tm/noexcept-4.C
+++ b/src/gcc/testsuite/g++.dg/tm/noexcept-4.C
@@ -31,5 +31,3 @@ int f3()
 
 /* { dg-final { scan-tree-dump-times "eh_must_not_throw" 6 "tmlower" } } */
 /* { dg-final { scan-tree-dump-times "ITM_RU" 6 "tmmark" } } */
-/* { dg-final { cleanup-tree-dump "tmmark" } } */
-/* { dg-final { cleanup-tree-dump "tmlower" } } */
--- a/src/gcc/testsuite/g++.dg/tm/noexcept-5.C
+++ b/src/gcc/testsuite/g++.dg/tm/noexcept-5.C
@@ -17,5 +17,3 @@ void f2(int x)
 }
 /* { dg-final { scan-tree-dump-times "eh_must_not_throw" 1 "tmlower" } } */
 /* { dg-final { scan-tree-dump-times "ITM_RU" 1 "tmmark" } } */
-/* { dg-final { cleanup-tree-dump "tmmark" } } */
-/* { dg-final { cleanup-tree-dump "tmlower" } } */
--- a/src/gcc/testsuite/g++.dg/tm/noexcept-6.C
+++ b/src/gcc/testsuite/g++.dg/tm/noexcept-6.C
@@ -20,4 +20,3 @@ int f1()
 
 /* { dg-final { scan-tree-dump-times "eh_must_not_throw" 0 "tmlower" } } */
 /* { dg-final { scan-tree-dump-times "__transaction_atomic" 1 "tmlower" } } */
-/* { dg-final { cleanup-tree-dump "tmlower" } } */
--- a/src/gcc/testsuite/g++.dg/tm/pr47530-2.C
+++ b/src/gcc/testsuite/g++.dg/tm/pr47530-2.C
@@ -36,4 +36,3 @@ void bench_test()
 // The one in the instrumented code path is not.
 // { dg-final { scan-tree-dump-times "ITM_commitTransaction.*tail call" 1 "tmedge" } }
 
-// { dg-final { cleanup-tree-dump "tmedge" } }
--- a/src/gcc/testsuite/g++.dg/tm/pr47530.C
+++ b/src/gcc/testsuite/g++.dg/tm/pr47530.C
@@ -76,5 +76,4 @@ void LinkedList::insert(int val)
 // Make sure we don't do tail optimization on the commit, except on
 // the uninstrumented code path.
 // { dg-final { scan-tree-dump-times "commitTransaction...; .tail call" 1 "optimized" } }
-// { dg-final { cleanup-tree-dump "optimized" } }
 
--- a/src/gcc/testsuite/g++.dg/tm/pr51516.C
+++ b/src/gcc/testsuite/g++.dg/tm/pr51516.C
@@ -18,4 +18,3 @@ int main()
 }
 
 /* { dg-final { scan-assembler-not "_ITM_getTMCloneOrIrrevocable" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/g++.dg/tm/template-1.C
+++ b/src/gcc/testsuite/g++.dg/tm/template-1.C
@@ -33,4 +33,3 @@ int f1()
 /* 4 transactions overall, two of them write to global:  */
 /* { dg-final { scan-tree-dump-times "ITM_RU4\\s*\\(&global" 4 "tmmark" } } */
 /* { dg-final { scan-tree-dump-times "ITM_WU4\\s*\\(&global" 2 "tmmark" } } */
-/* { dg-final { cleanup-tree-dump "tmmark" } } */
--- a/src/gcc/testsuite/g++.dg/tm/template-2.C
+++ b/src/gcc/testsuite/g++.dg/tm/template-2.C
@@ -19,4 +19,3 @@ int f1()
 }
 
 /* { dg-final { scan-tree-dump-times "ITM_RU" 2 "tmmark" } } */
-/* { dg-final { cleanup-tree-dump "tmmark" } } */
--- a/src/gcc/testsuite/g++.dg/torture/pr53085.C
+++ b/src/gcc/testsuite/g++.dg/torture/pr53085.C
@@ -14,4 +14,3 @@ void aa::f(){
 }
 
 // { dg-final { scan-tree-dump-times "a ={v} 1;" 2 "optimized" } }
-// { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/g++.dg/tree-prof/indir-call-prof.C
+++ b/src/gcc/testsuite/g++.dg/tree-prof/indir-call-prof.C
@@ -35,5 +35,3 @@ main (void)
 
 /* { dg-final-use { scan-ipa-dump "Indirect call -> direct call.* AA transformation on insn" "profile" } } */
 /* { dg-final-use { scan-tree-dump-not "Invalid sum" "optimized" } } */
-/* { dg-final-use { cleanup-tree-dump "optimized" } } */
-/* { dg-final-use { cleanup-ipa-dump "profile" } } */
--- a/src/gcc/testsuite/g++.dg/tree-prof/inline_mismatch_args.C
+++ b/src/gcc/testsuite/g++.dg/tree-prof/inline_mismatch_args.C
@@ -33,4 +33,3 @@ int main(void)
 }
 /* { dg-final-use { scan-tree-dump "Inlining .*Super::Foo" "einline" } } */
 /* { dg-final-use { scan-tree-dump-not "mismatched arguments" "einline" } } */
-/* { dg-final-use { cleanup-tree-dump "einline" } } */
--- a/src/gcc/testsuite/g++.dg/tree-prof/morefunc.C
+++ b/src/gcc/testsuite/g++.dg/tree-prof/morefunc.C
@@ -52,4 +52,3 @@ int main()
 }
 
 /* { dg-final-use { scan-ipa-dump-times "Indirect call -> direct call" 2 "profile" } } */
-/* { dg-final-use { cleanup-ipa-dump "profile" } } */
--- a/src/gcc/testsuite/g++.dg/tree-prof/pr35545.C
+++ b/src/gcc/testsuite/g++.dg/tree-prof/pr35545.C
@@ -47,6 +47,4 @@ int main()
 
 }
 /* { dg-final-use { scan-ipa-dump "Indirect call -> direct call" "profile_estimate" } } */
-/* { dg-final-use { cleanup-ipa-dump "profile_estimate" } } */
 /* { dg-final-use { scan-tree-dump-not "OBJ_TYPE_REF" "optimized" } } */
-/* { dg-final-use { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/g++.dg/tree-prof/reorder.C
+++ b/src/gcc/testsuite/g++.dg/tree-prof/reorder.C
@@ -45,4 +45,3 @@ int main()
 }
 
 /* { dg-final-use { scan-ipa-dump-times "Indirect call -> direct call" 2 "profile" } } */
-/* { dg-final-use { cleanup-ipa-dump "profile" } } */
--- a/src/gcc/testsuite/g++.dg/tree-ssa/block1.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/block1.C
@@ -8,4 +8,3 @@ void bar (void)
 }
 
 // { dg-final { scan-tree-dump-times "\{" 1 "gimple" } }
-// { dg-final { cleanup-tree-dump "gimple" } }
--- a/src/gcc/testsuite/g++.dg/tree-ssa/calloc.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/calloc.C
@@ -47,4 +47,3 @@ void f (void *p, int n)
 /* { dg-final { scan-tree-dump-times "calloc" 1 "optimized" } } */
 /* { dg-final { scan-tree-dump-not "malloc" "optimized" } } */
 /* { dg-final { scan-tree-dump-not "memset" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/g++.dg/tree-ssa/copyprop-1.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/copyprop-1.C
@@ -28,4 +28,3 @@ int foo(Object&o)
 /* Remaining should be two loads.  */
 
 /* { dg-final { scan-tree-dump-times " = \[^\n\]*;" 2 "dce2" } } */
-/* { dg-final { cleanup-tree-dump "dce2" } } */
--- a/src/gcc/testsuite/g++.dg/tree-ssa/deleted-label1.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/deleted-label1.C
@@ -1,7 +1,6 @@
 // PR debug/58315
 // { dg-options "-O -g -fdump-tree-einline" }
 // { dg-final { scan-tree-dump-not "DEBUG <L0>" "einline" } }
-// { dg-final { cleanup-tree-dump "einline" } }
 
 // We used to emit useless NOTE_INSN_DELETED_DEBUG_LABELs for the
 // artificial cdtor_label.
--- a/src/gcc/testsuite/g++.dg/tree-ssa/ehcleanup-1.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/ehcleanup-1.C
@@ -28,4 +28,3 @@ t (void)
 // And as a result also contained control flow.
 // { dg-final { scan-tree-dump-times "Removing unreachable" 6 "ehcleanup1" } }
 //
-// { dg-final { cleanup-tree-dump "ehcleanup1" } }
--- a/src/gcc/testsuite/g++.dg/tree-ssa/empty-1.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/empty-1.C
@@ -11,4 +11,3 @@ S bar (const S &a)
 
 /* Test whether memcpy call has been optimized out.  */
 /* { dg-final { scan-tree-dump-times "memcpy" 0 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/g++.dg/tree-ssa/empty-2.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/empty-2.C
@@ -11,5 +11,3 @@ void t(void)
 // { dg-final { scan-tree-dump-not "fallible" "gimple" } }
 // Whole constructor should be optimized away.
 // { dg-final { scan-tree-dump-not "int" "optimized" } }
-// { dg-final { cleanup-tree-dump "gimple" } }
-// { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/g++.dg/tree-ssa/fold-compare.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/fold-compare.C
@@ -24,5 +24,4 @@ int f(const ExtentsBase &e1) {
 }
 
 /* { dg-final { scan-tree-dump-not "&my_extents" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
--- a/src/gcc/testsuite/g++.dg/tree-ssa/forwprop-switch.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/forwprop-switch.C
@@ -21,4 +21,3 @@ int Test(Scale s)
 
 // { dg-final { scan-tree-dump-not "\\\(int\\\)" "cddce1" } }
 // { dg-final { scan-tree-dump "switch \\\(s_.\\\(D\\\)\\\)" "cddce1" } }
-// { dg-final { cleanup-tree-dump "cddce1" } }
--- a/src/gcc/testsuite/g++.dg/tree-ssa/fwprop-align.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/fwprop-align.C
@@ -17,4 +17,3 @@ int main()
 
 /* We should eliminate the check if p points to a virtual function. */
 /* { dg-final { scan-tree-dump-times "& 1" 0 "forwprop2" } } */
-/* { dg-final { cleanup-tree-dump "forwprop2" } } */
--- a/src/gcc/testsuite/g++.dg/tree-ssa/inline-1.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/inline-1.C
@@ -33,4 +33,3 @@ int main(int argc, char **argv)
 
 /* { dg-final { scan-tree-dump-times "Inlining void inline_me\\(" 1 "einline"} } */
 /* { dg-final { scan-tree-dump-times "Inlining void inline_me_too\\(" 1 "einline"} } */
-/* { dg-final { cleanup-tree-dump "einline" } } */
--- a/src/gcc/testsuite/g++.dg/tree-ssa/inline-2.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/inline-2.C
@@ -33,4 +33,3 @@ int main(int argc, char **argv)
 
 /* { dg-final { scan-tree-dump-times "Inlining void inline_me\\(" 1 "einline"} } */
 /* { dg-final { scan-tree-dump-times "Inlining void inline_me_too\\(" 1 "einline"} } */
-/* { dg-final { cleanup-tree-dump "einline" } } */
--- a/src/gcc/testsuite/g++.dg/tree-ssa/inline-3.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/inline-3.C
@@ -26,4 +26,3 @@ int main(int argc, char **argv)
 
 /* { dg-final { scan-tree-dump-times "Inlining void inline_me\\(" 1 "einline"} } */
 /* { dg-final { scan-tree-dump-times "Inlining void inline_me_too\\(" 1 "einline"} } */
-/* { dg-final { cleanup-tree-dump "einline" } } */
--- a/src/gcc/testsuite/g++.dg/tree-ssa/ivopts-1.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/ivopts-1.C
@@ -15,4 +15,3 @@ void bar(void)
 /* { dg-final { scan-tree-dump-not "-&x" "ivopts" } } */
 /* { dg-final { scan-tree-dump-not "offset: (4294967292|0x0f+fc)" "ivopts" } } */
 /* { dg-final { scan-tree-dump-not "&x\\\[5\\\]" "ivopts" } } */
-/* { dg-final { cleanup-tree-dump "ivopts" } } */
--- a/src/gcc/testsuite/g++.dg/tree-ssa/ivopts-2.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/ivopts-2.C
@@ -8,4 +8,3 @@ void test (int *b, int *e, int stride)
   }
 
 /* { dg-final { scan-tree-dump-times "PHI <\[pb\]" 1 "ivopts"} } */
-/* { dg-final { cleanup-tree-dump "ivopts" } } */
--- a/src/gcc/testsuite/g++.dg/tree-ssa/ivopts-3.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/ivopts-3.C
@@ -73,4 +73,3 @@ int main ( int , char** ) {
 // Verify that on x86_64 and i?86 we use a single IV for the innermost loop
 
 // { dg-final { scan-tree-dump "Selected IV set for loop \[0-9\]* at \[^ \]*:64, 1 IVs" "ivopts" { target x86_64-*-* i?86-*-* } } }
-// { dg-final { cleanup-tree-dump "ivopts" } }
--- a/src/gcc/testsuite/g++.dg/tree-ssa/new1.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/new1.C
@@ -39,4 +39,3 @@ int main()
 }
 
 /* { dg-final { scan-tree-dump-not "= .* \\+ -" "forwprop1" } } */
-/* { dg-final { cleanup-tree-dump "forwprop1" } } */
--- a/src/gcc/testsuite/g++.dg/tree-ssa/nonzero-1.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/nonzero-1.C
@@ -9,4 +9,3 @@ int m()
   return q != 0;
 }
 /* { dg-final { scan-tree-dump "return 1" "ccp1"} } */
-/* { dg-final { cleanup-tree-dump "ccp1" } } */
--- a/src/gcc/testsuite/g++.dg/tree-ssa/nonzero-2.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/nonzero-2.C
@@ -13,4 +13,3 @@ int m()
   return q != 0;
 }
 /* { dg-final { scan-tree-dump "return 1" "ccp1"} } */
-/* { dg-final { cleanup-tree-dump "ccp1" } } */
--- a/src/gcc/testsuite/g++.dg/tree-ssa/nothrow-1.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/nothrow-1.C
@@ -19,4 +19,3 @@ void q()
 }
 /* We shouldnotice nothrow attribute.  */
 /* { dg-final { scan-tree-dump-times "exception" 0 "cfg"} } */
-/* { dg-final { cleanup-tree-dump "cfg" } } */
--- a/src/gcc/testsuite/g++.dg/tree-ssa/pointer-reference-alias.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/pointer-reference-alias.C
@@ -10,4 +10,3 @@ int f(int *a)
 
 /* There should be only one dereferencing of a. */
 /* { dg-final { scan-tree-dump-times "\\*a" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/g++.dg/tree-ssa/pr13954.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/pr13954.C
@@ -26,4 +26,3 @@ copystruct1 (teststruct param)
 
 /* There should be no reference to link_error. */
 /* { dg-final { scan-tree-dump-times "link_error" 0 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/g++.dg/tree-ssa/pr14703.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/pr14703.C
@@ -46,4 +46,3 @@ int main()
    ::std::cerr << "fibcst<90>() == " << fibconst<90>() << "\n";
 }
 // { dg-final { scan-tree-dump-not "fibconst" "optimized" } }
-// { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/g++.dg/tree-ssa/pr14814.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/pr14814.C
@@ -16,5 +16,4 @@ int foo(XX& r) {
 
 /* { dg-final { scan-tree-dump-times "&this" 0 "forwprop2" } } */
 /* { dg-final { scan-tree-dump-times "&r" 0 "forwprop2" } } */
-/* { dg-final { cleanup-tree-dump "forwprop2" } } */
 
--- a/src/gcc/testsuite/g++.dg/tree-ssa/pr15791-3.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/pr15791-3.C
@@ -10,4 +10,3 @@ int f(int i, unsigned j)
 }
 
 /* { dg-final { scan-tree-dump-times "i == j" 0 "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/g++.dg/tree-ssa/pr15791-4.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/pr15791-4.C
@@ -10,4 +10,3 @@ int f(int i, int j)
 }
 
 /* { dg-final { scan-tree-dump-times "i == j" 0 "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/g++.dg/tree-ssa/pr15791-5.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/pr15791-5.C
@@ -10,4 +10,3 @@ int foo(int i, int j)
 }
 
 /* { dg-final { scan-tree-dump-times "i == j" 1 "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/g++.dg/tree-ssa/pr18178.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/pr18178.C
@@ -44,4 +44,3 @@ void doit (array *a)
 /* VRP should remove all but 1 if() in the loop.  */
 
 /* { dg-final { scan-tree-dump-times "if " 1 "vrp1"} } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/g++.dg/tree-ssa/pr19476-1.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/pr19476-1.C
@@ -13,4 +13,3 @@ int g(){
 
 /* { dg-final { scan-tree-dump     "return 42" "ccp1" } } */
 /* { dg-final { scan-tree-dump-not "return 33" "ccp1" } } */
-/* { dg-final { cleanup-tree-dump "ccp1" } } */
--- a/src/gcc/testsuite/g++.dg/tree-ssa/pr19476-2.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/pr19476-2.C
@@ -14,4 +14,3 @@ int g(){
 
 /* { dg-final { scan-tree-dump     "return 42" "optimized" } } */
 /* { dg-final { scan-tree-dump-not "return 33" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/g++.dg/tree-ssa/pr19476-3.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/pr19476-3.C
@@ -8,4 +8,3 @@ int g(){
 }
 
 /* { dg-final { scan-tree-dump-not "return 42" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/g++.dg/tree-ssa/pr19476-4.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/pr19476-4.C
@@ -8,4 +8,3 @@ int g(){
 }
 
 /* { dg-final { scan-tree-dump-not "return 42" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/g++.dg/tree-ssa/pr19476-5.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/pr19476-5.C
@@ -8,4 +8,3 @@ int g(){
 }
 
 /* { dg-final { scan-tree-dump     "return 42" "ccp1" } } */
-/* { dg-final { cleanup-tree-dump "ccp1" } } */
--- a/src/gcc/testsuite/g++.dg/tree-ssa/pr19637.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/pr19637.C
@@ -30,4 +30,3 @@ int foo_void_offset(void)
 }
 
 /* { dg-final { scan-tree-dump-times "return 1;" 3 "dom1" } } */
-/* { dg-final { cleanup-tree-dump "dom1" } } */
--- a/src/gcc/testsuite/g++.dg/tree-ssa/pr19807.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/pr19807.C
@@ -24,4 +24,3 @@ void bar(int i)
 /* We can't get &a[i +- 1] in the final code and it is not clear we
    want this.  Instead we get to see &a[i] and pointer offsetting
    by 4 and -4U.  */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/g++.dg/tree-ssa/pr21463.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/pr21463.C
@@ -17,4 +17,3 @@ template struct foo_t<int>;
 
 /* { dg-final { scan-tree-dump-times "MIN_EXPR" 2 "phiopt1" } } */
 /* { dg-final { scan-tree-dump-times "MAX_EXPR" 2 "phiopt1" } } */
-/* { dg-final { cleanup-tree-dump "phiopt1" } } */
--- a/src/gcc/testsuite/g++.dg/tree-ssa/pr23948.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/pr23948.C
@@ -16,4 +16,3 @@ int make_scheduler_request(double a, double b)
 }
 
 /* { dg-final { scan-tree-dump-times " / " 1 "recip" } } */
-/* { dg-final { cleanup-tree-dump "recip" } } */
--- a/src/gcc/testsuite/g++.dg/tree-ssa/pr26406.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/pr26406.C
@@ -11,4 +11,3 @@ int *f(int *b)
 }
 
 /* { dg-final { scan-tree-dump-not "if" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/g++.dg/tree-ssa/pr27090.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/pr27090.C
@@ -18,4 +18,3 @@ int foo(Foo& f)
 }
 
 /* { dg-final { scan-tree-dump "f_..D.->x;" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/g++.dg/tree-ssa/pr30738.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/pr30738.C
@@ -14,4 +14,3 @@ int test_min_ref (int x, int y)
 }
 
 /* { dg-final { scan-tree-dump "MIN_EXPR" "phiopt1" } } */
-/* { dg-final { cleanup-tree-dump "phiopt1" } } */
--- a/src/gcc/testsuite/g++.dg/tree-ssa/pr31146-2.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/pr31146-2.C
@@ -21,4 +21,3 @@ double foo (void)
 }
 
 /* { dg-final { scan-tree-dump "Replaced .* != 0B. with .1" "forwprop1" } } */
-/* { dg-final { cleanup-tree-dump "forwprop1" } } */
--- a/src/gcc/testsuite/g++.dg/tree-ssa/pr31146.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/pr31146.C
@@ -13,4 +13,3 @@ void foo (int j)
 }
 
 /* { dg-final { scan-tree-dump "MEM\\\[.*&i\\\]\\\[j.*\\\] =.* 1;" "forwprop1" } } */
-/* { dg-final { cleanup-tree-dump "forwprop?" } } */
--- a/src/gcc/testsuite/g++.dg/tree-ssa/pr31307.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/pr31307.C
@@ -37,4 +37,3 @@ int test(unsigned char *d)
 }
 
 /* { dg-final { scan-tree-dump-not "r.dst" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/g++.dg/tree-ssa/pr33593.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/pr33593.C
@@ -16,4 +16,3 @@ main (void)
 // The expression 1 / 0 should not be propagated into the call to foo() if it
 // may trap.
 // { dg-final { scan-tree-dump-times "foo \\(1 \\/ 0\\)" 0 "optimized" } }
-// { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/g++.dg/tree-ssa/pr33604.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/pr33604.C
@@ -46,4 +46,3 @@ int main(int argc, char *argv[])
    after optimization.  */
 
 /* { dg-final { scan-tree-dump-times ".MEM_\[0-9\]*\\\(D\\\)" 2 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/g++.dg/tree-ssa/pr33615-2.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/pr33615-2.C
@@ -17,4 +17,3 @@ foo (double a, int x)
 // The expression 1.0 / 0.0 should not be treated as a loop invariant
 // if it may throw an exception.
 // { dg-final { scan-tree-dump-times "Replaced 1\\\.0e\\\+0 / 0\\\.0" 0 "pre" } }
-// { dg-final { cleanup-tree-dump "pre" } }
--- a/src/gcc/testsuite/g++.dg/tree-ssa/pr33615.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/pr33615.C
@@ -17,4 +17,3 @@ foo (double a, int x)
 // The expression 1.0 / 0.0 should not be treated as a loop invariant
 // if it may throw an exception.
 // { dg-final { scan-tree-dump-times "invariant up to" 0 "lim1" } }
-// { dg-final { cleanup-tree-dump "lim1" } }
--- a/src/gcc/testsuite/g++.dg/tree-ssa/pr40874.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/pr40874.C
@@ -22,4 +22,3 @@ int main(int argc, char* argv[])
 }
 
 // { dg-final { scan-tree-dump "return 0" "optimized" } }
-// { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/g++.dg/tree-ssa/pr41186.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/pr41186.C
@@ -32,4 +32,3 @@ int main()
 /* { dg-final { scan-tree-dump "Replaced b1.b with 1" "fre1" } } */
 /* { dg-final { scan-tree-dump "Replaced b1.D.\[0-9\]*.i with 0" "fre1" } } */
 /* { dg-final { scan-tree-dump "Replaced b1.D.\[0-9\]*.f with 1" "fre1" } } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/g++.dg/tree-ssa/pr41428.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/pr41428.C
@@ -12,4 +12,3 @@ int foo(void)
 }
 
 /* { dg-final { scan-tree-dump "Folded into: if \\\(1 != 0\\\)" "ccp1" } } */
-/* { dg-final { cleanup-tree-dump "ccp1" } } */
--- a/src/gcc/testsuite/g++.dg/tree-ssa/pr43411.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/pr43411.C
@@ -26,4 +26,3 @@ void testInlinePsub() {
 }
 
 // { dg-final { scan-tree-dump-not "function_to_inline" "release_ssa" { xfail *-*-* } } }
-// { dg-final { cleanup-tree-dump "release_ssa" } }
--- a/src/gcc/testsuite/g++.dg/tree-ssa/pr44706.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/pr44706.C
@@ -43,4 +43,3 @@ XMLExcepts::AttrList_BadIndex, getMemoryManager());
 /* Mistake in branch prediction caused us to split away real body of the function keeping
    only throw () invokation.   This is bad idea.  */
 /* { dg-final { scan-tree-dump-not "Splitting function" "fnsplit"} } */
-/* { dg-final { cleanup-tree-dump "fnsplit" } } */
--- a/src/gcc/testsuite/g++.dg/tree-ssa/pr45453.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/pr45453.C
@@ -16,4 +16,3 @@ B ()
 }
 /* We should inline foo and devirtualize call to foo in the inlined version.  */
 // { dg-final { scan-tree-dump-times "OBJ_TYPE_REF" 1 "optimized" } }
-// { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/g++.dg/tree-ssa/pr45605.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/pr45605.C
@@ -34,4 +34,3 @@ int main() {
 
 /* We should devirtualize call to D::Run */
 /* { dg-final { scan-tree-dump-times "D::Run \\(" 1 "fre1" } } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/g++.dg/tree-ssa/pr46228.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/pr46228.C
@@ -20,4 +20,3 @@ int main()
 
 // This function is small enough to be inlined even at -Os.
 // { dg-final { scan-tree-dump-not "_ZNSt8_Rb_treeIiiSt9_IdentityIiESt4lessIiESaIiEED2Ev" "optimized" } }
-// { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/g++.dg/tree-ssa/pr49911.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/pr49911.C
@@ -38,4 +38,3 @@ void jsop_setelem(bool y, int z) {
 }
 
 /* { dg-final { scan-tree-dump-times "Folding predicate.*45" 0 "vrp2"} } */
-/* { dg-final { cleanup-tree-dump "vrp2" } } */
--- a/src/gcc/testsuite/g++.dg/tree-ssa/pr53844.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/pr53844.C
@@ -75,4 +75,3 @@ void test(const Vector<>& in, Vector<>& out, int i)
 // dead stores to unused temporaries should have been removed.
 
 // { dg-final { scan-tree-dump-times "VDEF" 1 "optimized" } }
-// { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/g++.dg/tree-ssa/pr57380.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/pr57380.C
@@ -19,4 +19,3 @@ int f(my_array a, my_array b) {
 }
 
 /* { dg-final { scan-tree-dump "MAX_EXPR" "phiopt1" } } */
-/* { dg-final { cleanup-tree-dump "phiopt1" } } */
--- a/src/gcc/testsuite/g++.dg/tree-ssa/pr58404.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/pr58404.C
@@ -17,4 +17,3 @@ foo ()
 // We should propagate the reference into both memory accesses
 // during the first forwprop pass
 // { dg-final { scan-tree-dump-times "= &a" 0 "cddce1" } }
-// { dg-final { cleanup-tree-dump "cddce1" } }
--- a/src/gcc/testsuite/g++.dg/tree-ssa/pr61009.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/pr61009.C
@@ -50,4 +50,3 @@ bool  Test(void) {
 // there should be a single == 0 comparison in the dump file.
 
 // { dg-final { scan-tree-dump-times "== 0" 1 "dom1" } }
-// { dg-final { cleanup-tree-dump "dom1" } }
--- a/src/gcc/testsuite/g++.dg/tree-ssa/pr61034.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/pr61034.C
@@ -44,4 +44,3 @@ bool f(I a, I b, I c, I d) {
 // { dg-final { scan-tree-dump-times ";; Function" 1 "fre2" } }
 // { dg-final { scan-tree-dump-times "free" 19 "fre2" } }
 // { dg-final { scan-tree-dump-times "unreachable" 11 "fre2" } }
-// { dg-final { cleanup-tree-dump "fre2" } }
--- /dev/null
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/pr66726.c
@@ -0,0 +1,36 @@
+
+/* { dg-do run } */
+/* { dg-options "-O2" } */
+
+/* Execution test for converting VIEW_CONVERT_EXPR.  */
+
+struct cpp_num {
+  bool f;
+};
+
+extern cpp_num  __attribute__((noinline))
+foo (cpp_num lhs,
+     cpp_num rhs)
+{
+  lhs.f = lhs.f || rhs.f;
+  return lhs;
+}
+
+cpp_num lhs, rhs, r;
+
+int main ()
+{
+
+  lhs.f = false;
+  rhs.f = false;
+  r = foo (lhs, rhs);
+  if (r.f)
+    __builtin_abort ();
+
+
+  lhs.f = false;
+  rhs.f = true;
+  r = foo (lhs, rhs);
+  if (!r.f)
+    __builtin_abort ();
+}
--- a/src/gcc/testsuite/g++.dg/tree-ssa/pr8781.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/pr8781.C
@@ -25,4 +25,3 @@ int x()
 /* We should optimize this to a direct call.  */
 
 /* { dg-final { scan-tree-dump-times "= f \\(\\);" 1 "fre1" } } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/g++.dg/tree-ssa/ptrmemfield.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/ptrmemfield.C
@@ -23,5 +23,4 @@ int h(void)
 /* { dg-final { scan-tree-dump-times "offset_type" 0 "optimized"} } */
 // And we should optimized this code to just return 0
 /* { dg-final { scan-tree-dump-times "return 0" 1 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
--- a/src/gcc/testsuite/g++.dg/tree-ssa/restrict1.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/restrict1.C
@@ -17,4 +17,3 @@ void bar(Foo f, int * __restrict__ q)
 }
 
 /* { dg-final { scan-tree-dump "Executing store motion" "lim1" } } */
-/* { dg-final { cleanup-tree-dump "lim1" } } */
--- a/src/gcc/testsuite/g++.dg/tree-ssa/restrict2.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/restrict2.C
@@ -59,4 +59,3 @@ f6 (S *x, S *y)
   return x->p[0];
 }
 
-// { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/g++.dg/tree-ssa/ssa-cast-1.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/ssa-cast-1.C
@@ -9,4 +9,3 @@ int &f(int *a)
 /* There should be no cast as pointer and references are
    considered the same type. */
 /* { dg-final { scan-tree-dump-times "\\(int &\\)" 0 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/g++.dg/tree-ssa/ssa-dom.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/ssa-dom.C
@@ -100,5 +100,4 @@ gimple_return_set_retval (gimple gs, tree retval)
   gimple_set_op (gs, 0, retval);
 }
 /* { dg-final { scan-tree-dump-times "gss_for_code_.10." 1 "dom1"} } */
-/* { dg-final { cleanup-tree-dump "dom1" } } */
 
--- a/src/gcc/testsuite/g++.dg/tree-ssa/ssa-sra-1.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/ssa-sra-1.C
@@ -58,4 +58,3 @@ void temp()
 /* We should have removed the casts from pointers to references and caused SRA to happen.  */
 
 /* { dg-final { scan-tree-dump-times "link_error" 0 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/g++.dg/tree-ssa/ssa-sra-2.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/ssa-sra-2.C
@@ -49,4 +49,3 @@ void test()
 
 /* We should have removed the casts from pointers to references and caused SRA to happen.  */
 /* { dg-final { scan-tree-dump-times "link_error" 0 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/g++.dg/tree-ssa/ssa-store-ccp-1.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/ssa-store-ccp-1.C
@@ -16,4 +16,3 @@ int f(void)
 /* There should be a reference to conststaticvariable since it may
    be overriden at link time.  */
 /* { dg-final { scan-tree-dump-times "conststaticvariable" 1 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/g++.dg/tree-ssa/stabilize1.C
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/stabilize1.C
@@ -1,7 +1,6 @@
 // PR c++/53356
 // { dg-options "-fdump-tree-gimple" }
 // { dg-final { scan-tree-dump-not "= 0" "gimple" } }
-// { dg-final { cleanup-tree-dump "gimple" } }
 
 class A {};
 
--- a/src/gcc/testsuite/g++.dg/ubsan/null-4.C
+++ b/src/gcc/testsuite/g++.dg/ubsan/null-4.C
@@ -17,4 +17,3 @@ main (void)
 
 // { dg-output "reference binding to null pointer of type 'int'(\n|\r\n|\r)" }
 // { dg-final { scan-tree-dump-times "Optimizing" 4 "sanopt"} }
-// { dg-final { cleanup-tree-dump "sanopt" } }
--- a/src/gcc/testsuite/g++.dg/ubsan/null-5.C
+++ b/src/gcc/testsuite/g++.dg/ubsan/null-5.C
@@ -16,4 +16,3 @@ main (void)
 }
 
 // { dg-final { scan-tree-dump-times "Optimizing" 4 "sanopt"} }
-// { dg-final { cleanup-tree-dump "sanopt" } }
--- a/src/gcc/testsuite/g++.dg/ubsan/vptr-6.C
+++ b/src/gcc/testsuite/g++.dg/ubsan/vptr-6.C
@@ -29,4 +29,3 @@ f4 (S &p, S &q)
 }
 
 // { dg-final { scan-tree-dump-times "__ubsan_handle_dynamic_type_cache_miss" 5 "optimized" } }
-// { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/g++.dg/ubsan/vptr-7.C
+++ b/src/gcc/testsuite/g++.dg/ubsan/vptr-7.C
@@ -23,4 +23,3 @@ f3 (S *p)
 }
 
 // { dg-final { scan-tree-dump-times "__ubsan_handle_dynamic_type_cache_miss" 0 "optimized" } }
-// { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/g++.dg/vect/param-max-aliased-pr26197.cc
+++ b/src/gcc/testsuite/g++.dg/vect/param-max-aliased-pr26197.cc
@@ -21,4 +21,3 @@ void bar()
   g(&b);
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/g++.dg/vect/pr19951.cc
+++ b/src/gcc/testsuite/g++.dg/vect/pr19951.cc
@@ -16,4 +16,3 @@ void bar()
         foo();
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/g++.dg/vect/pr21218.cc
+++ b/src/gcc/testsuite/g++.dg/vect/pr21218.cc
@@ -14,5 +14,4 @@ void bar(B& b)
         b.d[i] = b.foo(i);
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/g++.dg/vect/pr21734_1.cc
+++ b/src/gcc/testsuite/g++.dg/vect/pr21734_1.cc
@@ -17,4 +17,3 @@ void foo(B &b)
     b[i] = 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/g++.dg/vect/pr21734_2.cc
+++ b/src/gcc/testsuite/g++.dg/vect/pr21734_2.cc
@@ -13,4 +13,3 @@ void foo(A a1, A &a2)
     a2.a[i]=0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/g++.dg/vect/pr22543.cc
+++ b/src/gcc/testsuite/g++.dg/vect/pr22543.cc
@@ -35,4 +35,3 @@ C::C()
     int j = B().foo();
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/g++.dg/vect/pr33426-ivdep-2.cc
+++ b/src/gcc/testsuite/g++.dg/vect/pr33426-ivdep-2.cc
@@ -30,9 +30,6 @@ void bar(int n, int *a, int *b, int *c) {
 
 /* { dg-message "loop vectorized" "" { target *-*-* } 0 } */
 /* { dg-bogus " version\[^\n\r]* alias" "" { target *-*-* } 0 } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
 /* { dg-final { scan-tree-dump-times "ANNOTATE_EXPR " 2 "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
 /* { dg-final { scan-tree-dump-times "ANNOTATE " 2 "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/g++.dg/vect/pr33426-ivdep-3.cc
+++ b/src/gcc/testsuite/g++.dg/vect/pr33426-ivdep-3.cc
@@ -17,9 +17,6 @@ void foo(int *a) {
 
 /* { dg-message "loop vectorized" "" { target *-*-* } 0 } */
 /* { dg-bogus " version\[^\n\r]* alias" "" { target *-*-* } 0 } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
 /* { dg-final { scan-tree-dump-times "ANNOTATE_EXPR " 1 "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
 /* { dg-final { scan-tree-dump-times "ANNOTATE " 1 "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/g++.dg/vect/pr33426-ivdep-4.cc
+++ b/src/gcc/testsuite/g++.dg/vect/pr33426-ivdep-4.cc
@@ -22,9 +22,6 @@ void foo(std::vector<int> *ar, int *b) {
 
 /* { dg-message "loop vectorized" "" { target *-*-* } 0 } */
 /* FIXME:     dg-bogus " version\[^\n\r]* alias" "" { target *-*-* } 0  */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
 /* { dg-final { scan-tree-dump-times "ANNOTATE_EXPR " 1 "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
 /* { dg-final { scan-tree-dump-times "ANNOTATE " 1 "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/g++.dg/vect/pr33426-ivdep.cc
+++ b/src/gcc/testsuite/g++.dg/vect/pr33426-ivdep.cc
@@ -15,4 +15,3 @@ void foo(int n, int *a, int *b, int *c, int *d, int *e) {
 
 /* { dg-message "loop vectorized" "" { target *-*-* } 0 } */
 /* { dg-bogus " version\[^\n\r]* alias" "" { target *-*-* } 0 } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/g++.dg/vect/pr33834_1.cc
+++ b/src/gcc/testsuite/g++.dg/vect/pr33834_1.cc
@@ -47,4 +47,3 @@ internals::compute_s (void)
 {
   bend.compute_s ();
 }
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/g++.dg/vect/pr33834_2.cc
+++ b/src/gcc/testsuite/g++.dg/vect/pr33834_2.cc
@@ -29,4 +29,3 @@ LoadPAT (char *filename)
   }
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/g++.dg/vect/pr33835.cc
+++ b/src/gcc/testsuite/g++.dg/vect/pr33835.cc
@@ -47,4 +47,3 @@ internals::compute_s (void)
   bend.compute_s ();
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/g++.dg/vect/pr33860.cc
+++ b/src/gcc/testsuite/g++.dg/vect/pr33860.cc
@@ -22,4 +22,3 @@ Matrix Matrix::operator* (const Matrix matrix) const
   return ret;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/g++.dg/vect/pr33860a.cc
+++ b/src/gcc/testsuite/g++.dg/vect/pr33860a.cc
@@ -24,4 +24,3 @@ Matrix Matrix::operator* (const Matrix matrix) const
   return ret;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/g++.dg/vect/pr36648.cc
+++ b/src/gcc/testsuite/g++.dg/vect/pr36648.cc
@@ -19,6 +19,5 @@ int main() { }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { !  vect_no_align } } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect" { target { ! vect_no_align } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
 
--- a/src/gcc/testsuite/g++.dg/vect/pr37143.C
+++ b/src/gcc/testsuite/g++.dg/vect/pr37143.C
@@ -18,4 +18,3 @@ f(int NumberOfSideSets, int *ssNumDFperSide, float *ssDF)
     newssDF[nextDF++] = ssDF[i];
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/g++.dg/vect/pr37174.cc
+++ b/src/gcc/testsuite/g++.dg/vect/pr37174.cc
@@ -19,5 +19,4 @@ Bar::Bar() {
         }
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/g++.dg/vect/pr43771.cc
+++ b/src/gcc/testsuite/g++.dg/vect/pr43771.cc
@@ -11,4 +11,3 @@ void KWayNodeRefine__(int nparts, int *gpwgts, int *badminpwgt, int
    }
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/g++.dg/vect/pr44861.cc
+++ b/src/gcc/testsuite/g++.dg/vect/pr44861.cc
@@ -31,4 +31,3 @@ void g() {
     new Bar(*foo, foo);
 }
 
-// { dg-final { cleanup-tree-dump "vect" } }
--- a/src/gcc/testsuite/g++.dg/vect/pr45470-a.cc
+++ b/src/gcc/testsuite/g++.dg/vect/pr45470-a.cc
@@ -21,4 +21,3 @@ B::B ()
 {
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/g++.dg/vect/pr45470-b.cc
+++ b/src/gcc/testsuite/g++.dg/vect/pr45470-b.cc
@@ -49,4 +49,3 @@ struct LoadGraph
 LoadGraph::LoadGraph (int)
 {}
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/g++.dg/vect/pr50698.cc
+++ b/src/gcc/testsuite/g++.dg/vect/pr50698.cc
@@ -24,4 +24,3 @@ void sumS() {
 }
 
 // { dg-final { scan-tree-dump-not "run-time aliasing" "vect" } }
-// { dg-final { cleanup-tree-dump "vect" } }
--- a/src/gcc/testsuite/g++.dg/vect/pr51485.cc
+++ b/src/gcc/testsuite/g++.dg/vect/pr51485.cc
@@ -11,4 +11,3 @@ foo (unsigned int x, double *y, A *z)
     y[i] = bar (z[i]);
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/g++.dg/vect/pr58513.cc
+++ b/src/gcc/testsuite/g++.dg/vect/pr58513.cc
@@ -10,4 +10,3 @@ void foo(int* a)
 }
 
 // { dg-final { scan-tree-dump "vectorized 1 loops" "vect" } }
-// { dg-final { cleanup-tree-dump "vect" } }
--- a/src/gcc/testsuite/g++.dg/vect/pr60000.cc
+++ b/src/gcc/testsuite/g++.dg/vect/pr60000.cc
@@ -10,4 +10,3 @@ void foo (bool* a, int* b)
     }
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/g++.dg/vect/pr60023.cc
+++ b/src/gcc/testsuite/g++.dg/vect/pr60023.cc
@@ -77,4 +77,3 @@ f8 (int *p, int *q)
     p[i] = q[i] + 1;
 }
 
-// { dg-final { cleanup-tree-dump "vect" } }
--- a/src/gcc/testsuite/g++.dg/vect/pr60559.cc
+++ b/src/gcc/testsuite/g++.dg/vect/pr60559.cc
@@ -5,4 +5,3 @@
 
 #include "pr60023.cc"
 
-// { dg-final { cleanup-tree-dump "vect" } }
--- a/src/gcc/testsuite/g++.dg/vect/pr60729.cc
+++ b/src/gcc/testsuite/g++.dg/vect/pr60729.cc
@@ -7,4 +7,3 @@ void doSomething(int dim, double *Y, double *A)
     Y[k] += __builtin_fabs (A[k]);
 }
 
-// { dg-final { cleanup-tree-dump "vect" } }
--- a/src/gcc/testsuite/g++.dg/vect/pr60836.cc
+++ b/src/gcc/testsuite/g++.dg/vect/pr60836.cc
@@ -36,4 +36,3 @@ norm ()
   f = 0;
 }
 
-// { dg-final { cleanup-tree-dump "vect" } }
--- a/src/gcc/testsuite/g++.dg/vect/pr64410.cc
+++ b/src/gcc/testsuite/g++.dg/vect/pr64410.cc
@@ -50,4 +50,3 @@ main(int argc, char** argv)
 }
 
 // { dg-final { scan-tree-dump "vectorized 1 loops in function" "vect" } }
-// { dg-final { cleanup-tree-dump "vect" } }
--- a/src/gcc/testsuite/g++.dg/vect/slp-pr50413.cc
+++ b/src/gcc/testsuite/g++.dg/vect/slp-pr50413.cc
@@ -161,5 +161,4 @@ void shift(unsigned char t)
 }
 
 /* { dg-final { scan-tree-dump-times "basic block vectorized" 0 "slp2" } } */
-/* { dg-final { cleanup-tree-dump "slp2" } } */
 
--- a/src/gcc/testsuite/g++.dg/vect/slp-pr50819.cc
+++ b/src/gcc/testsuite/g++.dg/vect/slp-pr50819.cc
@@ -50,4 +50,3 @@ const & v2) {
 }
 
 /* { dg-final { scan-tree-dump-times "basic block vectorized" 2 "slp2" } } */
-/* { dg-final { cleanup-tree-dump "slp2" } } */
--- a/src/gcc/testsuite/g++.dg/vect/slp-pr56812.cc
+++ b/src/gcc/testsuite/g++.dg/vect/slp-pr56812.cc
@@ -18,4 +18,3 @@ void mydata::Set (float x)
 }
 
 /* { dg-final { scan-tree-dump-times "basic block vectorized" 1 "slp1" } } */
-/* { dg-final { cleanup-tree-dump "slp1" } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.c-torture/compile/pr66168.c
@@ -0,0 +1,15 @@
+int a, b;
+
+void
+fn1 ()
+{
+  for (;;)
+    {
+      for (b = 0; b < 3; b++)
+	{
+	  char e[2];
+	  char f = e[1];
+	  a ^= f ? 1 / f : 0;
+	}
+    }
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.c-torture/execute/pr65648.c
@@ -0,0 +1,34 @@
+/* PR target/65648 */
+
+int a = 0, *b = 0, c = 0;
+static int d = 0;
+short e = 1;
+static long long f = 0;
+long long *i = &f;
+unsigned char j = 0;
+
+__attribute__((noinline, noclone)) void
+foo (int x, int *y)
+{
+  asm volatile ("" : : "r" (x), "r" (y) : "memory");
+}
+
+__attribute__((noinline, noclone)) void
+bar (const char *x, long long y)
+{
+  asm volatile ("" : : "r" (x), "r" (&y) : "memory");
+  if (y != 0)
+    __builtin_abort ();
+}
+
+int
+main ()
+{
+  int k = 0;
+  b = &k;
+  j = (!a) - (c <= e);
+  *i = j;
+  foo (a, &k);
+  bar ("", f);
+  return 0;
+}
--- a/src/gcc/testsuite/gcc.dg/20050811-1.c
+++ b/src/gcc/testsuite/gcc.dg/20050811-1.c
@@ -17,4 +17,3 @@ int bar (int x)
     return foo ();
 }
 
-// { dg-final { cleanup-rtl-dump "*" } }
--- a/src/gcc/testsuite/gcc.dg/20050811-2.c
+++ b/src/gcc/testsuite/gcc.dg/20050811-2.c
@@ -17,4 +17,3 @@ int bar (int x)
     return foo ();
 }
 
-/* { dg-final { cleanup-rtl-dump "postreload*" } } */
--- a/src/gcc/testsuite/gcc.dg/20101013-1.c
+++ b/src/gcc/testsuite/gcc.dg/20101013-1.c
@@ -8,4 +8,3 @@ int foo(int a)
 }
 
 /* { dg-final { scan-tree-dump ">>" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/20111227-2.c
+++ b/src/gcc/testsuite/gcc.dg/20111227-2.c
@@ -43,4 +43,3 @@ int main(void)
   return 0;
 }
 /* { dg-final { scan-rtl-dump "Elimination opportunities = 3 realized = 3" "ree" } }  */
-/* { dg-final { cleanup-rtl-dump "ree" } }  */
--- a/src/gcc/testsuite/gcc.dg/20111227-3.c
+++ b/src/gcc/testsuite/gcc.dg/20111227-3.c
@@ -43,4 +43,3 @@ int main(void)
   return 0;
 }
 /* { dg-final { scan-rtl-dump "Elimination opportunities = 3 realized = 3" "ree" } }  */
-/* { dg-final { cleanup-rtl-dump "ree" } }  */
--- a/src/gcc/testsuite/gcc.dg/20141029-1.c
+++ b/src/gcc/testsuite/gcc.dg/20141029-1.c
@@ -25,4 +25,3 @@ foo()
     }
 }
 /* { dg-final { scan-rtl-dump-times "mem/v(/.)*:HI" 4 "final" } } */
-/* { dg-final { cleanup-rtl-dump "final" } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.dg/Wcxx-compat-22.c
@@ -0,0 +1,8 @@
+/* { dg-do compile } */
+/* { dg-options "-Wc++-compat" } */
+struct A {}; /* { dg-warning "empty struct has size 0 in C" } */
+union B {}; /* { dg-warning "empty union has size 0 in C" } */
+struct C { struct D {}; int x; }; /* { dg-warning "empty struct has size 0 in C|declaration does not declare anything" } */
+struct E { union F {}; int x; }; /* { dg-warning "empty union has size 0 in C|declaration does not declare anything" } */
+union G { union H {}; int x; }; /* { dg-warning "empty union has size 0 in C|declaration does not declare anything" } */
+union I { struct J {}; int x; }; /* { dg-warning "empty struct has size 0 in C|declaration does not declare anything" } */
--- a/src/gcc/testsuite/gcc.dg/alias-10.c
+++ b/src/gcc/testsuite/gcc.dg/alias-10.c
@@ -29,4 +29,3 @@ void foo (bitmap head, bitmap_element *elt)
 
 
 /* { dg-final { scan-tree-dump-times "Unswitching" 1 "unswitch"} } */
-/* { dg-final { cleanup-tree-dump "unswitch" } } */
--- a/src/gcc/testsuite/gcc.dg/asr_div1.c
+++ b/src/gcc/testsuite/gcc.dg/asr_div1.c
@@ -53,4 +53,3 @@ main ()
 
 /* { dg-final { scan-rtl-dump "\\(const_int 36 " "combine" { target aarch64*-*-* } } } */
 
-/* { dg-final { cleanup-rtl-dump "combine" } } */
--- a/src/gcc/testsuite/gcc.dg/atomic-op-optimize.c
+++ b/src/gcc/testsuite/gcc.dg/atomic-op-optimize.c
@@ -2,8 +2,8 @@
    Test that it at happens on x86 by making sure there are 2 xchg's and no
    compare_exchange loop.  */
 
-/* { dg-require-effective-target sync_int_long } */
 /* { dg-do compile { target { i?86-*-* x86_64-*-* } } } */
+/* { dg-require-effective-target sync_int_long } */
 /* { dg-final { scan-assembler-times "cmpxchg" 0 } } */
 /* { dg-final { scan-assembler-times "xchg" 2 } } */
 
--- a/src/gcc/testsuite/gcc.dg/attr-alloc_align-3.c
+++ b/src/gcc/testsuite/gcc.dg/attr-alloc_align-3.c
@@ -53,4 +53,3 @@ test6 (int len, int align)
 }
 
 /* { dg-final { scan-tree-dump-times "return 0" 4 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/attr-assume_aligned-3.c
+++ b/src/gcc/testsuite/gcc.dg/attr-assume_aligned-3.c
@@ -21,4 +21,3 @@ test2 (int len)
 }
 
 /* { dg-final { scan-tree-dump-times "return 0" 2 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/autopar/outer-1.c
+++ b/src/gcc/testsuite/gcc.dg/autopar/outer-1.c
@@ -29,5 +29,3 @@ int main(void)
 /* Check that outer loop is parallelized.  */
 /* { dg-final { scan-tree-dump-times "parallelizing outer loop" 1 "parloops" } } */
 /* { dg-final { scan-tree-dump-times "loopfn" 4 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "parloops" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/autopar/outer-2.c
+++ b/src/gcc/testsuite/gcc.dg/autopar/outer-2.c
@@ -29,5 +29,3 @@ int main(void)
 
 /* { dg-final { scan-tree-dump-times "parallelizing outer loop" 1 "parloops" } } */
 /* { dg-final { scan-tree-dump-times "loopfn" 4 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "parloops" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/autopar/outer-3.c
+++ b/src/gcc/testsuite/gcc.dg/autopar/outer-3.c
@@ -29,5 +29,3 @@ int main(void)
 /* Check that outer loop is parallelized.  */
 /* { dg-final { scan-tree-dump-times "parallelizing outer loop" 1 "parloops" } } */
 /* { dg-final { scan-tree-dump-times "loopfn" 4 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "parloops" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/autopar/outer-4.c
+++ b/src/gcc/testsuite/gcc.dg/autopar/outer-4.c
@@ -33,5 +33,3 @@ int main(void)
 
 /* { dg-final { scan-tree-dump-times "parallelizing outer loop" 1 "parloops" { xfail *-*-* } } } */
 /* { dg-final { scan-tree-dump-times "loopfn" 4 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "parloops" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/autopar/outer-5.c
+++ b/src/gcc/testsuite/gcc.dg/autopar/outer-5.c
@@ -46,5 +46,3 @@ int main(void)
 
 /* { dg-final { scan-tree-dump-times "parallelizing outer loop" 1 "parloops" { xfail *-*-* } } } */
 /* { dg-final { scan-tree-dump-times "loopfn" 4 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "parloops" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/autopar/outer-6.c
+++ b/src/gcc/testsuite/gcc.dg/autopar/outer-6.c
@@ -47,5 +47,3 @@ int main(void)
 /* { dg-final { scan-tree-dump-times "parallelizing outer loop" 1 "parloops" } } */
 /* { dg-final { scan-tree-dump-times "parallelizing inner loop" 0 "parloops" } } */
 /* { dg-final { scan-tree-dump-times "loopfn" 4 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "parloops" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/autopar/parallelization-1.c
+++ b/src/gcc/testsuite/gcc.dg/autopar/parallelization-1.c
@@ -29,5 +29,3 @@ int main(void)
 
 /* { dg-final { scan-tree-dump-times "SUCCESS: may be parallelized" 1 "parloops" } } */
 /* { dg-final { scan-tree-dump-times "loopfn" 4 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "parloops" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/autopar/pr39500-1.c
+++ b/src/gcc/testsuite/gcc.dg/autopar/pr39500-1.c
@@ -25,4 +25,3 @@ int main (void)
 /* Check that the first loop in parloop got parallelized.  */
 
 /* { dg-final { scan-tree-dump-times "SUCCESS: may be parallelized" 1 "parloops" } } */
-/* { dg-final { cleanup-tree-dump "parloops" } } */
--- a/src/gcc/testsuite/gcc.dg/autopar/pr39500-2.c
+++ b/src/gcc/testsuite/gcc.dg/autopar/pr39500-2.c
@@ -17,4 +17,3 @@ int main (void)
 /* This loop cannot be parallelized due to a dependence.  */
 
 /* { dg-final { scan-tree-dump-times "SUCCESS: may be parallelized" 0 "parloops" } } */
-/* { dg-final { cleanup-tree-dump "parloops" } } */
--- a/src/gcc/testsuite/gcc.dg/autopar/pr46194.c
+++ b/src/gcc/testsuite/gcc.dg/autopar/pr46194.c
@@ -21,4 +21,3 @@ int foo (void)
 /* This loop cannot be parallelized due to a dependence.  */
 
 /* { dg-final { scan-tree-dump-times "SUCCESS: may be parallelized" 0 "parloops" } } */
-/* { dg-final { cleanup-tree-dump "parloops" } } */
--- a/src/gcc/testsuite/gcc.dg/autopar/pr49580.c
+++ b/src/gcc/testsuite/gcc.dg/autopar/pr49580.c
@@ -34,5 +34,4 @@ int main (void)
 
 
 /* { dg-final { scan-tree-dump-times "SUCCESS: may be parallelized" 1 "parloops" } } */
-/* { dg-final { cleanup-tree-dump "parloops" } } */
 
--- a/src/gcc/testsuite/gcc.dg/autopar/pr49960-1.c
+++ b/src/gcc/testsuite/gcc.dg/autopar/pr49960-1.c
@@ -32,5 +32,3 @@ int main()
 
 /* { dg-final { scan-tree-dump-times "SUCCESS: may be parallelized" 0 "parloops" } } */
 /* { dg-final { scan-tree-dump-times "loopfn" 0 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "parloops" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/autopar/pr49960.c
+++ b/src/gcc/testsuite/gcc.dg/autopar/pr49960.c
@@ -52,5 +52,3 @@ void main ()
 
 /* { dg-final { scan-tree-dump-times "SUCCESS: may be parallelized" 0 "parloops" } } */
 /* { dg-final { scan-tree-dump-times "loopfn" 0 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "parloops" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/autopar/reduc-1.c
+++ b/src/gcc/testsuite/gcc.dg/autopar/reduc-1.c
@@ -68,6 +68,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "Detected reduction" 3 "parloops" } } */
 /* { dg-final { scan-tree-dump-times "SUCCESS: may be parallelized" 4 "parloops" } } */
-/* { dg-final { cleanup-tree-dump "parloops" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
--- a/src/gcc/testsuite/gcc.dg/autopar/reduc-1char.c
+++ b/src/gcc/testsuite/gcc.dg/autopar/reduc-1char.c
@@ -62,6 +62,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "Detected reduction" 3 "parloops" } } */
 /* { dg-final { scan-tree-dump-times "SUCCESS: may be parallelized" 4 "parloops" } } */
-/* { dg-final { cleanup-tree-dump "parloops" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
--- a/src/gcc/testsuite/gcc.dg/autopar/reduc-1short.c
+++ b/src/gcc/testsuite/gcc.dg/autopar/reduc-1short.c
@@ -61,6 +61,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "Detected reduction" 3 "parloops" } } */
 /* { dg-final { scan-tree-dump-times "SUCCESS: may be parallelized" 4 "parloops" } } */
-/* { dg-final { cleanup-tree-dump "parloops" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
--- a/src/gcc/testsuite/gcc.dg/autopar/reduc-2.c
+++ b/src/gcc/testsuite/gcc.dg/autopar/reduc-2.c
@@ -65,6 +65,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "Detected reduction" 3 "parloops" } } */
 /* { dg-final { scan-tree-dump-times "SUCCESS: may be parallelized" 4 "parloops" } } */
-/* { dg-final { cleanup-tree-dump "parloops" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
--- a/src/gcc/testsuite/gcc.dg/autopar/reduc-2char.c
+++ b/src/gcc/testsuite/gcc.dg/autopar/reduc-2char.c
@@ -62,7 +62,5 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "Detected reduction" 2 "parloops" } } */
 /* { dg-final { scan-tree-dump-times "SUCCESS: may be parallelized" 3 "parloops" } } */
-/* { dg-final { cleanup-tree-dump "parloops" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
 
--- a/src/gcc/testsuite/gcc.dg/autopar/reduc-2short.c
+++ b/src/gcc/testsuite/gcc.dg/autopar/reduc-2short.c
@@ -61,6 +61,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "Detected reduction" 2 "parloops" } } */
 /* { dg-final { scan-tree-dump-times "SUCCESS: may be parallelized" 3 "parloops" } } */
-/* { dg-final { cleanup-tree-dump "parloops" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
--- a/src/gcc/testsuite/gcc.dg/autopar/reduc-3.c
+++ b/src/gcc/testsuite/gcc.dg/autopar/reduc-3.c
@@ -52,6 +52,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "Detected reduction" 1 "parloops" } } */
 /* { dg-final { scan-tree-dump-times "SUCCESS: may be parallelized" 2 "parloops" } } */
-/* { dg-final { cleanup-tree-dump "parloops" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
--- a/src/gcc/testsuite/gcc.dg/autopar/reduc-6.c
+++ b/src/gcc/testsuite/gcc.dg/autopar/reduc-6.c
@@ -59,5 +59,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "Detected reduction" 0 "parloops" } } */
 /* { dg-final { scan-tree-dump-times "SUCCESS: may be parallelized" 1 "parloops" } } */
 /* { dg-final { scan-tree-dump-times "FAILED: it is not a part of reduction" 3 "parloops" } } */
-/* { dg-final { cleanup-tree-dump "parloops" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/autopar/reduc-7.c
+++ b/src/gcc/testsuite/gcc.dg/autopar/reduc-7.c
@@ -86,6 +86,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "Detected reduction" 2 "parloops" } } */
 /* { dg-final { scan-tree-dump-times "SUCCESS: may be parallelized" 3 "parloops" } } */
-/* { dg-final { cleanup-tree-dump "parloops" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
--- a/src/gcc/testsuite/gcc.dg/autopar/reduc-8.c
+++ b/src/gcc/testsuite/gcc.dg/autopar/reduc-8.c
@@ -86,5 +86,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "Detected reduction" 2 "parloops" } } */
 /* { dg-final { scan-tree-dump-times "SUCCESS: may be parallelized" 3 "parloops" } } */
-/* { dg-final { cleanup-tree-dump "parloops" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/autopar/reduc-9.c
+++ b/src/gcc/testsuite/gcc.dg/autopar/reduc-9.c
@@ -86,5 +86,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "Detected reduction" 2 "parloops" } } */
 /* { dg-final { scan-tree-dump-times "SUCCESS: may be parallelized" 3 "parloops" } } */
-/* { dg-final { cleanup-tree-dump "parloops" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/binop-notand1.c
+++ b/src/gcc/testsuite/gcc.dg/binop-notand1.c
@@ -8,4 +8,3 @@ foo (int a, int b)
 }
 
 /* { dg-final { scan-tree-dump-times "return 0" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/binop-notand1a.c
+++ b/src/gcc/testsuite/gcc.dg/binop-notand1a.c
@@ -10,4 +10,3 @@ foo (char a, unsigned short b)
 /* As long as comparisons aren't boolified and casts from boolean-types
    aren't preserved, the folding of  X & !X to zero fails.  */
 /* { dg-final { scan-tree-dump-times "return 0" 1 "optimized" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/binop-notand2.c
+++ b/src/gcc/testsuite/gcc.dg/binop-notand2.c
@@ -8,4 +8,3 @@ foo (int a)
 }
 
 /* { dg-final { scan-tree-dump-times "return 0" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/binop-notand2a.c
+++ b/src/gcc/testsuite/gcc.dg/binop-notand2a.c
@@ -8,4 +8,3 @@ foo (int a)
 }
 
 /* { dg-final { scan-tree-dump-times "return 0" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/binop-notand3.c
+++ b/src/gcc/testsuite/gcc.dg/binop-notand3.c
@@ -8,4 +8,3 @@ foo (int a)
 }
 
 /* { dg-final { scan-tree-dump-times "return 0" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/binop-notand3a.c
+++ b/src/gcc/testsuite/gcc.dg/binop-notand3a.c
@@ -8,4 +8,3 @@ foo (short a)
 }
 
 /* { dg-final { scan-tree-dump-times "return 0" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/binop-notand4.c
+++ b/src/gcc/testsuite/gcc.dg/binop-notand4.c
@@ -8,4 +8,3 @@ foo (int a, int b)
 }
 
 /* { dg-final { scan-tree-dump-times "return 0" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/binop-notand4a.c
+++ b/src/gcc/testsuite/gcc.dg/binop-notand4a.c
@@ -10,4 +10,3 @@ foo (unsigned char a, _Bool b)
 /* As long as comparisons aren't boolified and casts from boolean-types
    aren't preserved, the folding of  X & !X to zero fails.  */
 /* { dg-final { scan-tree-dump-times "return 0" 1 "optimized" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/binop-notand5.c
+++ b/src/gcc/testsuite/gcc.dg/binop-notand5.c
@@ -8,4 +8,3 @@ foo (int a, int b)
 }
 
 /* { dg-final { scan-tree-dump-times "return 0" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/binop-notand5a.c
+++ b/src/gcc/testsuite/gcc.dg/binop-notand5a.c
@@ -8,4 +8,3 @@ foo (long a, unsigned long b)
 }
 
 /* { dg-final { scan-tree-dump-times "return 0" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/binop-notand6.c
+++ b/src/gcc/testsuite/gcc.dg/binop-notand6.c
@@ -8,4 +8,3 @@ foo (int a, int b)
 }
 
 /* { dg-final { scan-tree-dump-times "return 0" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/binop-notand6a.c
+++ b/src/gcc/testsuite/gcc.dg/binop-notand6a.c
@@ -8,4 +8,3 @@ foo (unsigned long a, long b)
 }
 
 /* { dg-final { scan-tree-dump-times "return 0" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/binop-notor1.c
+++ b/src/gcc/testsuite/gcc.dg/binop-notor1.c
@@ -8,4 +8,3 @@ foo (_Bool a, _Bool b)
 }
 
 /* { dg-final { scan-tree-dump-times "return 1" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/binop-notor2.c
+++ b/src/gcc/testsuite/gcc.dg/binop-notor2.c
@@ -8,4 +8,3 @@ foo (_Bool a, _Bool b)
 }
 
 /* { dg-final { scan-tree-dump-times "return 1" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/binop-notxor1.c
+++ b/src/gcc/testsuite/gcc.dg/binop-notxor1.c
@@ -8,4 +8,3 @@ foo (_Bool a, _Bool b)
 }
 
 /* { dg-final { scan-tree-dump-times "return 1" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/binop-notxor2.c
+++ b/src/gcc/testsuite/gcc.dg/binop-notxor2.c
@@ -8,4 +8,3 @@ foo (_Bool a, _Bool b)
 }
 
 /* { dg-final { scan-tree-dump-times "return 1" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/binop-xor1.c
+++ b/src/gcc/testsuite/gcc.dg/binop-xor1.c
@@ -8,4 +8,3 @@ foo (int a, int b, int c)
 }
 
 /* { dg-final { scan-tree-dump-times "\\\^" 1 "optimized" { xfail logical_op_short_circuit } } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/binop-xor2.c
+++ b/src/gcc/testsuite/gcc.dg/binop-xor2.c
@@ -11,4 +11,3 @@ foo (int a, int b)
    it in the real test.  */
 /* { dg-final { scan-tree-dump-times "<bb\[^>\]*>" 1 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "\\\^" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/binop-xor3.c
+++ b/src/gcc/testsuite/gcc.dg/binop-xor3.c
@@ -8,4 +8,3 @@ foo (int a, int b)
 }
 
 /* { dg-final { scan-tree-dump-times "\\\^" 1 "optimized" { target i?86-*-* x86_64-*-* } } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/binop-xor4.c
+++ b/src/gcc/testsuite/gcc.dg/binop-xor4.c
@@ -11,4 +11,3 @@ foo (int a, int b, int c)
    it in the real test.  */
 /* { dg-final { scan-tree-dump-times "<bb\[^>\]*>" 1 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "\\\^" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/binop-xor5.c
+++ b/src/gcc/testsuite/gcc.dg/binop-xor5.c
@@ -12,4 +12,3 @@ foo (int a, int b, int c)
 /* { dg-final { scan-tree-dump-times "<bb\[^>\]*>" 1 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "\\\^" 1 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "\&" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/builtin-arith-overflow-1.c
+++ b/src/gcc/testsuite/gcc.dg/builtin-arith-overflow-1.c
@@ -129,4 +129,3 @@ main ()
 /* { dg-final { scan-tree-dump-not "ADD_OVERFLOW" "optimized" } } */
 /* { dg-final { scan-tree-dump-not "SUB_OVERFLOW" "optimized" } } */
 /* { dg-final { scan-tree-dump-not "MUL_OVERFLOW" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/builtin-arith-overflow-2.c
+++ b/src/gcc/testsuite/gcc.dg/builtin-arith-overflow-2.c
@@ -107,4 +107,3 @@ main ()
 /* { dg-final { scan-tree-dump-times "ADD_OVERFLOW" 2 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "SUB_OVERFLOW" 0 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "MUL_OVERFLOW" 3 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/builtin-assume-aligned-1.c
+++ b/src/gcc/testsuite/gcc.dg/builtin-assume-aligned-1.c
@@ -38,4 +38,3 @@ test2 (double *out1, double *out2, double *out3, double *in1,
 }
 
 /* { dg-final { scan-tree-dump-not "__builtin_assume_aligned" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/builtin-bswap-6.c
+++ b/src/gcc/testsuite/gcc.dg/builtin-bswap-6.c
@@ -39,4 +39,3 @@ int foo4 (uint32_t a, uint32_t b)
 }
 
 /* { dg-final { scan-rtl-dump-not "bswapsi" "combine" } } */
-/* { dg-final { cleanup-rtl-dump "combine" } } */
--- a/src/gcc/testsuite/gcc.dg/builtin-bswap-6a.c
+++ b/src/gcc/testsuite/gcc.dg/builtin-bswap-6a.c
@@ -41,4 +41,3 @@ int foo4 (uint32_t a, uint32_t b)
 }
 
 /* { dg-final { scan-rtl-dump-not "bswapsi" "combine" } } */
-/* { dg-final { cleanup-rtl-dump "combine" } } */
--- a/src/gcc/testsuite/gcc.dg/builtin-bswap-7.c
+++ b/src/gcc/testsuite/gcc.dg/builtin-bswap-7.c
@@ -40,4 +40,3 @@ int foo4 (uint64_t a, uint64_t b)
 }
 
 /* { dg-final { scan-rtl-dump-not "bswapdi" "combine" } } */
-/* { dg-final { cleanup-rtl-dump "combine" } } */
--- a/src/gcc/testsuite/gcc.dg/builtin-bswap-7a.c
+++ b/src/gcc/testsuite/gcc.dg/builtin-bswap-7a.c
@@ -41,4 +41,3 @@ int foo4 (uint64_t a, uint64_t b)
 }
 
 /* { dg-final { scan-rtl-dump-not "bswapdi" "combine" } } */
-/* { dg-final { cleanup-rtl-dump "combine" } } */
--- a/src/gcc/testsuite/gcc.dg/builtin-bswap-8.c
+++ b/src/gcc/testsuite/gcc.dg/builtin-bswap-8.c
@@ -43,4 +43,3 @@ uint32_t foo7 (uint32_t a, uint32_t b)
 }
 
 /* { dg-final { scan-rtl-dump-not "bswapsi" "combine" } } */
-/* { dg-final { cleanup-rtl-dump "combine" } } */
--- a/src/gcc/testsuite/gcc.dg/builtin-bswap-9.c
+++ b/src/gcc/testsuite/gcc.dg/builtin-bswap-9.c
@@ -43,4 +43,3 @@ uint64_t foo7 (uint64_t a, uint64_t b)
 }
 
 /* { dg-final { scan-rtl-dump-not "bswapdi" "combine" } } */
-/* { dg-final { cleanup-rtl-dump "combine" } } */
--- a/src/gcc/testsuite/gcc.dg/builtin-object-size-10.c
+++ b/src/gcc/testsuite/gcc.dg/builtin-object-size-10.c
@@ -24,4 +24,3 @@ foo(char *x)
 
 /* { dg-final { scan-tree-dump "maximum object size 21" "objsz1" } } */
 /* { dg-final { scan-tree-dump "maximum subobject size 16" "objsz1" } } */
-/* { dg-final { cleanup-tree-dump "objsz1" } } */
--- a/src/gcc/testsuite/gcc.dg/builtin-unreachable-2.c
+++ b/src/gcc/testsuite/gcc.dg/builtin-unreachable-2.c
@@ -16,5 +16,3 @@ f (int i)
 }
 /* { dg-final { scan-tree-dump-not "foo" "optimized" } } */
 /* { dg-final { scan-rtl-dump-not "\\(if_then_else" "cse1" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
-/* { dg-final { cleanup-rtl-dump "cse1" } } */
--- a/src/gcc/testsuite/gcc.dg/builtin-unreachable-5.c
+++ b/src/gcc/testsuite/gcc.dg/builtin-unreachable-5.c
@@ -20,4 +20,3 @@ foo (int a)
 /* { dg-final { scan-tree-dump-times "goto" 0 "fab1" } } */
 /* { dg-final { scan-tree-dump-times "L1:" 0 "fab1" } } */
 /* { dg-final { scan-tree-dump-times "__builtin_unreachable" 0 "fab1" } } */
-/* { dg-final { cleanup-tree-dump "fab1" } } */
--- a/src/gcc/testsuite/gcc.dg/builtin-unreachable-6.c
+++ b/src/gcc/testsuite/gcc.dg/builtin-unreachable-6.c
@@ -18,4 +18,3 @@ lab2:
 
 /* { dg-final { scan-tree-dump-times "lab:" 1 "fab1" } } */
 /* { dg-final { scan-tree-dump-times "__builtin_unreachable" 1 "fab1" } } */
-/* { dg-final { cleanup-tree-dump "fab1" } } */
--- a/src/gcc/testsuite/gcc.dg/builtins-20.c
+++ b/src/gcc/testsuite/gcc.dg/builtins-20.c
@@ -122,7 +122,7 @@ void test2(double x, double y)
   if (cos((y*=3, -x)) != cos((y*=3,x)))
     link_error ();
 
-  if (cos((y*=2, -fabs(tan(x/-y)))) != cos((y*=2,tan(x/y))))
+  if (cos(-fabs(tan(x/-y))) != cos(tan(x/y)))
     link_error ();
 
   if (cos(copysign(x,y)) != cos(x))
@@ -350,7 +350,7 @@ void test2f(float x, float y)
   if (cosf((y*=3, -x)) != cosf((y*=3,x)))
     link_error ();
 
-  if (cosf((y*=2, -fabsf(tanf(x/-y)))) != cosf((y*=2,tanf(x/y))))
+  if (cosf(-fabsf(tanf(x/-y))) != cosf(tanf(x/y)))
     link_error ();
 
   if (cosf(copysignf(x,y)) != cosf(x))
@@ -577,7 +577,7 @@ void test2l(long double x, long double y)
   if (cosl((y*=3, -x)) != cosl((y*=3,x)))
     link_error ();
 
-  if (cosl((y*=2, -fabsl(tanl(x/-y)))) != cosl((y*=2,tanl(x/y))))
+  if (cosl(-fabsl(tanl(x/-y))) != cosl(tanl(x/y)))
     link_error ();
 
   if (cosl(copysignl(x,y)) != cosl(x))
--- a/src/gcc/testsuite/gcc.dg/builtins-43.c
+++ b/src/gcc/testsuite/gcc.dg/builtins-43.c
@@ -52,8 +52,6 @@ main ()
 
 /* Check that all instances of __builtin_isnan were folded.  */
 /* { dg-final { scan-tree-dump-times "isnan" 0 "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
 
 /* Check that all instances of link_error were subject to DCE.  */
 /* { dg-final { scan-tree-dump-times "link_error" 0 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/builtins-44.c
+++ b/src/gcc/testsuite/gcc.dg/builtins-44.c
@@ -55,4 +55,3 @@ main ()
 
 /* Check that all instances of link_error were subject to DCE.  */
 /* { dg-final { scan-tree-dump-times "link_error" 0 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/builtins-45.c
+++ b/src/gcc/testsuite/gcc.dg/builtins-45.c
@@ -54,4 +54,3 @@ main ()
 
 /* Check that all instances of link_error were subject to DCE.  */
 /* { dg-final { scan-tree-dump-times "link_error" 0 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/builtins-47.c
+++ b/src/gcc/testsuite/gcc.dg/builtins-47.c
@@ -17,4 +17,3 @@ int main ()
 
 /* { dg-final { scan-tree-dump-times "sqrt" 0 "gimple" } } */
 /* { dg-final { scan-tree-dump-times "pow" 0 "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/builtins-59.c
+++ b/src/gcc/testsuite/gcc.dg/builtins-59.c
@@ -12,4 +12,3 @@ double test (double x)
 
 /* { dg-final { scan-tree-dump "__builtin_cexpi" "gimple" } } */
 /* { dg-final { scan-tree-dump-not "sincos" "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/builtins-60.c
+++ b/src/gcc/testsuite/gcc.dg/builtins-60.c
@@ -13,4 +13,3 @@ double test2 (double x)
 
 /* { dg-final { scan-tree-dump "cos" "gimple" } } */
 /* { dg-final { scan-tree-dump "sin" "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/builtins-61.c
+++ b/src/gcc/testsuite/gcc.dg/builtins-61.c
@@ -30,4 +30,3 @@ double test4(double x, double y)
 /* { dg-final { scan-tree-dump "sin" "optimized" } } */
 /* { dg-final { scan-tree-dump "cos" "optimized" } } */
 /* { dg-final { scan-tree-dump "return 0.0" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/builtins-62.c
+++ b/src/gcc/testsuite/gcc.dg/builtins-62.c
@@ -38,4 +38,3 @@ double test4 (double x)
 }
 
 /* { dg-final { scan-tree-dump-times "cexpi" 3 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/cdce1.c
+++ b/src/gcc/testsuite/gcc.dg/cdce1.c
@@ -1,8 +1,7 @@
 /* { dg-do  run  } */
 /* { dg-options "-O2 -fmath-errno -fdump-tree-cdce-details  -lm" } */
 /* { dg-require-effective-target int32plus } */
-/* { dg-final { scan-tree-dump  "cdce1.c:17: note: function call is shrink-wrapped into error conditions\."  "cdce" } } */
-/* { dg-final { cleanup-tree-dump "cdce" } } */
+/* { dg-final { scan-tree-dump  "cdce1.c:16: note: function call is shrink-wrapped into error conditions\."  "cdce" } } */
 /* { dg-require-effective-target large_double } */
 
 #include <stdlib.h>
--- a/src/gcc/testsuite/gcc.dg/cdce2.c
+++ b/src/gcc/testsuite/gcc.dg/cdce2.c
@@ -1,8 +1,7 @@
 /* { dg-do  run  } */
 /* { dg-skip-if "doubles are floats" { "avr-*-*" } { "*" } { "" } } */
 /* { dg-options "-O2 -fmath-errno -fdump-tree-cdce-details  -lm" } */
-/* { dg-final { scan-tree-dump  "cdce2.c:16: note: function call is shrink-wrapped into error conditions\." "cdce" } }*/
-/* { dg-final { cleanup-tree-dump "cdce" } } */
+/* { dg-final { scan-tree-dump  "cdce2.c:15: note: function call is shrink-wrapped into error conditions\." "cdce" } } */
  
 #include <stdlib.h>
 #include <math.h>
--- a/src/gcc/testsuite/gcc.dg/combine-clobber.c
+++ b/src/gcc/testsuite/gcc.dg/combine-clobber.c
@@ -19,4 +19,3 @@ int f(int a, int b) { return -(a == b); }
 
 /* This regexp works for reg parameters as well as mem parameters.  */
 /* { dg-final { scan-rtl-dump {neg:SI[^:]*eq:SI[^:]*:SI} "combine" } } */
-/* { dg-final { cleanup-rtl-dump "combine" } } */
--- a/src/gcc/testsuite/gcc.dg/combine_ashiftrt_1.c
+++ b/src/gcc/testsuite/gcc.dg/combine_ashiftrt_1.c
@@ -18,4 +18,3 @@ foo (int64_t a)
    the *attempt* to match this RTL pattern, regardless of whether an
    actual insn may be found on the platform.  */
 /* { dg-final { scan-rtl-dump "\\(neg:DI \\(ge:DI" "combine" } } */
-/* { dg-final { cleanup-rtl-dump "combine" } } */
--- a/src/gcc/testsuite/gcc.dg/combine_ashiftrt_2.c
+++ b/src/gcc/testsuite/gcc.dg/combine_ashiftrt_2.c
@@ -18,4 +18,3 @@ foo (int32_t a)
    the *attempt* to match this RTL pattern, regardless of whether an
    actual insn may be found on the platform.  */
 /* { dg-final { scan-rtl-dump "\\(neg:SI \\(ge:SI" "combine" } } */
-/* { dg-final { cleanup-rtl-dump "combine" } } */
--- a/src/gcc/testsuite/gcc.dg/const-uniq-1.c
+++ b/src/gcc/testsuite/gcc.dg/const-uniq-1.c
@@ -21,4 +21,3 @@ int lookup2 (int i)
 }
 
 /* { dg-final { scan-tree-dump-times "L\\\$?C\\\.*0" 2 "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/cpp/direct2s.c
+++ b/src/gcc/testsuite/gcc.dg/cpp/direct2s.c
@@ -41,4 +41,3 @@ void f ()
   int j = Y;    /* { dg-error "undeclared|for each" "no macro Y" } */
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.dg/cpp/paste4.c
+++ b/src/gcc/testsuite/gcc.dg/cpp/paste4.c
@@ -15,4 +15,3 @@ int main ()
   return 0;
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.dg/cpp/separate-1.c
+++ b/src/gcc/testsuite/gcc.dg/cpp/separate-1.c
@@ -14,4 +14,3 @@ int FOO(
 int baz FOO /* { dg-error "parse error|syntax error|expected" "error on this line" } */
 ;
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.dg/debug/dwarf2/pr41445-1.c
+++ b/src/gcc/testsuite/gcc.dg/debug/dwarf2/pr41445-1.c
@@ -15,4 +15,3 @@ int varj;
 /* { dg-final { scan-assembler "DW_TAG_variable\[^\\r\\n\]*\[\\r\\n\]+\[^\\r\\n\]*\"varh\[^\\r\\n\]*DW_AT_name(\[^\\r\\n\]*\[\\r\\n\]+\[^\\r\\n\]*DW_AT_)*\[^\\r\\n\]*\[\\r\\n\]+\[^\\r\\n\]*\[^0-9a-fA-FxX](0x)?8\[^0-9a-fA-FxX]\[^\\r\\n\]*DW_AT_decl_line" } } */
 /* { dg-final { scan-assembler "DW_TAG_variable\[^\\r\\n\]*\[\\r\\n\]+\[^\\r\\n\]*\"vari\[^\\r\\n\]*DW_AT_name(\[^\\r\\n\]*\[\\r\\n\]+\[^\\r\\n\]*DW_AT_)*\[^\\r\\n\]*\[\\r\\n\]+\[^\\r\\n\]*\[^0-9a-fA-FxX](0xc|12)\[^0-9a-fA-FxX]\[^\\r\\n\]*DW_AT_decl_line" } } */
 /* { dg-final { scan-assembler "DW_TAG_variable\[^\\r\\n\]*\[\\r\\n\]+\[^\\r\\n\]*\"varj\[^\\r\\n\]*DW_AT_name(\[^\\r\\n\]*\[\\r\\n\]+\[^\\r\\n\]*DW_AT_)*\[^\\r\\n\]*\[\\r\\n\]+\[^\\r\\n\]*\[^0-9a-fA-FxX](0xd|13)\[^0-9a-fA-FxX]\[^\\r\\n\]*DW_AT_decl_line" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.dg/debug/dwarf2/pr41445-3.c
+++ b/src/gcc/testsuite/gcc.dg/debug/dwarf2/pr41445-3.c
@@ -15,4 +15,3 @@ int varj;
 /* { dg-final { scan-assembler "DW_TAG_variable\[^\\r\\n\]*\[\\r\\n\]+\[^\\r\\n\]*\"varh\[^\\r\\n\]*DW_AT_name(\[^\\r\\n\]*\[\\r\\n\]+\[^\\r\\n\]*DW_AT_)*\[^\\r\\n\]*\[\\r\\n\]+\[^\\r\\n\]*\[^0-9a-fA-FxX](0x)?8\[^0-9a-fA-FxX]\[^\\r\\n\]*DW_AT_decl_line" } } */
 /* { dg-final { scan-assembler "DW_TAG_variable\[^\\r\\n\]*\[\\r\\n\]+\[^\\r\\n\]*\"vari\[^\\r\\n\]*DW_AT_name(\[^\\r\\n\]*\[\\r\\n\]+\[^\\r\\n\]*DW_AT_)*\[^\\r\\n\]*\[\\r\\n\]+\[^\\r\\n\]*\[^0-9a-fA-FxX](0xc|12)\[^0-9a-fA-FxX]\[^\\r\\n\]*DW_AT_decl_line" } } */
 /* { dg-final { scan-assembler "DW_TAG_variable\[^\\r\\n\]*\[\\r\\n\]+\[^\\r\\n\]*\"varj\[^\\r\\n\]*DW_AT_name(\[^\\r\\n\]*\[\\r\\n\]+\[^\\r\\n\]*DW_AT_)*\[^\\r\\n\]*\[\\r\\n\]+\[^\\r\\n\]*\[^0-9a-fA-FxX](0xd|13)\[^0-9a-fA-FxX]\[^\\r\\n\]*DW_AT_decl_line" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.dg/debug/dwarf2/pr41445-5.c
+++ b/src/gcc/testsuite/gcc.dg/debug/dwarf2/pr41445-5.c
@@ -14,4 +14,3 @@ int A(B) ;
 
 /* { dg-final { scan-assembler "DW_TAG_variable\[^\\r\\n\]*\[\\r\\n\]+\[^\\r\\n\]*\"vari\[^\\r\\n\]*DW_AT_name(\[^\\r\\n\]*\[\\r\\n\]+\[^\\r\\n\]*DW_AT_)*\[^\\r\\n\]*\[\\r\\n\]+\[^\\r\\n\]*\[^0-9a-fA-FxX](0xa|10)\[^0-9a-fA-FxX]\[^\\r\\n\]*DW_AT_decl_line" } } */
 /* { dg-final { scan-assembler "DW_TAG_variable\[^\\r\\n\]*\[\\r\\n\]+\[^\\r\\n\]*\"varj\[^\\r\\n\]*DW_AT_name(\[^\\r\\n\]*\[\\r\\n\]+\[^\\r\\n\]*DW_AT_)*\[^\\r\\n\]*\[\\r\\n\]+\[^\\r\\n\]*\[^0-9a-fA-FxX](0xa|10)\[^0-9a-fA-FxX]\[^\\r\\n\]*DW_AT_decl_line" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.dg/debug/dwarf2/pr41543.c
+++ b/src/gcc/testsuite/gcc.dg/debug/dwarf2/pr41543.c
@@ -11,4 +11,3 @@ foo (va_list ap)
 }
 
 /* { dg-final { scan-assembler-not "DW_AT_decl_file\[^\\r\\n\]*\(pr41543\.i\)" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.dg/debug/dwarf2/pr47939-1.c
+++ b/src/gcc/testsuite/gcc.dg/debug/dwarf2/pr47939-1.c
@@ -5,4 +5,3 @@ typedef struct _Harry { int dummy; } Harry_t;
 Harry_t harry;
 
 /* { dg-final { scan-assembler "DW_TAG_typedef\[^\\r\\n\]*\[\\r\\n\]+\[^\\r\\n\]*(DW_AT_name: \"Harry_t\"|\"Harry_t..\"\[^\\r\\n\]*DW_AT_name)" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.dg/debug/dwarf2/pr47939-2.c
+++ b/src/gcc/testsuite/gcc.dg/debug/dwarf2/pr47939-2.c
@@ -5,4 +5,3 @@ typedef const struct _Harry { int dummy; } Harry_t;
 Harry_t harry;
 
 /* { dg-final { scan-assembler "DW_TAG_typedef\[^\\r\\n\]*\[\\r\\n\]+\[^\\r\\n\]*(DW_AT_name: \"Harry_t\"|\"Harry_t..\"\[^\\r\\n\]*DW_AT_name)" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.dg/debug/dwarf2/pr47939-3.c
+++ b/src/gcc/testsuite/gcc.dg/debug/dwarf2/pr47939-3.c
@@ -5,4 +5,3 @@ typedef struct _Harry { int dummy; } Harry_t;
 const Harry_t harry[5];
 
 /* { dg-final { scan-assembler "DW_TAG_typedef\[^\\r\\n\]*\[\\r\\n\]+\[^\\r\\n\]*(DW_AT_name: \"Harry_t\"|\"Harry_t..\"\[^\\r\\n\]*DW_AT_name)" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.dg/debug/dwarf2/pr47939-4.c
+++ b/src/gcc/testsuite/gcc.dg/debug/dwarf2/pr47939-4.c
@@ -5,4 +5,3 @@ typedef const struct _Harry { int dummy; } Harry_t;
 Harry_t harry[10];
 
 /* { dg-final { scan-assembler "DW_TAG_typedef\[^\\r\\n\]*\[\\r\\n\]+\[^\\r\\n\]*(DW_AT_name: \"Harry_t\"|\"Harry_t..\"\[^\\r\\n\]*DW_AT_name)" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.dg/dse.c
+++ b/src/gcc/testsuite/gcc.dg/dse.c
@@ -28,5 +28,4 @@ foo (void)
 }
 
 /* { dg-final { scan-tree-dump-times "Deleted dead store" 2 "dse1" } } */
-/* { dg-final { cleanup-tree-dump "dse*" } } */
 
--- /dev/null
+++ b/src/gcc/testsuite/gcc.dg/dx-test.c
@@ -0,0 +1,5 @@
+/* { dg-do compile } */
+/* { dg-options "-dx" } */
+
+void f(void)
+{}
--- a/src/gcc/testsuite/gcc.dg/fold-abs-3.c
+++ b/src/gcc/testsuite/gcc.dg/fold-abs-3.c
@@ -6,4 +6,3 @@ int f (int a) {
 }
 
 /* { dg-final { scan-tree-dump-times "ABS" 1 "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/fold-abs-4.c
+++ b/src/gcc/testsuite/gcc.dg/fold-abs-4.c
@@ -12,4 +12,3 @@ int g (_Complex float a) {
 }
 
 /* { dg-final { scan-tree-dump-times "ABS" 0 "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/fold-abs-5.c
+++ b/src/gcc/testsuite/gcc.dg/fold-abs-5.c
@@ -8,4 +8,3 @@ int test (int a, int b, int sum)
 }
 
 /* { dg-final { scan-tree-dump "ABS" "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/gcc.dg/fold-addr-1.c
+++ b/src/gcc/testsuite/gcc.dg/fold-addr-1.c
@@ -7,4 +7,3 @@ int bar(char p1, char p2)
 }
 
 /* { dg-final { scan-tree-dump "return 0;" "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/gcc.dg/fold-alloca-1.c
+++ b/src/gcc/testsuite/gcc.dg/fold-alloca-1.c
@@ -11,4 +11,3 @@ int main (int argc, char *argv[]) {
 	return 0;
 }
 /* { dg-final { scan-tree-dump-times "link_error" 0 "cfg" } } */
-/* { dg-final { cleanup-tree-dump "cfg" } } */
--- a/src/gcc/testsuite/gcc.dg/fold-andxor-1.c
+++ b/src/gcc/testsuite/gcc.dg/fold-andxor-1.c
@@ -25,5 +25,4 @@ int test4(int g, int h)
 /* { dg-final { scan-tree-dump-times "~c \& d" 1 "original" } } */
 /* { dg-final { scan-tree-dump-times "~f \& e" 1 "original" } } */
 /* { dg-final { scan-tree-dump-times "~h \& g" 1 "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
 
--- a/src/gcc/testsuite/gcc.dg/fold-bitand-1.c
+++ b/src/gcc/testsuite/gcc.dg/fold-bitand-1.c
@@ -30,4 +30,3 @@ unsigned f4(void)
 /* { dg-final { scan-tree-dump-times "\&c4 \& 3" 0 "original" } } */
 /* { dg-final { scan-tree-dump-times "\&c8 \& 3" 0 "original" } } */
 /* { dg-final { scan-tree-dump-times "return 0" 2 "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/gcc.dg/fold-bitand-2.c
+++ b/src/gcc/testsuite/gcc.dg/fold-bitand-2.c
@@ -39,4 +39,3 @@ unsigned f5 (void)
 /* { dg-final { scan-tree-dump-times "return 1" 1 "original" } } */
 /* { dg-final { scan-tree-dump-times "return 2" 1 "original" } } */
 /* { dg-final { scan-tree-dump-times "return 3" 1 "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/gcc.dg/fold-bitand-3.c
+++ b/src/gcc/testsuite/gcc.dg/fold-bitand-3.c
@@ -22,4 +22,3 @@ int f2 (void)
 
 /* { dg-final { scan-tree-dump-times "\& 3" 0 "original" } } */
 /* { dg-final { scan-tree-dump-times "return 1" 2 "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/gcc.dg/fold-bitand-4.c
+++ b/src/gcc/testsuite/gcc.dg/fold-bitand-4.c
@@ -13,4 +13,3 @@ unsigned bar (unsigned i)
 
 /* { dg-final { scan-tree-dump-times "\\\&" 1 "original" } } */
 /* { dg-final { scan-tree-dump-times "\\\& 4;" 1 "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/gcc.dg/fold-compare-1.c
+++ b/src/gcc/testsuite/gcc.dg/fold-compare-1.c
@@ -49,5 +49,4 @@ int test8(int l)
 /* { dg-final { scan-tree-dump-times "j >= i" 1 "original" } } */
 /* { dg-final { scan-tree-dump-times "k >= -3" 1 "original" } } */
 /* { dg-final { scan-tree-dump-times "l < -2" 1 "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
 
--- a/src/gcc/testsuite/gcc.dg/fold-compare-2.c
+++ b/src/gcc/testsuite/gcc.dg/fold-compare-2.c
@@ -16,5 +16,4 @@ main(void)
 }
 
 /* { dg-final { scan-tree-dump-times "Removing basic block" 2 "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
 
--- a/src/gcc/testsuite/gcc.dg/fold-compare-3.c
+++ b/src/gcc/testsuite/gcc.dg/fold-compare-3.c
@@ -156,4 +156,3 @@ void bla4ge (int var)
 /* { dg-final { scan-tree-dump-times "this_comparison_is_not_decidable" 12 "cfg" } } */
 /* { dg-final { scan-tree-dump-times "if " 12 "cfg" } } */
 
-/* { dg-final { cleanup-tree-dump "cfg" } } */
--- a/src/gcc/testsuite/gcc.dg/fold-compare-4.c
+++ b/src/gcc/testsuite/gcc.dg/fold-compare-4.c
@@ -20,4 +20,3 @@ int test4 (int a)
 
 /* { dg-final { scan-tree-dump-times "b == 0" 2 "original" } } */
 /* { dg-final { scan-tree-dump-times "return 0" 2 "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/gcc.dg/fold-compare-5.c
+++ b/src/gcc/testsuite/gcc.dg/fold-compare-5.c
@@ -17,4 +17,3 @@ int test3 (int a)
 /* { dg-final { scan-tree-dump-times "return 2 - a == a" 1 "original" } } */
 /* { dg-final { scan-tree-dump-times "return 0" 1 "original" } } */
 /* { dg-final { scan-tree-dump-times "return 1" 1 "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/gcc.dg/fold-compare-6.c
+++ b/src/gcc/testsuite/gcc.dg/fold-compare-6.c
@@ -9,4 +9,3 @@ int foo (void)
 }
 
 /* { dg-final { scan-tree-dump "xlcbug = 1;" "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/gcc.dg/fold-compare-8.c
+++ b/src/gcc/testsuite/gcc.dg/fold-compare-8.c
@@ -8,4 +8,3 @@ foo (int x, int y)
 }
 
 /* { dg-final { scan-tree-dump "x < y" "original"  { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/gcc.dg/fold-complex-1.c
+++ b/src/gcc/testsuite/gcc.dg/fold-complex-1.c
@@ -8,4 +8,3 @@ foo (_Complex float x)
 }
 
 /* { dg-final { scan-tree-dump-times "COMPLEX_EXPR" 0 "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/gcc.dg/fold-cond-1.c
+++ b/src/gcc/testsuite/gcc.dg/fold-cond-1.c
@@ -26,4 +26,3 @@ _Bool test4(int g, int h)
 /* { dg-final { scan-tree-dump-times "e == 0 \&\& f != 0" 1 "original" } } */
 /* { dg-final { scan-tree-dump-times "g == 0 \\? h != 0 : 1" 0 "original" } } */
 /* { dg-final { scan-tree-dump-times "g != 0 \\? 1 : h != 0" 0 "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/gcc.dg/fold-convnotconv-1.c
+++ b/src/gcc/testsuite/gcc.dg/fold-convnotconv-1.c
@@ -13,5 +13,4 @@ unsigned int test2(unsigned int b)
 
 /* { dg-final { scan-tree-dump-times "~a" 1 "original" } } */
 /* { dg-final { scan-tree-dump-times "~b" 1 "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
 
--- a/src/gcc/testsuite/gcc.dg/fold-convround-1.c
+++ b/src/gcc/testsuite/gcc.dg/fold-convround-1.c
@@ -26,5 +26,4 @@ unsigned long long test3(double x)
 /* { dg-final { scan-tree-dump-times "__builtin_llfloor" 0 "original" } } */
 /* { dg-final { scan-tree-dump-times "__builtin_lceil" 0 "original" } } */
 /* { dg-final { scan-tree-dump-times "__builtin_llceil" 0 "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
 
--- a/src/gcc/testsuite/gcc.dg/fold-cstvecshift.c
+++ b/src/gcc/testsuite/gcc.dg/fold-cstvecshift.c
@@ -10,4 +10,3 @@ void f (vec *r)
 }
 
 /* { dg-final { scan-tree-dump "{ 4, 6, 8, 10 }" "ccp1"} } */
-/* { dg-final { cleanup-tree-dump "ccp1" } } */
--- a/src/gcc/testsuite/gcc.dg/fold-div-1.c
+++ b/src/gcc/testsuite/gcc.dg/fold-div-1.c
@@ -26,5 +26,4 @@ float i(float x)
 
 /* { dg-final { scan-tree-dump-times " \\* " 2 "gimple" } } */
 /* { dg-final { scan-tree-dump-times " / " 2 "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
 
--- a/src/gcc/testsuite/gcc.dg/fold-div-2.c
+++ b/src/gcc/testsuite/gcc.dg/fold-div-2.c
@@ -9,5 +9,4 @@ double f(double x)
 /* Division should be turned into 1.0.  */
 
 /* { dg-final { scan-tree-dump-not " / " "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
 
--- a/src/gcc/testsuite/gcc.dg/fold-div-3.c
+++ b/src/gcc/testsuite/gcc.dg/fold-div-3.c
@@ -12,4 +12,3 @@ apply_frontend_param (unsigned int spi_bias)
 /* Make sure we perform the division in the narrower type.  */
 
 /* { dg-final { scan-tree-dump "spi_bias = spi_bias / 1008;" "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/gcc.dg/fold-eqand-1.c
+++ b/src/gcc/testsuite/gcc.dg/fold-eqand-1.c
@@ -14,4 +14,3 @@ unsigned bar (unsigned c, unsigned d)
 
 /* { dg-final { scan-tree-dump-times "a \\^ b" 1 "original" } } */
 /* { dg-final { scan-tree-dump-times "c \\^ d" 1 "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/gcc.dg/fold-eqandnot-1.c
+++ b/src/gcc/testsuite/gcc.dg/fold-eqandnot-1.c
@@ -30,4 +30,3 @@ int test5(int e)
 /* { dg-final { scan-tree-dump-times "\\(c \& 4\\) == 0" 1 "original" } } */
 /* { dg-final { scan-tree-dump-times "\\(d \& 4\\) == 0" 1 "original" } } */
 /* { dg-final { scan-tree-dump-times "\\(e \& 4\\) == 0" 1 "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/gcc.dg/fold-eqandshift-1.c
+++ b/src/gcc/testsuite/gcc.dg/fold-eqandshift-1.c
@@ -53,4 +53,3 @@ void test6(unsigned int f)
 /* { dg-final { scan-tree-dump-times "d >> 3 \& 4" 1 "original" } } */
 /* { dg-final { scan-tree-dump-times "e < 0" 1 "original" } } */
 /* { dg-final { scan-tree-dump-times "if \\(0\\)" 1 "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/gcc.dg/fold-eqandshift-2.c
+++ b/src/gcc/testsuite/gcc.dg/fold-eqandshift-2.c
@@ -18,5 +18,4 @@ void baz (unsigned int b)
 
 /* { dg-final { scan-tree-dump-times "\\(a \& 4\\) != 0" 1 "original" } } */
 /* { dg-final { scan-tree-dump-times "\\(b \& 4\\) == 0" 1 "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
 
--- a/src/gcc/testsuite/gcc.dg/fold-eqandshift-3.c
+++ b/src/gcc/testsuite/gcc.dg/fold-eqandshift-3.c
@@ -26,4 +26,3 @@ int test2 (unsigned long b)
 
 /* { dg-final { scan-tree-dump-times "\\(a \& 1073741824\\) != 0" 1 "original" } } */
 /* { dg-final { scan-tree-dump-times "\\(b \& 1073741824\\) != 0" 1 "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/gcc.dg/fold-eqcmplx-1.c
+++ b/src/gcc/testsuite/gcc.dg/fold-eqcmplx-1.c
@@ -7,4 +7,3 @@ int foo(float x, float y)
 }
 
 /* { dg-final { scan-tree-dump-times "x == y" 1 "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/gcc.dg/fold-eqxor-1.c
+++ b/src/gcc/testsuite/gcc.dg/fold-eqxor-1.c
@@ -25,4 +25,3 @@ unsigned int test4(unsigned int g, unsigned int h)
 /* { dg-final { scan-tree-dump-times "c != d" 1 "original" } } */
 /* { dg-final { scan-tree-dump-times "e == f" 1 "original" } } */
 /* { dg-final { scan-tree-dump-times "g != h" 1 "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/gcc.dg/fold-eqxor-2.c
+++ b/src/gcc/testsuite/gcc.dg/fold-eqxor-2.c
@@ -25,4 +25,3 @@ int test4(int g, int h)
 /* { dg-final { scan-tree-dump-times "d != 0" 1 "original" } } */
 /* { dg-final { scan-tree-dump-times "e == 0" 1 "original" } } */
 /* { dg-final { scan-tree-dump-times "g != 0" 1 "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/gcc.dg/fold-eqxor-3.c
+++ b/src/gcc/testsuite/gcc.dg/fold-eqxor-3.c
@@ -25,4 +25,3 @@ int test4(int g, int h)
 /* { dg-final { scan-tree-dump-times "c != 0" 1 "original" } } */
 /* { dg-final { scan-tree-dump-times "e == 4" 1 "original" } } */
 /* { dg-final { scan-tree-dump-times "g != 2" 1 "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/gcc.dg/fold-eqxor-4.c
+++ b/src/gcc/testsuite/gcc.dg/fold-eqxor-4.c
@@ -19,4 +19,3 @@ int test3(int e, int f)
 /* { dg-final { scan-tree-dump-times "a == 4" 1 "original" } } */
 /* { dg-final { scan-tree-dump-times "b == c" 1 "original" } } */
 /* { dg-final { scan-tree-dump-times "e \\^ 2" 1 "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/gcc.dg/fold-even-1.c
+++ b/src/gcc/testsuite/gcc.dg/fold-even-1.c
@@ -30,4 +30,3 @@ int test5(int e)
 /* { dg-final { scan-tree-dump-times "\\(c \& 1\\) == 0" 1 "original" } } */
 /* { dg-final { scan-tree-dump-times "\\(d \& 1\\) == 0" 1 "original" } } */
 /* { dg-final { scan-tree-dump-times "\\(e \& 1\\) == 0" 1 "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/gcc.dg/fold-minus-1.c
+++ b/src/gcc/testsuite/gcc.dg/fold-minus-1.c
@@ -17,4 +17,3 @@ void g(vec*x,vec*y,vec*z){
 /* { dg-final { scan-tree-dump-not "/" "gimple"} } */
 /* { dg-final { scan-tree-dump-not "\\\+" "gimple"} } */
 /* { dg-final { scan-tree-dump "{ -13, -13 }" "gimple"} } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/fold-mod-1.c
+++ b/src/gcc/testsuite/gcc.dg/fold-mod-1.c
@@ -23,4 +23,3 @@ unsigned int k (unsigned int d) {
 
 /* { dg-final { scan-tree-dump "a % (4294967288|0x0fffffff8)" "gimple" } } */
 /* { dg-final { scan-tree-dump-times " & 7" 3 "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/fold-mulconj-1.c
+++ b/src/gcc/testsuite/gcc.dg/fold-mulconj-1.c
@@ -13,4 +13,3 @@ _Complex int bar(_Complex int z)
 }
 
 /* { dg-final { scan-tree-dump-times "CONJ_EXPR" 0 "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/fold-notunord.c
+++ b/src/gcc/testsuite/gcc.dg/fold-notunord.c
@@ -7,4 +7,3 @@ int f (double d)
 }
 
 /* { dg-final { scan-tree-dump " ord " "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/fold-perm.c
+++ b/src/gcc/testsuite/gcc.dg/fold-perm.c
@@ -17,4 +17,3 @@ void fun (veci *f, veci *g, veci *h, veci *i)
 /* { dg-final { scan-tree-dump "VEC_PERM_EXPR.*{ 3, 3, 0, 2 }" "ccp1" } } */
 /* { dg-final { scan-tree-dump "VEC_PERM_EXPR.*{ 1, 1, 3, 2 }" "ccp1" } } */
 /* { dg-final { scan-tree-dump-times "VEC_PERM_EXPR" 2 "ccp1" } } */
-/* { dg-final { cleanup-tree-dump "ccp1" } } */
--- a/src/gcc/testsuite/gcc.dg/fold-plusmult-2.c
+++ b/src/gcc/testsuite/gcc.dg/fold-plusmult-2.c
@@ -17,4 +17,3 @@ int bar (int i)
 
 /* { dg-final { scan-tree-dump "i \\\* 4 \\\+ 2" "original" } } */
 /* { dg-final { scan-tree-dump "\\\(i \\\+ 2\\\) \\\* 2" "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/gcc.dg/fold-plusmult.c
+++ b/src/gcc/testsuite/gcc.dg/fold-plusmult.c
@@ -12,4 +12,3 @@ int test2 (int a)
 }
 
 /* { dg-final { scan-tree-dump-times "<a> \\\* 4" 2 "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/gcc.dg/fold-plusnot-1.c
+++ b/src/gcc/testsuite/gcc.dg/fold-plusnot-1.c
@@ -26,5 +26,4 @@ unsigned int test4(unsigned int d)
 /* { dg-final { scan-tree-dump-times "\\+ b" 0 "original" } } */
 /* { dg-final { scan-tree-dump-times "\\+ c" 0 "original" } } */
 /* { dg-final { scan-tree-dump-times "\\+ d" 0 "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
 
--- a/src/gcc/testsuite/gcc.dg/fold-reassoc-1.c
+++ b/src/gcc/testsuite/gcc.dg/fold-reassoc-1.c
@@ -7,4 +7,3 @@ double foo (double x)
 }
 
 /* { dg-final { scan-tree-dump "return 0.0;" "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/gcc.dg/fold-reassoc-2.c
+++ b/src/gcc/testsuite/gcc.dg/fold-reassoc-2.c
@@ -11,4 +11,3 @@ int bar (int i)
 }
 
 /* { dg-final { scan-tree-dump "return 1;" "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/gcc.dg/fold-reassoc-3.c
+++ b/src/gcc/testsuite/gcc.dg/fold-reassoc-3.c
@@ -14,4 +14,3 @@ foo (void)
 
 /* { dg-final { scan-tree-dump-not " - " "original" } } */
 /* { dg-final { scan-tree-dump-not " \\+ " "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/gcc.dg/fold-rotate-1.c
+++ b/src/gcc/testsuite/gcc.dg/fold-rotate-1.c
@@ -71,4 +71,3 @@ g3 (unsigned int a)
 int i;
 
 /* { dg-final { scan-tree-dump-times "&" 0 "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/gcc.dg/fold-sub.c
+++ b/src/gcc/testsuite/gcc.dg/fold-sub.c
@@ -9,4 +9,3 @@ float f(float x)
 /* Substraction should be turned into 0.  */
 
 /* { dg-final { scan-tree-dump-not " - " "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/fold-xor-1.c
+++ b/src/gcc/testsuite/gcc.dg/fold-xor-1.c
@@ -9,4 +9,3 @@ unsigned int g (unsigned int a, unsigned int b) {
   return ~a ^ ~b;
 }
 /* { dg-final { scan-tree-dump-times "a \\^ b" 2 "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/fold-xor-2.c
+++ b/src/gcc/testsuite/gcc.dg/fold-xor-2.c
@@ -13,4 +13,3 @@ unsigned int h (unsigned int a, unsigned int b) {
 }
 
 /* { dg-final { scan-tree-dump-times "b \\^ a" 3 "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/fold-xorand-1.c
+++ b/src/gcc/testsuite/gcc.dg/fold-xorand-1.c
@@ -25,5 +25,4 @@ int test4(int g, int h)
 /* { dg-final { scan-tree-dump-times "~c \& d" 1 "original" } } */
 /* { dg-final { scan-tree-dump-times "~f \& e" 1 "original" } } */
 /* { dg-final { scan-tree-dump-times "~h \& g" 1 "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
 
--- a/src/gcc/testsuite/gcc.dg/fold-xornot-1.c
+++ b/src/gcc/testsuite/gcc.dg/fold-xornot-1.c
@@ -13,4 +13,3 @@ int bar(int y)
 
 /* { dg-final { scan-tree-dump-times "x \\^ -5" 1 "original" } } */
 /* { dg-final { scan-tree-dump-times "y \\^ -5" 1 "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/gcc.dg/goacc/acc_on_device-1.c
+++ b/src/gcc/testsuite/gcc.dg/goacc/acc_on_device-1.c
@@ -17,4 +17,3 @@ f (void)
 /* Unsuitable to be handled as a builtin, so we're expecting four calls.
    { dg-final { scan-rtl-dump-times "\\\(call \[^\\n\]* acc_on_device" 4 "expand" } } */
 
-/* { dg-final { cleanup-rtl-dump "expand" } } */
--- a/src/gcc/testsuite/gcc.dg/gomp/barrier-1.c
+++ b/src/gcc/testsuite/gcc.dg/gomp/barrier-1.c
@@ -15,4 +15,3 @@ void f2(_Bool p)
 }
 
 /* { dg-final { scan-tree-dump-times "GOMP_barrier" 2 "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/gomp/combined-1.c
+++ b/src/gcc/testsuite/gcc.dg/gomp/combined-1.c
@@ -21,4 +21,3 @@ int foo (void)
 }
 
 /* { dg-final { scan-tree-dump-times "GOMP_parallel_loop_runtime" 3 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/gomp/critical-1.c
+++ b/src/gcc/testsuite/gcc.dg/gomp/critical-1.c
@@ -25,4 +25,3 @@ void foo (void)
 /* { dg-final { scan-tree-dump-times "GOMP_critical_end" 2 "ompexp" } } */
 /* { dg-final { scan-tree-dump-times "GOMP_critical_name_start" 2 "ompexp" } } */
 /* { dg-final { scan-tree-dump-times "GOMP_critical_name_end" 2 "ompexp" } } */
-/* { dg-final { cleanup-tree-dump "ompexp" } } */
--- a/src/gcc/testsuite/gcc.dg/gomp/critical-3.c
+++ b/src/gcc/testsuite/gcc.dg/gomp/critical-3.c
@@ -9,4 +9,3 @@ void foo(void)
 }
 
 // { dg-final { scan-tree-dump-times "\\&\\.gomp_critical_user_xyzzy" 2 "ompexp" } }
-// { dg-final { cleanup-tree-dump "ompexp" } }
--- a/src/gcc/testsuite/gcc.dg/gomp/empty.c
+++ b/src/gcc/testsuite/gcc.dg/gomp/empty.c
@@ -10,4 +10,3 @@ main()
 
 /* There should not be a GOMP_parallel_start call.  */
 /* { dg-final { scan-tree-dump-times "GOMP_parallel_start" 0 "ompexp"} } */
-/* { dg-final { cleanup-tree-dump "ompexp" } } */
--- a/src/gcc/testsuite/gcc.dg/gomp/flush-1.c
+++ b/src/gcc/testsuite/gcc.dg/gomp/flush-1.c
@@ -21,4 +21,3 @@ void f2(_Bool p)
 }
 
 /* { dg-final { scan-tree-dump-times "__sync_synchronize" 3 "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/gomp/for-10.c
+++ b/src/gcc/testsuite/gcc.dg/gomp/for-10.c
@@ -14,4 +14,3 @@ void foo (int n)
 
 /* { dg-final { scan-tree-dump-times "GOMP_loop_ordered_runtime_start" 1 "ompexp" } } */
 /* { dg-final { scan-tree-dump-times "GOMP_loop_ordered_runtime_next" 1 "ompexp" } } */
-/* { dg-final { cleanup-tree-dump "ompexp" } } */
--- a/src/gcc/testsuite/gcc.dg/gomp/for-13.c
+++ b/src/gcc/testsuite/gcc.dg/gomp/for-13.c
@@ -15,4 +15,3 @@ void foo(void)
 }
 
 // { dg-final { scan-tree-dump-times "omp_data_o" 0 "ompexp" } }
-// { dg-final { cleanup-tree-dump "ompexp" } }
--- a/src/gcc/testsuite/gcc.dg/gomp/for-18.c
+++ b/src/gcc/testsuite/gcc.dg/gomp/for-18.c
@@ -39,4 +39,3 @@ bar (int *a, int i)
 
 /* { dg-final { scan-tree-dump-times "GOMP_parallel_loop_dynamic_start" 4 "ompexp" { xfail *-*-* } } } */
 /* { dg-final { scan-tree-dump-times "GOMP_parallel_loop_guided_start" 4 "ompexp" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "ompexp" } } */
--- a/src/gcc/testsuite/gcc.dg/gomp/for-19.c
+++ b/src/gcc/testsuite/gcc.dg/gomp/for-19.c
@@ -18,4 +18,3 @@ void foo (int *a, int i, int j, int k, int l, int m)
 /* { dg-final { scan-tree-dump-times "shared\\(k\\)" 0 "gimple" { xfail *-*-* } } } */
 /* { dg-final { scan-tree-dump-times "shared\\(l\\)" 0 "gimple" { xfail *-*-* } } } */
 /* { dg-final { scan-tree-dump-times "shared\\(m\\)" 0 "gimple" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/gomp/for-4.c
+++ b/src/gcc/testsuite/gcc.dg/gomp/for-4.c
@@ -14,4 +14,3 @@ void foo (int n)
 
 /* { dg-final { scan-tree-dump-times "GOMP_loop_dynamic_start" 1 "ompexp" } } */
 /* { dg-final { scan-tree-dump-times "GOMP_loop_dynamic_next" 1 "ompexp" } } */
-/* { dg-final { cleanup-tree-dump "ompexp" } } */
--- a/src/gcc/testsuite/gcc.dg/gomp/for-5.c
+++ b/src/gcc/testsuite/gcc.dg/gomp/for-5.c
@@ -14,4 +14,3 @@ void foo (int n)
 
 /* { dg-final { scan-tree-dump-times "GOMP_loop_guided_start" 1 "ompexp" } } */
 /* { dg-final { scan-tree-dump-times "GOMP_loop_guided_next" 1 "ompexp" } } */
-/* { dg-final { cleanup-tree-dump "ompexp" } } */
--- a/src/gcc/testsuite/gcc.dg/gomp/for-6.c
+++ b/src/gcc/testsuite/gcc.dg/gomp/for-6.c
@@ -14,4 +14,3 @@ void foo (int n)
 
 /* { dg-final { scan-tree-dump-times "GOMP_loop_runtime_start" 1 "ompexp" } } */
 /* { dg-final { scan-tree-dump-times "GOMP_loop_runtime_next" 1 "ompexp" } } */
-/* { dg-final { cleanup-tree-dump "ompexp" } } */
--- a/src/gcc/testsuite/gcc.dg/gomp/for-7.c
+++ b/src/gcc/testsuite/gcc.dg/gomp/for-7.c
@@ -14,4 +14,3 @@ void foo (int n)
 
 /* { dg-final { scan-tree-dump-times "GOMP_loop_ordered_static_start" 1 "ompexp" } } */
 /* { dg-final { scan-tree-dump-times "GOMP_loop_ordered_static_next" 1 "ompexp" } } */
-/* { dg-final { cleanup-tree-dump "ompexp" } } */
--- a/src/gcc/testsuite/gcc.dg/gomp/for-8.c
+++ b/src/gcc/testsuite/gcc.dg/gomp/for-8.c
@@ -14,4 +14,3 @@ void foo (int n)
 
 /* { dg-final { scan-tree-dump-times "GOMP_loop_ordered_dynamic_start" 1 "ompexp" } } */
 /* { dg-final { scan-tree-dump-times "GOMP_loop_ordered_dynamic_next" 1 "ompexp" } } */
-/* { dg-final { cleanup-tree-dump "ompexp" } } */
--- a/src/gcc/testsuite/gcc.dg/gomp/for-9.c
+++ b/src/gcc/testsuite/gcc.dg/gomp/for-9.c
@@ -14,4 +14,3 @@ void foo (int n)
 
 /* { dg-final { scan-tree-dump-times "GOMP_loop_ordered_guided_start" 1 "ompexp" } } */
 /* { dg-final { scan-tree-dump-times "GOMP_loop_ordered_guided_next" 1 "ompexp" } } */
-/* { dg-final { cleanup-tree-dump "ompexp" } } */
--- a/src/gcc/testsuite/gcc.dg/gomp/macro-3.c
+++ b/src/gcc/testsuite/gcc.dg/gomp/macro-3.c
@@ -23,4 +23,3 @@ foo (void)
 }
 
 /* { dg-final { scan-tree-dump-times "#pragma omp parallel" 4 "omplower" } } */
-/* { dg-final { cleanup-tree-dump "omplower" } } */
--- a/src/gcc/testsuite/gcc.dg/gomp/master-3.c
+++ b/src/gcc/testsuite/gcc.dg/gomp/master-3.c
@@ -10,4 +10,3 @@ void foo (void)
 }
 
 /* { dg-final { scan-tree-dump-times "omp_get_thread_num" 1 "ompexp" } } */
-/* { dg-final { cleanup-tree-dump "ompexp" } } */
--- a/src/gcc/testsuite/gcc.dg/gomp/openmp-simd-1.c
+++ b/src/gcc/testsuite/gcc.dg/gomp/openmp-simd-1.c
@@ -44,4 +44,3 @@ void foo(int n, float *a, float *b)
 /* { dg-final { scan-tree-dump-not "omp teams" "original" } } */
 /* { dg-final { scan-tree-dump-not "omp target" "original" } } */
 /* { dg-final { scan-tree-dump-not "omp parallel" "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/gcc.dg/gomp/openmp-simd-2.c
+++ b/src/gcc/testsuite/gcc.dg/gomp/openmp-simd-2.c
@@ -40,4 +40,3 @@ void bar(int n, float *a, float *b)
 /* { dg-final { scan-tree-dump-times "pragma omp simd safelen\\(64\\)" 1 "original" } } */
 /* { dg-final { scan-tree-dump-not "omp parallel" "original" } } */
 /* { dg-final { scan-tree-dump-not "omp for" "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/gcc.dg/gomp/openmp-simd-3.c
+++ b/src/gcc/testsuite/gcc.dg/gomp/openmp-simd-3.c
@@ -12,4 +12,3 @@ int main() {
 }
 
 /* { dg-final { scan-tree-dump-not "omp" "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/gcc.dg/gomp/ordered-1.c
+++ b/src/gcc/testsuite/gcc.dg/gomp/ordered-1.c
@@ -17,4 +17,3 @@ void foo (void)
 
 /* { dg-final { scan-tree-dump-times "GOMP_ordered_start" 2 "ompexp" } } */
 /* { dg-final { scan-tree-dump-times "GOMP_ordered_end" 2 "ompexp" } } */
-/* { dg-final { cleanup-tree-dump "ompexp" } } */
--- a/src/gcc/testsuite/gcc.dg/gomp/pr27388-1.c
+++ b/src/gcc/testsuite/gcc.dg/gomp/pr27388-1.c
@@ -20,4 +20,3 @@ foo (void)
 
 /* { dg-final { scan-tree-dump-times "shared\\\(i\\\)" 0 "omplower" } } */
 /* { dg-final { scan-tree-dump-times "private\\\(i\\\)" 1 "omplower" } } */
-/* { dg-final { cleanup-tree-dump "omplower" } } */
--- a/src/gcc/testsuite/gcc.dg/gomp/pr27388-2.c
+++ b/src/gcc/testsuite/gcc.dg/gomp/pr27388-2.c
@@ -32,4 +32,3 @@ bar (void)
 /* { dg-final { scan-tree-dump-times "shared\\\(j\\\)\[^\\n\]*private\\\(j\\\)" 0 "omplower" } } */
 /* { dg-final { scan-tree-dump-times "private\\\(j\\\)\[^\\n\]*shared\\\(j\\\)" 0 "omplower" } } */
 /* { dg-final { scan-tree-dump-times "omp for\[^\\n\]*private\\\(j\\\)" 1 "omplower" } } */
-/* { dg-final { cleanup-tree-dump "omplower" } } */
--- a/src/gcc/testsuite/gcc.dg/gomp/pr27388-3.c
+++ b/src/gcc/testsuite/gcc.dg/gomp/pr27388-3.c
@@ -20,4 +20,3 @@ foo (void)
 }
 
 /* { dg-final { scan-tree-dump-times "omp for\[^\\n\]*private" 2 "omplower" } } */
-/* { dg-final { cleanup-tree-dump "omplower" } } */
--- a/src/gcc/testsuite/gcc.dg/gomp/pr32468-1.c
+++ b/src/gcc/testsuite/gcc.dg/gomp/pr32468-1.c
@@ -97,4 +97,3 @@ f6 (void)
 /* There should not be a GOMP_parallel_{loop,sections}* call.  */
 /* { dg-final { scan-tree-dump-times "GOMP_parallel_loop" 0 "ompexp"} } */
 /* { dg-final { scan-tree-dump-times "GOMP_parallel_sections" 0 "ompexp"} } */
-/* { dg-final { cleanup-tree-dump "ompexp" } } */
--- a/src/gcc/testsuite/gcc.dg/gomp/pr34692.c
+++ b/src/gcc/testsuite/gcc.dg/gomp/pr34692.c
@@ -25,4 +25,3 @@ cde f g h);
   }
 }
 
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/gomp/simd-clones-1.c
+++ b/src/gcc/testsuite/gcc.dg/gomp/simd-clones-1.c
@@ -30,4 +30,3 @@ void fillit(int *tot)
 }
 
 /* { dg-final { scan-tree-dump-not "special_add.constprop" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/gomp/simd-clones-2.c
+++ b/src/gcc/testsuite/gcc.dg/gomp/simd-clones-2.c
@@ -23,4 +23,3 @@ float setArray(float *a, float x, int k)
 /* { dg-final { scan-tree-dump "_ZGVdN8ua32vl_setArray" "optimized" { target i?86-*-* x86_64-*-* } } } */
 /* { dg-final { scan-tree-dump "_ZGVdN8vvva32_addit" "optimized" { target i?86-*-* x86_64-*-* } } } */
 /* { dg-final { scan-tree-dump "_ZGVdM8vl66u_addit" "optimized" { target i?86-*-* x86_64-*-* } } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/gomp/simd-clones-3.c
+++ b/src/gcc/testsuite/gcc.dg/gomp/simd-clones-3.c
@@ -15,4 +15,3 @@ int addit(int a, int b, int c)
 /* { dg-final { scan-tree-dump "_ZGVcM4vvv_addit" "optimized" { target i?86-*-* x86_64-*-* } } } */
 /* { dg-final { scan-tree-dump "_ZGVdN8vvv_addit" "optimized" { target i?86-*-* x86_64-*-* } } } */
 /* { dg-final { scan-tree-dump "_ZGVdM8vvv_addit" "optimized" { target i?86-*-* x86_64-*-* } } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/block-0.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/block-0.c
@@ -43,4 +43,3 @@ main (void)
 }
 
 /* { dg-final { scan-tree-dump-not "will be loop blocked" "graphite" } } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/block-1.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/block-1.c
@@ -46,4 +46,3 @@ main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "will be loop blocked" 3 "graphite" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/block-3.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/block-3.c
@@ -59,4 +59,3 @@ main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "will be loop blocked" 1 "graphite" } } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/block-4.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/block-4.c
@@ -58,4 +58,3 @@ main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "will be loop blocked" 1 "graphite" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/block-5.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/block-5.c
@@ -54,4 +54,3 @@ main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "will be loop blocked" 1 "graphite" } } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/block-6.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/block-6.c
@@ -49,4 +49,3 @@ main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "will be loop blocked" 0 "graphite" } } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/block-7.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/block-7.c
@@ -55,4 +55,3 @@ main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "will be loop blocked" 1 "graphite" } } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/block-8.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/block-8.c
@@ -56,4 +56,3 @@ main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "will be loop blocked" 1 "graphite" } } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/block-pr47654.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/block-pr47654.c
@@ -22,4 +22,3 @@ main ()
 }
 
 /* { dg-final { scan-tree-dump-not "will be loop blocked" "graphite" } } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/interchange-0.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/interchange-0.c
@@ -47,4 +47,3 @@ main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "will be interchanged" 1 "graphite" } } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/interchange-1.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/interchange-1.c
@@ -50,4 +50,3 @@ main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "will be interchanged" 1 "graphite" } } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/interchange-10.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/interchange-10.c
@@ -47,4 +47,3 @@ main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "will be interchanged" 2 "graphite" } } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/interchange-11.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/interchange-11.c
@@ -47,4 +47,3 @@ main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "will be interchanged" 1 "graphite" } } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/interchange-12.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/interchange-12.c
@@ -54,4 +54,3 @@ main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "will be interchanged" 1 "graphite" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/interchange-13.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/interchange-13.c
@@ -51,4 +51,3 @@ main (void)
 
 
 /* { dg-final { scan-tree-dump-times "will be interchanged" 1 "graphite" } } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/interchange-14.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/interchange-14.c
@@ -56,4 +56,3 @@ main (void)
 
 /* PRE destroys the perfect nest and we can't cope with that yet.  */
 /* { dg-final { scan-tree-dump-times "will be interchanged" 1 "graphite" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/interchange-15.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/interchange-15.c
@@ -50,5 +50,4 @@ main (void)
 
 /* PRE destroys the perfect nest and we can't cope with that yet.  */
 /* { dg-final { scan-tree-dump-times "will be interchanged" 1 "graphite" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
 
--- a/src/gcc/testsuite/gcc.dg/graphite/interchange-16.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/interchange-16.c
@@ -19,4 +19,3 @@ void spread_i1 (int *rptr, int *sptr, int ncopies, int *extent, int rdelta, int
 
 int main() { return 0; }
 
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/interchange-2.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/interchange-2.c
@@ -53,4 +53,3 @@ main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "will be interchanged" 1 "graphite" { xfail *-*-* } } } */ 
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/interchange-3.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/interchange-3.c
@@ -48,4 +48,3 @@ main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "will be interchanged" 1 "graphite" } } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/interchange-4.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/interchange-4.c
@@ -47,4 +47,3 @@ main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "will be interchanged" 1 "graphite" } } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/interchange-5.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/interchange-5.c
@@ -47,4 +47,3 @@ main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "will be interchanged" 1 "graphite" } } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/interchange-6.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/interchange-6.c
@@ -48,4 +48,3 @@ main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "will be interchanged" 1 "graphite" } } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/interchange-7.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/interchange-7.c
@@ -47,4 +47,3 @@ main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "will be interchanged" 1 "graphite" } } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/interchange-8.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/interchange-8.c
@@ -83,4 +83,3 @@ main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "will be interchanged" 2 "graphite" } } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/interchange-9.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/interchange-9.c
@@ -45,4 +45,3 @@ main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "will be interchanged" 1 "graphite" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/interchange-mvt.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/interchange-mvt.c
@@ -60,5 +60,4 @@ main (void)
 
 /* PRE destroys the perfect nest and we can't cope with that yet.  */
 /* { dg-final { scan-tree-dump-times "will be interchanged" 1 "graphite" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
 
--- a/src/gcc/testsuite/gcc.dg/graphite/isl-codegen-loop-dumping.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/isl-codegen-loop-dumping.c
@@ -13,4 +13,3 @@ main (int n, int *a)
 }
 
 /* { dg-final { scan-tree-dump-times "ISL AST generated by ISL: \nfor \\(int c1 = 0; c1 < n - 1; c1 \\+= 1\\)\n  for \\(int c3 = 0; c3 < n; c3 \\+= 1\\)\n    S_4\\(c1, c3\\);" 1 "graphite"} } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/pr35356-1.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/pr35356-1.c
@@ -23,4 +23,3 @@ foo (int bar, int n, int k)
 */
 
 /* { dg-final { scan-tree-dump-times "loop_1" 0 "graphite" } } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/pr35356-2.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/pr35356-2.c
@@ -39,4 +39,3 @@ foo (int bar, int n, int k)
 */
 
 /* { dg-final { scan-tree-dump-times "for\[^\n\]+\n\[^\n\]+if" 0 "graphite" } } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/pr35356-3.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/pr35356-3.c
@@ -37,4 +37,3 @@ match (void)
    for such cases.  */
 
 /* { dg-final { scan-tree-dump-times "loop_1" 0 "graphite" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/pr37485.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/pr37485.c
@@ -31,4 +31,3 @@ void fallbackSort ( UInt32* fmap,
    AssertH ( j < 256, 1005 );
 }
 /* { dg-final { scan-tree-dump-times "Loop blocked" 1 "graphite" { xfail *-*-* }} } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/pr37684.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/pr37684.c
@@ -64,4 +64,3 @@ int BZ2_bzCompressInit
    prepare_new_block ( s );
 }
 
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/pr37943.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/pr37943.c
@@ -29,5 +29,4 @@ unsigned char compress(test *in)
    }
    return p_in || p_out;
 }
-/* { dg-final { cleanup-tree-dump "graphite" } } */
 
--- a/src/gcc/testsuite/gcc.dg/graphite/scop-0.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/scop-0.c
@@ -18,5 +18,4 @@ int toto()
 }
 
 /* { dg-final { scan-tree-dump-times "number of SCoPs: 1" 1 "graphite"} } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
 
--- a/src/gcc/testsuite/gcc.dg/graphite/scop-1.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/scop-1.c
@@ -28,4 +28,3 @@ int toto()
 }
 
 /* { dg-final { scan-tree-dump-times "number of SCoPs: 3" 1 "graphite"} } */ 
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/scop-10.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/scop-10.c
@@ -28,4 +28,3 @@ int toto()
 }
 
 /* { dg-final { scan-tree-dump-times "number of SCoPs: 3" 1 "graphite"} } */ 
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/scop-11.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/scop-11.c
@@ -29,4 +29,3 @@ int toto()
 }
 
 /* { dg-final { scan-tree-dump-times "number of SCoPs: 3" 1 "graphite"} } */ 
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/scop-12.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/scop-12.c
@@ -33,4 +33,3 @@ int toto()
 }
 
 /* { dg-final { scan-tree-dump-times "number of SCoPs: 5" 1 "graphite"} } */ 
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/scop-13.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/scop-13.c
@@ -38,4 +38,3 @@ int toto()
 }
 
 /* { dg-final { scan-tree-dump-times "number of SCoPs: 2" 1 "graphite"} } */ 
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/scop-14.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/scop-14.c
@@ -22,4 +22,3 @@ int toto()
 }
 
 /* { dg-final { scan-tree-dump-times "number of SCoPs: 0" 1 "graphite"} } */ 
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/scop-15.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/scop-15.c
@@ -48,4 +48,3 @@ int longest_match(IPos cur_match)
 }
 
 /* { dg-final { scan-tree-dump-times "number of SCoPs: 0" 1 "graphite"} } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/scop-16.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/scop-16.c
@@ -22,4 +22,3 @@ int test ()
 }
 
 /* { dg-final { scan-tree-dump-times "number of SCoPs: 2" 1 "graphite"} } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/scop-17.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/scop-17.c
@@ -21,4 +21,3 @@ int test ()
 }
 
 /* { dg-final { scan-tree-dump-times "number of SCoPs: 2" 1 "graphite"} } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/scop-18.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/scop-18.c
@@ -23,4 +23,3 @@ void test (void)
 }
 
 /* { dg-final { scan-tree-dump-times "number of SCoPs: 2" 1 "graphite"} } */ 
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/scop-19.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/scop-19.c
@@ -33,5 +33,4 @@ d_growable_string_append_buffer (struct d_growable_string *dgs,
 }
 /* { dg-final { scan-tree-dump-times "number of SCoPs: 0" 2 "graphite" { target nonpic } } } */
 /* { dg-final { scan-tree-dump-times "number of SCoPs: 0" 1 "graphite" { target { ! nonpic } } } } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
 
--- a/src/gcc/testsuite/gcc.dg/graphite/scop-2.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/scop-2.c
@@ -36,4 +36,3 @@ int toto()
 }
 
 /* { dg-final { scan-tree-dump-times "number of SCoPs: 4" 1 "graphite"} } */ 
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/scop-20.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/scop-20.c
@@ -24,4 +24,3 @@ int toto()
 }
 
 /* { dg-final { scan-tree-dump-times "number of SCoPs: 2" 1 "graphite" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/scop-21.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/scop-21.c
@@ -28,4 +28,3 @@ int test ()
   return a[20];
 }
 /* { dg-final { scan-tree-dump-times "number of SCoPs: 1" 1 "graphite"} } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/scop-22.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/scop-22.c
@@ -18,4 +18,3 @@ void foo(int N, int *res)
 }
 
 /* { dg-final { scan-tree-dump-times "number of SCoPs: 1" 1 "graphite"} } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/scop-3.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/scop-3.c
@@ -25,4 +25,3 @@ int toto()
 }
 
 /* { dg-final { scan-tree-dump-times "number of SCoPs: 1" 1 "graphite"} } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/scop-4.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/scop-4.c
@@ -26,4 +26,3 @@ int toto()
 }
 
 /* { dg-final { scan-tree-dump-times "number of SCoPs: 2" 1 "graphite"} } */ 
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/scop-5.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/scop-5.c
@@ -32,4 +32,3 @@ int toto()
 }
 
 /* { dg-final { scan-tree-dump-times "number of SCoPs: 3" 1 "graphite"} } */ 
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/scop-6.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/scop-6.c
@@ -28,4 +28,3 @@ int toto()
 }
 
 /* { dg-final { scan-tree-dump-times "number of SCoPs: 3" 1 "graphite"} } */ 
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/scop-7.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/scop-7.c
@@ -28,4 +28,3 @@ int toto()
 }
 
 /* { dg-final { scan-tree-dump-times "number of SCoPs: 3" 1 "graphite"} } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/scop-8.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/scop-8.c
@@ -28,4 +28,3 @@ int toto()
 }
 
 /* { dg-final { scan-tree-dump-times "number of SCoPs: 2" 1 "graphite"} } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/scop-9.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/scop-9.c
@@ -24,4 +24,3 @@ int toto()
 }
 
 /* { dg-final { scan-tree-dump-times "number of SCoPs: 2" 1 "graphite"} } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/scop-dsyr2k.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/scop-dsyr2k.c
@@ -17,5 +17,4 @@ void dsyr2k(long N) {
 }
 
 /* { dg-final { scan-tree-dump-times "number of SCoPs: 1" 1 "graphite"} } */ 
-/* { dg-final { cleanup-tree-dump "graphite" } } */
 
--- a/src/gcc/testsuite/gcc.dg/graphite/scop-dsyrk.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/scop-dsyrk.c
@@ -19,4 +19,3 @@ void dsyrk(long N)
 }
 
 /* { dg-final { scan-tree-dump-times "number of SCoPs: 1" 1 "graphite" } } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/scop-matmult.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/scop-matmult.c
@@ -17,4 +17,3 @@ void matmult (int n)
 /* This one fails because the number of iterations cannot be
    determined anymore for the outermost loop.  */
 /* { dg-final { scan-tree-dump-times "number of SCoPs: 1" 1 "graphite" } } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/scop-mvt.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/scop-mvt.c
@@ -20,5 +20,4 @@ void mvt(long N) {
 }
 
 /* { dg-final { scan-tree-dump-times "number of SCoPs: 2" 1 "graphite" } } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
 
--- a/src/gcc/testsuite/gcc.dg/graphite/scop-sor.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/scop-sor.c
@@ -15,4 +15,3 @@ void sor(int N1, int N2){
 }
 
 /* { dg-final { scan-tree-dump-times "number of SCoPs: 1" 1 "graphite" } } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/uns-block-1.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/uns-block-1.c
@@ -46,4 +46,3 @@ main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "will be loop blocked" 3 "graphite" } } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/uns-interchange-12.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/uns-interchange-12.c
@@ -55,4 +55,3 @@ main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "will be interchanged" 1 "graphite" } } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/uns-interchange-14.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/uns-interchange-14.c
@@ -57,4 +57,3 @@ main (void)
 
 /* PRE destroys the perfect nest and we can't cope with that yet.  */
 /* { dg-final { scan-tree-dump-times "will be interchanged" 1 "graphite" } } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/uns-interchange-15.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/uns-interchange-15.c
@@ -51,5 +51,3 @@ main (void)
 
 /* PRE destroys the perfect nest and we can't cope with that yet.  */
 /* { dg-final { scan-tree-dump-times "will be interchanged" 1 "graphite" } } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
-
--- a/src/gcc/testsuite/gcc.dg/graphite/uns-interchange-9.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/uns-interchange-9.c
@@ -46,4 +46,3 @@ main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "will be interchanged" 1 "graphite" } } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
--- a/src/gcc/testsuite/gcc.dg/graphite/uns-interchange-mvt.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/uns-interchange-mvt.c
@@ -61,5 +61,3 @@ main (void)
 
 /* PRE destroys the perfect nest and we can't cope with that yet.  */
 /* { dg-final { scan-tree-dump-times "will be interchanged" 1 "graphite" } } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
-
--- a/src/gcc/testsuite/gcc.dg/graphite/vect-pr43423.c
+++ b/src/gcc/testsuite/gcc.dg/graphite/vect-pr43423.c
@@ -16,4 +16,3 @@ void foo(int n, int mid)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 2 loops" 1 "vect" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/hoist-register-pressure-1.c
+++ b/src/gcc/testsuite/gcc.dg/hoist-register-pressure-1.c
@@ -4,7 +4,6 @@
    requires a load address instruction which is fine on 64 bit but
    cannot be used on 31 bit since it does a 31 bit add only.  */
 /* { dg-final { scan-rtl-dump "PRE/HOIST: end of bb .* copying expression" "hoist" { target { { !s390*-*-* || lp64 } && nonpic } } } } */
-/* { dg-final { cleanup-rtl-dump "hoist" } } */
 
 #define BUF 100
 long a[BUF];
--- a/src/gcc/testsuite/gcc.dg/hoist-register-pressure-2.c
+++ b/src/gcc/testsuite/gcc.dg/hoist-register-pressure-2.c
@@ -4,7 +4,6 @@
    requires a load address instruction which is fine on 64 bit but
    cannot be used on 31 bit since it does a 31 bit add only.  */
 /* { dg-final { scan-rtl-dump "PRE/HOIST: end of bb .* copying expression" "hoist" { target { !s390*-*-* || lp64 } } } } */
-/* { dg-final { cleanup-rtl-dump "hoist" } } */
 
 #define BUF 100
 long a[BUF];
--- a/src/gcc/testsuite/gcc.dg/hoist-register-pressure-3.c
+++ b/src/gcc/testsuite/gcc.dg/hoist-register-pressure-3.c
@@ -4,7 +4,6 @@
    requires a load address instruction which is fine on 64 bit but
    cannot be used on 31 bit since it does a 31 bit add only.  */
 /* { dg-final { scan-rtl-dump "PRE/HOIST: end of bb .* copying expression" "hoist" { target { !s390*-*-* || lp64 } } } } */
-/* { dg-final { cleanup-rtl-dump "hoist" } } */
 
 #define BUF 100
 long a[BUF];
--- a/src/gcc/testsuite/gcc.dg/inline-33.c
+++ b/src/gcc/testsuite/gcc.dg/inline-33.c
@@ -20,4 +20,3 @@ int foo (i)
 }
 
 /* { dg-final { scan-tree-dump-times "bar"  2 "optimized"  } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/inline-36.c
+++ b/src/gcc/testsuite/gcc.dg/inline-36.c
@@ -19,4 +19,3 @@ int foo2 (void)
 }
 
 /* { dg-final { scan-tree-dump-times "bar" 5 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/inline-37.c
+++ b/src/gcc/testsuite/gcc.dg/inline-37.c
@@ -19,4 +19,3 @@ int foo2 (void)
 }
 
 /* { dg-final { scan-tree-dump-times "bar" 5 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/inline-38.c
+++ b/src/gcc/testsuite/gcc.dg/inline-38.c
@@ -19,4 +19,3 @@ int foo2 (void)
 }
 
 /* { dg-final { scan-tree-dump-times "bar" 5 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/inline-39.c
+++ b/src/gcc/testsuite/gcc.dg/inline-39.c
@@ -20,4 +20,3 @@ int foo2 (void)
 }
 
 /* { dg-final { scan-tree-dump-times "bar" 4 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/PR64550.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/PR64550.c
@@ -72,4 +72,3 @@ int main()
 }
 
 /* { dg-final { scan-ipa-dump "Equal symbols: 0" "icf"  } } */
-/* { dg-final { cleanup-ipa-dump "icf" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/PR65282.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/PR65282.c
@@ -17,4 +17,3 @@ main ()
 }
 
 /* { dg-final { scan-ipa-dump "Equal symbols: 0" "icf"  } } */
-/* { dg-final { cleanup-ipa-dump "icf" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ctor-empty-1.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ctor-empty-1.c
@@ -5,4 +5,3 @@ void empty_constructor()
 {
 }
 /* { dg-final { scan-ipa-dump "Reclaiming functions: empty_constructor"  "free-inline-summary"  } } */
-/* { dg-final { cleanup-ipa-dump "free-inline-summary" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/iinline-1.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/iinline-1.c
@@ -24,4 +24,3 @@ int test (void)
 
 /* { dg-final { scan-ipa-dump "indirect_call"  "inline"  } } */
 /* { dg-final { scan-ipa-dump "hooray\[^\\n\]*inline copy in test"  "inline"  } } */
-/* { dg-final { cleanup-ipa-dump "inline" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/iinline-2.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/iinline-2.c
@@ -38,4 +38,3 @@ int main (int argc, int *argv[])
 
 /* { dg-final { scan-ipa-dump "hooray\[^\\n\]*inline copy in main" "inline"  } } */
 /* { dg-final { scan-ipa-dump "hip2\[^\\n\]*inline copy in main" "inline"  } } */
-/* { dg-final { cleanup-ipa-dump "inline" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/iinline-4.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/iinline-4.c
@@ -218,4 +218,3 @@ int test7 (void)
 /* { dg-final { scan-ipa-dump "hooray5\[^\\n\]*inline copy in test5"  "inline"  } } */
 /* { dg-final { scan-ipa-dump "hooray6\[^\\n\]*inline copy in test6"  "inline"  } } */
 /* { dg-final { scan-ipa-dump "hooray7\[^\\n\]*inline copy in test7"  "inline"  } } */
-/* { dg-final { cleanup-ipa-dump "inline" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/iinline-5.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/iinline-5.c
@@ -121,4 +121,3 @@ int main (int argc, char **argv)
 
 
 /* { dg-final { scan-ipa-dump-not "wrong_target\[^\\n\]*inline copy in" "inline"  } } */
-/* { dg-final { cleanup-ipa-dump "inline" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/iinline-6.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/iinline-6.c
@@ -69,4 +69,3 @@ int main (int argc, char **argv)
 
 
 /* { dg-final { scan-ipa-dump-not "wrong_target\[^\\n\]*inline copy in" "inline"  } } */
-/* { dg-final { cleanup-ipa-dump "inline" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/iinline-7.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/iinline-7.c
@@ -154,4 +154,3 @@ int main (int argc, char **argv)
 
 
 /* { dg-final { scan-ipa-dump-not "wrong_target\[^\\n\]*inline copy in" "inline"  } } */
-/* { dg-final { cleanup-ipa-dump "inline" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/inline-1.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/inline-1.c
@@ -34,4 +34,3 @@ void foo (int invariant, struct bah invariant2)
 /* op7 change.  */
 /* { dg-final { scan-ipa-dump-not "op7 is compile time invariant"  "inline"  } } */
 /* { dg-final { scan-ipa-dump-not "op7 change"  "inline"  } } */
-/* { dg-final { cleanup-ipa-dump "inline" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/inline-2.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/inline-2.c
@@ -31,4 +31,3 @@ void foo (int invariant)
 /* { dg-final { scan-ipa-dump "op2 change 10.000000. of time"  "inline"  } } */
 /* After inlining bar into foo, op3 is invariant within both loops.  */
 /* { dg-final { scan-ipa-dump "op3 change 1.000000. of time"  "inline"  } } */
-/* { dg-final { cleanup-ipa-dump "inline" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/inline-3.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/inline-3.c
@@ -22,4 +22,3 @@ int foo (int invariant)
 
 
 /* { dg-final { scan-ipa-dump "Scaling time by probability:0.100000"  "inline"  } } */
-/* { dg-final { cleanup-ipa-dump "inline" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/inline-4.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/inline-4.c
@@ -29,4 +29,3 @@ int foo (int invariant)
 /* { dg-final { scan-ipa-dump "Inlined 1 calls, eliminated 0 functions"  "inline"  } } */
 /* Call to work_hard should be detected as optimized out.  */
 /* { dg-final { scan-ipa-dump-times "predicate: .false." 8 "inline"  } } */
-/* { dg-final { cleanup-ipa-dump "inline" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/inline-5.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/inline-5.c
@@ -36,4 +36,3 @@ accessreference (struct a *a)
 
 /* { dg-final { scan-ipa-dump-times "Will be eliminated" 4 "inline" { xfail { { hppa*-*-* } && { ! lp64 } } } } } */
 /* { dg-final { scan-ipa-dump-times "50. will be eliminated" 1 "inline"  } } */
-/* { dg-final { cleanup-ipa-dump "inline" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/inline-6.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/inline-6.c
@@ -45,4 +45,3 @@ main()
 } 
 /* Even if function is huge, inlining it will save code.  */
 /* { dg-final { scan-ipa-dump-times "Inlined into" 2 "inline"  } } */
-/* { dg-final { cleanup-ipa-dump "inline" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/inline-7.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/inline-7.c
@@ -22,4 +22,3 @@ m()
  a(0);
 }
 /* { dg-final { scan-tree-dump-times "Inlining a into m" 1 "einline"  } } */
-/* { dg-final { cleanup-tree-dump "einline" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/inlinehint-1.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/inlinehint-1.c
@@ -18,4 +18,3 @@ m()
   test (10);
 }
 /* { dg-final { scan-ipa-dump "loop_iterations"  "inline"  } } */
-/* { dg-final { cleanup-ipa-dump "inline" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/inlinehint-2.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/inlinehint-2.c
@@ -14,4 +14,3 @@ m(void **p)
   t (10, p);
 }
 /* { dg-final { scan-ipa-dump "loop_stride"  "inline"  } } */
-/* { dg-final { cleanup-ipa-dump "inline" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/inlinehint-3.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/inlinehint-3.c
@@ -38,4 +38,3 @@ main()
 /* { dg-final { scan-ipa-dump "same_scc"  "inline"  } } */
 /* Main is not in scc, the two functions are.  */
 /* { dg-final { scan-ipa-dump-times "In SCC" 2 "inline"  } } */
-/* { dg-final { cleanup-ipa-dump "inline" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/inlinehint-4.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/inlinehint-4.c
@@ -37,4 +37,3 @@ test (int i)
 /* { dg-final { scan-ipa-dump "Wrapper penalty"  "inline"  } } */
 /* { dg-final { scan-ipa-dump-not "Inlining lookup_slow to lookup"  "inline"  } } */
 /* { dg-final { scan-ipa-dump "Inlining lookup to test"  "inline"  } } */
-/* { dg-final { cleanup-ipa-dump "inline" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-1.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-1.c
@@ -26,6 +26,5 @@ int main ()
 
 /* { dg-final { scan-ipa-dump "Creating a specialized node of f" "cp" } } */
 /* { dg-final { scan-ipa-dump "replacing param .0 a with const 7" "cp"  } } */
-/* { dg-final { cleanup-ipa-dump "cp" } } */
 
 
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-2.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-2.c
@@ -24,4 +24,3 @@ int main ()
 
 /* { dg-final { scan-ipa-dump "Creating a specialized node of f" "cp" } } */
 /* { dg-final { scan-ipa-dump "replacing param .0 a with const 7" "cp"  } } */
-/* { dg-final { cleanup-ipa-dump "cp" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-3.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-3.c
@@ -33,4 +33,3 @@ int main ()
 /* { dg-final { scan-ipa-dump "Creating a specialized node of g" "cp" } } */
 /* { dg-final { scan-ipa-dump "replacing param .0 b with const 7" "cp"  } } */
 /* { dg-final { scan-ipa-dump "replacing param .1 c with const 3" "cp"  } } */
-/* { dg-final { cleanup-ipa-dump "cp" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-4.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-4.c
@@ -27,4 +27,3 @@ int main ()
 
 /* { dg-final { scan-ipa-dump "Creating a specialized node of f" "cp"  } } */
 /* { dg-final { scan-ipa-dump-times "replacing param .0 a with const 7" 1 "cp"  } } */
-/* { dg-final { cleanup-ipa-dump "cp" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-5.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-5.c
@@ -30,4 +30,3 @@ int main ()
 /* { dg-final { scan-ipa-dump-times "Creating a specialized node" 3 "cp"  } } */
 /* { dg-final { scan-ipa-dump "replacing param .1 c with const 3" "cp"  } } */
 /* { dg-final { scan-ipa-dump "replacing param .0 a with const 7" "cp"  } } */
-/* { dg-final { cleanup-ipa-dump "cp" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-7.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-7.c
@@ -28,6 +28,5 @@ int main ()
 
 /* { dg-final { scan-ipa-dump "Creating a specialized node of f" "cp" } } */
 /* { dg-final { scan-ipa-dump-times "replacing param .. . with const 7" 1 "cp" } } */
-/* { dg-final { cleanup-ipa-dump "cp" } } */
 
 
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-8.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-8.c
@@ -26,6 +26,5 @@ int main ()
 /* { dg-final { scan-ipa-dump "replacing param .0 a with const 7" "cp"  } } */
 /* { dg-final { scan-ipa-dump "Creating a specialized node of g" "cp" } } */
 /* { dg-final { scan-ipa-dump "replacing param .0 b with const 7" "cp"  } } */
-/* { dg-final { cleanup-ipa-dump "cp" } } */
 
 
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-clone-1.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-clone-1.c
@@ -17,4 +17,3 @@ bar (int arg)
 
 /* { dg-final { scan-assembler "test_section" } } */
 /* { dg-final { scan-ipa-dump "Creating a specialized node of foo" "cp" } } */
-/* { dg-final { cleanup-ipa-dump "cp" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-1.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-1.c
@@ -58,4 +58,3 @@ int main(int argc, char **argv)
 
 /* { dg-final { scan-ipa-dump "Semantic equality hit:x2->x1" "icf"  } } */
 /* { dg-final { scan-ipa-dump "Equal symbols: 1" "icf"  } } */
-/* { dg-final { cleanup-ipa-dump "icf" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-10.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-10.c
@@ -31,4 +31,3 @@ int main(int argc, char **argv)
 
 /* { dg-final { scan-ipa-dump "Semantic equality hit:funkce->ferda" "icf"  } } */
 /* { dg-final { scan-ipa-dump "Equal symbols: 1" "icf"  } } */
-/* { dg-final { cleanup-ipa-dump "icf" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-11.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-11.c
@@ -26,4 +26,3 @@ int main(int argc, char **argv)
 
 /* { dg-final { scan-ipa-dump "Semantic equality hit:f1->f0" "icf"  } } */
 /* { dg-final { scan-ipa-dump "Equal symbols: 1" "icf"  } } */
-/* { dg-final { cleanup-ipa-dump "icf" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-12.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-12.c
@@ -75,4 +75,3 @@ int main(int argc, char **argv)
 
 /* { dg-final { scan-ipa-dump "Semantic equality hit:nsd->gcd" "icf"  } } */
 /* { dg-final { scan-ipa-dump "Equal symbols: 1" "icf"  } } */
-/* { dg-final { cleanup-ipa-dump "icf" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-13.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-13.c
@@ -191,4 +191,3 @@ int main(int argc, char **argv)
 /* { dg-final { scan-ipa-dump "Semantic equality hit:nsd_different_result2->nsd_different_result" "icf"  } } */
 /* { dg-final { scan-ipa-dump "Semantic equality hit:nsd->gcd" "icf"  } } */
 /* { dg-final { scan-ipa-dump "Equal symbols: 3" "icf"  } } */
-/* { dg-final { cleanup-ipa-dump "icf" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-14.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-14.c
@@ -44,4 +44,3 @@ int main(int argc, char **argv)
 
 /* { dg-final { scan-ipa-dump-not "Semantic equality hit:" "icf"  } } */
 /* { dg-final { scan-ipa-dump "Equal symbols: 0" "icf"  } } */
-/* { dg-final { cleanup-ipa-dump "icf" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-15.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-15.c
@@ -43,4 +43,3 @@ int main(int argc, char **argv)
 }
 
 /* { dg-final { scan-ipa-dump "Equal symbols: 0" "icf"  } } */
-/* { dg-final { cleanup-ipa-dump "icf" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-16.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-16.c
@@ -24,4 +24,3 @@ int main()
 
 /* { dg-final { scan-ipa-dump "Semantic equality hit:bar->foo" "icf"  } } */
 /* { dg-final { scan-ipa-dump "Equal symbols: 1" "icf"  } } */
-/* { dg-final { cleanup-ipa-dump "icf" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-17.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-17.c
@@ -34,4 +34,3 @@ int main()
 
 /* { dg-final { scan-ipa-dump-not "Semantic equality hit:" "icf"  } } */
 /* { dg-final { scan-ipa-dump "Equal symbols: 0" "icf"  } } */
-/* { dg-final { cleanup-ipa-dump "icf" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-18.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-18.c
@@ -34,4 +34,3 @@ int main()
 
 /* { dg-final { scan-ipa-dump "Semantic equality hit:bar->foo" "icf"  } } */
 /* { dg-final { scan-ipa-dump "Equal symbols: 1" "icf"  } } */
-/* { dg-final { cleanup-ipa-dump "icf" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-19.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-19.c
@@ -34,4 +34,3 @@ int main()
 
 /* { dg-final { scan-ipa-dump-not "Semantic equality hit:" "icf"  } } */
 /* { dg-final { scan-ipa-dump "Equal symbols: 0" "icf"  } } */
-/* { dg-final { cleanup-ipa-dump "icf" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-2.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-2.c
@@ -66,4 +66,3 @@ int main(int argc, char **argv)
 
 /* { dg-final { scan-ipa-dump "Semantic equality hit:f2->f1" "icf"  } } */
 /* { dg-final { scan-ipa-dump "Equal symbols: 1" "icf"  } } */
-/* { dg-final { cleanup-ipa-dump "icf" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-20.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-20.c
@@ -25,4 +25,3 @@ int main()
 
 /* { dg-final { scan-ipa-dump "Semantic equality hit:bar->foo" "icf"  } } */
 /* { dg-final { scan-ipa-dump "Equal symbols: 1" "icf"  } } */
-/* { dg-final { cleanup-ipa-dump "icf" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-21.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-21.c
@@ -24,4 +24,3 @@ int main()
 
 /* { dg-final { scan-ipa-dump "Semantic equality hit:bar->foo" "icf"  } } */
 /* { dg-final { scan-ipa-dump "Equal symbols: 1" "icf"  } } */
-/* { dg-final { cleanup-ipa-dump "icf" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-22.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-22.c
@@ -34,4 +34,3 @@ int main()
 
 /* { dg-final { scan-ipa-dump-not "Semantic equality hit:" "icf"  } } */
 /* { dg-final { scan-ipa-dump "Equal symbols: 0" "icf"  } } */
-/* { dg-final { cleanup-ipa-dump "icf" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-23.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-23.c
@@ -26,4 +26,3 @@ int main()
 
 /* { dg-final { scan-ipa-dump "Semantic equality hit:bar->foo" "icf"  } } */
 /* { dg-final { scan-ipa-dump "Equal symbols: 1" "icf"  } } */
-/* { dg-final { cleanup-ipa-dump "icf" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-24.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-24.c
@@ -33,4 +33,3 @@ int main()
 }
 
 /* { dg-final { scan-ipa-dump "Equal symbols: 0" "icf"  } } */
-/* { dg-final { cleanup-ipa-dump "icf" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-25.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-25.c
@@ -49,4 +49,3 @@ int main()
 /* { dg-final { scan-ipa-dump "Semantic equality hit:bar->foo" "icf"  } } */
 /* { dg-final { scan-ipa-dump "Semantic equality hit:zap->zip" "icf"  } } */
 /* { dg-final { scan-ipa-dump "Equal symbols: 2" "icf"  } } */
-/* { dg-final { cleanup-ipa-dump "icf" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-26.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-26.c
@@ -40,4 +40,3 @@ int main()
 
 /* { dg-final { scan-ipa-dump "Semantic equality hit:remove->destroy" "icf"  } } */
 /* { dg-final { scan-ipa-dump "Equal symbols: 1" "icf"  } } */
-/* { dg-final { cleanup-ipa-dump "icf" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-27.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-27.c
@@ -27,4 +27,3 @@ int main()
 
 /* { dg-final { scan-ipa-dump "Semantic equality hit:remove->destroy" "icf"  } } */
 /* { dg-final { scan-ipa-dump "Equal symbols: 1" "icf"  } } */
-/* { dg-final { cleanup-ipa-dump "icf" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-28.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-28.c
@@ -21,4 +21,3 @@ int main()
 }
 /* { dg-final { scan-ipa-dump "Equal symbols: 0" "icf"  } } */
 /* { dg-final { scan-ipa-dump "attribute values are different" "icf"  } } */
-/* { dg-final { cleanup-ipa-dump "icf" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-29.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-29.c
@@ -27,4 +27,3 @@ int main()
 }
 
 /* { dg-final { scan-ipa-dump "Equal symbols: 0" "icf"  } } */
-/* { dg-final { cleanup-ipa-dump "icf" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-3.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-3.c
@@ -33,4 +33,3 @@ int main()
 
 /* { dg-final { scan-ipa-dump "Semantic equality hit:bar->foo" "icf"  } } */
 /* { dg-final { scan-ipa-dump "Equal symbols: 1" "icf"  } } */
-/* { dg-final { cleanup-ipa-dump "icf" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-30.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-30.c
@@ -27,4 +27,3 @@ int main()
 }
 
 /* { dg-final { scan-ipa-dump "Equal symbols: 1" "icf"  } } */
-/* { dg-final { cleanup-ipa-dump "icf" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-32.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-32.c
@@ -21,4 +21,3 @@ int main()
 
 /* { dg-final { scan-ipa-dump "optimization flags are different" "icf"  } } */
 /* { dg-final { scan-ipa-dump "Equal symbols: 0" "icf"  } } */
-/* { dg-final { cleanup-ipa-dump "icf" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-33.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-33.c
@@ -23,4 +23,3 @@ int main()
 }
 
 /* { dg-final { scan-ipa-dump "Equal symbols: 1" "icf"  } } */
-/* { dg-final { cleanup-ipa-dump "icf" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-34.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-34.c
@@ -26,4 +26,3 @@ int main()
 }
 
 /* { dg-final { scan-ipa-dump "Equal symbols: 1" "icf"  } } */
-/* { dg-final { cleanup-ipa-dump "icf" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-35.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-35.c
@@ -28,4 +28,3 @@ int main()
 /* { dg-final { scan-ipa-dump "Semantic equality hit:f2->f1" "icf"  } } */
 /* { dg-final { scan-ipa-dump "Semantic equality hit:d->c" "icf"  } } */
 /* { dg-final { scan-ipa-dump "Semantic equality hit:b->a" "icf"  } } */
-/* { dg-final { cleanup-ipa-dump "icf" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-36.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-36.c
@@ -34,4 +34,3 @@ int t(int tt)
 /* { dg-final { scan-ipa-dump "Semantic equality hit:f->e" "icf"  } } */
 /* { dg-final { scan-ipa-dump "Semantic equality hit:h->g" "icf"  } } */
 /* { dg-final { scan-ipa-dump "Semantic equality hit:k->i" "icf"  } } */
-/* { dg-final { cleanup-ipa-dump "icf" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-37.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-37.c
@@ -34,4 +34,3 @@ int t(int tt)
 /* { dg-final { scan-ipa-dump "Semantic equality hit:f->e" "icf"  } } */
 /* { dg-final { scan-ipa-dump "Semantic equality hit:h->g" "icf"  } } */
 /* { dg-final { scan-ipa-dump "Semantic equality hit:j->i" "icf"  } } */
-/* { dg-final { cleanup-ipa-dump "icf" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-4.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-4.c
@@ -29,4 +29,3 @@ int main(int argc, char **argv)
 
 /* { dg-final { scan-ipa-dump-not "Semantic equality hit:" "icf"  } } */
 /* { dg-final { scan-ipa-dump "Equal symbols: 0" "icf"  } } */
-/* { dg-final { cleanup-ipa-dump "icf" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-5.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-5.c
@@ -53,4 +53,3 @@ int main()
 
 /* { dg-final { scan-ipa-dump "Semantic equality hit:f2->f1" "icf"  } } */
 /* { dg-final { scan-ipa-dump "Equal symbols: 1" "icf"  } } */
-/* { dg-final { cleanup-ipa-dump "icf" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-6.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-6.c
@@ -33,4 +33,3 @@ int main()
 
 /* { dg-final { scan-ipa-dump-not "Semantic equality hit:" "icf"  } } */
 /* { dg-final { scan-ipa-dump "Equal symbols: 0" "icf"  } } */
-/* { dg-final { cleanup-ipa-dump "icf" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-7.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-7.c
@@ -70,4 +70,3 @@ int main()
 
 /* { dg-final { scan-ipa-dump "Semantic equality hit:foo2->foo" "icf"  } } */
 /* { dg-final { scan-ipa-dump "Equal symbols: 1" "icf"  } } */
-/* { dg-final { cleanup-ipa-dump "icf" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-8.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-8.c
@@ -42,4 +42,3 @@ int main(int argc, char **argv)
 
 /* { dg-final { scan-ipa-dump "Semantic equality hit:fce2->fce1" "icf"  } } */
 /* { dg-final { scan-ipa-dump "Equal symbols: 1" "icf"  } } */
-/* { dg-final { cleanup-ipa-dump "icf" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-9.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-icf-9.c
@@ -30,4 +30,3 @@ int main(int argc, char **argv)
 
 /* { dg-final { scan-ipa-dump-not "Semantic equality hit:" "icf"  } } */
 /* { dg-final { scan-ipa-dump "Equal symbols: 0" "icf"  } } */
-/* { dg-final { cleanup-ipa-dump "icf" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-pta-1.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-pta-1.c
@@ -47,4 +47,3 @@ int main()
 /* { dg-final { scan-ipa-dump "bar.arg1 = { a }" "pta" } } */
 /* { dg-final { scan-ipa-dump "foo.arg0 = { a }" "pta" } } */
 /* { dg-final { scan-ipa-dump "foo.arg1 = { a }" "pta" } } */
-/* { dg-final { cleanup-ipa-dump "pta" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-pta-10.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-pta-10.c
@@ -27,4 +27,3 @@ int main()
    stuff through it.  */
 
 /* { dg-final { scan-ipa-dump "ESCAPED = { (ESCAPED )?(NONLOCAL )?}" "pta" } } */
-/* { dg-final { cleanup-ipa-dump "pta" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-pta-11.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-pta-11.c
@@ -33,4 +33,3 @@ int main()
    we should have i, r and s in ESCAPED as well.  */
 
 /* { dg-final { scan-ipa-dump "ESCAPED = { ESCAPED NONLOCAL l k }" "pta" } } */
-/* { dg-final { cleanup-ipa-dump "pta" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-pta-13.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-pta-13.c
@@ -58,5 +58,3 @@ int main()
   return x;
 }
 
-/* { dg-final { cleanup-ipa-dump "pta" } } */
-/* { dg-final { cleanup-tree-dump "fre2" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-pta-14.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-pta-14.c
@@ -29,4 +29,3 @@ int main()
   return 0;
 }
 
-/* { dg-final { cleanup-ipa-dump "pta" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-pta-16.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-pta-16.c
@@ -30,4 +30,3 @@ int main()
 }
 
 /* { dg-final { scan-ipa-dump "y.\[0-9\]*\\\+\[0-9\]* = { i }" "pta" } } */
-/* { dg-final { cleanup-ipa-dump "pta" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-pta-2.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-pta-2.c
@@ -22,4 +22,3 @@ int main()
    are properly adjusted.  */
 
 /* { dg-final { scan-ipa-dump "foo.arg0 = { ESCAPED NONLOCAL }" "pta" } } */
-/* { dg-final { cleanup-ipa-dump "pta" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-pta-3.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-pta-3.c
@@ -24,5 +24,3 @@ int main()
 /* { dg-final { scan-ipa-dump "foo.arg0 = &a" "pta" } } */
 /* { dg-final { scan-ipa-dump "foo.arg1 = &b" "pta" } } */
 /* { dg-final { scan-tree-dump "Replaced \\\*p_2\\\(D\\\) with 1" "fre2" } } */
-/* { dg-final { cleanup-tree-dump "fre2" } } */
-/* { dg-final { cleanup-ipa-dump "pta" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-pta-4.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-pta-4.c
@@ -29,5 +29,3 @@ int main()
 /* { dg-final { scan-ipa-dump "foo.arg0 = &a" "pta" } } */
 /* { dg-final { scan-ipa-dump "foo.arg1 = &b" "pta" } } */
 /* { dg-final { scan-tree-dump "Replaced \\\*p_2\\\(D\\\) with 1" "fre2" } } */
-/* { dg-final { cleanup-tree-dump "fre2" } } */
-/* { dg-final { cleanup-ipa-dump "pta" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-pta-5.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-pta-5.c
@@ -23,4 +23,3 @@ int main()
   return 0;
 }
 
-/* { dg-final { cleanup-ipa-dump "pta" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-pta-6.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-pta-6.c
@@ -22,4 +22,3 @@ int main()
    still properly account for the store via *p in foo.  */
 
 /* { dg-final { scan-ipa-dump "ESCAPED = { }" "pta" } } */
-/* { dg-final { cleanup-ipa-dump "pta" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-sra-1.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-sra-1.c
@@ -37,4 +37,3 @@ main (int argc, char *argv[])
 }
 
 /* { dg-final { scan-tree-dump-times "About to replace expr" 2 "eipa_sra" } } */
-/* { dg-final { cleanup-tree-dump "eipa_sra" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-sra-2.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-sra-2.c
@@ -49,4 +49,3 @@ int main (int argc, char *argv[])
 /* { dg-final { scan-tree-dump "About to replace expr cow_.*D.->green with ISRA" "eipa_sra"  } } */
 /* { dg-final { scan-tree-dump "About to replace expr calf_.*D.->red with \\*ISRA" "eipa_sra"  } } */
 /* { dg-final { scan-tree-dump "About to replace expr calf_.*D.->green with ISRA" "eipa_sra"  } } */
-/* { dg-final { cleanup-tree-dump "eipa_sra" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-sra-3.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-sra-3.c
@@ -36,4 +36,3 @@ void caller (void)
 
 /* { dg-final { scan-tree-dump "base: z, remove_param" "eipa_sra"  } } */
 /* { dg-final { scan-tree-dump "base: calf, remove_param" "eipa_sra"  } } */
-/* { dg-final { cleanup-tree-dump "eipa_sra" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-sra-4.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-sra-4.c
@@ -65,4 +65,3 @@ void caller (void)
 /* { dg-final { scan-tree-dump "About to replace expr \\*l_.*D. with ISRA" "eipa_sra"  } } */
 /* { dg-final { scan-tree-dump-times "About to replace expr \*j_.*D. with ISRA" 0 "eipa_sra"  } } */
 /* { dg-final { scan-tree-dump-times "About to replace expr \*k_.*D. with ISRA" 0 "eipa_sra"  } } */
-/* { dg-final { cleanup-tree-dump "eipa_sra" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-sra-5.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-sra-5.c
@@ -17,4 +17,3 @@ int *caller (void)
   return ox (&a, &b);
 }
 /* { dg-final { scan-tree-dump-times "base: j, remove_param" 0 "eipa_sra"  } } */
-/* { dg-final { cleanup-tree-dump "eipa_sra" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-sra-6.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-sra-6.c
@@ -31,4 +31,3 @@ int main (int argc, char *argv[])
 }
 
 /* { dg-final { scan-tree-dump-times "foo " 1 "eipa_sra"  } } */
-/* { dg-final { cleanup-tree-dump "eipa_sra" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipacost-1.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipacost-1.c
@@ -58,5 +58,3 @@ main()
 /* { dg-final { scan-ipa-dump-not "Creating a specialized node of i_can_not_be_propagated_fully/" "cp"  } } */
 /* { dg-final { scan-tree-dump-not "i_can_be_propagated_fully " "optimized"  } } */
 /* { dg-final { scan-tree-dump-not "i_can_be_propagated_fully2 " "optimized"  } } */
-/* { dg-final { cleanup-ipa-dump "cp" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipacost-2.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipacost-2.c
@@ -77,5 +77,3 @@ main()
 /* { dg-final { scan-ipa-dump-not "Creating a specialized node of i_can_not_be_propagated_fully/" "cp"  } } */
 /* { dg-final { scan-tree-dump-not "i_can_be_propagated_fully \\(" "optimized"  } } */
 /* { dg-final { scan-tree-dump-not "i_can_be_propagated_fully2 \\(" "optimized"  } } */
-/* { dg-final { cleanup-ipa-dump "cp" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipcp-1.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipcp-1.c
@@ -47,6 +47,5 @@ main (int argc, char *argv[])
 
 /* { dg-final { scan-ipa-dump "Creating a specialized node of f.*for all known contexts" "cp" } } */
 /* { dg-final { scan-ipa-dump "replacing param .0 a with const 7" "cp"  } } */
-/* { dg-final { cleanup-ipa-dump "cp" } } */
 
 
--- a/src/gcc/testsuite/gcc.dg/ipa/ipcp-2.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipcp-2.c
@@ -96,4 +96,3 @@ top2 (int q)
 /* { dg-final { scan-ipa-dump-times "Creating a specialized node of foo" 1 "cp" } } */
 /* { dg-final { scan-ipa-dump-times "replacing param .. p with const 0" 3 "cp"  } } */
 /* { dg-final { scan-ipa-dump "replacing param .0 s with const 4" "cp"  } } */
-/* { dg-final { cleanup-ipa-dump "cp" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipcp-3.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipcp-3.c
@@ -66,5 +66,4 @@ int main()
 
 
 /* { dg-final { scan-ipa-dump "Creating a specialized node of mark_cell" "cp" } } */
-/* { dg-final { cleanup-ipa-dump "cp" } } */
 
--- a/src/gcc/testsuite/gcc.dg/ipa/ipcp-4.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipcp-4.c
@@ -63,6 +63,5 @@ main (int argc, char *argv[])
 /* { dg-final { scan-ipa-dump-not "Creating a specialized node of h.*for all known contexts" "cp" } } */
 /* { dg-final { scan-ipa-dump-times "replacing param .0 a with const 7" 2 "cp"  } } */
 /* { dg-final { scan-ipa-dump "replacing param .0 a with const 11" "cp"  } } */
-/* { dg-final { cleanup-ipa-dump "cp" } } */
 
 
--- a/src/gcc/testsuite/gcc.dg/ipa/ipcp-agg-1.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipcp-agg-1.c
@@ -32,6 +32,4 @@ entry (void)
 
 /* { dg-final { scan-ipa-dump "Creating a specialized node of foo.*for all known contexts" "cp" } } */
 /* { dg-final { scan-ipa-dump-times "Aggregate replacements:" 2 "cp" } } */
-/* { dg-final { cleanup-ipa-dump "cp" } } */
 /* { dg-final { scan-tree-dump-not "->c;" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipcp-agg-2.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipcp-agg-2.c
@@ -38,6 +38,4 @@ entry (int c)
 }
 /* { dg-final { scan-ipa-dump-times "Creating a specialized node of foo/\[0-9\]*\\." 2 "cp" } } */
 /* { dg-final { scan-ipa-dump-times "Aggregate replacements:" 4 "cp" } } */
-/* { dg-final { cleanup-ipa-dump "cp" } } */
 /* { dg-final { scan-tree-dump-not "->c;" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipcp-agg-3.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipcp-agg-3.c
@@ -39,6 +39,4 @@ entry (int c)
 /* { dg-final { scan-ipa-dump-times "Creating a specialized node of foo/\[0-9\]*\\." 2 "cp" } } */
 /* { dg-final { scan-ipa-dump-times "Aggregate replacements: 1" 2 "cp" } } */
 /* { dg-final { scan-ipa-dump-times "Aggregate replacements: 0" 2 "cp" } } */
-/* { dg-final { cleanup-ipa-dump "cp" } } */
 /* { dg-final { scan-tree-dump-not "->c;" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipcp-agg-4.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipcp-agg-4.c
@@ -57,6 +57,4 @@ entry2 (int c)
 
 /* { dg-final { scan-ipa-dump-times "Creating a specialized node of foo/\[0-9\]*\\." 2 "cp" } } */
 /* { dg-final { scan-ipa-dump-times "Aggregate replacements:" 4 "cp" } } */
-/* { dg-final { cleanup-ipa-dump "cp" } } */
 /* { dg-final { scan-tree-dump-not "->c;" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipcp-agg-5.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipcp-agg-5.c
@@ -63,6 +63,4 @@ entry2 (int c)
 /* { dg-final { scan-ipa-dump-times "Creating a specialized node of foo/\[0-9\]*\\." 2 "cp" } } */
 /* { dg-final { scan-ipa-dump-times "Creating a specialized node of bar/\[0-9\]*\\." 2 "cp" } } */
 /* { dg-final { scan-ipa-dump-times "Aggregate replacements:" 8 "cp" } } */
-/* { dg-final { cleanup-ipa-dump "cp" } } */
 /* { dg-final { scan-tree-dump-not "->c;" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipcp-agg-6.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipcp-agg-6.c
@@ -70,6 +70,4 @@ entry2 (int c)
 /* { dg-final { scan-ipa-dump-times "Creating a specialized node of bar/\[0-9\]*\\." 2 "cp" } } */
 /* { dg-final { scan-ipa-dump "Creating a specialized node of bar_2.*for all known contexts" "cp" } } */
 /* { dg-final { scan-ipa-dump-times "Aggregate replacements:" 10 "cp" } } */
-/* { dg-final { cleanup-ipa-dump "cp" } } */
 /* { dg-final { scan-tree-dump-not "->c;" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipcp-agg-7.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipcp-agg-7.c
@@ -49,6 +49,4 @@ entry (int c)
 }
 /* { dg-final { scan-ipa-dump-times "Clone of bar" 1 "cp" } } */
 /* { dg-final { scan-ipa-dump-times "Clone of foo" 1 "cp" } } */
-/* { dg-final { cleanup-ipa-dump "cp" } } */
 /* { dg-final { scan-tree-dump-not "->c;" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipcp-agg-8.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipcp-agg-8.c
@@ -49,4 +49,3 @@ entry (int c)
     }
 }
 /* { dg-final { scan-tree-dump "->b;" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipcp-agg-9.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipcp-agg-9.c
@@ -41,5 +41,3 @@ int test1 (void)
 
 /* { dg-final { scan-ipa-dump "ipa-prop: Discovered an indirect call to a known target"  "cp"  } } */
 /* { dg-final { scan-ipa-dump "hooray1\[^\\n\]*inline copy in hiphip1"  "inline"  } } */
-/* { dg-final { cleanup-ipa-dump "cp" } } */
-/* { dg-final { cleanup-ipa-dump "inline" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/ipcp-ii-1.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipcp-ii-1.c
@@ -31,4 +31,3 @@ int main (int argc, int *argv[])
 }
 
 /* { dg-final { scan-ipa-dump "hooray\[^\\n\]*inline copy in hiphip.constprop"  "inline"  } } */
-/* { dg-final { cleanup-ipa-dump "inline" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/noclone-1.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/noclone-1.c
@@ -26,4 +26,3 @@ int main ()
 
 
 /* { dg-final { scan-ipa-dump-times "versioned function" 0 "cp"  } } */
-/* { dg-final { cleanup-ipa-dump "cp" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/pr63569.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/pr63569.c
@@ -28,4 +28,3 @@ int h(int t, int *a)
 }
 
 /* { dg-final { scan-ipa-dump "Equal symbols: 0" "icf"  } } */
-/* { dg-final { cleanup-ipa-dump "icf" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/pr63595.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/pr63595.c
@@ -62,4 +62,3 @@ int main()
 
 /* { dg-final { scan-ipa-dump "Equal symbols: 0" "icf"  } } */
 /* { dg-final { scan-ipa-dump "PHI results are different" "icf"  } } */
-/* { dg-final { cleanup-ipa-dump "icf" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/pr63747.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/pr63747.c
@@ -37,4 +37,3 @@ int main()
 }
 
 /* { dg-final { scan-ipa-dump "Equal symbols: 0" "icf"  } } */
-/* { dg-final { cleanup-ipa-dump "icf" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/pr64307.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/pr64307.c
@@ -29,4 +29,3 @@ int main()
 
 /* { dg-final { scan-ipa-dump "Semantic equality hit:real_part_2->real_part" "icf"  } } */
 /* { dg-final { scan-ipa-dump "Equal symbols: 1" "icf"  } } */
-/* { dg-final { cleanup-ipa-dump "icf" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/pr65318.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/pr65318.c
@@ -15,4 +15,3 @@ main ()
 }
 
 /* { dg-final { scan-ipa-dump "Equal symbols: 0" "icf"  } } */
-/* { dg-final { cleanup-ipa-dump "icf" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/propalign-1.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/propalign-1.c
@@ -28,5 +28,3 @@ bar (void)
 
 /* { dg-final { scan-ipa-dump "Adjusting alignment of param" "cp" } } */
 /* { dg-final { scan-tree-dump-not "fail_the_test" "optimized" } } */
-/* { dg-final { cleanup-ipa-dump "cp" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/propalign-2.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/propalign-2.c
@@ -54,5 +54,3 @@ bar2 (void)
 
 /* { dg-final { scan-ipa-dump "Adjusting alignment of param" "cp" } } */
 /* { dg-final { scan-tree-dump-not "fail_the_test" "optimized" } } */
-/* { dg-final { cleanup-ipa-dump "cp" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/propalign-3.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/propalign-3.c
@@ -54,5 +54,3 @@ bar2 (void)
 
 /* { dg-final { scan-ipa-dump-not "Adjusting alignment of param" "cp" } } */
 /* { dg-final { scan-tree-dump "fail_the_test" "optimized" } } */
-/* { dg-final { cleanup-ipa-dump "cp" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/pure-const-1.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/pure-const-1.c
@@ -75,7 +75,4 @@ test()
 /* { dg-final { scan-tree-dump "found to be looping pure: i_am_pure4" "local-pure-const1"} } */
 /* { dg-final { scan-ipa-dump "found to be const: i_am_const2" "pure-const"} } */
 /* { dg-final { scan-ipa-dump "found to be const: i_am_const3" "pure-const"} } */
-/* { dg-final { cleanup-tree-dump "local-pure-const1" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
-/* { dg-final { cleanup-ipa-dump "pure-const" } } */
 
--- a/src/gcc/testsuite/gcc.dg/ipa/pure-const-2.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/pure-const-2.c
@@ -26,5 +26,3 @@ main(void)
 }
 /* { dg-final { scan-tree-dump "found to be pure: i_am_pure" "local-pure-const1"} } */
 /* { dg-final { scan-tree-dump-not "i_am_pure" "optimized"} } */
-/* { dg-final { cleanup-tree-dump "local-pure-const1" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/remref-0.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/remref-0.c
@@ -26,5 +26,3 @@ int main (void)
 
 /* { dg-final { scan-ipa-dump "ipa-prop: Removed a reference"  "inline"  } } */
 /* { dg-final { scan-tree-dump-not "hooray"  "optimized"  } } */
-/* { dg-final { cleanup-ipa-dump "inline" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/remref-1a.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/remref-1a.c
@@ -30,5 +30,3 @@ int main (void)
 
 /* { dg-final { scan-ipa-dump "ipa-prop: Removed a reference"  "inline"  } } */
 /* { dg-final { scan-tree-dump-not "hooray"  "optimized"  } } */
-/* { dg-final { cleanup-ipa-dump "inline" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/remref-1b.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/remref-1b.c
@@ -32,6 +32,3 @@ int main (void)
 /* { dg-final { scan-ipa-dump "removing its cloning-created reference"  "cp"  } } */
 /* { dg-final { scan-ipa-dump "ipa-prop: Removed a reference"  "inline"  } } */
 /* { dg-final { scan-tree-dump-not "hooray"  "optimized"  } } */
-/* { dg-final { cleanup-ipa-dump "cp" } } */
-/* { dg-final { cleanup-ipa-dump "inline" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/remref-2a.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/remref-2a.c
@@ -86,5 +86,3 @@ main (int argc, int *argv[])
 
 /* { dg-final { scan-ipa-dump-times "ipa-prop: Removed a reference" 2 "inline"  } } */
 /* { dg-final { scan-tree-dump-not "hooray"  "optimized"  } } */
-/* { dg-final { cleanup-ipa-dump "inline" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/ipa/remref-2b.c
+++ b/src/gcc/testsuite/gcc.dg/ipa/remref-2b.c
@@ -89,6 +89,3 @@ main (int argc, int *argv[])
 /* { dg-final { scan-ipa-dump "ipa-prop: Removed a reference"  "inline"  } } */
 /* { dg-final { scan-ipa-dump-times "ipa-prop: Removing cloning-created reference" 2 "inline"  } } */
 /* { dg-final { scan-tree-dump-not "hooray"  "optimized"  } } */
-/* { dg-final { cleanup-ipa-dump "cp" } } */
-/* { dg-final { cleanup-ipa-dump "inline" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/ira-loop-pressure.c
+++ b/src/gcc/testsuite/gcc.dg/ira-loop-pressure.c
@@ -28,5 +28,4 @@ int foo (int a, int b, int c, int d)
 }
 
 /* { dg-final { scan-rtl-dump "Decided to move invariant" "loop2_invariant"  } } */
-/* { dg-final { cleanup-rtl-dump "loop2_invariant" } } */
 
--- a/src/gcc/testsuite/gcc.dg/ira-shrinkwrap-prep-1.c
+++ b/src/gcc/testsuite/gcc.dg/ira-shrinkwrap-prep-1.c
@@ -27,5 +27,3 @@ bar (long a)
 /* { dg-final { scan-rtl-dump "Will split live ranges of parameters" "ira"  } } */
 /* { dg-final { scan-rtl-dump "Split live-range of register" "ira"  } } */
 /* { dg-final { scan-rtl-dump "Performing shrink-wrapping" "pro_and_epilogue"  } } */
-/* { dg-final { cleanup-rtl-dump "ira" } } */
-/* { dg-final { cleanup-rtl-dump "pro_and_epilogue" } } */
--- a/src/gcc/testsuite/gcc.dg/ira-shrinkwrap-prep-2.c
+++ b/src/gcc/testsuite/gcc.dg/ira-shrinkwrap-prep-2.c
@@ -32,5 +32,3 @@ bar (long a)
 /* { dg-final { scan-rtl-dump "Will split live ranges of parameters" "ira"  } } */
 /* { dg-final { scan-rtl-dump "Split live-range of register" "ira"  } } */
 /* { dg-final { scan-rtl-dump "Performing shrink-wrapping" "pro_and_epilogue"  } } */
-/* { dg-final { cleanup-rtl-dump "ira" } } */
-/* { dg-final { cleanup-rtl-dump "pro_and_epilogue" } } */
--- a/src/gcc/testsuite/gcc.dg/loop-7.c
+++ b/src/gcc/testsuite/gcc.dg/loop-7.c
@@ -12,5 +12,4 @@ void f(int *a)
 
 /* Load of 0 is moved out of the loop.  */
 /* { dg-final { scan-rtl-dump-times "Decided" 1 "loop2_invariant" } } */
-/* { dg-final { cleanup-rtl-dump "loop2_invariant" } } */
 
--- /dev/null
+++ b/src/gcc/testsuite/gcc.dg/loop-8.c
@@ -0,0 +1,23 @@
+/* { dg-do compile } */
+/* { dg-options "-O1 -fdump-rtl-loop2_invariant" } */
+
+void
+f (int *a, int *b)
+{
+  int i;
+
+  for (i = 0; i < 100; i++)
+    {
+      int d = 42;
+
+      a[i] = d;
+      if (i % 2)
+	d = i;
+      b[i] = d;
+    }
+}
+
+/* Load of 42 is moved out of the loop, introducing a new pseudo register.  */
+/* { dg-final { scan-rtl-dump-times "Decided" 1 "loop2_invariant" } } */
+/* { dg-final { scan-rtl-dump-not "without introducing a new temporary register" "loop2_invariant" } } */
+
--- /dev/null
+++ b/src/gcc/testsuite/gcc.dg/loop-9.c
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+/* { dg-options "-O1 -fdump-rtl-loop2_invariant" } */
+
+void
+f (double *a)
+{
+  int i;
+  for (i = 0; i < 100; i++)
+    a[i] = 18.4242;
+}
+
+/* Load of x is moved out of the loop.  */
+/* { dg-final { scan-rtl-dump "Decided" "loop2_invariant" } } */
+/* { dg-final { scan-rtl-dump "without introducing a new temporary register" "loop2_invariant" } } */
+
--- /dev/null
+++ b/src/gcc/testsuite/gcc.dg/loop-invariant.c
@@ -0,0 +1,42 @@
+/* { dg-do compile { target x86_64-*-* } } */
+/* { dg-options "-O2 -fdump-rtl-loop2_invariant" } */
+/* NOTE: The target list above could be extended to other targets that have
+         conditional moves, but don't have zero registers.  */
+
+enum test_type
+{
+  TYPE0,
+  TYPE1
+};
+
+struct type_node
+{
+  enum test_type type;
+};
+
+struct test_ref
+{
+  struct type_node *referring;
+};
+
+struct test_node
+{
+  struct test_node *next;
+};
+
+int iterate (struct test_node *, unsigned, struct test_ref **);
+
+int
+loop_invar (struct test_node *node)
+{
+  struct test_ref *ref;
+
+  for (unsigned i = 0; iterate (node, i, &ref); i++)
+    if (loop_invar ((ref->referring && ref->referring->type == TYPE0)
+                    ? ((struct test_node *) (ref->referring)) : 0))
+      return 1;
+
+  return 0;
+}
+
+/* { dg-final { scan-rtl-dump "Decided to move invariant" "loop2_invariant" } } */
--- a/src/gcc/testsuite/gcc.dg/lower-subreg-1.c
+++ b/src/gcc/testsuite/gcc.dg/lower-subreg-1.c
@@ -6,4 +6,3 @@
 long long test (long long a, long long b) { return a | b; }
 
 /* { dg-final { scan-rtl-dump "Splitting reg" "subreg1" } } */
-/* { dg-final { cleanup-rtl-dump "subreg1" } } */
--- a/src/gcc/testsuite/gcc.dg/macro-fusion-1.c
+++ b/src/gcc/testsuite/gcc.dg/macro-fusion-1.c
@@ -12,4 +12,3 @@ double bar (double sum)
 }
 
 /* { dg-final { scan-rtl-dump-not "compare.*insn.*jump_insn.*jump_insn" "sched2" } } */
-/* { dg-final { cleanup-rtl-dump "sched2" } } */
--- a/src/gcc/testsuite/gcc.dg/macro-fusion-2.c
+++ b/src/gcc/testsuite/gcc.dg/macro-fusion-2.c
@@ -15,4 +15,3 @@ double bar (double sum)
 }
 
 /* { dg-final { scan-rtl-dump-not "compare.*insn.*jump_insn.*jump_insn" "sched2" } } */
-/* { dg-final { cleanup-rtl-dump "sched2" } } */
--- a/src/gcc/testsuite/gcc.dg/memcpy-1.c
+++ b/src/gcc/testsuite/gcc.dg/memcpy-1.c
@@ -2,7 +2,6 @@
 /* { dg-options "-O2 -fdump-tree-optimized" } */
 /* PR36598 AVR fail maybe due to cost metrics */
 /* { dg-final { scan-tree-dump-times "nasty_local\\." 0 "optimized" { xfail { "avr-*-*" } } } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 struct a {int a,b,c;} a;
 int test(struct a a)
 {
--- a/src/gcc/testsuite/gcc.dg/memcpy-3.c
+++ b/src/gcc/testsuite/gcc.dg/memcpy-3.c
@@ -11,4 +11,3 @@ int get_int(const void *p)
 
 /* { dg-final { scan-tree-dump-not "memcpy" "optimized" } } */
 /* { dg-final { scan-tree-dump-times "MEM" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/memcpy-4.c
+++ b/src/gcc/testsuite/gcc.dg/memcpy-4.c
@@ -11,4 +11,3 @@ f1 (char *p)
 }
 
 /* { dg-final { scan-rtl-dump "mem/u.*mem/u" "expand" { target mips*-*-* } } } */
-/* { dg-final { cleanup-rtl-dump "expand" } } */
--- a/src/gcc/testsuite/gcc.dg/memcpy-5.c
+++ b/src/gcc/testsuite/gcc.dg/memcpy-5.c
@@ -25,4 +25,3 @@ TEST (d64d, double __attribute__((vector_size (64))));
 TEST (d128d, double __attribute__((vector_size (128))));
 
 /* { dg-final { scan-tree-dump-not "memcpy" "optimized" { target i?86-*-* x86_64-*-* } } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/memmove-1.c
+++ b/src/gcc/testsuite/gcc.dg/memmove-1.c
@@ -1,7 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-O2 -fdump-tree-optimized" } */
 /* { dg-final { scan-tree-dump-times "memmove" 0 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 static const char a[100]={1,2,3,4};
 char b[1000];
 int i,i1;
--- a/src/gcc/testsuite/gcc.dg/memmove-2.c
+++ b/src/gcc/testsuite/gcc.dg/memmove-2.c
@@ -1,7 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-O2 -fdump-tree-optimized" } */
 /* { dg-final { scan-tree-dump-times "memmove" 0 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
 char a[40];
 extern void bar (char *);
--- a/src/gcc/testsuite/gcc.dg/memmove-3.c
+++ b/src/gcc/testsuite/gcc.dg/memmove-3.c
@@ -1,7 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-O2 -fdump-tree-optimized" } */
 /* { dg-final { scan-tree-dump-times "memmove" 3 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
 char a[40];
 struct A { char a[30]; };
--- a/src/gcc/testsuite/gcc.dg/memmove-4.c
+++ b/src/gcc/testsuite/gcc.dg/memmove-4.c
@@ -9,4 +9,3 @@ void b(char *a, char *b, int i)
 }
 
 /* { dg-final { scan-tree-dump-not "memmove" "optimized" { xfail { ! non_strict_align } } } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/minmax-1.c
+++ b/src/gcc/testsuite/gcc.dg/minmax-1.c
@@ -80,4 +80,3 @@ int main(void)
 
 /* { dg-final { scan-tree-dump-times "MIN_EXPR" 0 "original"} } */
 /* { dg-final { scan-tree-dump-times "MAX_EXPR" 0 "original"} } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/gcc.dg/nested-func-7.c
+++ b/src/gcc/testsuite/gcc.dg/nested-func-7.c
@@ -12,4 +12,3 @@ void foo (void)
 }
 
 /* { dg-final { scan-tree-dump-not "bar" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/no-strict-overflow-1.c
+++ b/src/gcc/testsuite/gcc.dg/no-strict-overflow-1.c
@@ -13,4 +13,3 @@ foo (int i)
 }
 
 /* { dg-final { scan-tree-dump "-[ ]*5" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/no-strict-overflow-2.c
+++ b/src/gcc/testsuite/gcc.dg/no-strict-overflow-2.c
@@ -13,4 +13,3 @@ foo (int i)
 }
 
 /* { dg-final { scan-tree-dump "100" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/no-strict-overflow-3.c
+++ b/src/gcc/testsuite/gcc.dg/no-strict-overflow-3.c
@@ -13,4 +13,3 @@ foo (int i, int j)
 }
 
 /* { dg-final { scan-tree-dump "1000" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/no-strict-overflow-4.c
+++ b/src/gcc/testsuite/gcc.dg/no-strict-overflow-4.c
@@ -13,4 +13,3 @@ foo (int i)
 }
 
 /* { dg-final { scan-tree-dump "\[^ \]*_.(\\\(D\\\))? (>|<) \[^ \]*_." "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/no-strict-overflow-5.c
+++ b/src/gcc/testsuite/gcc.dg/no-strict-overflow-5.c
@@ -17,4 +17,3 @@ int foo (int i)
 }
 
 /* { dg-final { scan-tree-dump-times "r = 3" 0 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/no-strict-overflow-6.c
+++ b/src/gcc/testsuite/gcc.dg/no-strict-overflow-6.c
@@ -18,4 +18,3 @@ foo ()
 }
 
 /* { dg-final { scan-tree-dump "return bits" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/no-strict-overflow-7.c
+++ b/src/gcc/testsuite/gcc.dg/no-strict-overflow-7.c
@@ -13,4 +13,3 @@ foo (char* p)
 }
 
 /* { dg-final { scan-tree-dump "\[+\]\[ \]*1000" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/no-strict-overflow-8.c
+++ b/src/gcc/testsuite/gcc.dg/no-strict-overflow-8.c
@@ -22,4 +22,3 @@ foo (struct c *p)
 }
 
 /* { dg-final { scan-tree-dump "i_.* > 0" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/nrv3.c
+++ b/src/gcc/testsuite/gcc.dg/nrv3.c
@@ -32,4 +32,3 @@ void foo (void)
 }
 
 /* { dg-final { scan-tree-dump-times "return slot optimization" 2 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/nrv4.c
+++ b/src/gcc/testsuite/gcc.dg/nrv4.c
@@ -29,5 +29,4 @@ void foo (void)
 }
 
 /* { dg-final { scan-tree-dump-times "return slot optimization" 0 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
--- a/src/gcc/testsuite/gcc.dg/nrv5.c
+++ b/src/gcc/testsuite/gcc.dg/nrv5.c
@@ -25,4 +25,3 @@ void foo (void)
 }
 
 /* { dg-final { scan-tree-dump-times "return slot optimization" 0 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/optimize-bswapdi-1.c
+++ b/src/gcc/testsuite/gcc.dg/optimize-bswapdi-1.c
@@ -58,4 +58,3 @@ swap64_c (uint64_t x)
 
 
 /* { dg-final { scan-tree-dump-times "64 bit bswap implementation found at" 3 "bswap" } } */
-/* { dg-final { cleanup-tree-dump "bswap" } } */
--- a/src/gcc/testsuite/gcc.dg/optimize-bswapdi-2.c
+++ b/src/gcc/testsuite/gcc.dg/optimize-bswapdi-2.c
@@ -23,4 +23,3 @@ swap64_c (uint64_t x)
 
 
 /* { dg-final { scan-tree-dump-times "64 bit bswap implementation found at" 1 "bswap" } } */
-/* { dg-final { cleanup-tree-dump "bswap" } } */
--- a/src/gcc/testsuite/gcc.dg/optimize-bswapdi-3.c
+++ b/src/gcc/testsuite/gcc.dg/optimize-bswapdi-3.c
@@ -61,4 +61,3 @@ uint64_t read_be64_3 (unsigned char *data)
 
 /* { dg-final { scan-tree-dump-times "64 bit load in target endianness found at" 3 "bswap" } } */
 /* { dg-final { scan-tree-dump-times "64 bit bswap implementation found at" 3 "bswap" { xfail alpha*-*-* arm*-*-* } } } */
-/* { dg-final { cleanup-tree-dump "bswap" } } */
--- a/src/gcc/testsuite/gcc.dg/optimize-bswaphi-1.c
+++ b/src/gcc/testsuite/gcc.dg/optimize-bswaphi-1.c
@@ -57,4 +57,3 @@ swap16 (HItype in)
 /* { dg-final { scan-tree-dump-times "16 bit load in target endianness found at" 3 "bswap" } } */
 /* { dg-final { scan-tree-dump-times "16 bit bswap implementation found at" 1 "bswap" { target alpha*-*-* arm*-*-* } } } */
 /* { dg-final { scan-tree-dump-times "16 bit bswap implementation found at" 4 "bswap" { xfail alpha*-*-* arm*-*-* } } } */
-/* { dg-final { cleanup-tree-dump "bswap" } } */
--- a/src/gcc/testsuite/gcc.dg/optimize-bswapsi-1.c
+++ b/src/gcc/testsuite/gcc.dg/optimize-bswapsi-1.c
@@ -90,4 +90,3 @@ swap32_f (unsigned in)
 }
 
 /* { dg-final { scan-tree-dump-times "32 bit bswap implementation found at" 6 "bswap" } } */
-/* { dg-final { cleanup-tree-dump "bswap" } } */
--- a/src/gcc/testsuite/gcc.dg/optimize-bswapsi-2.c
+++ b/src/gcc/testsuite/gcc.dg/optimize-bswapsi-2.c
@@ -46,4 +46,3 @@ uint32_t read_be32_3 (unsigned char *data)
 
 /* { dg-final { scan-tree-dump-times "32 bit load in target endianness found at" 3 "bswap" } } */
 /* { dg-final { scan-tree-dump-times "32 bit bswap implementation found at" 3 "bswap" { xfail alpha*-*-* arm*-*-* } } } */
-/* { dg-final { cleanup-tree-dump "bswap" } } */
--- a/src/gcc/testsuite/gcc.dg/optimize-bswapsi-3.c
+++ b/src/gcc/testsuite/gcc.dg/optimize-bswapsi-3.c
@@ -21,4 +21,3 @@ swap32 (SItype in)
 }
 
 /* { dg-final { scan-tree-dump-not "32 bit bswap implementation found at" "bswap" } } */
-/* { dg-final { cleanup-tree-dump "bswap" } } */
--- a/src/gcc/testsuite/gcc.dg/opts-4.c
+++ b/src/gcc/testsuite/gcc.dg/opts-4.c
@@ -6,4 +6,3 @@ void f (void)
 {
 }
 
-/* { dg-final { cleanup-rtl-dump "*" } } */
--- a/src/gcc/testsuite/gcc.dg/pch/save-temps-1.c
+++ b/src/gcc/testsuite/gcc.dg/pch/save-temps-1.c
@@ -5,5 +5,4 @@
 #endif
 #include <stddef.h>
 int x;
-
-/* { dg-final { cleanup-saved-temps ".s" } } */
+/* { dg-keep-saved-temps ".s" } */
--- a/src/gcc/testsuite/gcc.dg/pointer-arith-10.c
+++ b/src/gcc/testsuite/gcc.dg/pointer-arith-10.c
@@ -7,4 +7,3 @@ char *foo(char *p, __UINTPTR_TYPE__ i)
 }
 
 /* { dg-final { scan-tree-dump "p +" "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.dg/pow-sqrt-1.c
@@ -0,0 +1,6 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -ffast-math --param max-pow-sqrt-depth=5" } */
+
+#define EXPN (-6 * (0.5*0.5*0.5*0.5))
+
+#include "pow-sqrt.x"
--- /dev/null
+++ b/src/gcc/testsuite/gcc.dg/pow-sqrt-2.c
@@ -0,0 +1,5 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -ffast-math --param max-pow-sqrt-depth=5" } */
+
+#define EXPN (-5.875)
+#include "pow-sqrt.x"
--- /dev/null
+++ b/src/gcc/testsuite/gcc.dg/pow-sqrt-3.c
@@ -0,0 +1,5 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -ffast-math --param max-pow-sqrt-depth=3" } */
+
+#define EXPN (1.25)
+#include "pow-sqrt.x"
--- /dev/null
+++ b/src/gcc/testsuite/gcc.dg/pow-sqrt-synth-1.c
@@ -0,0 +1,37 @@
+/* { dg-do compile { target sqrt_insn } } */
+/* { dg-options "-fdump-tree-sincos -Ofast --param max-pow-sqrt-depth=8" } */
+/* { dg-additional-options "-mfloat-abi=softfp -mfpu=neon-vfpv4" { target arm*-*-* } } */
+
+double
+foo (double a)
+{
+  return __builtin_pow (a, -5.875);
+}
+
+double
+foof (double a)
+{
+  return __builtin_pow (a, 0.75f);
+}
+
+double
+bar (double a)
+{
+  return __builtin_pow (a, 1.0 + 0.00390625);
+}
+
+double
+baz (double a)
+{
+  return __builtin_pow (a, -1.25) + __builtin_pow (a, 5.75) - __builtin_pow (a, 3.375);
+}
+
+#define N 256
+void
+vecfoo (double *a)
+{
+  for (int i = 0; i < N; i++)
+    a[i] = __builtin_pow (a[i], 1.25);
+}
+
+/* { dg-final { scan-tree-dump-times "synthesizing" 7 "sincos" } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.dg/pow-sqrt.x
@@ -0,0 +1,30 @@
+
+extern void abort (void);
+
+
+__attribute__((noinline)) double
+real_pow (double x, double pow_exp)
+{
+  return __builtin_pow (x, pow_exp);
+}
+
+#define EPS (0.000000000000000000001)
+
+#define SYNTH_POW(X, Y) __builtin_pow (X, Y)
+volatile double arg;
+
+int
+main (void)
+{
+  double i_arg = 0.1;
+
+  for (arg = i_arg; arg < 100.0; arg += 1.0)
+    {
+      double synth_res = SYNTH_POW (arg, EXPN);
+      double real_res = real_pow (arg, EXPN);
+
+      if (__builtin_abs (SYNTH_POW (arg, EXPN) - real_pow (arg, EXPN)) > EPS)
+	abort ();
+    }
+  return 0;
+}
--- a/src/gcc/testsuite/gcc.dg/pr10474.c
+++ b/src/gcc/testsuite/gcc.dg/pr10474.c
@@ -13,4 +13,3 @@ void f(int *i)
 }
 
 /* { dg-final { scan-rtl-dump "Performing shrink-wrapping" "pro_and_epilogue"  } } */
-/* { dg-final { cleanup-rtl-dump "pro_and_epilogue" } } */
--- a/src/gcc/testsuite/gcc.dg/pr14796-1.c
+++ b/src/gcc/testsuite/gcc.dg/pr14796-1.c
@@ -21,4 +21,3 @@ int l (int d) {
 /* { dg-final { scan-tree-dump "b & -32" "gimple" } } */
 /* { dg-final { scan-tree-dump "c & 15" "gimple" } } */
 /* { dg-final { scan-tree-dump "d << 6" "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/pr14796-2.c
+++ b/src/gcc/testsuite/gcc.dg/pr14796-2.c
@@ -20,4 +20,3 @@ long long j (long long c) {
 /* { dg-final { scan-tree-dump-times "= 0" 2 "gimple" } } */
 /* { dg-final { scan-tree-dump "b >> 31" "gimple" } } */
 /* { dg-final { scan-tree-dump "c & -(34359738368|0x800000000)" "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/pr15784-1.c
+++ b/src/gcc/testsuite/gcc.dg/pr15784-1.c
@@ -40,4 +40,3 @@ int i (float x) {
 	return fabs(x) == -0.0;
 }
 /* { dg-final { scan-tree-dump-times "ABS_EXPR" 0 "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/pr15784-2.c
+++ b/src/gcc/testsuite/gcc.dg/pr15784-2.c
@@ -9,4 +9,3 @@ int a (float x) {
 }
 
 /* { dg-final { scan-tree-dump-times "ABS_EXPR" 0 "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/pr15784-3.c
+++ b/src/gcc/testsuite/gcc.dg/pr15784-3.c
@@ -11,4 +11,3 @@ int a (float x) {
 }
 
 /* { dg-final { scan-tree-dump-times "ABS_EXPR" 1 "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/pr15784-4.c
+++ b/src/gcc/testsuite/gcc.dg/pr15784-4.c
@@ -10,4 +10,3 @@ int b (int x) {
 
 /* { dg-final { scan-tree-dump "~x_..D.;" "optimized" } } */
 /* { dg-final { scan-tree-dump "-x_..D.;" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/pr19105.c
+++ b/src/gcc/testsuite/gcc.dg/pr19105.c
@@ -18,5 +18,4 @@ int range2 (enum e v, int x)
 }
 
 /* { dg-final { scan-tree-dump-times "Optimizing range tests v_\[0-9\]*.D. -.2, 2. and -.3, 4.\[\n\r\]* into|Optimizing range tests v_\[0-9\]*.D. -.2, 2. and -.3, 3. and -.4, 4.\[\n\r\]* into" 1 "reassoc1" } } */
-/* { dg-final { cleanup-tree-dump "reassoc1" } } */
 
--- a/src/gcc/testsuite/gcc.dg/pr19988.c
+++ b/src/gcc/testsuite/gcc.dg/pr19988.c
@@ -10,5 +10,3 @@ double foo(double x, double y)
 /* { dg-final { scan-tree-dump-times " 1.23" 2 "original" } } */
 /* CSE one multiplication.  */
 /* { dg-final { scan-tree-dump-times " \\\* " 2 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/pr20115-1.c
+++ b/src/gcc/testsuite/gcc.dg/pr20115-1.c
@@ -12,4 +12,3 @@ int bar()
 
 /* Check that we only have one call to foo.  */
 /* { dg-final { scan-tree-dump-times "foo" 1 "dom1" } } */
-/* { dg-final { cleanup-tree-dump "dom1" } } */
--- a/src/gcc/testsuite/gcc.dg/pr20130-1.c
+++ b/src/gcc/testsuite/gcc.dg/pr20130-1.c
@@ -12,4 +12,3 @@ int y (int a) {
 	return -(-1 * -a);
 }
 /* { dg-final { scan-tree-dump-times "-a" 3 "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/pr20922-1.c
+++ b/src/gcc/testsuite/gcc.dg/pr20922-1.c
@@ -35,4 +35,3 @@ int z(double i)
   return (i + (-2.0)) > i;
 }
 /* { dg-final { scan-tree-dump-times " = 0" 7 "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/pr20922-2.c
+++ b/src/gcc/testsuite/gcc.dg/pr20922-2.c
@@ -15,4 +15,3 @@ int h (double i)
   return (i + 2.0) <= i;
 }
 /* { dg-final { scan-tree-dump-times " = 0" 0 "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/pr20922-3.c
+++ b/src/gcc/testsuite/gcc.dg/pr20922-3.c
@@ -30,4 +30,3 @@ int z(double i)
   return (i + (-2.0)) <= i;
 }
 /* { dg-final { scan-tree-dump-times " = 1" 6 "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/pr20922-4.c
+++ b/src/gcc/testsuite/gcc.dg/pr20922-4.c
@@ -35,4 +35,3 @@ int z(double i)
   return i < (i + (-2.0));
 }
 /* { dg-final { scan-tree-dump-times " = 0" 7 "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/pr20922-5.c
+++ b/src/gcc/testsuite/gcc.dg/pr20922-5.c
@@ -20,4 +20,3 @@ int j (double i)
   return i > i + 2.0;
 }
 /* { dg-final { scan-tree-dump-times " = 0" 0 "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/pr20922-6.c
+++ b/src/gcc/testsuite/gcc.dg/pr20922-6.c
@@ -30,4 +30,3 @@ int z(double i)
   return i >= (i + (-2.0));
 }
 /* { dg-final { scan-tree-dump-times " = 1" 6 "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/pr21032.c
+++ b/src/gcc/testsuite/gcc.dg/pr21032.c
@@ -8,4 +8,3 @@ void foo(double x)
 }
 
 /* { dg-final { scan-tree-dump-not "-\\(float\\)" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/pr21643.c
+++ b/src/gcc/testsuite/gcc.dg/pr21643.c
@@ -87,4 +87,3 @@ f9 (unsigned char c)
 }
 
 /* { dg-final { scan-tree-dump-times "Optimizing range tests c_\[0-9\]*.D. -.0, 31. and -.32, 32.\[\n\r\]* into" 6 "reassoc1" } } */
-/* { dg-final { cleanup-tree-dump "reassoc1" } } */
--- a/src/gcc/testsuite/gcc.dg/pr23295.c
+++ b/src/gcc/testsuite/gcc.dg/pr23295.c
@@ -7,4 +7,3 @@ int foo(int i)
 }
 
 /* { dg-final { scan-tree-dump "-5 - i" "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/pr23470-1.c
+++ b/src/gcc/testsuite/gcc.dg/pr23470-1.c
@@ -11,4 +11,3 @@ int f(double a, double b)
 }
 
 /* { dg-final { scan-tree-dump-times "if \\(0\\)" 1 "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/gcc.dg/pr23584.c
+++ b/src/gcc/testsuite/gcc.dg/pr23584.c
@@ -18,4 +18,3 @@ int test2 (void)
 
 /* { dg-final { scan-ipa-dump-not "found to be pure: test1" "pure-const" } } */
 /* { dg-final { scan-ipa-dump-not "found to be pure: test2" "pure-const" } } */
-/* { dg-final { cleanup-ipa-dump "pure-const" } } */
--- a/src/gcc/testsuite/gcc.dg/pr23623.c
+++ b/src/gcc/testsuite/gcc.dg/pr23623.c
@@ -45,4 +45,3 @@ void readb(void)
    the parenthesized subexpression in the regexp introduces an extra match
    variable, we need to give a count of 12 instead of 6 here.  */
 /* { dg-final { scan-rtl-dump-times "mem/v(/.)*:SI" 12 "final" } } */
-/* { dg-final { cleanup-rtl-dump "final" } } */
--- a/src/gcc/testsuite/gcc.dg/pr23911.c
+++ b/src/gcc/testsuite/gcc.dg/pr23911.c
@@ -18,4 +18,3 @@ test (void)
    constant folded.  There should be no loads from b left.  */
 /* { dg-final { scan-tree-dump-times "__complex__ \\\(1.0e\\\+0, 0.0\\\)" 2 "dce2" } } */
 /* { dg-final { scan-tree-dump-times "= b" 0 "dce2" } } */
-/* { dg-final { cleanup-tree-dump "dce2" } } */
--- a/src/gcc/testsuite/gcc.dg/pr27132.c
+++ b/src/gcc/testsuite/gcc.dg/pr27132.c
@@ -7,4 +7,3 @@ int foo(int i)
 }
 
 /* { dg-final { scan-tree-dump "i \\+ 1" "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/pr28685-1.c
+++ b/src/gcc/testsuite/gcc.dg/pr28685-1.c
@@ -47,4 +47,3 @@ int test5 (int a, int b)
 /* { dg-final { scan-tree-dump-times "return 0" 1 "optimized" } } */
 /* { dg-final { scan-tree-dump-not " < " "optimized" } } */
 /* { dg-final { scan-tree-dump-not " == " "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/pr29215.c
+++ b/src/gcc/testsuite/gcc.dg/pr29215.c
@@ -30,4 +30,3 @@ main (void)
 }
 
 /* { dg-final { scan-tree-dump-not "memcpy" "ccp1" } } */
-/* { dg-final { cleanup-tree-dump "ccp1" } } */
--- a/src/gcc/testsuite/gcc.dg/pr29801.c
+++ b/src/gcc/testsuite/gcc.dg/pr29801.c
@@ -21,4 +21,3 @@ int test (int param)
 /* { dg-final { scan-tree-dump-times "return 2" 1 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "return 5" 0 "optimized" } } */
 
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/pr30137-1.c
+++ b/src/gcc/testsuite/gcc.dg/pr30137-1.c
@@ -20,4 +20,3 @@ int foo13 (void) { return *p != &p; }
 
 /* { dg-final { scan-tree-dump-not "= 0;" "gimple" } } */
 /* { dg-final { scan-tree-dump-not "= 1;" "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/pr30137-2.c
+++ b/src/gcc/testsuite/gcc.dg/pr30137-2.c
@@ -17,4 +17,3 @@ int foo8 (void) { return &x.u.i == &x.u.s; }
 
 /* { dg-final { scan-tree-dump-times "= 0" 1 "gimple" } } */
 /* { dg-final { scan-tree-dump-times "= 1" 7 "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/pr30172-1.c
+++ b/src/gcc/testsuite/gcc.dg/pr30172-1.c
@@ -12,4 +12,3 @@ _Complex double test5 (double x, double y) { return (x + y * 1.i) * -1.i; }
 /* { dg-final { scan-tree-dump "COMPLEX_EXPR <x, y>" "gimple" } } */
 /* { dg-final { scan-tree-dump "D.* = -y;\n.*COMPLEX_EXPR <D.*, x>" "gimple" } } */
 /* { dg-final { scan-tree-dump "D.* = -x;\n.*COMPLEX_EXPR <y, D.*>" "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/pr30904.c
+++ b/src/gcc/testsuite/gcc.dg/pr30904.c
@@ -15,4 +15,3 @@ int main (void)
 
 
 /* { dg-final { scan-tree-dump-times "link_error" 0 "optimized"  } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/pr30957-1.c
+++ b/src/gcc/testsuite/gcc.dg/pr30957-1.c
@@ -34,4 +34,3 @@ main ()
 }
 
 /* { dg-final { scan-rtl-dump "Expanding Accumulator" "loop2_unroll" } } */
-/* { dg-final { cleanup-rtl-dump "loop*" } } */
--- a/src/gcc/testsuite/gcc.dg/pr31847.c
+++ b/src/gcc/testsuite/gcc.dg/pr31847.c
@@ -12,4 +12,3 @@ int foo()
 }
 
 /* { dg-final { scan-tree-dump-not "Created value  for " "pre"} } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/pr32328.c
+++ b/src/gcc/testsuite/gcc.dg/pr32328.c
@@ -14,4 +14,3 @@ void baz()
 }
 
 /* { dg-final { scan-tree-dump "Everything OK" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/pr32721.c
+++ b/src/gcc/testsuite/gcc.dg/pr32721.c
@@ -16,4 +16,3 @@ spinlock1 = &spinlock[1];
 
 /* { dg-final { scan-tree-dump "={v} .*spinlock" "optimized" } } */
 /* { dg-final { scan-tree-dump "spinlock.* ={v}" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/pr32912-3.c
+++ b/src/gcc/testsuite/gcc.dg/pr32912-3.c
@@ -11,4 +11,3 @@ bar (void)
 }
 
 /* { dg-final { scan-tree-dump-not "~\{" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/pr33653.c
+++ b/src/gcc/testsuite/gcc.dg/pr33653.c
@@ -7,4 +7,3 @@ void f (volatile char *p)
 }
 
 /* { dg-final { scan-rtl-dump "mem/v" "shorten" } } */
-/* { dg-final { cleanup-rtl-dump "shorten" } } */
--- a/src/gcc/testsuite/gcc.dg/pr33826.c
+++ b/src/gcc/testsuite/gcc.dg/pr33826.c
@@ -48,5 +48,3 @@ int norecurse1b (int i)
 /* { dg-final { scan-ipa-dump-not "found to be const: recurse1" "pure-const" } } */
 /* { dg-final { scan-ipa-dump-not "found to be const: recurse2a" "pure-const" } } */
 /* { dg-final { scan-ipa-dump-not "found to be const: recurse2b" "pure-const" } } */
-/* { dg-final { cleanup-ipa-dump "pure-const" } } */
-/* { dg-final { cleanup-tree-dump "local-pure-const1" } } */
--- a/src/gcc/testsuite/gcc.dg/pr34027-1.c
+++ b/src/gcc/testsuite/gcc.dg/pr34027-1.c
@@ -13,4 +13,3 @@ unsigned long foobar(unsigned long ns)
    that anymore.  */
 /* { dg-final { scan-tree-dump-times "%" 0 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "/" 0 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/pr34027-2.c
+++ b/src/gcc/testsuite/gcc.dg/pr34027-2.c
@@ -7,4 +7,3 @@ long foo(long n, long m)
 }
 
 /* { dg-final { scan-tree-dump "n % m" "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/pr34263.c
+++ b/src/gcc/testsuite/gcc.dg/pr34263.c
@@ -56,5 +56,4 @@ int look( struct s *p, struct s **pp )
 }
 
 /* { dg-final { scan-tree-dump "Cleaned-up latch block of loop with single BB" "optimized" { xfail { *-*-* } } } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
--- a/src/gcc/testsuite/gcc.dg/pr35729.c
+++ b/src/gcc/testsuite/gcc.dg/pr35729.c
@@ -15,4 +15,3 @@ void func_1 (void)
 }
 
 /* { dg-final { scan-rtl-dump-times "Decided to move invariant" 0 "loop2_invariant" } } */
-/* { dg-final { cleanup-rtl-dump "loop2_invariant" } } */
--- a/src/gcc/testsuite/gcc.dg/pr37171.c
+++ b/src/gcc/testsuite/gcc.dg/pr37171.c
@@ -16,4 +16,3 @@ unsigned int f4 (void)
 /* { dg-final { scan-tree-dump-times "= f1 \\(\\)" 1 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "= f2 \\(\\)" 1 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "= f3 \\(\\)" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/pr37261.c
+++ b/src/gcc/testsuite/gcc.dg/pr37261.c
@@ -12,4 +12,3 @@ foo (int x)
 }
 
 /* { dg-final { scan-tree-dump "return 0" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/pr37289.c
+++ b/src/gcc/testsuite/gcc.dg/pr37289.c
@@ -11,4 +11,3 @@ void g(long x)
 /* Make sure we do not lose the conversion.  */
 
 /* { dg-final { scan-tree-dump "-\\\(long unsigned int\\\) x" "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/gcc.dg/pr37858.c
+++ b/src/gcc/testsuite/gcc.dg/pr37858.c
@@ -9,4 +9,3 @@ main (void)
   return 0;
 }
 
-/* { dg-final { cleanup-ipa-dump "build_ssa_passes" } } */
--- a/src/gcc/testsuite/gcc.dg/pr38245-1.c
+++ b/src/gcc/testsuite/gcc.dg/pr38245-1.c
@@ -33,4 +33,3 @@ main (void)
 
 /* { dg-final { scan-tree-dump-not "% 2123" "optimized" } } */
 /* { dg-final { scan-tree-dump-not "0 / " "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/pr38245-2.c
+++ b/src/gcc/testsuite/gcc.dg/pr38245-2.c
@@ -107,4 +107,3 @@ f13 (unsigned int a, unsigned int b)
 }
 
 /* { dg-final { scan-tree-dump-not "link_error" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/pr38645.c
+++ b/src/gcc/testsuite/gcc.dg/pr38645.c
@@ -14,4 +14,3 @@ int foo()
 }
 
 /* { dg-final { scan-tree-dump "a.0. ={v} 1;" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/pr38984.c
+++ b/src/gcc/testsuite/gcc.dg/pr38984.c
@@ -12,6 +12,5 @@ int f(int *p)
 
 /* { dg-final { scan-tree-dump-times "\\\*p" 2 "optimized" } } */
 /* { dg-final { scan-tree-dump-not "return 1" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
 
--- a/src/gcc/testsuite/gcc.dg/pr39874.c
+++ b/src/gcc/testsuite/gcc.dg/pr39874.c
@@ -24,6 +24,5 @@ void test2(char *signature)
 
 /* { dg-final { scan-tree-dump-times " == 15" 2 "optimized" } } */
 /* { dg-final { scan-tree-dump-not " == 3" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
 
--- a/src/gcc/testsuite/gcc.dg/pr41488.c
+++ b/src/gcc/testsuite/gcc.dg/pr41488.c
@@ -15,4 +15,3 @@ void foo (struct struct_t* sp, int start, int end)
 }
 
 /* { dg-final { scan-tree-dump-times "Simplify PEELED_CHREC into POLYNOMIAL_CHREC" 1 "sccp" } } */
-/* { dg-final { cleanup-tree-dump "sccp" } } */
--- a/src/gcc/testsuite/gcc.dg/pr41574.c
+++ b/src/gcc/testsuite/gcc.dg/pr41574.c
@@ -12,4 +12,3 @@ f(double x)
 }
 
 /* { dg-final { scan-rtl-dump-not "\\(plus:DF \\(mult:DF" "combine" } } */
-/* { dg-final { cleanup-rtl-dump "combine*" } } */
--- a/src/gcc/testsuite/gcc.dg/pr41783.c
+++ b/src/gcc/testsuite/gcc.dg/pr41783.c
@@ -17,4 +17,3 @@ int main()
    and we want that load to be into a PRE temporary.  */
 /* { dg-final { scan-tree-dump-times "= a_global_var;" 1 "pre" } } */
 /* { dg-final { scan-tree-dump "pretmp\[^\\n\]* = a_global_var;" "pre" } } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/pr42963.c
+++ b/src/gcc/testsuite/gcc.dg/pr42963.c
@@ -25,4 +25,3 @@ bar (void)
     }
 }
 /* { dg-final { scan-tree-dump-times "case 1:" 0 "cfg" } } */
-/* { dg-final { cleanup-tree-dump "cfg" } } */
--- a/src/gcc/testsuite/gcc.dg/pr43513.c
+++ b/src/gcc/testsuite/gcc.dg/pr43513.c
@@ -16,4 +16,3 @@ foo3 ()
 }
 
 /* { dg-final { scan-tree-dump-times "alloca" 0 "ccp2"} } */
-/* { dg-final { cleanup-tree-dump "ccp2" } } */
--- a/src/gcc/testsuite/gcc.dg/pr43864-2.c
+++ b/src/gcc/testsuite/gcc.dg/pr43864-2.c
@@ -20,4 +20,3 @@ f (int c, int b, int d)
 /* { dg-final { scan-tree-dump-times "if " 0 "pre"} } */
 /* { dg-final { scan-tree-dump-times "(?n)_.*\\+.*_" 1 "pre"} } */
 /* { dg-final { scan-tree-dump-not "Invalid sum" "pre"} } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/pr43864-3.c
+++ b/src/gcc/testsuite/gcc.dg/pr43864-3.c
@@ -21,4 +21,3 @@ int f(int c, int b, int d)
 /* { dg-final { scan-tree-dump-times "if " 0 "pre"} } */
 /* { dg-final { scan-tree-dump-times "(?n)_.*\\+.*_" 1 "pre"} } */
 /* { dg-final { scan-tree-dump-not "Invalid sum" "pre"} } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/pr43864-4.c
+++ b/src/gcc/testsuite/gcc.dg/pr43864-4.c
@@ -26,4 +26,3 @@ int f(int c, int b, int d)
 /* { dg-final { scan-tree-dump-times "(?n)_.*\\+.*_" 1 "pre"} } */
 /* { dg-final { scan-tree-dump-times "(?n)_.*-.*_" 2 "pre"} } */
 /* { dg-final { scan-tree-dump-not "Invalid sum" "pre"} } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/pr43864.c
+++ b/src/gcc/testsuite/gcc.dg/pr43864.c
@@ -33,4 +33,3 @@ hprofStartupp (char *outputFileName, char *ctx)
 
 /* { dg-final { scan-tree-dump-times "myfree \\(" 1 "pre"} } */
 /* { dg-final { scan-tree-dump-not "Invalid sum" "pre"} } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/pr44024.c
+++ b/src/gcc/testsuite/gcc.dg/pr44024.c
@@ -12,4 +12,3 @@ int main()
 }
 
 /* { dg-final { scan-tree-dump-not "if \\(foo" "ccp1" { target { ! avr*-*-* } } } } */
-/* { dg-final { cleanup-tree-dump "ccp1" } } */
--- a/src/gcc/testsuite/gcc.dg/pr44194-1.c
+++ b/src/gcc/testsuite/gcc.dg/pr44194-1.c
@@ -13,11 +13,9 @@ void func() {
 }
 
 /* { dg-final { scan-rtl-dump "global deletions = (2|3)" "dse1" } } */
-/* { dg-final { cleanup-rtl-dump "dse1" } } */
 
 /* Here we want to ignore frame-related instructions, marked as insn/f,
    that do things like store the link register to the stack.  We also want
    to treat insns the same regardless of whether they have a scheduling
    :TI marker, so match both "insn " and "insn:".  */
 /* { dg-final { scan-rtl-dump-not "insn\[: \]\[^\n\]*set \\(mem(?!\[^\n\]*scratch)" "final" } } */
-/* { dg-final { cleanup-rtl-dump "final" } } */
--- a/src/gcc/testsuite/gcc.dg/pr44194-2.c
+++ b/src/gcc/testsuite/gcc.dg/pr44194-2.c
@@ -9,4 +9,3 @@ void func() {
   bar(s.a, s.b);
 }
 /* { dg-final { scan-rtl-dump "global deletions = 0"  "dse1" } } */
-/* { dg-final { cleanup-rtl-dump "dse1" } } */
--- a/src/gcc/testsuite/gcc.dg/pr44214-1.c
+++ b/src/gcc/testsuite/gcc.dg/pr44214-1.c
@@ -15,4 +15,3 @@ void do_div (v2df *a, v2df *b)
 
 /* { dg-final { scan-tree-dump-times " \\\* " 3 "ccp1" } } */
 /* { dg-final { scan-tree-dump-times " / " 0 "ccp1" } } */
-/* { dg-final { cleanup-tree-dump "ccp1" } } */
--- a/src/gcc/testsuite/gcc.dg/pr44214-2.c
+++ b/src/gcc/testsuite/gcc.dg/pr44214-2.c
@@ -11,4 +11,3 @@ void do_div (_Complex double *a, _Complex double *b)
 
 /* { dg-final { scan-tree-dump-times " \\\* " 1 "original" } } */
 /* { dg-final { scan-tree-dump-times " / " 0 "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/gcc.dg/pr44214-3.c
+++ b/src/gcc/testsuite/gcc.dg/pr44214-3.c
@@ -16,4 +16,3 @@ void do_div (v2df *a, v2df *b)
 
 /* { dg-final { scan-tree-dump-times " \\\* " 3 "ccp1" } } */
 /* { dg-final { scan-tree-dump-times " / " 0 "ccp1" } } */
-/* { dg-final { cleanup-tree-dump "ccp1" } } */
--- a/src/gcc/testsuite/gcc.dg/pr44290-1.c
+++ b/src/gcc/testsuite/gcc.dg/pr44290-1.c
@@ -15,4 +15,3 @@ void fum(void *to)
 }
 
 /* { dg-final { scan-tree-dump "foo \\\(void \\\* from, void \\\* to\\\)" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/pr44290-2.c
+++ b/src/gcc/testsuite/gcc.dg/pr44290-2.c
@@ -21,4 +21,3 @@ bar (void)
 }
 
 /* { dg-final { scan-tree-dump "foo \\\(long unsigned int base\\\)" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/pr45819.c
+++ b/src/gcc/testsuite/gcc.dg/pr45819.c
@@ -17,4 +17,3 @@ int ehci_hub_control (struct ehci_hcd *ehci, int wIndex)
 }
 
 /* { dg-final { scan-tree-dump "={v}" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/pr46217.c
+++ b/src/gcc/testsuite/gcc.dg/pr46217.c
@@ -8,4 +8,3 @@ int foo(int a)
 }
 
 /* { dg-final { scan-tree-dump "={v}" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/pr46309-2.c
+++ b/src/gcc/testsuite/gcc.dg/pr46309-2.c
@@ -143,5 +143,3 @@ f10 (int a)
 /* { dg-final { scan-tree-dump-times "Optimizing range tests a_\[0-9\]*.D. -.128, 159. and -.192, 223.\[\n\r\]* into" 1 "reassoc1" } } */
 /* { dg-final { scan-tree-dump-times "Optimizing range tests a_\[0-9\]*.D. -.1, 1. and -.2, 2. and -.3, 3. and -.4, 4. and -.5, 5. and -.6, 6. and -.7, 7. and -.8, 8.\[\n\r\]* into" 7 "reassoc1" } } */
 /* { dg-final { scan-tree-dump-times "Optimizing range tests \[^\r\n\]*_\[0-9\]* -.0, 31. and -.128, 159.\[\n\r\]* into" 1 "reassoc2" } } */
-/* { dg-final { cleanup-tree-dump "reassoc1" } } */
-/* { dg-final { cleanup-tree-dump "reassoc2" } } */
--- a/src/gcc/testsuite/gcc.dg/pr46309.c
+++ b/src/gcc/testsuite/gcc.dg/pr46309.c
@@ -66,5 +66,3 @@ f6 (unsigned int a)
 /* { dg-final { scan-tree-dump-times "Optimizing range tests a_\[0-9\]*.D. -.0, 31. and -.64, 95.\[\n\r\]* into" 2 "reassoc1" } } */
 /* { dg-final { scan-tree-dump-times "Optimizing range tests a_\[0-9\]*.D. -.128, 159. and -.192, 223.\[\n\r\]* into" 1 "reassoc1" } } */
 /* { dg-final { scan-tree-dump-times "Optimizing range tests \[^\r\n\]*_\[0-9\]* -.0, 31. and -.128, 159.\[\n\r\]* into" 1 "reassoc2" } } */
-/* { dg-final { cleanup-tree-dump "reassoc1" } } */
-/* { dg-final { cleanup-tree-dump "reassoc2" } } */
--- a/src/gcc/testsuite/gcc.dg/pr46647.c
+++ b/src/gcc/testsuite/gcc.dg/pr46647.c
@@ -27,4 +27,3 @@ func3 (void)
 
 /* The xfail for avr, cris-* and crisv32-* is due to PR53535.  */
 /* { dg-final { scan-tree-dump-not "memset" "optimized" { xfail avr-*-* cris-*-* crisv32-*-* } } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/pr46909.c
+++ b/src/gcc/testsuite/gcc.dg/pr46909.c
@@ -17,4 +17,3 @@ foo (unsigned int x)
 /* { dg-final { scan-tree-dump-times "x_\[0-9\]+\\(D\\) != 6" 0 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "x_\[0-9\]+\\(D\\) == 2" 0 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "x_\[0-9\]+\\(D\\) == 6" 0 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/pr47391.c
+++ b/src/gcc/testsuite/gcc.dg/pr47391.c
@@ -19,4 +19,3 @@ main (void)
 }
 
 /* { dg-final { scan-tree-dump-not "i = 1;" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/pr47763.c
+++ b/src/gcc/testsuite/gcc.dg/pr47763.c
@@ -7,4 +7,3 @@ foo()
 }
 
 /* { dg-final { scan-rtl-dump-not "Web oldreg" "web" } } */
-/* { dg-final { cleanup-rtl-dump "web" } } */
--- a/src/gcc/testsuite/gcc.dg/pr47917.c
+++ b/src/gcc/testsuite/gcc.dg/pr47917.c
@@ -35,4 +35,3 @@ main (void)
 
 /* { dg-final { scan-tree-dump-times "snprintf" 2 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "sprintf" 0 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.dg/pr49551.c
@@ -0,0 +1,7 @@
+/* { dg-do compile } */
+/* { dg-options "-O -fdata-sections" } */
+
+int x = 1;
+int x;
+
+/* { dg-final { scan-assembler-not {comm[\t ]+x} } } */
--- a/src/gcc/testsuite/gcc.dg/pr50717-1.c
+++ b/src/gcc/testsuite/gcc.dg/pr50717-1.c
@@ -23,4 +23,3 @@ h (char a, char b, int c)
 }
 
 /* { dg-final { scan-tree-dump-times "WIDEN_MULT_PLUS_EXPR" 0 "widening_mul" } } */
-/* { dg-final { cleanup-tree-dump "widening_mul" } } */
--- a/src/gcc/testsuite/gcc.dg/pr50763.c
+++ b/src/gcc/testsuite/gcc.dg/pr50763.c
@@ -13,4 +13,3 @@ foo (int c, int d)
 }
 
 /* { dg-final { scan-tree-dump-times "== 33" 2 "pre"} } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/pr51491-2.c
+++ b/src/gcc/testsuite/gcc.dg/pr51491-2.c
@@ -31,4 +31,3 @@ f (int n)
 }
 
 /* { dg-final { scan-tree-dump-times "CLOBBER" 2 "ccp1"} } */
-/* { dg-final { cleanup-tree-dump "ccp1" } } */
--- a/src/gcc/testsuite/gcc.dg/pr51491.c
+++ b/src/gcc/testsuite/gcc.dg/pr51491.c
@@ -22,4 +22,3 @@ int f(void)
 }
 
 /* { dg-final { scan-rtl-dump-times "Partition" 1 "expand"} } */
-/* { dg-final { cleanup-rtl-dump "expand" } } */
--- a/src/gcc/testsuite/gcc.dg/pr51683.c
+++ b/src/gcc/testsuite/gcc.dg/pr51683.c
@@ -15,4 +15,3 @@ foo (void *p)
 }
 
 /* { dg-final { scan-tree-dump "memcpy" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/pr51867.c
+++ b/src/gcc/testsuite/gcc.dg/pr51867.c
@@ -14,4 +14,3 @@ float b(float x)
 /* Here the calls to sqrtf should be expanded into CALL_INSNs, rather than
    fpu sqrtf rtl patterns.  */
 /* { dg-final { scan-rtl-dump-times "call_insn" 2 "expand" } } */
-/* { dg-final { cleanup-rtl-dump "expand" } } */
--- a/src/gcc/testsuite/gcc.dg/pr51879-12.c
+++ b/src/gcc/testsuite/gcc.dg/pr51879-12.c
@@ -26,4 +26,3 @@ foo (int y)
 
 /* { dg-final { scan-tree-dump-times "bar \\(" 1 "pre" { xfail *-*-* } } } */
 /* { dg-final { scan-tree-dump-times "bar2 \\(" 1 "pre" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/pr51879-16.c
+++ b/src/gcc/testsuite/gcc.dg/pr51879-16.c
@@ -29,4 +29,3 @@ int bar (int c) {
 
 /* { dg-final { scan-tree-dump-times "foo \\(" 1 "pre"} } */
 /* { dg-final { scan-tree-dump-times "foo2 \\(" 1 "pre"} } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/pr51879-17.c
+++ b/src/gcc/testsuite/gcc.dg/pr51879-17.c
@@ -29,4 +29,3 @@ int bar (int c) {
 
 /* { dg-final { scan-tree-dump-times "foo \\(" 2 "pre"} } */
 /* { dg-final { scan-tree-dump-times "foo2 \\(" 2 "pre"} } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/pr51879-18.c
+++ b/src/gcc/testsuite/gcc.dg/pr51879-18.c
@@ -14,4 +14,3 @@ void bar (int c, int *p)
 }
 
 /* { dg-final { scan-tree-dump-times "foo \\(" 1 "pre"} } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/pr51879-2.c
+++ b/src/gcc/testsuite/gcc.dg/pr51879-2.c
@@ -16,4 +16,3 @@ foo (int y)
 
 /* { dg-final { scan-tree-dump-times "bar \\(" 1 "pre"} } */
 /* { dg-final { scan-tree-dump-times "baz \\(" 1 "pre"} } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/pr51879-3.c
+++ b/src/gcc/testsuite/gcc.dg/pr51879-3.c
@@ -16,4 +16,3 @@ foo (int y)
 }
 
 /* { dg-final { scan-tree-dump-times "bar \\(" 1 "pre"} } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/pr51879-4.c
+++ b/src/gcc/testsuite/gcc.dg/pr51879-4.c
@@ -13,4 +13,3 @@ int foo (int y)
 }
 
 /* { dg-final { scan-tree-dump-times "bar \\(" 2 "pre"} } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/pr51879-6.c
+++ b/src/gcc/testsuite/gcc.dg/pr51879-6.c
@@ -24,4 +24,3 @@ foo (int y)
 }
 
 /* { dg-final { scan-tree-dump-times "bar \\(" 1 "pre"} } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/pr51879-7.c
+++ b/src/gcc/testsuite/gcc.dg/pr51879-7.c
@@ -13,4 +13,3 @@ foo (int y)
 }
 
 /* { dg-final { scan-tree-dump-times "z = 5" 1 "pre"} } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/pr51879.c
+++ b/src/gcc/testsuite/gcc.dg/pr51879.c
@@ -16,4 +16,3 @@ foo (int y)
 }
 
 /* { dg-final { scan-tree-dump-times "bar \\(" 1 "pre"} } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/pr52134.c
+++ b/src/gcc/testsuite/gcc.dg/pr52134.c
@@ -11,4 +11,3 @@ int f1(int t)
 }
 
 /* { dg-final { scan-tree-dump-not "\\\&" "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/gcc.dg/pr52267.c
+++ b/src/gcc/testsuite/gcc.dg/pr52267.c
@@ -21,4 +21,3 @@ bar (int a)
 
 /* { dg-final { scan-tree-dump-not "& 3" "optimized" } } */
 /* { dg-final { scan-tree-dump-not "& -4" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/pr52445.c
+++ b/src/gcc/testsuite/gcc.dg/pr52445.c
@@ -12,4 +12,3 @@ foo (char *buf, unsigned long len)
 }
 
 /* { dg-final { scan-tree-dump-not "cstore\." "cselim" } } */
-/* { dg-final { cleanup-tree-dump "cselim" } } */
--- a/src/gcc/testsuite/gcc.dg/pr52448.c
+++ b/src/gcc/testsuite/gcc.dg/pr52448.c
@@ -27,4 +27,3 @@ void f2 (int *p, int a, int b, int *cond, int *cond2)
 
 /* None of the above conditional stores might be made unconditional.  */
 /* { dg-final { scan-tree-dump-not "cstore" "cselim" } } */
-/* { dg-final { cleanup-tree-dump "cselim" } } */
--- a/src/gcc/testsuite/gcc.dg/pr52578.c
+++ b/src/gcc/testsuite/gcc.dg/pr52578.c
@@ -11,4 +11,3 @@ long foo (int i)
 }
 
 /* { dg-final { scan-tree-dump-times "return 2;" 2 "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/gcc.dg/pr52691.c
+++ b/src/gcc/testsuite/gcc.dg/pr52691.c
@@ -21,4 +21,3 @@ foo (int a, ...)
 /* { dg-final { scan-tree-dump "__builtin_next_arg" "optimized" { target { { i?86-*-* x86_64-*-* } && ia32 } } } } */
 /* { dg-final { scan-tree-dump "__builtin_next_arg" "optimized" { target { powerpc*-*-darwin* powerpc*-*-aix* } } } } */
 /* { dg-final { scan-tree-dump "__builtin_next_arg" "optimized" { target { powerpc*-*-linux* && lp64 } } } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/pr54087.c
+++ b/src/gcc/testsuite/gcc.dg/pr54087.c
@@ -1,7 +1,7 @@
 /* PR54087.  Verify __atomic_sub (val) uses __atomic_add (-val) if there is no
              atomic_aub.  */
-/* { dg-require-effective-target sync_int_long } */
 /* { dg-do compile { target { i?86-*-* x86_64-*-* } } } */
+/* { dg-require-effective-target sync_int_long } */
 /* { dg-final { scan-assembler-times "xadd" 2 } } */
 
 
--- a/src/gcc/testsuite/gcc.dg/pr55027.c
+++ b/src/gcc/testsuite/gcc.dg/pr55027.c
@@ -9,4 +9,3 @@ void f (v2df *x)
 }
 
 /* { dg-final { scan-tree-dump-not "gimple_assign" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/pr56094.c
+++ b/src/gcc/testsuite/gcc.dg/pr56094.c
@@ -78,4 +78,3 @@ foo ()
 
 /* Verify no statements get the location of the foo () decl.  */
 /* { dg-final { scan-tree-dump-not " : 65:1\\\]" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/pr56098-1.c
+++ b/src/gcc/testsuite/gcc.dg/pr56098-1.c
@@ -13,4 +13,3 @@ foo (int x)
 }
 
 /* { dg-final { scan-tree-dump-not "=\[^\n\r]*\\*p" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/pr56098-2.c
+++ b/src/gcc/testsuite/gcc.dg/pr56098-2.c
@@ -16,4 +16,3 @@ bar (struct S *x, int y)
 }
 
 /* { dg-final { scan-tree-dump-not "r_\[0-9]* =.v. \[^\n\r]*;\[\n\r]*  r_\[0-9]* =.v. " "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/pr56837.c
+++ b/src/gcc/testsuite/gcc.dg/pr56837.c
@@ -64,4 +64,3 @@ fv (void)
 /* { dg-final { scan-tree-dump-times "memset ..b, 1, 1024.;" 1 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "memset ..c, 68, 16384.;" 1 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "memset ..v, 18, 16384.;" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/pr56997-4.c
+++ b/src/gcc/testsuite/gcc.dg/pr56997-4.c
@@ -20,4 +20,3 @@ foo (test_type u)
 /* The C++ memory model forbids data store race conditions outside the
    unaligned data member, therefore only QI or HI access is allowed, no SI.  */
 /* { dg-final { scan-rtl-dump-not "mem/v(/.)*:SI" "final" } } */
-/* { dg-final { cleanup-rtl-dump "final" } } */
--- a/src/gcc/testsuite/gcc.dg/pr57518.c
+++ b/src/gcc/testsuite/gcc.dg/pr57518.c
@@ -14,4 +14,3 @@ void foo() {
 }
 
 /* { dg-final { scan-rtl-dump-not "REG_EQUIV\[^\n\]*mem\[^\n\]*\"ip\".*subreg" "ira" } } */
-/* { dg-final { cleanup-rtl-dump "ira" } } */
--- a/src/gcc/testsuite/gcc.dg/pr58145-1.c
+++ b/src/gcc/testsuite/gcc.dg/pr58145-1.c
@@ -34,4 +34,3 @@ f4 (int val)
 }
 
 /* { dg-final { scan-tree-dump-times " ={v} " 4 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/pr58145-2.c
+++ b/src/gcc/testsuite/gcc.dg/pr58145-2.c
@@ -48,4 +48,3 @@ f5 (void)
 }
 
 /* { dg-final { scan-tree-dump-times " ={v} " 4 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/pr58463.c
+++ b/src/gcc/testsuite/gcc.dg/pr58463.c
@@ -12,4 +12,3 @@ fn1 (list_data * p1)
     p1->data16 = p1->data16 & 1 & p1->data16 >> 1;
 }
 
-/* { dg-final { cleanup-tree-dump "ealias" } } */
--- a/src/gcc/testsuite/gcc.dg/pr58742-1.c
+++ b/src/gcc/testsuite/gcc.dg/pr58742-1.c
@@ -10,4 +10,3 @@ fx (int *b, int *e)
 }
 
 /* { dg-final { scan-tree-dump "return e" "cddce1" } } */
-/* { dg-final { cleanup-tree-dump "cddce1" } } */
--- a/src/gcc/testsuite/gcc.dg/pr58742-2.c
+++ b/src/gcc/testsuite/gcc.dg/pr58742-2.c
@@ -10,4 +10,3 @@ fx (char *a, __SIZE_TYPE__ sz)
 }
 
 /* { dg-final { scan-tree-dump "return sz" "cddce1" } } */
-/* { dg-final { cleanup-tree-dump "cddce1" } } */
--- a/src/gcc/testsuite/gcc.dg/pr58742-3.c
+++ b/src/gcc/testsuite/gcc.dg/pr58742-3.c
@@ -11,4 +11,3 @@ fx (int *a, int sz)
 }
 
 /* { dg-final { scan-tree-dump "return a" "cddce1" } } */
-/* { dg-final { cleanup-tree-dump "cddce1" } } */
--- a/src/gcc/testsuite/gcc.dg/pr58805.c
+++ b/src/gcc/testsuite/gcc.dg/pr58805.c
@@ -21,4 +21,3 @@ foo (int n, TYPE *x, TYPE *y)
 }
 
 /* { dg-final { scan-tree-dump-times "__asm__" 2 "pre"} } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/pr59643.c
+++ b/src/gcc/testsuite/gcc.dg/pr59643.c
@@ -12,4 +12,3 @@ foo (double *a, double *b, double *c, double d, double e, int n)
 
 /* { dg-final { scan-tree-dump-times "Before commoning:" 1 "pcom" } } */
 /* { dg-final { scan-tree-dump-times "Unrolling 2 times" 1 "pcom" } } */
-/* { dg-final { cleanup-tree-dump "pcom" } } */
--- a/src/gcc/testsuite/gcc.dg/pr60267.c
+++ b/src/gcc/testsuite/gcc.dg/pr60267.c
@@ -11,4 +11,3 @@ foo (int *a, int *b, int *c)
     a[i] = b[i] * c[i];
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.dg/pr61158.c
+++ b/src/gcc/testsuite/gcc.dg/pr61158.c
@@ -9,4 +9,3 @@ foo (unsigned int x)
 }
 
 /* { dg-final { scan-tree-dump "return 0;" "original" { target { ilp32 || lp64 } } } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/gcc.dg/pr61762.c
+++ b/src/gcc/testsuite/gcc.dg/pr61762.c
@@ -16,4 +16,3 @@ unsigned int f()
    the unused local static is removed.  */
 
 /* { dg-final { scan-tree-dump-not "Private" "release_ssa" } } */
-/* { dg-final { cleanup-tree-dump "release_ssa" } } */
--- a/src/gcc/testsuite/gcc.dg/pr62167.c
+++ b/src/gcc/testsuite/gcc.dg/pr62167.c
@@ -47,4 +47,3 @@ main ()
 }
 
 /* { dg-final { scan-tree-dump-not "Removing basic block" "pre"} } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/pr63568.c
+++ b/src/gcc/testsuite/gcc.dg/pr63568.c
@@ -51,4 +51,3 @@ fn8 (int a, int b, int m)
 }
 
 /* { dg-final { scan-tree-dump-not " \\| " "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/gcc.dg/pr63743.c
+++ b/src/gcc/testsuite/gcc.dg/pr63743.c
@@ -8,4 +8,3 @@ libcall_dep (double x, double y)
 }
 
 /* { dg-final { scan-rtl-dump-times "Swap operands" 1 "expand" } } */
-/* { dg-final { cleanup-rtl-dump "expand" } } */
--- a/src/gcc/testsuite/gcc.dg/pr64277.c
+++ b/src/gcc/testsuite/gcc.dg/pr64277.c
@@ -3,7 +3,6 @@
 /* { dg-options "-O3 -Wall -Werror -fdump-tree-cunroll-details" } */
 /* { dg-final { scan-tree-dump "loop with 5 iterations completely unrolled" "cunroll" } } */
 /* { dg-final { scan-tree-dump "loop with 6 iterations completely unrolled" "cunroll" } } */
-/* { dg-final { cleanup-tree-dump "cunroll" } } */
 
 int f1[10];
 void test1 (short a[], short m, unsigned short l)
--- a/src/gcc/testsuite/gcc.dg/pr64309.c
+++ b/src/gcc/testsuite/gcc.dg/pr64309.c
@@ -63,4 +63,3 @@ main (void)
 }
 
 /* { dg-final { scan-tree-dump-not "(<<|>>)" "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/gcc.dg/pr64434.c
+++ b/src/gcc/testsuite/gcc.dg/pr64434.c
@@ -16,6 +16,5 @@ void foo ()
 }
 
 /* { dg-final { scan-rtl-dump-times "Swap operands" 1 "expand" } } */
-/* { dg-final { cleanup-rtl-dump "expand" } } */
 
 
--- a/src/gcc/testsuite/gcc.dg/pr64454.c
+++ b/src/gcc/testsuite/gcc.dg/pr64454.c
@@ -40,4 +40,3 @@ f6 (int x)
 
 /* { dg-final { scan-tree-dump-times "% 5" 6 "vrp1" } } */
 /* { dg-final { scan-tree-dump-times "% 6" 0 "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/pr64715-1.c
+++ b/src/gcc/testsuite/gcc.dg/pr64715-1.c
@@ -20,4 +20,3 @@ foo ()
 }
 
 /* { dg-final { scan-tree-dump "__builtin___strcpy_chk\[^;\n\r\]*, 5\\\);" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/pr64715-2.c
+++ b/src/gcc/testsuite/gcc.dg/pr64715-2.c
@@ -16,4 +16,3 @@ foo (int x)
 }
 
 /* { dg-final { scan-tree-dump "__builtin_memcpy \\\(\[^;\n\r\]*, \"abcdefghijkl\", 13\\\);" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.dg/pr67043.c
@@ -0,0 +1,32 @@
+/* { dg-do compile } */
+/* { dg-options "-O3 -fcompare-debug -w" } */
+
+extern void rt_mutex_owner (void);
+extern void rt_mutex_deadlock_account_lock (int);
+extern void signal_pending (void);
+__typeof__ (int *) a;
+int b;
+
+int
+try_to_take_rt_mutex (int p1) {
+  rt_mutex_owner ();
+  if (b)
+    return 0;
+  rt_mutex_deadlock_account_lock (p1);
+  return 1;
+}
+
+void
+__rt_mutex_slowlock (int p1) {
+  int c;
+  for (;;) {
+    c = ({
+      asm ("" : "=r"(a));
+      a;
+    });
+    if (try_to_take_rt_mutex (c))
+      break;
+    if (__builtin_expect (p1 == 0, 0))
+      signal_pending ();
+  }
+}
--- a/src/gcc/testsuite/gcc.dg/predict-1.c
+++ b/src/gcc/testsuite/gcc.dg/predict-1.c
@@ -24,4 +24,3 @@ void foo (int bound)
 }
 
 /* { dg-final { scan-tree-dump-times "loop iv compare heuristics: 0.0%" 5 "profile_estimate"} } */
-/* { dg-final { cleanup-tree-dump "profile_estimate" } } */
--- a/src/gcc/testsuite/gcc.dg/predict-2.c
+++ b/src/gcc/testsuite/gcc.dg/predict-2.c
@@ -24,4 +24,3 @@ void foo (int base, int bound)
 }
 
 /* { dg-final { scan-tree-dump-not "loop iv compare heuristics" "profile_estimate"} } */
-/* { dg-final { cleanup-tree-dump "profile_estimate" } } */
--- a/src/gcc/testsuite/gcc.dg/predict-3.c
+++ b/src/gcc/testsuite/gcc.dg/predict-3.c
@@ -22,4 +22,3 @@ void foo (int bound)
 }
 
 /* { dg-final { scan-tree-dump-times "loop iv compare heuristics: 100.0%" 4 "profile_estimate"} } */
-/* { dg-final { cleanup-tree-dump "profile_estimate" } } */
--- a/src/gcc/testsuite/gcc.dg/predict-4.c
+++ b/src/gcc/testsuite/gcc.dg/predict-4.c
@@ -16,4 +16,3 @@ void foo (int bound)
 }
 
 /* { dg-final { scan-tree-dump "loop iv compare heuristics: 50.0%" "profile_estimate"} } */
-/* { dg-final { cleanup-tree-dump "profile_estimate" } } */
--- a/src/gcc/testsuite/gcc.dg/predict-5.c
+++ b/src/gcc/testsuite/gcc.dg/predict-5.c
@@ -22,4 +22,3 @@ void foo (int base, int bound)
 }
 
 /* { dg-final { scan-tree-dump-times "loop iv compare heuristics: 100.0%" 4 "profile_estimate"} } */
-/* { dg-final { cleanup-tree-dump "profile_estimate" } } */
--- a/src/gcc/testsuite/gcc.dg/predict-6.c
+++ b/src/gcc/testsuite/gcc.dg/predict-6.c
@@ -22,4 +22,3 @@ void foo (int base, int bound)
 }
 
 /* { dg-final { scan-tree-dump-times "loop iv compare heuristics: 0.0%" 4 "profile_estimate"} } */
-/* { dg-final { cleanup-tree-dump "profile_estimate" } } */
--- a/src/gcc/testsuite/gcc.dg/predict-7.c
+++ b/src/gcc/testsuite/gcc.dg/predict-7.c
@@ -14,4 +14,3 @@ void foo (int base)
 }
 
 /* { dg-final { scan-tree-dump-times "loop branch heuristics" 0 "profile_estimate"} } */
-/* { dg-final { cleanup-tree-dump "profile_estimate" } } */
--- a/src/gcc/testsuite/gcc.dg/predict-8.c
+++ b/src/gcc/testsuite/gcc.dg/predict-8.c
@@ -9,4 +9,3 @@ int foo(float a, float b) {
 }
 
 /* { dg-final { scan-rtl-dump-times "REG_BR_PROB 100" 1 "expand"} } */
-/* { dg-final { cleanup-rtl-dump "expand" } } */
--- a/src/gcc/testsuite/gcc.dg/profile-dir-1.c
+++ b/src/gcc/testsuite/gcc.dg/profile-dir-1.c
@@ -9,4 +9,3 @@ main(void)
   return 0;
 }
 
-/* { dg-final { cleanup-ipa-dump "cgraph" } } */
--- a/src/gcc/testsuite/gcc.dg/profile-dir-2.c
+++ b/src/gcc/testsuite/gcc.dg/profile-dir-2.c
@@ -9,4 +9,3 @@ main(void)
   return 0;
 }
 
-/* { dg-final { cleanup-ipa-dump "cgraph" } } */
--- a/src/gcc/testsuite/gcc.dg/profile-dir-3.c
+++ b/src/gcc/testsuite/gcc.dg/profile-dir-3.c
@@ -9,4 +9,3 @@ main(void)
   return 0;
 }
 
-/* { dg-final { cleanup-ipa-dump "cgraph" } } */
--- a/src/gcc/testsuite/gcc.dg/pure-1.c
+++ b/src/gcc/testsuite/gcc.dg/pure-1.c
@@ -13,4 +13,3 @@ int func_a(struct test_a *a)
 }
 
 /* { dg-final { scan-ipa-dump-not "found to be pure: func_a" "pure-const" } } */
-/* { dg-final { cleanup-ipa-dump "pure-const" } } */
--- a/src/gcc/testsuite/gcc.dg/shrink-wrap-loop.c
+++ b/src/gcc/testsuite/gcc.dg/shrink-wrap-loop.c
@@ -17,4 +17,3 @@ test (int *p1, int *p2)
   return 1;
 }
 /* { dg-final { scan-rtl-dump "Performing shrink-wrapping" "pro_and_epilogue"  } } */
-/* { dg-final { cleanup-rtl-dump "pro_and_epilogue" } } */
--- a/src/gcc/testsuite/gcc.dg/sms-1.c
+++ b/src/gcc/testsuite/gcc.dg/sms-1.c
@@ -41,5 +41,4 @@ main ()
 }
 
 /* { dg-final { scan-rtl-dump-times "SMS succeeded" 1 "sms"  { target powerpc*-*-* spu-*-* } } } */
-/* { dg-final { cleanup-rtl-dump "sms" } } */
 
--- a/src/gcc/testsuite/gcc.dg/sms-10.c
+++ b/src/gcc/testsuite/gcc.dg/sms-10.c
@@ -115,5 +115,4 @@ main ()
 }
 
 /* { dg-final { scan-rtl-dump-times "SMS succeeded" 1 "sms" { target powerpc*-*-* } } } */
-/* { dg-final { cleanup-rtl-dump "sms" } } */
 
--- a/src/gcc/testsuite/gcc.dg/sms-11.c
+++ b/src/gcc/testsuite/gcc.dg/sms-11.c
@@ -34,4 +34,3 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-rtl-dump "sms" } } */
--- a/src/gcc/testsuite/gcc.dg/sms-12.c
+++ b/src/gcc/testsuite/gcc.dg/sms-12.c
@@ -39,5 +39,4 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-rtl-dump "sms" } } */
 
--- a/src/gcc/testsuite/gcc.dg/sms-2.c
+++ b/src/gcc/testsuite/gcc.dg/sms-2.c
@@ -33,4 +33,3 @@ fun (nb)
 }
 
 /* { dg-final { scan-rtl-dump-times "SMS loop many exits" 1 "sms" { target spu-*-* powerpc*-*-* } } } */
-/* { dg-final { cleanup-rtl-dump "sms" } } */
--- a/src/gcc/testsuite/gcc.dg/sms-3.c
+++ b/src/gcc/testsuite/gcc.dg/sms-3.c
@@ -39,5 +39,4 @@ main ()
 }
 
 /* { dg-final { scan-rtl-dump-times "SMS succeeded" 1 "sms" { target spu-*-* powerpc*-*-* } } } */
-/* { dg-final { cleanup-rtl-dump "sms" } } */
 
--- a/src/gcc/testsuite/gcc.dg/sms-4.c
+++ b/src/gcc/testsuite/gcc.dg/sms-4.c
@@ -36,5 +36,4 @@ main ()
 }
 
 /* { dg-final { scan-rtl-dump-times "SMS succeeded" 1 "sms" { target spu-*-* powerpc*-*-* } } } */
-/* { dg-final { cleanup-rtl-dump "sms" } } */
 
--- a/src/gcc/testsuite/gcc.dg/sms-5.c
+++ b/src/gcc/testsuite/gcc.dg/sms-5.c
@@ -48,5 +48,4 @@ int main ()
 
 /* { dg-final { scan-rtl-dump-times "SMS succeeded" 1 "sms" { target spu-*-* } } } */
 
-/* { dg-final { cleanup-rtl-dump "sms" } } */
 
--- a/src/gcc/testsuite/gcc.dg/sms-6.c
+++ b/src/gcc/testsuite/gcc.dg/sms-6.c
@@ -44,4 +44,3 @@ int main()
 
 /* { dg-final { scan-rtl-dump-times "SMS succeeded" 1 "sms" { target spu-*-* } } } */
 /* { dg-final { scan-rtl-dump-times "SMS succeeded" 3 "sms" { target powerpc*-*-* } } } */
-/* { dg-final { cleanup-rtl-dump "sms" } } */
--- a/src/gcc/testsuite/gcc.dg/sms-7.c
+++ b/src/gcc/testsuite/gcc.dg/sms-7.c
@@ -45,5 +45,4 @@ int main()
 }
 
 /* { dg-final { scan-rtl-dump-times "SMS succeeded" 1 "sms" { target spu-*-* } } } */
-/* { dg-final { cleanup-rtl-dump "sms" } } */
 
--- a/src/gcc/testsuite/gcc.dg/sms-8.c
+++ b/src/gcc/testsuite/gcc.dg/sms-8.c
@@ -37,6 +37,5 @@ main ()
 }
 
 /* { dg-final { scan-rtl-dump-times "SMS succeeded" 0 "sms" { target powerpc*-*-* } } } */
-/* { dg-final { cleanup-rtl-dump "sms" } } */
 
 
--- a/src/gcc/testsuite/gcc.dg/stack-layout-1.c
+++ b/src/gcc/testsuite/gcc.dg/stack-layout-1.c
@@ -22,4 +22,3 @@ void foo ()
   }
 
 /* { dg-final { scan-rtl-dump-times "Partition" 1 "expand" } } */
-/* { dg-final { cleanup-rtl-dump "expand" } } */
--- a/src/gcc/testsuite/gcc.dg/stack-layout-2.c
+++ b/src/gcc/testsuite/gcc.dg/stack-layout-2.c
@@ -21,4 +21,3 @@ int foo()
 }
 /* { dg-final { scan-rtl-dump "size 8192" "expand" } } */
 /* { dg-final { scan-rtl-dump "size 32" "expand" } } */
-/* { dg-final { cleanup-rtl-dump "expand" } } */
--- a/src/gcc/testsuite/gcc.dg/store-motion-fgcse-sm.c
+++ b/src/gcc/testsuite/gcc.dg/store-motion-fgcse-sm.c
@@ -30,5 +30,4 @@ main ()
 
 /* Check that -fgcse-sm did something for f.  */
 /* { dg-final { scan-rtl-dump "STORE_MOTION of f, .* basic blocks, 1 insns deleted, 1 insns created" "store_motion" } } */
-/* { dg-final { cleanup-rtl-dump "store_motion" } } */
  
--- a/src/gcc/testsuite/gcc.dg/strict-overflow-1.c
+++ b/src/gcc/testsuite/gcc.dg/strict-overflow-1.c
@@ -13,4 +13,3 @@ foo (int i)
 }
 
 /* { dg-final { scan-tree-dump-not "-\[ \]*5" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/strict-overflow-2.c
+++ b/src/gcc/testsuite/gcc.dg/strict-overflow-2.c
@@ -13,4 +13,3 @@ foo (int i)
 }
 
 /* { dg-final { scan-tree-dump-not "100" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/strict-overflow-3.c
+++ b/src/gcc/testsuite/gcc.dg/strict-overflow-3.c
@@ -13,4 +13,3 @@ foo (int i, int j)
 }
 
 /* { dg-final { scan-tree-dump-not "1000" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/strict-overflow-4.c
+++ b/src/gcc/testsuite/gcc.dg/strict-overflow-4.c
@@ -13,4 +13,3 @@ foo (int i)
 }
 
 /* { dg-final { scan-tree-dump "return 1;" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/strict-overflow-5.c
+++ b/src/gcc/testsuite/gcc.dg/strict-overflow-5.c
@@ -15,5 +15,4 @@ int foo (int i)
 }
 
 /* { dg-final { scan-tree-dump "return 3" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
--- a/src/gcc/testsuite/gcc.dg/strict-overflow-6.c
+++ b/src/gcc/testsuite/gcc.dg/strict-overflow-6.c
@@ -13,4 +13,3 @@ foo (char* p)
 }
 
 /* { dg-final { scan-tree-dump-not "\[+\]\[ \]*1000" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/strlenopt-1.c
+++ b/src/gcc/testsuite/gcc.dg/strlenopt-1.c
@@ -42,4 +42,3 @@ main ()
 /* { dg-final { scan-tree-dump-times "strcat \\(" 0 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "strchr \\(" 0 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "stpcpy \\(" 0 "strlen" } } */
-/* { dg-final { cleanup-tree-dump "strlen" } } */
--- a/src/gcc/testsuite/gcc.dg/strlenopt-10.c
+++ b/src/gcc/testsuite/gcc.dg/strlenopt-10.c
@@ -80,4 +80,3 @@ main ()
 /* { dg-final { scan-tree-dump-times "stpcpy \\(" 0 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "\\*q_\[0-9\]* = 32;" 1 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "memcpy \\(\[^\n\r\]*, 1\\)" 1 "strlen" } } */
-/* { dg-final { cleanup-tree-dump "strlen" } } */
--- a/src/gcc/testsuite/gcc.dg/strlenopt-11.c
+++ b/src/gcc/testsuite/gcc.dg/strlenopt-11.c
@@ -73,4 +73,3 @@ main ()
 /* { dg-final { scan-tree-dump-times "  _\[0-9\]* = strlen \\(\[^\n\r\]*;\[\n\r\]*  l.6. = " 1 "strlen" { target { ! avr-*-* } } } } */
 /* { dg-final { scan-tree-dump-times "  _\[0-9\]* = strlen \\(\[^\n\r\]*;\[\n\r\]*  l.9. = " 1 "strlen" { target { ! avr-*-* } } } } */
 /* { dg-final { scan-tree-dump-times "  _\[0-9\]* = strlen \\(\[^\n\r\]*;" 3 "strlen" { target { avr-*-* } } } } */
-/* { dg-final { cleanup-tree-dump "strlen" } } */
--- a/src/gcc/testsuite/gcc.dg/strlenopt-13.c
+++ b/src/gcc/testsuite/gcc.dg/strlenopt-13.c
@@ -71,4 +71,3 @@ main ()
 /* { dg-final { scan-tree-dump-times "  _\[0-9\]* = strlen \\(\[^\n\r\]*;\[\n\r\]*  l.5. = " 1 "strlen" { target { ! avr-*-* } } } } */
 /* { dg-final { scan-tree-dump-times "  _\[0-9\]* = strlen \\(\[^\n\r\]*;\[\n\r\]*  l.6. = " 1 "strlen" { target { ! avr-*-* } } } } */
 /* { dg-final { scan-tree-dump-times "  _\[0-9\]* = strlen \\(\[^\n\r\]*;" 4 "strlen" { target { avr-*-* } } } } */
-/* { dg-final { cleanup-tree-dump "strlen" } } */
--- a/src/gcc/testsuite/gcc.dg/strlenopt-14g.c
+++ b/src/gcc/testsuite/gcc.dg/strlenopt-14g.c
@@ -114,4 +114,3 @@ main ()
 /* { dg-final { scan-tree-dump-times "strcat \\(" 0 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "strchr \\(" 0 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "stpcpy \\(" 2 "strlen" } } */
-/* { dg-final { cleanup-tree-dump "strlen" } } */
--- a/src/gcc/testsuite/gcc.dg/strlenopt-14gf.c
+++ b/src/gcc/testsuite/gcc.dg/strlenopt-14gf.c
@@ -23,4 +23,3 @@
 /* { dg-final { scan-tree-dump-times "strcpy \\(" 0 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "strcat \\(" 0 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "stpcpy \\(" 2 "strlen" } } */
-/* { dg-final { cleanup-tree-dump "strlen" } } */
--- a/src/gcc/testsuite/gcc.dg/strlenopt-15.c
+++ b/src/gcc/testsuite/gcc.dg/strlenopt-15.c
@@ -57,4 +57,3 @@ main ()
 /* { dg-final { scan-tree-dump-times "strcat \\(" 0 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "strchr \\(" 0 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "stpcpy \\(" 0 "strlen" } } */
-/* { dg-final { cleanup-tree-dump "strlen" } } */
--- a/src/gcc/testsuite/gcc.dg/strlenopt-16g.c
+++ b/src/gcc/testsuite/gcc.dg/strlenopt-16g.c
@@ -31,4 +31,3 @@ main ()
 /* { dg-final { scan-tree-dump-times "strcat \\(" 0 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "strchr \\(" 0 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "stpcpy \\(" 1 "strlen" } } */
-/* { dg-final { cleanup-tree-dump "strlen" } } */
--- a/src/gcc/testsuite/gcc.dg/strlenopt-17g.c
+++ b/src/gcc/testsuite/gcc.dg/strlenopt-17g.c
@@ -54,4 +54,3 @@ main ()
 /* { dg-final { scan-tree-dump-times "strcat \\(" 0 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "strchr \\(" 0 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "stpcpy \\(" 1 "strlen" } } */
-/* { dg-final { cleanup-tree-dump "strlen" } } */
--- a/src/gcc/testsuite/gcc.dg/strlenopt-18g.c
+++ b/src/gcc/testsuite/gcc.dg/strlenopt-18g.c
@@ -79,4 +79,3 @@ main ()
 /* { dg-final { scan-tree-dump-times "strcat \\(" 0 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "strchr \\(" 0 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "stpcpy \\(" 2 "strlen" } } */
-/* { dg-final { cleanup-tree-dump "strlen" } } */
--- a/src/gcc/testsuite/gcc.dg/strlenopt-19.c
+++ b/src/gcc/testsuite/gcc.dg/strlenopt-19.c
@@ -78,4 +78,3 @@ main ()
 /* { dg-final { scan-tree-dump-times "strcat \\(" 0 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "strchr \\(" 0 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "stpcpy \\(" 0 "strlen" } } */
-/* { dg-final { cleanup-tree-dump "strlen" } } */
--- a/src/gcc/testsuite/gcc.dg/strlenopt-1f.c
+++ b/src/gcc/testsuite/gcc.dg/strlenopt-1f.c
@@ -15,4 +15,3 @@
 /* { dg-final { scan-tree-dump-times "strcpy \\(" 0 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "strcat \\(" 0 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "stpcpy \\(" 0 "strlen" } } */
-/* { dg-final { cleanup-tree-dump "strlen" } } */
--- a/src/gcc/testsuite/gcc.dg/strlenopt-2.c
+++ b/src/gcc/testsuite/gcc.dg/strlenopt-2.c
@@ -46,4 +46,3 @@ main ()
 /* { dg-final { scan-tree-dump-times "strcat \\(" 0 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "strchr \\(" 0 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "stpcpy \\(" 0 "strlen" } } */
-/* { dg-final { cleanup-tree-dump "strlen" } } */
--- a/src/gcc/testsuite/gcc.dg/strlenopt-20.c
+++ b/src/gcc/testsuite/gcc.dg/strlenopt-20.c
@@ -92,4 +92,3 @@ main ()
 /* { dg-final { scan-tree-dump-times "strcat \\(" 0 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "strchr \\(" 1 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "stpcpy \\(" 0 "strlen" } } */
-/* { dg-final { cleanup-tree-dump "strlen" } } */
--- a/src/gcc/testsuite/gcc.dg/strlenopt-21.c
+++ b/src/gcc/testsuite/gcc.dg/strlenopt-21.c
@@ -63,4 +63,3 @@ main ()
 /* { dg-final { scan-tree-dump-times "strcat \\(" 0 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "strchr \\(" 1 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "stpcpy \\(" 0 "strlen" } } */
-/* { dg-final { cleanup-tree-dump "strlen" } } */
--- a/src/gcc/testsuite/gcc.dg/strlenopt-22.c
+++ b/src/gcc/testsuite/gcc.dg/strlenopt-22.c
@@ -36,5 +36,4 @@ main ()
 /* { dg-final { scan-tree-dump-times "strcpy \\(" 1 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "strcat \\(" 0 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "strchr \\(" 1 "strlen" } } */
-/* { dg-final { scan-tree-dump-times "stpcpy \\(" 0 "strlen" } } *
-/* { dg-final { cleanup-tree-dump "strlen" } } */
+/* { dg-final { scan-tree-dump-times "stpcpy \\(" 0 "strlen" } } */
--- a/src/gcc/testsuite/gcc.dg/strlenopt-22g.c
+++ b/src/gcc/testsuite/gcc.dg/strlenopt-22g.c
@@ -11,4 +11,3 @@
 /* { dg-final { scan-tree-dump-times "strcat \\(" 0 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "strchr \\(" 1 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "stpcpy \\(" 1 "strlen" } } */
-/* { dg-final { cleanup-tree-dump "strlen" } } */
--- a/src/gcc/testsuite/gcc.dg/strlenopt-24.c
+++ b/src/gcc/testsuite/gcc.dg/strlenopt-24.c
@@ -13,5 +13,4 @@ main ()
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "strlen \\(" 0 "strlen" } } *
-/* { dg-final { cleanup-tree-dump "strlen" } } */
+/* { dg-final { scan-tree-dump-times "strlen \\(" 0 "strlen" } } */
--- a/src/gcc/testsuite/gcc.dg/strlenopt-25.c
+++ b/src/gcc/testsuite/gcc.dg/strlenopt-25.c
@@ -15,4 +15,3 @@ main ()
 }
 
 /* { dg-final { scan-tree-dump-times "strlen \\(" 0 "strlen" } } */
-/* { dg-final { cleanup-tree-dump "strlen" } } */
--- a/src/gcc/testsuite/gcc.dg/strlenopt-26.c
+++ b/src/gcc/testsuite/gcc.dg/strlenopt-26.c
@@ -22,4 +22,3 @@ main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "strlen \\(" 1 "strlen" } } */
-/* { dg-final { cleanup-tree-dump "strlen" } } */
--- a/src/gcc/testsuite/gcc.dg/strlenopt-27.c
+++ b/src/gcc/testsuite/gcc.dg/strlenopt-27.c
@@ -20,4 +20,3 @@ main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "strlen \\(" 0 "strlen" } } */
-/* { dg-final { cleanup-tree-dump "strlen" } } */
--- a/src/gcc/testsuite/gcc.dg/strlenopt-2f.c
+++ b/src/gcc/testsuite/gcc.dg/strlenopt-2f.c
@@ -15,4 +15,3 @@
 /* { dg-final { scan-tree-dump-times "strcpy \\(" 0 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "strcat \\(" 0 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "stpcpy \\(" 0 "strlen" } } */
-/* { dg-final { cleanup-tree-dump "strlen" } } */
--- a/src/gcc/testsuite/gcc.dg/strlenopt-3.c
+++ b/src/gcc/testsuite/gcc.dg/strlenopt-3.c
@@ -59,8 +59,6 @@ main ()
 /* { dg-final { scan-tree-dump-times "strcat \\(" 0 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "strchr \\(" 0 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "stpcpy \\(" 0 "strlen" } } */
-/* { dg-final { cleanup-tree-dump "strlen" } } */
 /* { dg-final { scan-tree-dump-times "return 0" 3 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "return 4" 1 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "return 3" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/strlenopt-4.c
+++ b/src/gcc/testsuite/gcc.dg/strlenopt-4.c
@@ -72,4 +72,3 @@ main ()
 /* { dg-final { scan-tree-dump-times "strcat \\(" 3 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "strchr \\(" 0 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "stpcpy \\(" 0 "strlen" } } */
-/* { dg-final { cleanup-tree-dump "strlen" } } */
--- a/src/gcc/testsuite/gcc.dg/strlenopt-4g.c
+++ b/src/gcc/testsuite/gcc.dg/strlenopt-4g.c
@@ -11,4 +11,3 @@
 /* { dg-final { scan-tree-dump-times "strcat \\(" 0 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "strchr \\(" 0 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "stpcpy \\(" 5 "strlen" } } */
-/* { dg-final { cleanup-tree-dump "strlen" } } */
--- a/src/gcc/testsuite/gcc.dg/strlenopt-4gf.c
+++ b/src/gcc/testsuite/gcc.dg/strlenopt-4gf.c
@@ -16,4 +16,3 @@
 /* { dg-final { scan-tree-dump-times "strcpy \\(" 1 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "strcat \\(" 0 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "stpcpy \\(" 5 "strlen" } } */
-/* { dg-final { cleanup-tree-dump "strlen" } } */
--- a/src/gcc/testsuite/gcc.dg/strlenopt-5.c
+++ b/src/gcc/testsuite/gcc.dg/strlenopt-5.c
@@ -54,4 +54,3 @@ main ()
 /* { dg-final { scan-tree-dump-times "strcat \\(" 0 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "strchr \\(" 2 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "stpcpy \\(" 0 "strlen" } } */
-/* { dg-final { cleanup-tree-dump "strlen" } } */
--- a/src/gcc/testsuite/gcc.dg/strlenopt-6.c
+++ b/src/gcc/testsuite/gcc.dg/strlenopt-6.c
@@ -83,4 +83,3 @@ main ()
 /* { dg-final { scan-tree-dump-times "strcat \\(" 0 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "strchr \\(" 0 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "stpcpy \\(" 0 "strlen" } } */
-/* { dg-final { cleanup-tree-dump "strlen" } } */
--- a/src/gcc/testsuite/gcc.dg/strlenopt-7.c
+++ b/src/gcc/testsuite/gcc.dg/strlenopt-7.c
@@ -47,7 +47,5 @@ main ()
 /* { dg-final { scan-tree-dump-times "strchr \\(" 1 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "stpcpy \\(" 0 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "\\*r_\[0-9\]* = 0;" 1 "strlen" } } */
-/* { dg-final { cleanup-tree-dump "strlen" } } */
 /* { dg-final { scan-tree-dump-times "return 3;" 1 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "return 0;" 2 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/strlenopt-8.c
+++ b/src/gcc/testsuite/gcc.dg/strlenopt-8.c
@@ -54,4 +54,3 @@ main ()
 /* { dg-final { scan-tree-dump-times "strcat \\(" 0 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "strchr \\(" 0 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "stpcpy \\(" 0 "strlen" } } */
-/* { dg-final { cleanup-tree-dump "strlen" } } */
--- a/src/gcc/testsuite/gcc.dg/strlenopt-9.c
+++ b/src/gcc/testsuite/gcc.dg/strlenopt-9.c
@@ -104,6 +104,4 @@ main ()
 /* { dg-final { scan-tree-dump-times "strcat \\(" 0 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "strchr \\(" 3 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "stpcpy \\(" 0 "strlen" } } */
-/* { dg-final { cleanup-tree-dump "strlen" } } */
 /* { dg-final { scan-tree-dump-times "return 4;" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/superblock.c
+++ b/src/gcc/testsuite/gcc.dg/superblock.c
@@ -19,6 +19,4 @@ foo (void)
 
 /* { dg-final { scan-rtl-dump-times "0 uses" 0 "bbro"} } */
 /* { dg-final { scan-rtl-dump-times "ADVANCING TO" 2 "sched2"} } */
-/* { dg-final { cleanup-rtl-dump "bbro" } } */
-/* { dg-final { cleanup-rtl-dump "sched2" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tail-merge-store.c
+++ b/src/gcc/testsuite/gcc.dg/tail-merge-store.c
@@ -19,4 +19,3 @@ f (int c, int d)
 
 /* { dg-final { scan-tree-dump-times "duplicate of" 1 "pre"} } */
 /* { dg-final { scan-tree-dump-times "z = 5" 1 "pre"} } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/tls/section-2.c
+++ b/src/gcc/testsuite/gcc.dg/tls/section-2.c
@@ -1,7 +1,7 @@
 /* Verify that we get errors for trying to put TLS data in 
    sections which can't work.  */
-/* { dg-require-effective-target tls } */
 /* { dg-do compile { target *-*-vxworks } } */
+/* { dg-require-effective-target tls } */
 
 #define A(X)	__attribute__((section(X)))
 
--- a/src/gcc/testsuite/gcc.dg/tm/20091221.c
+++ b/src/gcc/testsuite/gcc.dg/tm/20091221.c
@@ -13,4 +13,3 @@ foo()
 }
 
 /* { dg-final { scan-tree-dump-times "readOnly" 1 "tmedge" } } */
-/* { dg-final { cleanup-tree-dump "tmedge" } } */
--- a/src/gcc/testsuite/gcc.dg/tm/20100125.c
+++ b/src/gcc/testsuite/gcc.dg/tm/20100125.c
@@ -15,4 +15,3 @@ void set_remove(int * val)
 }
 
 /* { dg-final { scan-tree-dump-times "getTMCloneOrIrrevocable" 0 "tmmark" } } */
-/* { dg-final { cleanup-tree-dump "tmmark" } } */
--- a/src/gcc/testsuite/gcc.dg/tm/20100603.c
+++ b/src/gcc/testsuite/gcc.dg/tm/20100603.c
@@ -18,4 +18,3 @@ void TMlist_free ()
 }
 
 /* { dg-final { scan-tree-dump-times "Function poof ._ZGTt4poof" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tm/alias-1.c
+++ b/src/gcc/testsuite/gcc.dg/tm/alias-1.c
@@ -37,4 +37,3 @@ void f(void)
 /* { dg-final { scan-tree-dump-times "someptr = .*same as mystruct" 1 "ealias" } } */
 /* { dg-final { scan-tree-dump-times "ui\..* = .*same as mystruct" 1 "ealias" } } */
 /* { dg-final { scan-tree-dump-times "pp\..* = .*same as mystruct" 1 "ealias" } } */
-/* { dg-final { cleanup-tree-dump "ealias" } } */
--- a/src/gcc/testsuite/gcc.dg/tm/alias-2.c
+++ b/src/gcc/testsuite/gcc.dg/tm/alias-2.c
@@ -39,4 +39,3 @@ void foo()
 /* { dg-final { scan-tree-dump-times "ui\..* = .*same as mystruct" 1 "ealias" } } */
 /* { dg-final { scan-tree-dump-times "mystruct.*ESCAPED" 1 "ealias" } } */
 /* { dg-final { scan-tree-dump-times "pp = .*same as mystruct" 1 "ealias" } } */
-/* { dg-final { cleanup-tree-dump "ealias" } } */
--- a/src/gcc/testsuite/gcc.dg/tm/clone-1.c
+++ b/src/gcc/testsuite/gcc.dg/tm/clone-1.c
@@ -10,4 +10,3 @@ void cloneme()
 }
 
 /* { dg-final { scan-tree-dump-times "ITM_WU.*foo" 1 "tmmark" } } */
-/* { dg-final { cleanup-tree-dump "tmmark" } } */
--- a/src/gcc/testsuite/gcc.dg/tm/debug-1.c
+++ b/src/gcc/testsuite/gcc.dg/tm/debug-1.c
@@ -23,4 +23,3 @@ int main() {
 /* { dg-final { scan-tree-dump-times ":14:.*_ITM_beginTransaction" 1 "tmmark" } } */
 /* { dg-final { scan-tree-dump-times ":15:.*ITM_WU. \\(&z" 1 "tmmark" } } */
 /* { dg-final { scan-tree-dump-times ":16:.*ITM_WU. \\(&a" 1 "tmmark" } } */
-/* { dg-final { cleanup-tree-dump "tmmark" } } */
--- a/src/gcc/testsuite/gcc.dg/tm/instrumented-mask.c
+++ b/src/gcc/testsuite/gcc.dg/tm/instrumented-mask.c
@@ -13,4 +13,3 @@ main()
 }
 
 /* { dg-final { scan-tree-dump-times " instrumentedCode" 0 "tmmark" } } */
-/* { dg-final { cleanup-tree-dump "tmmark" } } */
--- a/src/gcc/testsuite/gcc.dg/tm/ipa-1.c
+++ b/src/gcc/testsuite/gcc.dg/tm/ipa-1.c
@@ -11,4 +11,3 @@ void bar(void)
 }
 
 /* { dg-final { scan-tree-dump-times "_ZGTt3foo" 1 "tmmark" } } */
-/* { dg-final { cleanup-tree-dump "tmmark" } } */
--- a/src/gcc/testsuite/gcc.dg/tm/ipa-2.c
+++ b/src/gcc/testsuite/gcc.dg/tm/ipa-2.c
@@ -11,4 +11,3 @@ void bar(void)
 }
 
 /* { dg-final { scan-tree-dump-times "_ZGTt3foo" 0 "tmmark" } } */
-/* { dg-final { cleanup-tree-dump "tmmark" } } */
--- a/src/gcc/testsuite/gcc.dg/tm/irrevocable-2.c
+++ b/src/gcc/testsuite/gcc.dg/tm/irrevocable-2.c
@@ -19,4 +19,3 @@ foo()
 
 /* { dg-final { scan-tree-dump-times "doesGoIrrevocable" 1 "tmedge" } } */
 /* { dg-final { scan-tree-dump-times "hasNoIrrevocable" 0 "tmedge" } } */
-/* { dg-final { cleanup-tree-dump "tmedge" } } */
--- a/src/gcc/testsuite/gcc.dg/tm/irrevocable-3.c
+++ b/src/gcc/testsuite/gcc.dg/tm/irrevocable-3.c
@@ -12,4 +12,3 @@ foo()
 }
 
 /* { dg-final { scan-tree-dump-times "doesGoIrrevocable" 1 "tmmark" } } */
-/* { dg-final { cleanup-tree-dump "tmmark" } } */
--- a/src/gcc/testsuite/gcc.dg/tm/irrevocable-4.c
+++ b/src/gcc/testsuite/gcc.dg/tm/irrevocable-4.c
@@ -13,4 +13,3 @@ foo()
 }
 
 /* { dg-final { scan-tree-dump-times "hasNoIrrevocable" 0 "tmmark" } } */
-/* { dg-final { cleanup-tree-dump "tmmark" } } */
--- a/src/gcc/testsuite/gcc.dg/tm/irrevocable-5.c
+++ b/src/gcc/testsuite/gcc.dg/tm/irrevocable-5.c
@@ -24,4 +24,3 @@ void wildthing()
 /* { dg-final { scan-ipa-dump-times "bb 4 goes irr" 1 "tmipa" } } */
 /* { dg-final { scan-ipa-dump-times "bb 5 goes irr" 1 "tmipa" } } */
 /* { dg-final { scan-ipa-dump-times "bb 6 goes irr" 1 "tmipa" } } */
-/* { dg-final { cleanup-ipa-dump "tmipa" } } */
--- a/src/gcc/testsuite/gcc.dg/tm/irrevocable-6.c
+++ b/src/gcc/testsuite/gcc.dg/tm/irrevocable-6.c
@@ -31,4 +31,3 @@ void wildthing()
 /* { dg-final { scan-ipa-dump-times "bb 7 goes irr" 1 "tmipa" } } */
 /* { dg-final { scan-ipa-dump-times "bb 8 goes irr" 1 "tmipa" } } */
 /* { dg-final { scan-ipa-dump-times "bb 9 goes irr" 1 "tmipa" } } */
-/* { dg-final { cleanup-ipa-dump "tmipa" } } */
--- a/src/gcc/testsuite/gcc.dg/tm/irrevocable-7.c
+++ b/src/gcc/testsuite/gcc.dg/tm/irrevocable-7.c
@@ -10,4 +10,3 @@ int foo()
 }
 
 /* { dg-final { scan-ipa-dump-times "changeTransactionMode \\(0\\)" 1 "tmipa" } } */
-/* { dg-final { cleanup-ipa-dump "tmipa" } } */
--- a/src/gcc/testsuite/gcc.dg/tm/memopt-1.c
+++ b/src/gcc/testsuite/gcc.dg/tm/memopt-1.c
@@ -27,4 +27,3 @@ f()
 /* { dg-final { scan-tree-dump-times "transforming: .*_ITM_WaRU4 \\(&i," 1 "tmmemopt" } } */
 /* { dg-final { scan-tree-dump-times "transforming: .*_ITM_RaWU4 \\(&i\\);" 1 "tmmemopt" } } */
 /* { dg-final { scan-tree-dump-times "transforming: .*_ITM_WaWU4 \\(&i," 1 "tmmemopt" } } */
-/* { dg-final { cleanup-tree-dump "tmmemopt" } } */
--- a/src/gcc/testsuite/gcc.dg/tm/memopt-10.c
+++ b/src/gcc/testsuite/gcc.dg/tm/memopt-10.c
@@ -25,4 +25,3 @@ int f()
 /* { dg-final { scan-tree-dump-times "ITM_LU" 0 "tmmark" } } */
 /* { dg-final { scan-tree-dump-times "ITM_WU" 0 "tmmark" } } */
 /* { dg-final { scan-tree-dump-times "int tm_save" 1 "tmmark" } } */
-/* { dg-final { cleanup-tree-dump "tmmark" } } */
--- a/src/gcc/testsuite/gcc.dg/tm/memopt-11.c
+++ b/src/gcc/testsuite/gcc.dg/tm/memopt-11.c
@@ -27,4 +27,3 @@ int f()
 /* { dg-final { scan-tree-dump-times "ITM_LU" 0 "tmmark" } } */
 /* { dg-final { scan-tree-dump-times "ITM_WU" 0 "tmmark" } } */
 /* { dg-final { scan-tree-dump-times "int tm_save" 1 "tmmark" } } */
-/* { dg-final { cleanup-tree-dump "tmmark" } } */
--- a/src/gcc/testsuite/gcc.dg/tm/memopt-12.c
+++ b/src/gcc/testsuite/gcc.dg/tm/memopt-12.c
@@ -32,4 +32,3 @@ int f()
 }
 
 /* { dg-final { scan-tree-dump-times "ITM_WU" 0 "tmmark" } } */
-/* { dg-final { cleanup-tree-dump "tmmark" } } */
--- a/src/gcc/testsuite/gcc.dg/tm/memopt-13.c
+++ b/src/gcc/testsuite/gcc.dg/tm/memopt-13.c
@@ -13,4 +13,3 @@ void f()
 }
 
 /* { dg-final { scan-tree-dump-times "memmoveRtWt \\\(&large_global," 1 "tmmark" } } */
-/* { dg-final { cleanup-tree-dump "tmmark" } } */
--- a/src/gcc/testsuite/gcc.dg/tm/memopt-16.c
+++ b/src/gcc/testsuite/gcc.dg/tm/memopt-16.c
@@ -41,4 +41,3 @@ int f(int j)
 }
 
 /* { dg-final { scan-tree-dump-times "ITM_WU" 0 "tmmark" } } */
-/* { dg-final { cleanup-tree-dump "tmmark" } } */
--- a/src/gcc/testsuite/gcc.dg/tm/memopt-2.c
+++ b/src/gcc/testsuite/gcc.dg/tm/memopt-2.c
@@ -12,4 +12,3 @@ void f(void)
 
 /* { dg-final { scan-tree-dump-times "transforming.*RfWU1 \\(&c" 1 "tmmemopt" } } */
 /* { dg-final { scan-tree-dump-times "transforming.*WaWU1 \\(&c" 1 "tmmemopt" } } */
-/* { dg-final { cleanup-tree-dump "tmmemopt" } } */
--- a/src/gcc/testsuite/gcc.dg/tm/memopt-3.c
+++ b/src/gcc/testsuite/gcc.dg/tm/memopt-3.c
@@ -18,4 +18,3 @@ int f()
 }
 
 /* { dg-final { scan-tree-dump-times "logging: lala.x\\\[i_4\\\]" 1 "tmmark" } } */
-/* { dg-final { cleanup-tree-dump "tmmark" } } */
--- a/src/gcc/testsuite/gcc.dg/tm/memopt-4.c
+++ b/src/gcc/testsuite/gcc.dg/tm/memopt-4.c
@@ -22,4 +22,3 @@ int f()
 
 /* { dg-final { scan-tree-dump-times "tm_save.\[0-9_\]+ = lala.x\\\[55\\\]" 1 "tmedge" } } */
 /* { dg-final { scan-tree-dump-times "lala.x\\\[55\\\] = tm_save" 1 "tmedge" } } */
-/* { dg-final { cleanup-tree-dump "tmedge" } } */
--- a/src/gcc/testsuite/gcc.dg/tm/memopt-5.c
+++ b/src/gcc/testsuite/gcc.dg/tm/memopt-5.c
@@ -21,4 +21,3 @@ int f()
 }
 
 /* { dg-final { scan-tree-dump-times "ITM_LU\[0-9\] \\\(&lala.x\\\[55\\\]" 1 "tmedge" } } */
-/* { dg-final { cleanup-tree-dump "tmedge" } } */
--- a/src/gcc/testsuite/gcc.dg/tm/memopt-6.c
+++ b/src/gcc/testsuite/gcc.dg/tm/memopt-6.c
@@ -19,4 +19,3 @@ int f()
 }
 
 /* { dg-final { scan-tree-dump-times "memmoveRtWt \\\(.*, &lacopy" 1 "tmedge" } } */
-/* { dg-final { cleanup-tree-dump "tmedge" } } */
--- a/src/gcc/testsuite/gcc.dg/tm/memopt-7.c
+++ b/src/gcc/testsuite/gcc.dg/tm/memopt-7.c
@@ -19,4 +19,3 @@ int f()
 
 /* { dg-final { scan-tree-dump-times "tm_save.\[0-9_\]+ = lala" 1 "tmedge" } } */
 /* { dg-final { scan-tree-dump-times "lala = tm_save" 1 "tmedge" } } */
-/* { dg-final { cleanup-tree-dump "tmedge" } } */
--- a/src/gcc/testsuite/gcc.dg/tm/memopt-8.c
+++ b/src/gcc/testsuite/gcc.dg/tm/memopt-8.c
@@ -23,4 +23,3 @@ int f()
 }
 
 /* { dg-final { scan-tree-dump-times "ITM_WU" 1 "tmmark" } } */
-/* { dg-final { cleanup-tree-dump "tmmark" } } */
--- a/src/gcc/testsuite/gcc.dg/tm/memopt-9.c
+++ b/src/gcc/testsuite/gcc.dg/tm/memopt-9.c
@@ -26,4 +26,3 @@ int f()
 }
 
 /* { dg-final { scan-tree-dump-times "ITM_WU" 0 "tmmark" } } */
-/* { dg-final { cleanup-tree-dump "tmmark" } } */
--- a/src/gcc/testsuite/gcc.dg/tm/memset-2.c
+++ b/src/gcc/testsuite/gcc.dg/tm/memset-2.c
@@ -14,4 +14,3 @@ int main()
 }
 
 /* { dg-final { scan-tree-dump-times "GTMA_HAVE_STORE" 1 "tmlower" } } */
-/* { dg-final { cleanup-tree-dump "tmlower" } } */
--- a/src/gcc/testsuite/gcc.dg/tm/pr55401.c
+++ b/src/gcc/testsuite/gcc.dg/tm/pr55401.c
@@ -19,4 +19,3 @@ void foo()
    FOO.  */
 /* { dg-final { scan-tree-dump-times "ITM_WU\[0-9\] \\(&george," 2 "optimized" } } */
 
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tm/props-1.c
+++ b/src/gcc/testsuite/gcc.dg/tm/props-1.c
@@ -16,5 +16,3 @@ foo(int local)
 /* { dg-final { scan-tree-dump-times " instrumentedCode" 1 "tmedge" } } */
 /* { dg-final { scan-tree-dump-times "hasNoAbort" 0 "tmedge" } } */
 /* { dg-final { scan-tree-dump-times "GTMA_HAVE_ABORT" 1 "tmlower" } } */
-/* { dg-final { cleanup-tree-dump "tmedge" } } */
-/* { dg-final { cleanup-tree-dump "tmlower" } } */
--- a/src/gcc/testsuite/gcc.dg/tm/props-2.c
+++ b/src/gcc/testsuite/gcc.dg/tm/props-2.c
@@ -18,4 +18,3 @@ foo(){
 }
 
 /* { dg-final { scan-ipa-dump-times "GTMA_MAY_ENTER_IRREVOCABLE" 1 "tmipa" } } */
-/* { dg-final { cleanup-ipa-dump "tmipa" } } */
--- a/src/gcc/testsuite/gcc.dg/tm/props-3.c
+++ b/src/gcc/testsuite/gcc.dg/tm/props-3.c
@@ -13,4 +13,3 @@ foo(){
 }
 
 /* { dg-final { scan-ipa-dump-times "GTMA_MAY_ENTER_IRREVOCABLE" 1 "tmipa" } } */
-/* { dg-final { cleanup-ipa-dump "tmipa" } } */
--- a/src/gcc/testsuite/gcc.dg/tm/props-4.c
+++ b/src/gcc/testsuite/gcc.dg/tm/props-4.c
@@ -22,5 +22,3 @@ foo(void)
 
 /* { dg-final { scan-tree-dump-times " instrumentedCode" 1 "tmedge" } } */
 /* { dg-final { scan-tree-dump-times "hasNoAbort" 0 "tmedge" } } */
-/* { dg-final { cleanup-tree-dump "tmedge" } } */
-/* { dg-final { cleanup-tree-dump "tmmark" } } */
--- a/src/gcc/testsuite/gcc.dg/tm/pub-safety-1.c
+++ b/src/gcc/testsuite/gcc.dg/tm/pub-safety-1.c
@@ -21,4 +21,3 @@ void reader()
 }
 
 /* { dg-final { scan-tree-dump-times "Cannot hoist.*DATA_DATA because it is in a transaction" 1 "lim1" } } */
-/* { dg-final { cleanup-tree-dump "lim1" } } */
--- a/src/gcc/testsuite/gcc.dg/tm/reg-promotion.c
+++ b/src/gcc/testsuite/gcc.dg/tm/reg-promotion.c
@@ -21,4 +21,3 @@ void func()
 }
 
 /* { dg-final { scan-tree-dump-times "Cannot hoist conditional load of count because it is in a transaction" 1 "lim1" } } */
-/* { dg-final { cleanup-tree-dump "lim1" } } */
--- a/src/gcc/testsuite/gcc.dg/tm/wrap-3.c
+++ b/src/gcc/testsuite/gcc.dg/tm/wrap-3.c
@@ -14,4 +14,3 @@ void foo()
    everything is as usual.  */
 /* { dg-final { scan-tree-dump-times "free" 1 "optimized" } } */
 
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tm/wrap-4.c
+++ b/src/gcc/testsuite/gcc.dg/tm/wrap-4.c
@@ -17,4 +17,3 @@ void foo()
    everything is as usual.  */
 /* { dg-final { scan-tree-dump-times "candy \\(\\);" 1 "optimized" } } */
 
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/torture/builtin-convert-4.c
+++ b/src/gcc/testsuite/gcc.dg/torture/builtin-convert-4.c
@@ -33,4 +33,3 @@ int main()
 /* { dg-final { scan-tree-dump-times "nearbyint " 1 "original" } } */
 /* { dg-final { scan-tree-dump-times "nearbyintf" 1 "original" } } */
 /* { dg-final { scan-tree-dump-times "nearbyintl" 1 "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/gcc.dg/torture/builtin-math-2.c
+++ b/src/gcc/testsuite/gcc.dg/torture/builtin-math-2.c
@@ -382,4 +382,3 @@ void bar()
 /* { dg-final { scan-tree-dump-times "_gamma_r " 6 "original" } } */
 /* { dg-final { scan-tree-dump-times "_gammaf_r" 6 "original" } } */
 /* { dg-final { scan-tree-dump-times "_gammal_r" 6 "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/gcc.dg/torture/builtin-math-5.c
+++ b/src/gcc/testsuite/gcc.dg/torture/builtin-math-5.c
@@ -120,4 +120,3 @@ void bar()
 /* { dg-final { scan-tree-dump-times "cpowf" 12 "original" { target { spu*-*-* } } } } */
 /* { dg-final { scan-tree-dump-times "cpow " 18 "original" } } */
 /* { dg-final { scan-tree-dump-times "cpowl" 18 "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/gcc.dg/torture/builtin-pow-mpfr-1.c
+++ b/src/gcc/testsuite/gcc.dg/torture/builtin-pow-mpfr-1.c
@@ -16,4 +16,3 @@ extern double testit()
 }
 
 /* { dg-final { scan-tree-dump "pow" "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/gcc.dg/torture/builtins-1.c
+++ b/src/gcc/testsuite/gcc.dg/torture/builtins-1.c
@@ -1,6 +1,5 @@
 /* { dg-do compile } */
 /* { dg-options "-fdump-rtl-expand-all" */
-/* { dg-final { cleanup-rtl-dump "expand" } } */
 int isdigit(int c)
 {
         return c >= 0;
--- a/src/gcc/testsuite/gcc.dg/torture/ipa-pta-1.c
+++ b/src/gcc/testsuite/gcc.dg/torture/ipa-pta-1.c
@@ -43,4 +43,3 @@ void test4 (int a4, char b, char c, char d, char e, char f, char g, char h)
 }
 
 /* { dg-final { scan-ipa-dump "bar.arg0 = { test4.arg0 test3.arg0 test2.arg0 test1.arg0 }" "pta" } } */
-/* { dg-final { cleanup-ipa-dump "pta" } } */
--- a/src/gcc/testsuite/gcc.dg/torture/ldist-1.c
+++ b/src/gcc/testsuite/gcc.dg/torture/ldist-1.c
@@ -9,4 +9,3 @@ void foo (volatile int *p, int n)
 }
 
 /* { dg-final { scan-assembler-not "memset" } } */
-/* { dg-final { cleanup-tree-dump "ldist" } } */
--- a/src/gcc/testsuite/gcc.dg/torture/pr23821.c
+++ b/src/gcc/testsuite/gcc.dg/torture/pr23821.c
@@ -26,4 +26,3 @@ main ()
    induction variable increment.  */
 
 /* { dg-final { scan-tree-dump "Added canonical iv" "ivcanon" } } */
-/* { dg-final { cleanup-tree-dump "ivcanon" } } */
--- a/src/gcc/testsuite/gcc.dg/torture/pr39074-2.c
+++ b/src/gcc/testsuite/gcc.dg/torture/pr39074-2.c
@@ -32,4 +32,3 @@ int main()
 
 /* { dg-final { scan-tree-dump "y.._. = { i }" "alias" } } */
 /* { dg-final { scan-tree-dump "y.._., points-to vars: { D..... }" "alias" } } */
-/* { dg-final { cleanup-tree-dump "alias" } } */
--- a/src/gcc/testsuite/gcc.dg/torture/pr39074.c
+++ b/src/gcc/testsuite/gcc.dg/torture/pr39074.c
@@ -31,4 +31,3 @@ int main()
 
 /* { dg-final { scan-tree-dump "y.._. = { i }" "alias" } } */
 /* { dg-final { scan-tree-dump "y.._., points-to vars: { D..... }" "alias" } } */
-/* { dg-final { cleanup-tree-dump "alias" } } */
--- a/src/gcc/testsuite/gcc.dg/torture/pr42898-2.c
+++ b/src/gcc/testsuite/gcc.dg/torture/pr42898-2.c
@@ -23,4 +23,3 @@ void f1(volatile struct hardware *ptr)
 }
 
 /* { dg-final { scan-tree-dump-times "\\*ptr" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/torture/pr42898.c
+++ b/src/gcc/testsuite/gcc.dg/torture/pr42898.c
@@ -21,4 +21,3 @@ void f1(volatile struct hardware *ptr)
 }
 
 /* { dg-final { scan-tree-dump-times "\\*ptr" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/torture/pr45704.c
+++ b/src/gcc/testsuite/gcc.dg/torture/pr45704.c
@@ -13,4 +13,3 @@ int foo(struct st *st)
 }
 
 /* { dg-final { scan-tree-dump-times "={v}" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/torture/pr50472.c
+++ b/src/gcc/testsuite/gcc.dg/torture/pr50472.c
@@ -10,4 +10,3 @@ unsigned int test( void )
 }
 
 /* { dg-final { scan-tree-dump-not "return 1" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/torture/pr55018.c
+++ b/src/gcc/testsuite/gcc.dg/torture/pr55018.c
@@ -20,4 +20,3 @@ lab:
 }
 
 /* { dg-final { scan-tree-dump "printf" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/torture/pr57147-1.c
+++ b/src/gcc/testsuite/gcc.dg/torture/pr57147-1.c
@@ -18,4 +18,3 @@ void TestSyscall(void)
 }
 
 /* { dg-final { scan-tree-dump-not "builtin_unreachable" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/torture/pr57147-2.c
+++ b/src/gcc/testsuite/gcc.dg/torture/pr57147-2.c
@@ -20,4 +20,3 @@ void TestSyscall(void)
 }
 
 /* { dg-final { scan-tree-dump "setjmp" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.dg/torture/pr66076.c
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-options "" } */
+/* { dg-options "-mno-prefer-avx128 -march=bdver4" { target i?86-*-* x86_64-*-* } } */
+
+void
+f0a (char *result, char *arg1, char *arg4, char temp_6)
+{
+  int idx = 0;
+  for (idx = 0; idx < 416; idx += 1)
+    result[idx] = (arg1[idx] + arg4[idx]) * temp_6;
+}
--- a/src/gcc/testsuite/gcc.dg/torture/pta-callused-1.c
+++ b/src/gcc/testsuite/gcc.dg/torture/pta-callused-1.c
@@ -22,4 +22,3 @@ int main()
 }
 
 /* { dg-final { scan-tree-dump "p.._. = { i j }" "alias" } } */
-/* { dg-final { cleanup-tree-dump "alias" } } */
--- a/src/gcc/testsuite/gcc.dg/torture/pta-escape-1.c
+++ b/src/gcc/testsuite/gcc.dg/torture/pta-escape-1.c
@@ -31,4 +31,3 @@ main()
 }
 
 /* { dg-final { scan-tree-dump "ESCAPED = {\[^\n\}\]* i \[^\n\}\]*}" "alias" } } */
-/* { dg-final { cleanup-tree-dump "alias" } } */
--- a/src/gcc/testsuite/gcc.dg/torture/pta-ptrarith-1.c
+++ b/src/gcc/testsuite/gcc.dg/torture/pta-ptrarith-1.c
@@ -30,4 +30,3 @@ int main()
 }
 
 /* { dg-final { scan-tree-dump "ESCAPED = {\[^\n\}\]* i f \[^\n\}\]*}" "alias" } } */
-/* { dg-final { cleanup-tree-dump "alias" } } */
--- a/src/gcc/testsuite/gcc.dg/torture/pta-ptrarith-2.c
+++ b/src/gcc/testsuite/gcc.dg/torture/pta-ptrarith-2.c
@@ -33,4 +33,3 @@ int main()
 /* In theory = { i } is the correct solution.  But it's not easy to scan
    for that reliably, so just use what we create now.  */
 /* { dg-final { scan-tree-dump "= { i j }" "alias" } } */
-/* { dg-final { cleanup-tree-dump "alias" } } */
--- a/src/gcc/testsuite/gcc.dg/torture/pta-ptrarith-3.c
+++ b/src/gcc/testsuite/gcc.dg/torture/pta-ptrarith-3.c
@@ -34,4 +34,3 @@ int main()
 }
 
 /* { dg-final { scan-tree-dump "q_. = { i j k }" "alias" } } */
-/* { dg-final { cleanup-tree-dump "alias" } } */
--- a/src/gcc/testsuite/gcc.dg/torture/pta-structcopy-1.c
+++ b/src/gcc/testsuite/gcc.dg/torture/pta-structcopy-1.c
@@ -33,4 +33,3 @@ int main()
 
 /* { dg-final { scan-tree-dump "y.* = { i }" "ealias" } } */
 /* { dg-final { scan-tree-dump "y.*, points-to vars: { D..... }" "ealias" } } */
-/* { dg-final { cleanup-tree-dump "ealias" } } */
--- a/src/gcc/testsuite/gcc.dg/torture/ssa-pta-fn-1.c
+++ b/src/gcc/testsuite/gcc.dg/torture/ssa-pta-fn-1.c
@@ -59,4 +59,3 @@ int main()
 /* { dg-final { scan-tree-dump "q_const_. = { NONLOCAL i }" "alias" } } */
 /* { dg-final { scan-tree-dump "q_pure_. = { ESCAPED NONLOCAL i }" "alias" } } */
 /* { dg-final { scan-tree-dump "q_normal_. = { ESCAPED NONLOCAL }" "alias" } } */
-/* { dg-final { cleanup-tree-dump "alias" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-prof/20050826-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-prof/20050826-2.c
@@ -73,4 +73,3 @@ main (void)
 }
 
 /* { dg-final-use { scan-tree-dump-not "Invalid sum" "dom1"} } */
-/* { dg-final-use { cleanup-tree-dump "dom1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-prof/cmpsf-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-prof/cmpsf-1.c
@@ -182,4 +182,3 @@ main (void)
 }
 
 /* { dg-final-use { scan-tree-dump-not "Invalid sum" "dom1"} } */
-/* { dg-final-use { cleanup-tree-dump "dom1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-prof/cold_partition_label.c
+++ b/src/gcc/testsuite/gcc.dg/tree-prof/cold_partition_label.c
@@ -35,4 +35,3 @@ main (int argc, char *argv[])
   return 0;
 }
 
-/* { dg-final-use { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.dg/tree-prof/ic-misattribution-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-prof/ic-misattribution-1.c
@@ -16,4 +16,3 @@ caller(void (*func) (void))
 }
 
 /* { dg-final-use { scan-ipa-dump "hist->count 1 hist->all 1" "profile" } } */
-/* { dg-final-use { cleanup-ipa-dump "profile" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-prof/ic-misattribution-1a.c
+++ b/src/gcc/testsuite/gcc.dg/tree-prof/ic-misattribution-1a.c
@@ -19,4 +19,3 @@ main ()
   return 0;
 }
 
-/* { dg-final-use { cleanup-ipa-dump "profile" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-prof/indir-call-prof.c
+++ b/src/gcc/testsuite/gcc.dg/tree-prof/indir-call-prof.c
@@ -39,5 +39,3 @@ main (void)
 
 /* { dg-final-use { scan-ipa-dump "Indirect call -> direct call.* a1 transformation on insn" "profile"} } */
 /* { dg-final-use { scan-tree-dump-not "Invalid sum" "optimized"} } */
-/* { dg-final-use { cleanup-tree-dump "optimized" } } */
-/* { dg-final-use { cleanup-ipa-dump "profile" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-prof/inliner-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-prof/inliner-1.c
@@ -40,4 +40,3 @@ main ()
    declaration or other appearances of the string in dump.  */
 /* { dg-final-use { scan-tree-dump "cold_function ..;" "optimized"} } */
 /* { dg-final-use { scan-tree-dump-not "hot_function ..;" "optimized"} } */
-/* { dg-final-use { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-prof/merge_block.c
+++ b/src/gcc/testsuite/gcc.dg/tree-prof/merge_block.c
@@ -19,4 +19,3 @@ main ()
   return 0;
 }
 /* { dg-final-use { scan-tree-dump-not "Invalid sum" "optimized"} } */
-/* { dg-final-use { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-prof/peel-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-prof/peel-1.c
@@ -23,4 +23,3 @@ main()
 /* { dg-final-use { scan-tree-dump "Peeled loop ., 2 times" "cunroll" } } */
 /* In fact one peeling is enough; we however mispredict number of iterations of the loop
    at least until loop_ch is schedule ahead of profiling pass.  */
-/* { dg-final-use { cleanup-tree-dump "cunroll" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-prof/stringop-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-prof/stringop-1.c
@@ -19,5 +19,3 @@ main()
 /* a[0] = b[0] is what we fold the resulting memcpy into.  */
 /* { dg-final-use { scan-tree-dump " = MEM.*&b" "optimized"} } */
 /* { dg-final-use { scan-tree-dump "MEM.*&a\\\] = " "optimized"} } */
-/* { dg-final-use { cleanup-tree-dump "optimized" } } */
-/* { dg-final-use { cleanup-ipa-dump "profile" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-prof/stringop-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-prof/stringop-2.c
@@ -21,5 +21,3 @@ main()
 /* { dg-final-use { scan-ipa-dump "Single value 4 stringop" "profile"} } */
 /* The versioned memset of size 4 should be optimized to an assignment.  */
 /* { dg-final-use { scan-tree-dump "MEM\\\[\\(void .\\)&a\\\] = 168430090" "optimized"} } */
-/* { dg-final-use { cleanup-tree-dump "optimized" } } */
-/* { dg-final-use { cleanup-ipa-dump "profile" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-prof/switch-case-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-prof/switch-case-1.c
@@ -37,4 +37,3 @@ int main ()
 }
 /* { dg-final-use { scan-rtl-dump-times ";; basic block\[^\\n\]*count 4000" 2 "expand"} } */
 /* { dg-final-use { scan-rtl-dump-times ";; basic block\[^\\n\]*count 2000" 1 "expand"} } */
-/* { dg-final-use { cleanup-rtl-dump "expand" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-prof/switch-case-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-prof/switch-case-2.c
@@ -37,4 +37,3 @@ int main ()
 }
 /* { dg-final-use { scan-rtl-dump-times ";; basic block\[^\\n\]*count 4000" 2 "expand"} } */
 /* { dg-final-use { scan-rtl-dump-times ";; basic block\[^\\n\]*count 2000" 1 "expand"} } */
-/* { dg-final-use { cleanup-rtl-dump "expand" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-prof/time-profiler-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-prof/time-profiler-1.c
@@ -19,4 +19,3 @@ int main ()
 /* { dg-final-use { scan-ipa-dump-times "Read tp_first_run: 0" 1 "profile"} } */
 /* { dg-final-use { scan-ipa-dump-times "Read tp_first_run: 1" 1 "profile"} } */
 /* { dg-final-use { scan-ipa-dump-times "Read tp_first_run: 2" 1 "profile"} } */
-/* { dg-final-use { cleanup-ipa-dump "profile" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-prof/time-profiler-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-prof/time-profiler-2.c
@@ -47,4 +47,3 @@ int main ()
 /* { dg-final-use { scan-ipa-dump-times "Read tp_first_run: 1" 1 "profile"} } */
 /* { dg-final-use { scan-ipa-dump-times "Read tp_first_run: 2" 1 "profile"} } */
 /* { dg-final-use { scan-ipa-dump-times "Read tp_first_run: 3" 1 "profile"} } */
-/* { dg-final-use { cleanup-ipa-dump "profile" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-prof/tracer-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-prof/tracer-1.c
@@ -15,4 +15,3 @@ int main ()
 }
 /* Superblock formation should produce two copies of the increment of c */
 /* { dg-final-generate { scan-tree-dump-times "c =" 2 "tracer" } } */
-/* { dg-final-use { cleanup-tree-dump "tracer" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-prof/unroll-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-prof/unroll-1.c
@@ -21,4 +21,3 @@ main()
   return 0;
 }
 /* { dg-final-use { scan-rtl-dump "Considering unrolling loop with constant number of iterations" "loop2_unroll" } } */
-/* { dg-final-use { cleanup-rtl-dump "loop2_unroll" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-prof/update-cunroll-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-prof/update-cunroll-2.c
@@ -19,4 +19,3 @@ main ()
   return 0;
 }
 /* { dg-final-use { scan-tree-dump-not "Invalid sum" "optimized"} } */
-/* { dg-final-use { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-prof/update-loopch.c
+++ b/src/gcc/testsuite/gcc.dg/tree-prof/update-loopch.c
@@ -19,5 +19,3 @@ main ()
 /* { dg-final-use { scan-tree-dump-not "loop depth 1, count 33332" "optimized"} } */
 /* { dg-final-use { scan-tree-dump "Removing basic block" "optimized"} } */
 /* { dg-final-use { scan-tree-dump-not "Invalid sum" "optimized"} } */
-/* { dg-final-use { cleanup-ipa-dump "profile" } } */
-/* { dg-final-use { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-prof/update-tailcall.c
+++ b/src/gcc/testsuite/gcc.dg/tree-prof/update-tailcall.c
@@ -16,5 +16,3 @@ main()
 }
 /* { dg-final-use { scan-tree-dump-not "Invalid sum" "tailc"} } */
 /* { dg-final-use { scan-tree-dump-not "Invalid sum" "optimized"} } */
-/* { dg-final-use { cleanup-tree-dump "tailc" } } */
-/* { dg-final-use { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-prof/val-prof-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-prof/val-prof-1.c
@@ -19,5 +19,3 @@ main ()
 /* { dg-final-use { scan-ipa-dump "Div.mod by constant n_\[0-9\]*=257 transformation on insn" "profile"} } */
 /* { dg-final-use { scan-tree-dump "if \\(n_\[0-9\]* != 257\\)" "optimized"} } */
 /* { dg-final-use { scan-tree-dump-not "Invalid sum" "optimized"} } */
-/* { dg-final-use { cleanup-tree-dump "optimized" } } */
-/* { dg-final-use { cleanup-ipa-dump "profile" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-prof/val-prof-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-prof/val-prof-2.c
@@ -29,5 +29,3 @@ main ()
    didn't get optimized out.  */
 /* { dg-final-use { scan-tree-dump "n_\[0-9\]* \\+ (4294967295|0x0*ffffffff)" "optimized"} } */
 /* { dg-final-use { scan-tree-dump-not "Invalid sum" "optimized"} } */
-/* { dg-final-use { cleanup-tree-dump "optimized" } } */
-/* { dg-final-use { cleanup-ipa-dump "profile" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-prof/val-prof-3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-prof/val-prof-3.c
@@ -29,5 +29,3 @@ main ()
    didn't get optimized out.  */
 /* { dg-final-use { scan-tree-dump "if \\(n_\[0-9\]* \\>" "optimized"} } */
 /* { dg-final-use { scan-tree-dump-not "Invalid sum" "optimized"} } */
-/* { dg-final-use { cleanup-tree-dump "optimized" } } */
-/* { dg-final-use { cleanup-ipa-dump "profile" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-prof/val-prof-4.c
+++ b/src/gcc/testsuite/gcc.dg/tree-prof/val-prof-4.c
@@ -29,5 +29,3 @@ main ()
    didn't get optimized out.  */
 /* { dg-final-use { scan-tree-dump "if \\(n_\[0-9\]* \\>" "optimized"} } */
 /* { dg-final-use { scan-tree-dump-not "Invalid sum" "optimized"} } */
-/* { dg-final-use { cleanup-tree-dump "optimized" } } */
-/* { dg-final-use { cleanup-ipa-dump "profile" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-prof/val-prof-5.c
+++ b/src/gcc/testsuite/gcc.dg/tree-prof/val-prof-5.c
@@ -14,5 +14,3 @@ main()
 }
 /* { dg-final-use { scan-ipa-dump "Div.mod by constant b.*=997 transformation on insn" "profile" } } */
 /* { dg-final-use { scan-tree-dump-not "Invalid sum" "optimized"} } */
-/* { dg-final-use { cleanup-tree-dump "optimized" } } */
-/* { dg-final-use { cleanup-ipa-dump "profile" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-prof/val-prof-6.c
+++ b/src/gcc/testsuite/gcc.dg/tree-prof/val-prof-6.c
@@ -17,4 +17,3 @@ main()
 }
 /* { dg-final-use { scan-tree-dump "Average value sum:499500" "optimized"} } */
 /* { dg-final-use { scan-tree-dump "IOR value" "optimized"} } */
-/* { dg-final-use { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-prof/val-prof-7.c
+++ b/src/gcc/testsuite/gcc.dg/tree-prof/val-prof-7.c
@@ -23,4 +23,3 @@ int main() {
 }
 
 /* { dg-final-use { scan-ipa-dump "Single value 8 stringop transformation on bzero" "profile" } } */
-/* { dg-final-use { cleanup-ipa-dump "profile" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20030530-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20030530-2.c
@@ -24,5 +24,4 @@ rs6000_emit_prologue (int i, rs6000_stack_t *info)
    commutative operands correctly.  */
 /* { dg-final { scan-tree-dump-times "\\+" 1 "dom2"} } */
  
-/* { dg-final { cleanup-tree-dump "dom2" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20030611-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20030611-1.c
@@ -12,4 +12,3 @@ shit(int a)
 /* There should be precisely one call to square.   If there is more than one,
    then the dominator optimizations failed to remove the redundant call.  */
 /* { dg-final { scan-tree-dump-times "square" 1 "dom2"} } */
-/* { dg-final { cleanup-tree-dump "dom2" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20030703-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20030703-1.c
@@ -20,4 +20,3 @@ foo(int index)
 /* There should be exactly one IF conditional.  */
 /* { dg-final { scan-tree-dump-times "if " 1 "dom2"} } */
 
-/* { dg-final { cleanup-tree-dump "dom2" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20030703-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20030703-2.c
@@ -41,4 +41,3 @@ get_alias_set (t)
    if() to disappear.  */
 /* { dg-final { scan-tree-dump-times "if " 1 "dom2"} } */
 
-/* { dg-final { cleanup-tree-dump "dom2" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20030708-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20030708-1.c
@@ -42,4 +42,3 @@ nonlocal_mentioned_p (x)
 /* There should be no IF conditionals.  */
 /* { dg-final { scan-tree-dump-times "if " 0 "dom2"} } */
                                                                                 
-/* { dg-final { cleanup-tree-dump "dom2" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20030709-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20030709-1.c
@@ -14,4 +14,3 @@ foo ()
 
 /* There should be no IF conditionals.  */
 /* { dg-final { scan-tree-dump-times "if " 0 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20030709-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20030709-2.c
@@ -52,4 +52,3 @@ get_alias_set (t)
    collapse down to a simple return 0 without any conditionals).  */
 /* { dg-final { scan-tree-dump-times "if " 1 "cddce2"} } */
 
-/* { dg-final { cleanup-tree-dump "cddce2" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20030709-3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20030709-3.c
@@ -45,4 +45,3 @@ record_component_aliases (type)
 /* There should be one IF conditional.  */
 /* { dg-final { scan-tree-dump-times "if " 1 "dom2"} } */
 
-/* { dg-final { cleanup-tree-dump "dom2" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20030710-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20030710-1.c
@@ -53,4 +53,3 @@ record_component_aliases (type)
 /* There should be two loads of vec.length.  */
 /* { dg-final { scan-tree-dump-times "vec.length" 2 "dom2"} } */
 
-/* { dg-final { cleanup-tree-dump "dom2" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20030711-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20030711-1.c
@@ -53,4 +53,3 @@ record_component_aliases (type)
 /* There should be four loads of vec.length.  */
 /* { dg-final { scan-tree-dump-times "vec.length" 4 "dom2"} } */
 
-/* { dg-final { cleanup-tree-dump "dom2" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20030711-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20030711-2.c
@@ -67,4 +67,3 @@ get_alias_set (t,z)
 /* There should be one load of alias.  */
 /* { dg-final { scan-tree-dump-times "->alias" 1 "dom2"} } */
 
-/* { dg-final { cleanup-tree-dump "dom2" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20030711-3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20030711-3.c
@@ -59,4 +59,3 @@ get_alias_set (t)
 /* There should be one load of alias.  */
 /* { dg-final { scan-tree-dump-times "->alias" 1 "dom2"} } */
 
-/* { dg-final { cleanup-tree-dump "dom2" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20030714-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20030714-1.c
@@ -43,4 +43,3 @@ find_base_value_wrapper (src)
 /* There should be no casts to short unsigned int.  */
 /* { dg-final { scan-tree-dump-times "\\(short unsigned int\\)" 0 "dom2"} } */
 
-/* { dg-final { cleanup-tree-dump "dom2" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20030714-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20030714-2.c
@@ -36,4 +36,3 @@ get_alias_set (t)
    properly.  */
 /* { dg-final { scan-tree-dump-times "if " 3 "dom2"} } */
  
-/* { dg-final { cleanup-tree-dump "dom2" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20030728-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20030728-1.c
@@ -42,4 +42,3 @@ objects_must_conflict_p (t1, t2)
    second to be propagated into all its uses and eliminated.   */
 /* { dg-final { scan-rtl-dump-times "PART.. = 0" 1 "expand"} } */
  
-/* { dg-final { cleanup-rtl-dump "expand" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20030729-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20030729-1.c
@@ -51,4 +51,3 @@ readonly_fields_p (type)
    because we load from ->common.code using different types.  */
 /* { dg-final { scan-tree-dump-times "common\.code" 1 "dom2"} } */
 
-/* { dg-final { cleanup-tree-dump "dom2" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20030730-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20030730-1.c
@@ -22,4 +22,3 @@ foo (int attr_kind, unsigned long offset)
 /* { dg-final { scan-tree-dump-times "if " 0 "dom2" { target { ! keeps_null_pointer_checks } } } } */
 /* { dg-final { scan-tree-dump "if " "dom2" { target { keeps_null_pointer_checks } } } } */
      
-/* { dg-final { cleanup-tree-dump "dom2" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20030730-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20030730-2.c
@@ -22,4 +22,3 @@ foo (int attr_kind, unsigned long offset)
 /* { dg-final { scan-tree-dump-times "if " 0 "dom2" { target { ! keeps_null_pointer_checks } } } } */
 /* { dg-final { scan-tree-dump "if " "dom2" { target { keeps_null_pointer_checks } } } } */
 
-/* { dg-final { cleanup-tree-dump "dom2" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20030731-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20030731-1.c
@@ -64,4 +64,3 @@ store_expr (exp, target, want_value)
    immediately dominates the comparison in question.  We need something
    stronger.  */
 /* { dg-final { scan-tree-dump-times "target.*!= 0" 0 "dom2" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "dom2" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20030731-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20030731-2.c
@@ -16,4 +16,3 @@ bar (int i, int partial, int args_addr)
 /* There should be only one IF conditional since the first does nothing
    useful.  */
 /* { dg-final { scan-tree-dump-times "if " 1 "dce1"} } */
-/* { dg-final { cleanup-tree-dump "dce1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20030807-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20030807-1.c
@@ -43,4 +43,3 @@ bar (rtx r)
    which combines the result of those two tests into a new test
    must always be true and it is optimized appropriately.  */
 /* { dg-final { scan-tree-dump-times "if " 2 "dom2"} } */
-/* { dg-final { cleanup-tree-dump "dom2" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20030807-10.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20030807-10.c
@@ -23,4 +23,3 @@ subreg_highpart_offset (outermode, innermode)
 /* There should be one right shift by 2 places.  */
 /* { dg-final { scan-tree-dump-times " >> 2" 1 "vrp1"} } */
 
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20030807-11.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20030807-11.c
@@ -19,4 +19,3 @@ foo (reg)
                                                                                 
 /* There should be no IF conditionals.  */
 /* { dg-final { scan-tree-dump-times "if " 0 "dom2"} } */
-/* { dg-final { cleanup-tree-dump "dom2" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20030807-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20030807-2.c
@@ -29,4 +29,3 @@ foo(int n)
                                                                                
 /* There should be no IF conditionals.  */
 /* { dg-final { scan-tree-dump-times "if " 0 "dom2" } } */
-/* { dg-final { cleanup-tree-dump "dom2" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20030807-3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20030807-3.c
@@ -26,4 +26,3 @@ cpp_parse_escape (pstr, limit, wide)
 /* There should be precisely three IF statements.  If there is
    more than two, then the dominator optimizations failed.  */
 /* { dg-final { scan-tree-dump-times "if " 3 "dom2"} } */
-/* { dg-final { cleanup-tree-dump "dom2" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20030807-5.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20030807-5.c
@@ -36,4 +36,3 @@ foo ()
    The other one for '(EXPR)->unchanging'.  */
 /* { dg-final { scan-tree-dump-times "if " 2 "dom2"} } */
 
-/* { dg-final { cleanup-tree-dump "dom2" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20030807-6.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20030807-6.c
@@ -40,4 +40,3 @@ foo4 (distance, i, j)
 
 /* There should be no ABS_EXPR.  */
 /* { dg-final { scan-tree-dump-times "ABS_EXPR " 0 "vrp1"} } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20030807-7.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20030807-7.c
@@ -35,4 +35,3 @@ simplify_condition (cond_p)
 
 /* There should be exactly one IF conditional.  */
 /* { dg-final { scan-tree-dump-times "if " 1 "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20030807-8.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20030807-8.c
@@ -52,4 +52,3 @@ output_location_lists (die)
 
 /* There should be exactly one IF conditional, in output_location_lists.  */
 /* { dg-final { scan-tree-dump-times "if " 1 "dom2"} } */
-/* { dg-final { cleanup-tree-dump "dom2" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20030807-9.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20030807-9.c
@@ -20,4 +20,3 @@ ooof ()
 
 /* There should be no IF conditionals.  */
 /* { dg-final { scan-tree-dump-times "if " 0 "dom2"} } */
-/* { dg-final { cleanup-tree-dump "dom2" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20030808-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20030808-1.c
@@ -38,4 +38,3 @@ delete_dead_jumptables ()
 /* There should be no IF statements.  */
 /* { dg-final { scan-tree-dump-times "if " 0 "cddce2"} } */
 
-/* { dg-final { cleanup-tree-dump "cddce2" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20030814-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20030814-1.c
@@ -20,4 +20,3 @@ com(int *blah)
    more than one, then the dominator optimizations failed.  */
 /* { dg-final { scan-tree-dump-times "\\*blah" 1 "dom2"} } */
   
-/* { dg-final { cleanup-tree-dump "dom2" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20030814-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20030814-2.c
@@ -20,4 +20,3 @@ foo (int value)
 /* There should be no IF conditionals.  */
 /* { dg-final { scan-tree-dump-times "if " 0 "dom2"} } */
  
-/* { dg-final { cleanup-tree-dump "dom2" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20030814-3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20030814-3.c
@@ -21,4 +21,3 @@ foo (int value)
 /* There should be one IF conditional.  */
 /* { dg-final { scan-tree-dump-times "if " 1 "dom2"} } */
  
-/* { dg-final { cleanup-tree-dump "dom2" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20030814-4.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20030814-4.c
@@ -36,9 +36,7 @@ blah (decl, set)
 /* There should be precisely one reference to pointer_alias_set.  If there is
    more than one, then the dominator optimizations failed.  */
 /* { dg-final { scan-tree-dump-times "pointer_alias_set" 1 "dom2"} } */
-/* { dg-final { cleanup-tree-dump "dom2" } } */
 
 /* The assignment set = -1 in the ELSE clause of the last IF
    statement should be removed by the final cleanup phase.  */
 /* { dg-final { scan-tree-dump-times "set = -1" 0 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20030814-5.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20030814-5.c
@@ -37,9 +37,7 @@ blah (decl, set)
 /* There should be precisely one reference to pointer_alias_set.  If there is
    more than one, then the dominator optimizations failed.  */
 /* { dg-final { scan-tree-dump-times "pointer_alias_set" 1 "dom2"} } */
-/* { dg-final { cleanup-tree-dump "dom2" } } */
 
 /* The assignment set = -1 in the ELSE clause of the last IF
    statement should be removed by the final cleanup phase.  */
 /* { dg-final { scan-tree-dump-times "set = -1" 0 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20030814-6.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20030814-6.c
@@ -42,4 +42,3 @@ foo (t, set)
 /* ??? Will fail until we properly distinguish member stores.  At
    present the write to type.alias_set kills the previous load.  */
 /* { dg-final { scan-tree-dump-times "common.code" 1 "dom2" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "dom2" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20030814-7.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20030814-7.c
@@ -39,4 +39,3 @@ mark_constant_function (void)
    This if we find current_function_decl used as an argument, then
    we have failed.  */
 /* { dg-final { scan-tree-dump-times "\\(current_function_decl\\)" 0 "dom2"} } */
-/* { dg-final { cleanup-tree-dump "dom2" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20030821-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20030821-1.c
@@ -26,5 +26,3 @@ y: ;
 
 /* We should have folded away the goto &x  */
 /* { dg-final { scan-tree-dump-times "goto &x" 0 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
-/* { dg-final { cleanup-tree-dump "dom1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20030824-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20030824-1.c
@@ -20,4 +20,3 @@ int foo (int x, int y)
 
 /* The addition should be optimized into 'y+x'.  */
 /* { dg-final { scan-tree-dump-times "\[xy\]_..D. \\+ \[xy]_..D." 1 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20030824-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20030824-2.c
@@ -20,4 +20,3 @@ int foo (int x, int y)
 
 /* This function should be optimized into 'return y+x'.  */
 /* { dg-final { scan-tree-dump-times "\[xy\]_..D. \\+ \[xy]_..D." 1 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20030825-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20030825-1.c
@@ -26,4 +26,3 @@ xxx:;
 
 /* Bla should not be optimized away.  */
 /* { dg-final { scan-tree-dump-times "bla" 1 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20030907-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20030907-1.c
@@ -27,4 +27,3 @@ int main()
 
 /* The abort() call clearly is unreachable.  */
 /* { dg-final { scan-tree-dump-times "abort" 0 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20030917-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20030917-1.c
@@ -16,4 +16,3 @@ findbestextension (int blah, int blah2)
 
 /* The argument to "foo" should be a variable, not a constant.  */
 /* { dg-final { scan-tree-dump-times "foo .defval" 1 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20030917-3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20030917-3.c
@@ -22,4 +22,3 @@ main ()
 
 /* The argument to "printf" should be a constant, not a variable.  */
 /* { dg-final { scan-tree-dump-times "printf.*, 0" 1 "ccp1"} } */
-/* { dg-final { cleanup-tree-dump "ccp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20030922-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20030922-1.c
@@ -31,4 +31,3 @@ voidify_wrapper_expr (tree wrapper)
 
 /* There should be no IF conditionals.  */
 /* { dg-final { scan-tree-dump-times "if " 0 "dom2"} } */
-/* { dg-final { cleanup-tree-dump "dom2" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20030922-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20030922-2.c
@@ -21,4 +21,3 @@ rgn_rank (rtx insn1, rtx insn2)
 
 /* There should be two IF conditionals.  */
 /* { dg-final { scan-tree-dump-times "if " 2 "dom1" } } */
-/* { dg-final { cleanup-tree-dump "dom1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20031015-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20031015-1.c
@@ -15,4 +15,3 @@ main(void)
 
 /* The VDEF comes from the initial assignment, the asm, and the clobber.  */
 /* { dg-final { scan-tree-dump-times "DEF" 3 "alias" } } */
-/* { dg-final { cleanup-tree-dump "alias" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20031021-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20031021-1.c
@@ -18,4 +18,3 @@ int main()
 
 /* We should only store to a.i, not load from it.  */
 /* { dg-final { scan-tree-dump-not "= a.i" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20031022-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20031022-1.c
@@ -27,4 +27,3 @@ blah (int arf)
 
 /* There should be one load from entry_exit_blocks[1].pred.  */
 /* { dg-final { scan-tree-dump-times "entry_exit_blocks.1..pred" 1 "dom1"} } */
-/* { dg-final { cleanup-tree-dump "dom1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20031106-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20031106-1.c
@@ -18,4 +18,3 @@ void foo (int testarray[])
 
 /* There should be no link_error calls.  */
 /* { dg-final { scan-tree-dump-times "link_error" 0 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20031106-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20031106-2.c
@@ -26,4 +26,3 @@ void foo (struct s* teststruct)
 /* There should be no link_error calls.  */
 /* { dg-final { scan-tree-dump-times "link_error" 0 "optimized"} } */
 
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20031106-3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20031106-3.c
@@ -19,4 +19,3 @@ void foo (int testarray[])
 
 /* There should be no link_error calls.  */
 /* { dg-final { scan-tree-dump-times "link_error" 0 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20031106-4.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20031106-4.c
@@ -27,4 +27,3 @@ void foo (struct s*  r)
 
 /* There should be no link_error calls.  */
 /* { dg-final { scan-tree-dump-times "link_error" 0 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20031106-5.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20031106-5.c
@@ -26,4 +26,3 @@ void foo2 (struct s*  r, struct s*  p)
 
 /* There should be no link_error calls.  */
 /* { dg-final { scan-tree-dump-times "link_error" 0 "optimized" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20031106-6.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20031106-6.c
@@ -26,4 +26,3 @@ struct s foo (struct s r)
 /* There should be no references to any of "temp_struct*"
    temporaries.  */
 /* { dg-final { scan-tree-dump-times "temp_struct" 0 "optimized" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20031216-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20031216-1.c
@@ -17,4 +17,3 @@ foo (int b)
 /* The comparison should be eliminated, there should be no reference
    to link_error.  */
 /* { dg-final { scan-tree-dump-times "link_error" 0 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20040204-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20040204-1.c
@@ -34,4 +34,3 @@ void test55 (int x, int y)
    by teaching dom to look through && and register all components
    as true.  */
 /* { dg-final { scan-tree-dump-times "link_error" 0 "optimized" { xfail { ! "alpha*-*-* arm*-*-* aarch64*-*-* powerpc*-*-* cris-*-* crisv32-*-* hppa*-*-* i?86-*-* mmix-*-* mips*-*-* m68k*-*-* moxie-*-* nds32*-*-* sh*-*-* sparc*-*-* spu-*-* visium-*-* x86_64-*-*" } } } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20040210-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20040210-1.c
@@ -30,4 +30,3 @@ main(){
 
 /* Should have no more than two ifs left after straightening.  */
 /* { dg-final { scan-tree-dump-times "if " 2 "phiopt1"} } */
-/* { dg-final { cleanup-tree-dump "phiopt1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20040211-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20040211-1.c
@@ -36,4 +36,3 @@ com (rtx insn, int blah)
 /* Cddce cannot remove possibly infinite loops and there is no way how to
    determine whether the loop in can_move_up ends.  */
 /* { dg-final { scan-tree-dump "if " "cddce2"} } */
-/* { dg-final { cleanup-tree-dump "cddce2" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20040216-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20040216-1.c
@@ -16,4 +16,3 @@ foo(int *z, int *y, int xx)
 
 /* We should convert two COND_EXPRs into straightline code.  */
 /* { dg-final { scan-tree-dump-times "Deleted dead store" 2 "dse1"} } */
-/* { dg-final { cleanup-tree-dump "dse1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20040305-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20040305-1.c
@@ -24,9 +24,7 @@ void foo(int edx, int eax)
 
 /* Verify that we did a forward propagation.  */
 /* { dg-final { scan-tree-dump-times "Replaced" 1 "forwprop1"} } */
-/* { dg-final { cleanup-tree-dump "forwprop1" } } */
 
 /* After cddce we should have two IF statements remaining as the other
    two tests can be threaded.  */
 /* { dg-final { scan-tree-dump-times "if " 2 "cddce2"} } */
-/* { dg-final { cleanup-tree-dump "cddce2" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20040430-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20040430-1.c
@@ -23,4 +23,3 @@ int main()
 }
 
 /* { dg-final { scan-tree-dump-times "if " 0 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20040513-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20040513-1.c
@@ -14,4 +14,3 @@ foo (unsigned int a)
 /* There should be no casts to a _Bool since we can use the temporary
    holding (a>>5)&1 directly.  */
 /* { dg-final { scan-tree-dump-times "\\(_Bool\\)" 0 "forwprop1"} } */
-/* { dg-final { cleanup-tree-dump "forwprop1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20040513-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20040513-2.c
@@ -22,4 +22,3 @@ int t(int i)
 /* There should be no link_error calls, if there is any, the
    optimization has failed */
 /* { dg-final { scan-tree-dump-times "link_error" 0 "dom2"} } */
-/* { dg-final { cleanup-tree-dump "dom2" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20040514-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20040514-1.c
@@ -16,4 +16,3 @@ end:
 
 /* Should have no ifs left after straightening.  */
 /* { dg-final { scan-tree-dump-times "if " 0 "phiopt1"} } */
-/* { dg-final { cleanup-tree-dump "phiopt1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20040514-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20040514-2.c
@@ -14,5 +14,4 @@ foo2 (distance, i, j)
 /* There should be one ABS_EXPR and no conditionals.  */
 /* { dg-final { scan-tree-dump-times "ABS_EXPR " 1 "phiopt1"} } */
 /* { dg-final { scan-tree-dump-times "if " 0 "phiopt1"} } */
-/* { dg-final { cleanup-tree-dump "phiopt1" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20040517-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20040517-1.c
@@ -19,4 +19,3 @@ void bar (void)
    Hence, we must have a VDEF for a before and after the call to foo().
    And one after the call to abort().  */
 /* { dg-final { scan-tree-dump-times "VDEF" 3 "alias"} } */
-/* { dg-final { cleanup-tree-dump "alias" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20040518-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20040518-1.c
@@ -10,4 +10,3 @@ int f(int a, int b)
 
 /* Should have no ifs left after straightening.  */
 /* { dg-final { scan-tree-dump-times "if " 0 "phiopt1"} } */
-/* { dg-final { cleanup-tree-dump "phiopt1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20040518-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20040518-2.c
@@ -14,4 +14,3 @@ int t( int i)
 /* We should convert one COND_EXPRs into straightline code with ABS.  */
 /* { dg-final { scan-tree-dump-times "straightline" 1 "phiopt1"} } */
 /* { dg-final { scan-tree-dump-times "ABS_EXPR" 1 "phiopt1"} } */
-/* { dg-final { cleanup-tree-dump "phiopt1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20040615-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20040615-1.c
@@ -14,4 +14,3 @@ foo (unsigned int a, unsigned int b)
 }
 
 /* { dg-final { scan-tree-dump-times "bar2" 0 "dom1" } } */
-/* { dg-final { cleanup-tree-dump "dom1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20040624-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20040624-1.c
@@ -18,4 +18,3 @@ foo (unsigned int a, unsigned int b)
    conditional.  */
 
 /* { dg-final { scan-tree-dump-times "if " 1 "dom1" } } */
-/* { dg-final { cleanup-tree-dump "dom1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20040703-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20040703-1.c
@@ -10,4 +10,3 @@ float foo(float x)
 
 /* We should *not* fold the arithmetic.  */
 /* { dg-final { scan-tree-dump-times "0\\.0" 0 "dom2"} } */
-/* { dg-final { cleanup-tree-dump "dom2" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20040729-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20040729-1.c
@@ -17,4 +17,3 @@ foo ()
    operands.  But 'p' itself is not volatile and taking the address of
    a volatile does not constitute a volatile operand.  */
 /* { dg-final { scan-tree-dump-times "&x" 0 "dce2"} } */
-/* { dg-final { cleanup-tree-dump "dce2" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20040911-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20040911-1.c
@@ -19,4 +19,3 @@ int foo (int i)
 }
 
 /* { dg-final { scan-tree-dump-not "VUSE <c" "alias" } } */
-/* { dg-final { cleanup-tree-dump "alias" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20041002-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20041002-1.c
@@ -21,4 +21,3 @@ bar (int i)
 }
 
 /* { dg-final { scan-tree-dump-times "if" 0 "ssa" } } */
-/* { dg-final { cleanup-tree-dump "ssa" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20041122-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20041122-1.c
@@ -35,4 +35,3 @@ find_unreachable_blocks (void)
    modify e or e->dest if we can assert strict-aliasing rules.
    The net result is that we only need one load of e->dest.  */
 /* { dg-final { scan-tree-dump-times "->dest" 1 "cddce1" } } */
-/* { dg-final { cleanup-tree-dump "cddce1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20050128-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20050128-1.c
@@ -11,4 +11,3 @@ foo (int align)
 /* We should have optimized away the mod operator before we gimpleized
    the code.  */
 /* { dg-final { scan-tree-dump-times "%" 0 "gimple"} } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20050215-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20050215-1.c
@@ -11,4 +11,3 @@ int foo (void)
 /* Make sure the optimizers don't introduce overflow where one
    did not exist in the original.  */
 /* { dg-final { scan-tree-dump-times "-0+4" 0 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20050314-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20050314-1.c
@@ -18,4 +18,3 @@ void xxx (void)
    cannot read nor write the memory.  */
 
 /* { dg-final { scan-tree-dump-times "Moving statement" 1 "lim1" } } */
-/* { dg-final { cleanup-tree-dump "lim1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20050412-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20050412-1.c
@@ -13,4 +13,3 @@ void foo (int a) {
 /* Make sure we do not have an assignment a = 0 in the resulting
    optimized dump.  */
 /* { dg-final { scan-tree-dump-times "a.* = 0;" 0 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/20080530.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/20080530.c
@@ -19,4 +19,3 @@ baz (void)
 }
 
 /* { dg-final { scan-tree-dump-times "Inlining foo into baz" 0 "einline"} } */
-/* { dg-final { cleanup-tree-dump "einline" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/alias-10.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/alias-10.c
@@ -16,5 +16,4 @@ int foo(int i)
 }
 
 /* { dg-final { scan-tree-dump "return 3;" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/alias-11.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/alias-11.c
@@ -18,4 +18,3 @@ int bar(void)
    the latter is an ssa temporary.  */
 /* { dg-final { scan-tree-dump "= a.0.;" "optimized" } } */
 /* { dg-final { scan-tree-dump "= \\*\[^\r\n\]*_.;" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/alias-12.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/alias-12.c
@@ -14,5 +14,4 @@ int foo(int i)
 }
 
 /* { dg-final { scan-tree-dump "VDEF" "alias" } } */
-/* { dg-final { cleanup-tree-dump "alias" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/alias-17.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/alias-17.c
@@ -15,4 +15,3 @@ int foo(int x)
 }
 
 /* { dg-final { scan-tree-dump-not "NOTE: no flow-sensitive alias info for" "ccp2" } } */
-/* { dg-final { cleanup-tree-dump "ccp2" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/alias-18.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/alias-18.c
@@ -86,5 +86,3 @@ int test8 (struct A *p, int *q)
 /* { dg-final { scan-tree-dump-not "return 6;" "optimized" } } */
 /* { dg-final { scan-tree-dump-not "return 7;" "optimized" } } */
 /* { dg-final { scan-tree-dump-not "return -1;" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/alias-19.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/alias-19.c
@@ -26,4 +26,3 @@ int main()
 }
 
 /* { dg-final { scan-tree-dump "q_. = { a b }" "alias" } } */
-/* { dg-final { cleanup-tree-dump "alias" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/alias-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/alias-2.c
@@ -25,4 +25,3 @@ int foo()
 /* We should have removed the link_error on the tree level as GCC can tell that
    a is not touched by the calling bar at all. */
 /* { dg-final { scan-tree-dump-times "link_error" 0 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/alias-20.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/alias-20.c
@@ -21,4 +21,3 @@ int foo(struct S *s, struct R *r)
 }
 
 /* { dg-final { scan-tree-dump-times "return 0;" 2 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/alias-21.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/alias-21.c
@@ -11,5 +11,4 @@ int f(int *r)
 
 
 /* { dg-final { scan-tree-dump-times "return 0;" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/alias-22.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/alias-22.c
@@ -11,5 +11,4 @@ int f(int *r)
 
 
 /* { dg-final { scan-tree-dump-times "return 0;" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/alias-23.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/alias-23.c
@@ -14,5 +14,4 @@ void f1 (const char *c)
 }
 
 /* { dg-final { scan-tree-dump-not "abort" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/alias-24.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/alias-24.c
@@ -18,5 +18,4 @@ void g (const char *c, int *i)
 
 /* { dg-final { scan-tree-dump-not "abort" "optimized" } } */
 /* { dg-final { scan-tree-dump "keepit" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/alias-25.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/alias-25.c
@@ -8,5 +8,4 @@ void f (long *p) {
 }
 
 /* { dg-final { scan-tree-dump-not "= 42" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/alias-26.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/alias-26.c
@@ -9,5 +9,4 @@ void f (const char *c, int *i)
 }
 
 /* { dg-final { scan-tree-dump-not "abort" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/alias-27.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/alias-27.c
@@ -8,4 +8,3 @@ void f (long *p) {
 }
 
 /* { dg-final { scan-tree-dump-not "= 42" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/alias-29.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/alias-29.c
@@ -25,4 +25,3 @@ void foo (union X *x)
    baz makes sure that ystruct has its address taken.  */
 
 /* { dg-final { scan-tree-dump-not "ystruct" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/alias-3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/alias-3.c
@@ -16,5 +16,4 @@ int foo(void)
 }
 
 /* { dg-final { scan-tree-dump "return 1;" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/alias-30.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/alias-30.c
@@ -19,4 +19,3 @@ int foo (float *p)
 /* We should be able to CSE the load from *p in the return stmt.  */
 
 /* { dg-final { scan-tree-dump "Replaced \\\*p" "fre1" } } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/alias-31.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/alias-31.c
@@ -21,4 +21,3 @@ int foo (float *p)
    other loads should be removed.  */
 
 /* { dg-final { scan-tree-dump-times "\\\*\[^ \]" 1 "cddce1" } } */
-/* { dg-final { cleanup-tree-dump "cddce1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/alias-32.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/alias-32.c
@@ -17,4 +17,3 @@ int bar (short *p)
 
 /* { dg-final { scan-tree-dump-times "\\\*\[^ \]" 1 "cddce1" } } */
 /* { dg-final { scan-tree-dump-not "aligned_alloc" "cddce1" } } */
-/* { dg-final { cleanup-tree-dump "cddce1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/alias-33.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/alias-33.c
@@ -17,4 +17,3 @@ int main ()
 }
 
 /* { dg-final { scan-tree-dump "Replaced j with 0" "fre1" } } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/alias-4.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/alias-4.c
@@ -17,5 +17,4 @@ int foo(void)
 }
 
 /* { dg-final { scan-tree-dump "return 1;" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/alias-5.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/alias-5.c
@@ -19,5 +19,4 @@ int foo(void)
 }
 
 /* { dg-final { scan-tree-dump "return 1;" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/alias-6.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/alias-6.c
@@ -18,4 +18,3 @@ int bar(void)
    the latter is an ssa temporary.  */
 /* { dg-final { scan-tree-dump "= a.0.;" "optimized" } } */
 /* { dg-final { scan-tree-dump "= \\*\[^\r\n\]*_.;" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/alias_bug.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/alias_bug.c
@@ -58,4 +58,3 @@ void keyboard_set_repeat(void)
 
 /* { dg-final { scan-tree-dump-times "ireg.*ax" 1 "optimized"} } */
  
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/andor-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/andor-1.c
@@ -61,5 +61,4 @@ int test10(int j)
 /* { dg-final { scan-tree-dump-times "h \\| 1" 1 "original" } } */
 /* { dg-final { scan-tree-dump-times "i \& 2 \\| 1" 1 "original" } } */
 /* { dg-final { scan-tree-dump-times "j \& 2 \\| 1" 1 "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/andor-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/andor-2.c
@@ -49,4 +49,3 @@ int test8(int o, int p)
 /* { dg-final { scan-tree-dump-times "return k;" 1 "original" } } */
 /* { dg-final { scan-tree-dump-times "return m;" 1 "original" } } */
 /* { dg-final { scan-tree-dump-times "return o;" 1 "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/andor-3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/andor-3.c
@@ -21,4 +21,3 @@ int f3(int y, int x)
 
 /* { dg-final { scan-tree-dump-times "~x" 0 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "x_..D. \& y_..D." 4 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/andor-4.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/andor-4.c
@@ -21,4 +21,3 @@ int f3(int y, int x)
 
 /* { dg-final { scan-tree-dump-times "~x" 0 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "x_..D. \\\| y_..D." 4 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/andor-5.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/andor-5.c
@@ -47,4 +47,3 @@ int f7(int y, int x)
 /* { dg-final { scan-tree-dump-times "\\\|" 0 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "\&" 0 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "return x_..D.;" 8 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/asm-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/asm-1.c
@@ -14,4 +14,3 @@ void f()
 
 /* { dg-final { scan-tree-dump-times "42" 1 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "63" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/asm-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/asm-2.c
@@ -18,4 +18,3 @@ void baz(void)
 }
 
 /* { dg-final { scan-tree-dump-times "asm\[^\\r\\n\]*xyzzy" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/asm-3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/asm-3.c
@@ -36,4 +36,3 @@ void test(void)
 /* In particular, hardreg should *not* appear in the call to bar.  */
 /* { dg-final { scan-tree-dump-times "bar \[(\]\[^\n\r\]*_.\[)\]" 1 "optimized" } } */
 
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/asmgoto-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/asmgoto-1.c
@@ -92,4 +92,3 @@ bad:
 }
 
 /* { dg-final { scan-tree-dump-times "XYZZY" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/assign-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/assign-1.c
@@ -9,4 +9,3 @@ void foo()
 }
 
 /* { dg-final { scan-tree-dump-times "count =" 1 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/assign-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/assign-2.c
@@ -9,5 +9,4 @@ void foo()
 }
 
 /* { dg-final { scan-tree-dump-times "count =" 1 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/assign-3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/assign-3.c
@@ -21,4 +21,3 @@ int main()
 }
 
 /* { dg-final { scan-tree-dump-times " = count;" 3 "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/attr-alias-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/attr-alias-2.c
@@ -9,4 +9,3 @@ main()
    return b+a;
 }
 /* { dg-final { scan-tree-dump "return 8" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/attr-alias.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/attr-alias.c
@@ -25,4 +25,3 @@ main()
 /* { dg-final { scan-tree-dump-times "  test4 " 1 "optimized" } } */
 /* { dg-final { scan-tree-dump-not "  test1 " "optimized" } } */
 /* { dg-final { scan-tree-dump-not "  test2 " "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/attr-hotcold-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/attr-hotcold-2.c
@@ -25,4 +25,3 @@ void f(int x, int y)
    the testcase around too much.  */
 /* { dg-final { scan-ipa-dump-times "block 5, loop depth 0, count 0, freq \[6-9\]\[0-9\]\[0-9\]\[0-9\]" 1 "profile_estimate" } } */
 
-/* { dg-final { cleanup-ipa-dump "profile_estimate" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/bitwise-sink.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/bitwise-sink.c
@@ -8,4 +8,3 @@ foo (_Bool x)
 }
 
 /* { dg-final { scan-tree-dump-times "~x" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/bool-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/bool-1.c
@@ -16,4 +16,3 @@ int f(_Bool x)
    away the comparison.  */
 /* { dg-final { scan-assembler-times "adde" 0 { target powerpc*-*-* } } } */
 
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/bool-10.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/bool-10.c
@@ -11,4 +11,3 @@ int f(_Bool x)
 /* { dg-final { scan-tree-dump-times "!= 1" 0 "optimized"} } */
 /* { dg-final { scan-tree-dump-times "~x" 1 "optimized"} } */
 
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/bool-11.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/bool-11.c
@@ -11,4 +11,3 @@ int f(_Bool x)
 /* { dg-final { scan-tree-dump-times "== 0" 0 "optimized"} } */
 /* { dg-final { scan-tree-dump-times "~x" 1 "optimized"} } */
 
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/bool-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/bool-2.c
@@ -19,4 +19,3 @@ int f(_Bool x)
    away the comparison.  */
 /* { dg-final { scan-assembler-times "adde" 0 { target powerpc*-*-* } } } */
 
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/bool-3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/bool-3.c
@@ -15,4 +15,3 @@ int f(_Bool x)
    fold its tree forwprop is able to clean up the mess.  */
 /* { dg-final { scan-tree-dump-times "== 0" 0 "optimized" } } */
 
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/bool-4.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/bool-4.c
@@ -14,4 +14,3 @@ int f(_Bool x)
    away the comparison.  */
 /* { dg-final { scan-assembler-times "adde" 0 { target powerpc*-*-* } } } */
 
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/bool-5.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/bool-5.c
@@ -16,4 +16,3 @@ int f(_Bool x)
    away the comparison.  */
 /* { dg-final { scan-assembler-times "adde" 0 { target powerpc*-*-* } } } */
 
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/bool-6.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/bool-6.c
@@ -19,4 +19,3 @@ int f(_Bool x)
    away the comparison.  */
 /* { dg-final { scan-assembler-times "adde" 0 { target powerpc*-*-* } } } */
 
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/bool-7.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/bool-7.c
@@ -14,4 +14,3 @@ int f(_Bool x)
 /* There should be no != 1. Fold changes x != 1 to ! x.  */
 /* { dg-final { scan-tree-dump-times "!= 1" 0 "optimized" } } */
 
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/bool-8.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/bool-8.c
@@ -14,4 +14,3 @@ int f(_Bool x)
    away the comparison.  */
 /* { dg-final { scan-assembler-times "adde" 0 { target powerpc*-*-* } } } */
 
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/bool-9.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/bool-9.c
@@ -14,4 +14,3 @@ _Bool f1(_Bool x)
    away the comparison.  */
 /* { dg-final { scan-assembler-times "subfe" 0 { target powerpc*-*-* } } } */
 
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/builtin-expect-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/builtin-expect-1.c
@@ -11,4 +11,3 @@ f (int i, float j, int i2, float j2)
 } 
 
 /* { dg-final { scan-tree-dump-times {builtin_expect[^\n]*, 0\);\n[^\n]*if} 2 "gimple"} } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/builtin-expect-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/builtin-expect-2.c
@@ -13,4 +13,3 @@ f (int i, float j, int i2, float j2)
 } 
 
 /* { dg-final { scan-tree-dump-times {builtin_expect[^\n]*, 0\);\n[^\n]*if} 2 "gimple"} } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/builtin-expect-3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/builtin-expect-3.c
@@ -14,4 +14,3 @@ f (int i, float j, int i2, float j2)
 } 
 
 /* { dg-final { scan-tree-dump-times {builtin_expect[^\n]*, 0\);\n[^\n]*if} 2 "gimple"} } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/builtin-expect-4.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/builtin-expect-4.c
@@ -14,4 +14,3 @@ f (int i, float j, int i2, float j2)
 } 
 
 /* { dg-final { scan-tree-dump-times {builtin_expect[^\n]*, 0\);\n[^\n]*if} 2 "gimple"} } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/builtin-expect-5.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/builtin-expect-5.c
@@ -16,4 +16,3 @@ f (int i, float j, int i2, float j2)
 /* { dg-final { scan-tree-dump-times { if } 2 "forwprop1"} } */
 /* { dg-final { scan-tree-dump {builtin_expect[^\n]*, 0\);\n[^\n]*if} "forwprop1"} } */
 /* { dg-final { scan-tree-dump {builtin_expect[^\n]*, 1\);\n[^\n]*if} "forwprop1"} } */
-/* { dg-final { cleanup-tree-dump "forwprop?" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/builtin-fprintf-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/builtin-fprintf-1.c
@@ -38,4 +38,3 @@ void test (void)
 /* { dg-final { scan-tree-dump "vi6.*fputc.*fp.*vi7" "fab1"} } */
 /* { dg-final { scan-tree-dump "vi7.*fputc.*fp.*vi8" "fab1"} } */
 /* { dg-final { scan-tree-dump "vi8.*fprintf.*fp.*\"%d%d\".*vi9" "fab1"} } */
-/* { dg-final { cleanup-tree-dump "fab1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/builtin-fprintf-chk-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/builtin-fprintf-chk-1.c
@@ -38,4 +38,3 @@ void test (void)
 /* { dg-final { scan-tree-dump "vi6.*fputc.*fp.*vi7" "fab1"} } */
 /* { dg-final { scan-tree-dump "vi7.*fputc.*fp.*vi8" "fab1"} } */
 /* { dg-final { scan-tree-dump "vi8.*__fprintf_chk.*fp.*1.*\"%d%d\".*vi9" "fab1"} } */
-/* { dg-final { cleanup-tree-dump "fab1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/builtin-free.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/builtin-free.c
@@ -17,4 +17,3 @@ void foo(unsigned n)
 /* We should remove the redundant call to free.  */
 
 /* { dg-final { scan-tree-dump-times "free" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/builtin-printf-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/builtin-printf-1.c
@@ -39,4 +39,3 @@ void test (void)
 /* { dg-final { scan-tree-dump "vi7 ={v} 0\[^\(\)\]*vi8 ={v} 0" "fab1"} } */
 /* { dg-final { scan-tree-dump "vi8.*putchar.*vi9" "fab1"} } */
 /* { dg-final { scan-tree-dump "vi9.*puts.*\"hello\\\\n\".*via" "fab1"} } */
-/* { dg-final { cleanup-tree-dump "fab1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/builtin-printf-chk-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/builtin-printf-chk-1.c
@@ -39,4 +39,3 @@ void test (void)
 /* { dg-final { scan-tree-dump "vi7 ={v} 0\[^\(\)\]*vi8 ={v} 0" "fab1"} } */
 /* { dg-final { scan-tree-dump "vi8.*putchar.*vi9" "fab1"} } */
 /* { dg-final { scan-tree-dump "vi9.*puts.*\"hello\\\\n\".*via" "fab1"} } */
-/* { dg-final { cleanup-tree-dump "fab1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/builtin-vfprintf-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/builtin-vfprintf-1.c
@@ -36,4 +36,3 @@ test (va_list ap1, va_list ap2, va_list ap3, va_list ap4, va_list ap5,
 /* { dg-final { scan-tree-dump "vi4.*vfprintf.*\"%s\".*vi5" "fab1"} } */
 /* { dg-final { scan-tree-dump "vi5.*vfprintf.*\"%c\".*vi6" "fab1"} } */
 /* { dg-final { scan-tree-dump "vi6.*vfprintf.*\"%s\\\\n\".*vi7" "fab1"} } */
-/* { dg-final { cleanup-tree-dump "fab1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/builtin-vfprintf-chk-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/builtin-vfprintf-chk-1.c
@@ -36,4 +36,3 @@ test (va_list ap1, va_list ap2, va_list ap3, va_list ap4, va_list ap5,
 /* { dg-final { scan-tree-dump "vi4.*__vfprintf_chk.*fp.*1.*\"%s\".*vi5" "fab1"} } */
 /* { dg-final { scan-tree-dump "vi5.*__vfprintf_chk.*fp.*1.*\"%c\".*vi6" "fab1"} } */
 /* { dg-final { scan-tree-dump "vi6.*__vfprintf_chk.*fp.*1.*\"%s\\\\n\".*vi7" "fab1"} } */
-/* { dg-final { cleanup-tree-dump "fab1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/builtin-vprintf-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/builtin-vprintf-1.c
@@ -34,4 +34,3 @@ test (va_list ap1, va_list ap2, va_list ap3, va_list ap4, va_list ap5,
 /* { dg-final { scan-tree-dump "vi4.*vprintf.*\"%s\".*vi5" "fab1"} } */
 /* { dg-final { scan-tree-dump "vi5.*vprintf.*\"%c\".*vi6" "fab1"} } */
 /* { dg-final { scan-tree-dump "vi6.*vprintf.*\"%s\\\\n\".*vi7" "fab1"} } */
-/* { dg-final { cleanup-tree-dump "fab1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/builtin-vprintf-chk-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/builtin-vprintf-chk-1.c
@@ -34,4 +34,3 @@ test (va_list ap1, va_list ap2, va_list ap3, va_list ap4, va_list ap5,
 /* { dg-final { scan-tree-dump "vi4.*__vprintf_chk.*1.*\"%s\".*vi5" "fab1"} } */
 /* { dg-final { scan-tree-dump "vi5.*__vprintf_chk.*1.*\"%c\".*vi6" "fab1"} } */
 /* { dg-final { scan-tree-dump "vi6.*__vprintf_chk.*1.*\"%s\\\\n\".*vi7" "fab1"} } */
-/* { dg-final { cleanup-tree-dump "fab1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/calloc-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/calloc-1.c
@@ -26,4 +26,3 @@ void* g(void)
 /* { dg-final { scan-tree-dump-times "calloc" 2 "optimized" } } */
 /* { dg-final { scan-tree-dump-not "malloc" "optimized" } } */
 /* { dg-final { scan-tree-dump-not "memset" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/calloc-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/calloc-2.c
@@ -24,4 +24,3 @@ void* g(int m1, int m2)
 /* { dg-final { scan-tree-dump-times "malloc" 1 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "calloc" 1 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "memset" 2 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/calloc-3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/calloc-3.c
@@ -11,4 +11,3 @@ void*f(){
 /* { dg-final { scan-tree-dump-not "malloc" "optimized" } } */
 /* { dg-final { scan-tree-dump-times "calloc" 1 "optimized" } } */
 /* { dg-final { scan-tree-dump-not "memset" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/cfgcleanup-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/cfgcleanup-1.c
@@ -16,4 +16,3 @@ cleanup (int a, int b)
 }
 /* Dce should get rid of the initializers and cfgcleanup should elliminate ifs  */
 /* { dg-final { scan-tree-dump-times "if " 0 "dce1"} } */
-/* { dg-final { cleanup-tree-dump "dce1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/coalesce-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/coalesce-1.c
@@ -196,5 +196,4 @@ process_switch (gimple swtch)
    any partition copies inserted.  */
 
 /* { dg-final { scan-rtl-dump-not "partition copy" "expand"} } */
-/* { dg-final { cleanup-rtl-dump "expand" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/coalesce-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/coalesce-2.c
@@ -13,4 +13,3 @@ void foo(int n)
    any partition copies inserted.  */
 
 /* { dg-final { scan-rtl-dump-not "partition copy" "expand"} } */
-/* { dg-final { cleanup-rtl-dump "expand" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/col-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/col-1.c
@@ -14,4 +14,3 @@ m(int x)
 /* { dg-final { scan-tree-dump-times "10:9.*c = 5" 1 "gimple" } } */
 /* { dg-final { scan-tree-dump-times "10:14.*c . 16" 1 "gimple" } } */
 /* { dg-final { scan-tree-dump-times "10:4.*a =" 1 "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/complex-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/complex-1.c
@@ -10,4 +10,3 @@ C foo(C x, float y)
 }
 
 /* { dg-final { scan-tree-dump-times "__mul" 0 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/complex-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/complex-2.c
@@ -10,4 +10,3 @@ C foo(C x, float y)
 }
 
 /* { dg-final { scan-tree-dump-times "__div" 0 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/complex-3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/complex-3.c
@@ -23,5 +23,4 @@ float imag_part(COMPLEX_FLOAT a)
 
 /* { dg-final { scan-tree-dump-times "REALPART_EXPR" 2 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "IMAGPART_EXPR" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/complex-4.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/complex-4.c
@@ -11,4 +11,3 @@ int f(void)
 }
 
 /* { dg-final { scan-tree-dump-times "__complex__" 0 "optimized" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/complex-5.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/complex-5.c
@@ -9,4 +9,3 @@ int f(void)
 }
 
 /* { dg-final { scan-tree-dump-times "__complex__" 0 "optimized" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/complex-6.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/complex-6.c
@@ -22,4 +22,3 @@ quantum_foo(float _Complex a)
 
 /* { dg-final { scan-tree-dump-times "REALPART_EXPR" 1 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "IMAGPART_EXPR" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/copy-headers.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/copy-headers.c
@@ -13,4 +13,3 @@ void bla (void)
 
 /* There should be a header duplicated.  */
 /* { dg-final { scan-tree-dump-times "Duplicating header" 1 "ch"} } */
-/* { dg-final { cleanup-tree-dump "ch" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/cswtch-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/cswtch-2.c
@@ -18,4 +18,3 @@ int h1 (X x)
 }
 
 /* { dg-final { scan-tree-dump-times "CSWTCH" 0 "switchconv" } } */
-/* { dg-final { cleanup-tree-dump "switchconv" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/cswtch.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/cswtch.c
@@ -78,4 +78,3 @@ int main ()
 }
 
 /* { dg-final { scan-tree-dump "Switch converted" "switchconv" } } */
-/* { dg-final { cleanup-tree-dump "switchconv" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/cunroll-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/cunroll-1.c
@@ -11,4 +11,3 @@ test(int c)
 /* Array bounds says the loop will not roll much.  */
 /* { dg-final { scan-tree-dump "loop with 3 iterations completely unrolled" "cunrolli"} } */
 /* { dg-final { scan-tree-dump "Last iteration exit edge was proved true." "cunrolli"} } */
-/* { dg-final { cleanup-tree-dump "cunrolli" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/cunroll-10.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/cunroll-10.c
@@ -11,4 +11,3 @@ foo (int n)
      a[i]++;
 }
 /* { dg-final { scan-tree-dump-times "Forced statement unreachable" 2 "cunroll" } } */
-/* { dg-final { cleanup-tree-dump "cunroll" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/cunroll-11.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/cunroll-11.c
@@ -15,4 +15,3 @@ extern void foo (s1 *x1, s1 *x2, int a, int b)
 }
 
 /* { dg-final { scan-tree-dump "Loop 1 iterates at most 3 times" "cunroll" } } */
-/* { dg-final { cleanup-tree-dump "cunroll" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/cunroll-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/cunroll-2.c
@@ -15,4 +15,3 @@ test(int c)
 }
 /* We are not able to get rid of the final conditional because the loop has two exits.  */
 /* { dg-final { scan-tree-dump "loop with 2 iterations completely unrolled" "cunroll"} } */
-/* { dg-final { cleanup-tree-dump "cunroll" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/cunroll-3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/cunroll-3.c
@@ -13,4 +13,3 @@ test(int c)
 /* If we start duplicating headers prior curoll, this loop will have 0 iterations.  */
 
 /* { dg-final { scan-tree-dump "loop with 2 iterations completely unrolled" "cunrolli"} } */
-/* { dg-final { cleanup-tree-dump "cunrolli" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/cunroll-4.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/cunroll-4.c
@@ -20,4 +20,3 @@ test(int c)
    from the last iteration.  */
 /* { dg-final { scan-tree-dump "loop turned into non-loop; it never loops." "ivcanon"} } */
 /* { dg-final { scan-tree-dump "Last iteration exit edge was proved true." "ivcanon"} } */
-/* { dg-final { cleanup-tree-dump "ivcanon" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/cunroll-5.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/cunroll-5.c
@@ -12,4 +12,3 @@ test(int c)
 /* { dg-final { scan-tree-dump "loop with 6 iterations completely unrolled" "cunroll"} } */
 /* { dg-final { scan-tree-dump "Exit condition of peeled iterations was eliminated." "cunroll"} } */
 /* { dg-final { scan-tree-dump "Last iteration exit edge was proved true." "cunroll"} } */
-/* { dg-final { cleanup-tree-dump "cunroll" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/cunroll-9.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/cunroll-9.c
@@ -21,4 +21,3 @@ t (int n)
   return sum;
 }
 /* { dg-final { scan-tree-dump-times "Removed pointless exit:" 1 "cunrolli" } } */
-/* { dg-final { cleanup-tree-dump "cunrolli" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/dce-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/dce-1.c
@@ -15,5 +15,4 @@ int foo (int b, int j)
    the exit condition after the loop.  */
 /* { dg-final { scan-tree-dump-not "999" "cddce1"} } */
 /* { dg-final { scan-tree-dump-not "1000" "cddce1"} } */
-/* { dg-final { cleanup-tree-dump "cddce1" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/divide-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/divide-1.c
@@ -10,5 +10,4 @@ int f(int a)
 /* { dg-final { scan-tree-dump-times "-a" 0 "optimized"} } */
 /* { dg-final { scan-tree-dump-times "a_..D. / -10" 1 "optimized"} } */
 
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/divide-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/divide-2.c
@@ -10,5 +10,4 @@ int f(int a)
 /* { dg-final { scan-tree-dump-times "10 / -a" 0 "optimized"} } */
 /* { dg-final { scan-tree-dump-times "-10 / a" 1 "optimized"} } */
 
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/divide-3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/divide-3.c
@@ -9,6 +9,5 @@ int f(int a)
 /* { dg-final { scan-tree-dump-times "a_\[0-9()D\]* / 10" 0 "optimized"} } */
 /* { dg-final { scan-tree-dump-times "a_..D. / -10" 1 "optimized"} } */
 
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/divide-4.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/divide-4.c
@@ -9,6 +9,5 @@ int f(int a)
 /* { dg-final { scan-tree-dump-times "-a" 0 "optimized"} } */
 /* { dg-final { scan-tree-dump-times "a_..D. / 10" 1 "optimized"} } */
 
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/dump-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/dump-1.c
@@ -6,4 +6,3 @@ int f(void)
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "profile_estimate" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/fnsplit-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/fnsplit-1.c
@@ -20,4 +20,3 @@ main(void)
 }
 /* { dg-final { scan-tree-dump-times "Splitting function at:" 1 "fnsplit"} } */
 
-/* { dg-final { cleanup-tree-dump "fnsplit" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/foldaddr-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/foldaddr-1.c
@@ -12,5 +12,4 @@ int foo(char *b)
    not identical and thus collapsed the function into a trivial
    "return 0".  */
 /* { dg-final { scan-tree-dump-times "return 0" 1 "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/foldcast-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/foldcast-1.c
@@ -13,4 +13,3 @@ char *bar (char *x)
 }
 
 /* { dg-final { scan-tree-dump-times "return x;" 2 "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/foldconst-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/foldconst-1.c
@@ -23,4 +23,3 @@ foo (void)
 /* The switch should be switch converted and later constant propagated.  */
 /* { dg-final { scan-tree-dump-not "CSWTCH" "optimized"} } */
 /* { dg-final { scan-tree-dump-not "switch" "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/foldconst-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/foldconst-2.c
@@ -57,4 +57,3 @@ emit_support_tinfos (void)
 /* We should copy loop header to fundamentals[0] and then fold it way into
    known value.  */
 /* { dg-final { scan-tree-dump-not "fundamentals.0" "ch"} } */
-/* { dg-final { cleanup-tree-dump "ch" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/foldconst-3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/foldconst-3.c
@@ -75,4 +75,3 @@ int_fits_type_p (const_tree c, const_tree type)
 }
 /* The switch should be switch converted and later constant propagated.  */
 /* { dg-final { scan-tree-dump-not "tree_code_type" "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/foldconst-4.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/foldconst-4.c
@@ -11,4 +11,3 @@ test()
   return a.a+b[c];
 }
 /* { dg-final { scan-tree-dump "return 0;" "ccp2" } } */
-/* { dg-final { cleanup-tree-dump "ccp2" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/foldconst-5.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/foldconst-5.c
@@ -11,5 +11,4 @@ test()
   return a[2]+b[1]+b[3]+c.b;
 }
 /* { dg-final { scan-tree-dump "return 11;" "ccp1" } } */
-/* { dg-final { cleanup-tree-dump "ccp1" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/foldconst-6.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/foldconst-6.c
@@ -11,4 +11,3 @@ void f (vec *r)
 }
 
 /* { dg-final { scan-tree-dump-not "2, 666" "ccp1" } } */
-/* { dg-final { cleanup-tree-dump "ccp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/foldstring-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/foldstring-1.c
@@ -10,4 +10,3 @@ arf ()
     blah ();
 }
 /* { dg-final { scan-tree-dump-times "= 0;" 1 "gimple"} } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-1.c
@@ -15,4 +15,3 @@ void f(struct a * b, __SIZE_TYPE__ i)
 }
 
 /* { dg-final { scan-tree-dump-times "\\\[\[^\n\r\]*\\\] = 1;" 0 "forwprop1" } } */
-/* { dg-final { cleanup-tree-dump "forwprop1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-10.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-10.c
@@ -19,4 +19,3 @@ void test2(void)
    the rhs of the store to b by 1.  */
 
 /* { dg-final { scan-tree-dump "Replaced\[^\\n\]*with 1" "fre1" } } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-11.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-11.c
@@ -17,4 +17,3 @@ int g(int *p, int n)
 }
 
 /* { dg-final { scan-tree-dump-times "= MEM\\\[\\\(int \\\*\\\)\[ap\]_.. \\\+ 4B\\\];" 2 "forwprop1" } } */
-/* { dg-final { cleanup-tree-dump "forwprop1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-12.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-12.c
@@ -19,4 +19,3 @@ int bar(struct X *p, int i)
    address arithmetic into the memory access as an array access.  */
 
 /* { dg-final { scan-tree-dump-times "->a\\\[D\\\." 2 "forwprop1" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "forwprop1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-13.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-13.c
@@ -13,4 +13,3 @@ foo (struct B *b)
 }
 
 /* { dg-final { scan-tree-dump-not "\\\(unsigned" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-14.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-14.c
@@ -15,4 +15,3 @@ foo (unsigned int eax)
 
 /* { dg-final { scan-tree-dump-times " & " 1 "optimized" } } */
 /* { dg-final { scan-tree-dump-times " \\\| " 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-15.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-15.c
@@ -11,4 +11,3 @@ foo (_Bool a, _Bool b, _Bool c)
 
 /* { dg-final { scan-tree-dump-times " == " 0 "forwprop1" } } */
 /* { dg-final { scan-tree-dump-times " != " 0 "forwprop1" } } */
-/* { dg-final { cleanup-tree-dump "forwprop1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-16.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-16.c
@@ -11,4 +11,3 @@ int foo (double xx, double xy)
 }
 
 /* { dg-final { scan-tree-dump "if \\\(x" "forwprop1" } } */
-/* { dg-final { cleanup-tree-dump "forwprop1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-17.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-17.c
@@ -9,4 +9,3 @@ int foo (int xx, int xy)
 }
 
 /* { dg-final { scan-tree-dump-times " & 1" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-18.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-18.c
@@ -21,4 +21,3 @@ signed char g2(unsigned long long n)
 
 /* { dg-final { scan-tree-dump-times "\\\(float\\\)" 2 "cddce1" } } */
 /* { dg-final { scan-tree-dump-not "\\\(long double\\\)" "cddce1" } } */
-/* { dg-final { cleanup-tree-dump "cddce1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-19.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-19.c
@@ -12,4 +12,3 @@ void f (vec *x1, vec *x2)
 }
 
 /* { dg-final { scan-tree-dump-not "VEC_PERM_EXPR" "forwprop1" } } */
-/* { dg-final { cleanup-tree-dump "forwprop1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-2.c
@@ -17,4 +17,3 @@ void f(__SIZE_TYPE__ i)
 }
 
 /* { dg-final { scan-tree-dump-times "\\\[\[^\n\r\]*\\\] = 1;" 0 "forwprop1" } } */
-/* { dg-final { cleanup-tree-dump "forwprop?" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-20.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-20.c
@@ -67,4 +67,3 @@ void l (double d, vecf* r)
 }
 
 /* { dg-final { scan-tree-dump-not "VEC_PERM_EXPR" "forwprop1" } } */
-/* { dg-final { cleanup-tree-dump "forwprop1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-21.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-21.c
@@ -13,4 +13,3 @@ test (v4si *x, v4si *y)
 /* Optimization in forwprop1, cleanup in cddce1.  */
 
 /* { dg-final { scan-tree-dump-not "VEC_PERM_EXPR" "cddce1" } } */
-/* { dg-final { cleanup-tree-dump "cddce1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-23.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-23.c
@@ -12,4 +12,3 @@ long f (long d, long e)
 
 
 /* { dg-final { scan-tree-dump-not "BIT_FIELD_REF" "forwprop1" } } */
-/* { dg-final { cleanup-tree-dump "forwprop1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-24.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-24.c
@@ -15,4 +15,3 @@ foo (unsigned char x, unsigned short y)
    as in (x ^ (char) y) & 1.  */
 
 /* { dg-final { scan-tree-dump-times " & " 1 "cddce1" } } */
-/* { dg-final { cleanup-tree-dump "cddce1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-25.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-25.c
@@ -38,7 +38,6 @@ convert_move (rtx to, rtx from, int unsignedp)
 }
 
 /* { dg-final { scan-tree-dump "Replaced.*!=.*with.*!=.* " "forwprop1"} } */
-/* { dg-final { cleanup-tree-dump "forwprop1" } } */
 
 
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-26.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-26.c
@@ -63,4 +63,3 @@ function_and_variable_visibility (unsigned char whole_program)
 }
 
 /* { dg-final { scan-tree-dump-not "& 255" "forwprop1"} } */
-/* { dg-final { cleanup-tree-dump "forwprop1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-27.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-27.c
@@ -36,5 +36,4 @@ void i (V *v1, V *v2){
 /* { dg-final { scan-tree-dump-not "\\\+" "forwprop1"} } */
 /* { dg-final { scan-tree-dump "{ 0, 4 }" "forwprop1"} } */
 /* { dg-final { scan-tree-dump "{ 37, -5 }" "forwprop1"} } */
-/* { dg-final { cleanup-tree-dump "forwprop1" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-28.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-28.c
@@ -85,5 +85,4 @@ test_8 (int code)
    we do that we even generate better code on x86 at least.  */
 
 /* { dg-final { scan-tree-dump-times "simplified to if \\\(\[^ ]* <" 4 "forwprop1"} } */
-/* { dg-final { cleanup-tree-dump "forwprop1" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-3.c
@@ -15,4 +15,3 @@ int foo(struct bar *x)
 }
 
 /* { dg-final { scan-tree-dump "Replaced .p_. < q_.. with .1." "forwprop1" } } */
-/* { dg-final { cleanup-tree-dump "forwprop1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-30.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-30.c
@@ -12,4 +12,3 @@ int *foo (int *q, int i, int j)
    need q + i as well.  */
 
 /* { dg-final { scan-tree-dump-times "\\+" 2 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-31.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-31.c
@@ -13,4 +13,3 @@ int foo (int x)
 /* { dg-final { scan-tree-dump-times "= 0;" 2 "forwprop1" } } */
 /* { dg-final { scan-tree-dump-times "-" 0 "forwprop1" } } */
 /* { dg-final { scan-tree-dump-times "\\+" 1 "forwprop1" } } */
-/* { dg-final { cleanup-tree-dump "forwprop1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-32.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-32.c
@@ -14,5 +14,3 @@ int bar (int x)
 
 /* { dg-final { scan-tree-dump "x_.\\(D\\) / 15" "forwprop1" } } */
 /* { dg-final { scan-tree-dump "return 0;" "ccp1" } } */
-/* { dg-final { cleanup-tree-dump "forwprop1" } } */
-/* { dg-final { cleanup-tree-dump "ccp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-4.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-4.c
@@ -15,4 +15,3 @@ void foo()
 }
 
 /* { dg-final { scan-tree-dump-not "link_error" "forwprop1" } } */
-/* { dg-final { cleanup-tree-dump "forwprop1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-5.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-5.c
@@ -17,4 +17,3 @@ vector float foo( vector float v )
 }
 
 /* { dg-final { scan-tree-dump-times "disappear" 0 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-6.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-6.c
@@ -25,4 +25,3 @@ void f(void)
    value-numbering, removing the load altogether.
    ???  We now do this after CPP re-writes a into SSA form.  */
 /* { dg-final { scan-tree-dump-times "VIEW_CONVERT_EXPR" 1 "ccp1" } } */
-/* { dg-final { cleanup-tree-dump "ccp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-7.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-7.c
@@ -13,4 +13,3 @@ int foo(void)
 
 /* { dg-final { scan-tree-dump-times "VIEW_CONVERT_EXPR" 0 "forwprop1"} } */
 /* { dg-final { scan-tree-dump-times "={v}" 2 "forwprop1"} } */
-/* { dg-final { cleanup-tree-dump "forwprop1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-8.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-8.c
@@ -12,4 +12,3 @@ int foo(struct X *q)
 
 /* We should have propragated &q->a into (*pointer).  */
 /* { dg-final { scan-tree-dump "q_.\\\(D\\\)\\\]\\\[0\\\];" "forwprop1" } } */
-/* { dg-final { cleanup-tree-dump "forwprop1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-9.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/forwprop-9.c
@@ -17,5 +17,3 @@ void f(void)
 
 /* { dg-final { scan-tree-dump-times " = 1" 2 "optimized"} } */
 /* { dg-final { scan-tree-dump-not " = a;" "fre1"} } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/fre-vce-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/fre-vce-1.c
@@ -34,4 +34,3 @@ void a2 (struct s1 sv, int i)
 
 /* { dg-final { scan-tree-dump-times "sv_\[0-9\]\\\(D\\\)->i" 2 "fre1" } } */
 /* { dg-final { scan-tree-dump-times "sv.i" 2 "fre1" } } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/gen-vect-11.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/gen-vect-11.c
@@ -31,4 +31,3 @@ int main ()
 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { ! avr-*-* } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/gen-vect-11a.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/gen-vect-11a.c
@@ -39,4 +39,3 @@ int main ()
 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { ! avr-*-* } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/gen-vect-11b.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/gen-vect-11b.c
@@ -32,4 +32,3 @@ int main ()
 
 
 /* { dg-final { scan-tree-dump-times "vectorized 0 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/gen-vect-11c.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/gen-vect-11c.c
@@ -40,4 +40,3 @@ int main ()
 
 
 /* { dg-final { scan-tree-dump-times "vectorized 0 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/gen-vect-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/gen-vect-2.c
@@ -38,4 +38,3 @@ int main ()
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { ! avr-*-* } } } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" { target { ! avr-*-* } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/gen-vect-25.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/gen-vect-25.c
@@ -56,4 +56,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 2 loops" 1 "vect" { target { ! avr-*-* } } } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" { target { ! avr-*-* } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/gen-vect-26.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/gen-vect-26.c
@@ -32,4 +32,3 @@ int main ()
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { ! avr-*-* } } } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" { target { ! avr-*-* } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { target { ! avr-*-* } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/gen-vect-28.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/gen-vect-28.c
@@ -40,4 +40,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { ! avr-*-* } } } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" { target { ! avr-*-* } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { target { ! avr-*-* } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/gen-vect-32.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/gen-vect-32.c
@@ -31,4 +31,3 @@ int main ()
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { ! avr-*-* } } } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" { target { ! avr-*-* } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ifc-20040816-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ifc-20040816-1.c
@@ -33,4 +33,3 @@ int main1 ()
 
 
 /* { dg-final { scan-tree-dump-times "Applying if-conversion" 1 "ifcvt" } } */
-/* { dg-final { cleanup-tree-dump "ifcvt" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ifc-20040816-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ifc-20040816-2.c
@@ -37,4 +37,3 @@ void foo(const int * __restrict__ zr_in,
 
 
 /* { dg-final { scan-tree-dump-times "Applying if-conversion" 1 "ifcvt" } } */
-/* { dg-final { cleanup-tree-dump "ifcvt" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ifc-4.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ifc-4.c
@@ -51,4 +51,3 @@ create_iso_definition (cpp_reader *pfile, cpp_macro *macro)
 
 /* This cannot be if-converted because the stores are to aggregate types.  */
 /* { dg-final { scan-tree-dump-times "Applying if-conversion" 0 "ifcvt" } } */
-/* { dg-final { cleanup-tree-dump "ifcvt" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ifc-5.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ifc-5.c
@@ -21,4 +21,3 @@ dct_unquantize_h263_inter_c (short *block, int n, int qscale, int nCoeffs)
 }
 
 /* { dg-final { scan-tree-dump-times "Applying if-conversion" 1 "ifcvt" } } */
-/* { dg-final { cleanup-tree-dump "ifcvt" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ifc-cd.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ifc-cd.c
@@ -26,4 +26,3 @@ void foo (int *x1, int *x2, int *x3, int *x4, int *y)
 }
 
 /* { dg-final { scan-tree-dump-times "Use predicate of bb" 8 "ifcvt" } } */
-/* { dg-final { cleanup-tree-dump "ifcvt" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/inline-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/inline-1.c
@@ -21,5 +21,4 @@ interval foo (interval a, interval b, interval c)
 
 
 /* { dg-final { scan-tree-dump-times "\\(struct interval\\)" 0 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/inline-10.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/inline-10.c
@@ -36,4 +36,3 @@ main()
 /* { dg-final { scan-tree-dump-times "do_something3" 1 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "do_something \\(5\\)" 1 "optimized" } } */
 /* { dg-final { scan-tree-dump-not "do_something \\(70\\)" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/inline-11.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/inline-11.c
@@ -11,4 +11,3 @@ void foo()
   bar();
 }
 /* { dg-final { scan-tree-dump-times "function body can be overwritten at link time" 1 "einline" } } */
-/* { dg-final { cleanup-tree-dump "einline" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/inline-3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/inline-3.c
@@ -29,4 +29,3 @@ inline_me_too (void)
 }
 /* { dg-final { scan-tree-dump-times "Inlining inline_me " 1 "einline"} } */
 /* { dg-final { scan-tree-dump-times "Inlining inline_me_too " 1 "einline"} } */
-/* { dg-final { cleanup-tree-dump "einline" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/inline-4.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/inline-4.c
@@ -24,4 +24,3 @@ int main()
 }
 
 /* { dg-final { scan-tree-dump "Inlining get_data_for into main" "einline" } } */
-/* { dg-final { cleanup-tree-dump "einline" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/inline-5.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/inline-5.c
@@ -36,4 +36,3 @@ test(struct a *a)
   do_something (a);
 }
 /* { dg-final { scan-tree-dump-times "do_inc" 12 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/inline-6.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/inline-6.c
@@ -40,4 +40,3 @@ test(struct a *a)
   do_something (a);
 }
 /* { dg-final { scan-tree-dump-times "do_inc" 12 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/inline-7.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/inline-7.c
@@ -6,4 +6,3 @@ inline void bar0() { foo0(); }
 void foobar() { bar0(); bar0(); bar0(); }
 
 /* { dg-final { scan-tree-dump "Iterations: 1" "einline" } } */
-/* { dg-final { cleanup-tree-dump "einline" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/inline-8.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/inline-8.c
@@ -28,4 +28,3 @@ int bar5() { return 0; }
 int foobar5() { return bar5(); }
 
 /* { dg-final { scan-tree-dump-times "Inlining" 5 "einline" } } */
-/* { dg-final { cleanup-tree-dump "einline" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/inline-9.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/inline-9.c
@@ -22,4 +22,3 @@ main()
 }
 /* { dg-final { scan-tree-dump-times "q \\(15\\)" 1 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "t \\(20\\)" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/inline_asm-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/inline_asm-1.c
@@ -13,8 +13,6 @@ char f(char *a)
 
 /* test_function should be called twice as the inline-asm changes memory. */
 /* { dg-final { scan-tree-dump-times "test_function" 2 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
 /* There should a VDEF for the inline-asm.  */
 /* { dg-final { scan-tree-dump-times "VDEF" 1 "alias"} } */
-/* { dg-final { cleanup-tree-dump "alias" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/inline_asm-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/inline_asm-2.c
@@ -15,4 +15,3 @@ void f(char *a)
 
 /* There should a VDEF for the inline-asm and one for the link_error.  */
 /* { dg-final { scan-tree-dump-times "VDEF" 2 "alias"} } */
-/* { dg-final { cleanup-tree-dump "alias" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/integer-addr.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/integer-addr.c
@@ -26,4 +26,3 @@ int foobar(void)
 }
 
 /* { dg-final { scan-tree-dump-times "= func" 2 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/interposition.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/interposition.c
@@ -10,4 +10,3 @@ int q(void)
   return t();
 }
 /* { dg-final { scan-tree-dump-times "return 1" 2 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ipa-cp-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ipa-cp-1.c
@@ -18,4 +18,3 @@ blah ()
 }
 /* One appearance for dump, one self recursive call and one call from main.  */
 /* { dg-final { scan-tree-dump-times "very_long_function.constprop \\(\\)" 3 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ipa-reference-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ipa-reference-1.c
@@ -12,4 +12,3 @@ int f(void)
    inlined the 0 as IPA reference should have marked the variable as a const
    as it is not set in the IR.  */
 /* { dg-final { scan-tree-dump-times "conststaticvariable" 0 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ipa-split-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ipa-split-1.c
@@ -30,4 +30,3 @@ test()
   test2(20);
 }
 /* { dg-final { scan-tree-dump-times "Splitting function" 1 "fnsplit"} } */
-/* { dg-final { cleanup-tree-dump "fnsplit" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ipa-split-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ipa-split-2.c
@@ -41,4 +41,3 @@ main()
   split_me (5);
 }
 /* { dg-final { scan-tree-dump-times "Splitting function" 1 "fnsplit"} } */
-/* { dg-final { cleanup-tree-dump "fnsplit" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ipa-split-4.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ipa-split-4.c
@@ -26,4 +26,3 @@ test(void)
   return split_me (0)+split_me(1)+split_me(2);
 }
 /* { dg-final { scan-tree-dump-times "Splitting function" 1 "fnsplit"} } */
-/* { dg-final { cleanup-tree-dump "fnsplit" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ipa-split-5.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ipa-split-5.c
@@ -33,6 +33,4 @@ test()
   split_me (val);
 }
 /* { dg-final { scan-tree-dump-times "Splitting function" 1 "fnsplit"} } */
-/* { dg-final { cleanup-tree-dump "fnsplit" } } */
 /* { dg-final { scan-tree-dump "part" "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ipa-split-6.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ipa-split-6.c
@@ -5,6 +5,4 @@
 #include "ipa-split-5.c"
 
 /* { dg-final { scan-tree-dump-times "Splitting function" 1 "fnsplit"} } */
-/* { dg-final { cleanup-tree-dump "fnsplit" } } */
 /* { dg-final { scan-tree-dump "part" "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/isolate-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/isolate-1.c
@@ -53,7 +53,6 @@ d_type (struct d_info *di)
 /* { dg-final { scan-tree-dump-times "->type = 42" 1 "isolate-paths"} } */
 /* { dg-final { scan-tree-dump-times "->type ={v} 0" 1 "isolate-paths"} } */
 /* { dg-final { scan-tree-dump-times "->zzz" 1 "isolate-paths"} } */
-/* { dg-final { cleanup-tree-dump "isolate-paths" } } */
 
 
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/isolate-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/isolate-2.c
@@ -38,7 +38,5 @@ bar (void)
    return statement so that it returns &z directly.
 /* { dg-final { scan-tree-dump-times "__builtin_trap" 2 "isolate-paths"} } */
 /* { dg-final { scan-tree-dump-times "return &z;" 1 "phicprop1"} } */
-/* { dg-final { cleanup-tree-dump "isolate-paths" } } */
-/* { dg-final { cleanup-tree-dump "phicprop1" } } */
 
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/isolate-3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/isolate-3.c
@@ -63,6 +63,5 @@ init_alias_analysis (void)
    started with a PHI, but by the time the path isolation code runs
    its explicit in the IL.  */
 /* { dg-final { scan-tree-dump-times "__builtin_trap" 1 "isolate-paths"} } */
-/* { dg-final { cleanup-tree-dump "isolate-paths" } } */
 
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/isolate-4.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/isolate-4.c
@@ -27,7 +27,5 @@ bar (void)
    return statement so that it returns &z directly.
 /* { dg-final { scan-tree-dump-times "__builtin_trap" 2 "isolate-paths"} } */
 /* { dg-final { scan-tree-dump-times "foo .&z.;" 1 "phicprop1"} } */
-/* { dg-final { cleanup-tree-dump "isolate-paths" } } */
-/* { dg-final { cleanup-tree-dump "phicprop1" } } */
 
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/isolate-5.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/isolate-5.c
@@ -52,5 +52,3 @@ d_type (struct d_info *di)
 /* { dg-final { scan-tree-dump-times "->type" 1 "optimized"} } */
 /* { dg-final { scan-tree-dump-times "\\.type" 1 "optimized"} } */
 /* { dg-final { scan-tree-dump-times "->zzz" 1 "isolate-paths"} } */
-/* { dg-final { cleanup-tree-dump "isolate-paths" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ivopt_1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ivopt_1.c
@@ -15,4 +15,3 @@ void foo (int i_width, TYPE dst, TYPE src1, TYPE src2)
 
 
 /* { dg-final { scan-tree-dump-times "ivtmp.\[0-9_\]* = PHI <" 1 "ivopts"} } */
-/* { dg-final { cleanup-tree-dump "ivopts" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ivopt_2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ivopt_2.c
@@ -14,4 +14,3 @@ void foo (int i_width, TYPE dst, TYPE src1, TYPE src2)
 }
 
 /* { dg-final { scan-tree-dump-times "ivtmp.\[0-9_\]* = PHI <" 1 "ivopts"} } */
-/* { dg-final { cleanup-tree-dump "ivopts" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ivopt_3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ivopt_3.c
@@ -17,4 +17,3 @@ void foo (int i_width, char* dst, char* src1, char* src2)
 }
 
 /* { dg-final { scan-tree-dump-times "ivtmp.\[0-9_\]* = PHI <" 1 "ivopts"} } */
-/* { dg-final { cleanup-tree-dump "ivopts" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ivopt_4.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ivopt_4.c
@@ -16,4 +16,3 @@ void foo (int i_width, TYPE dst, TYPE src1, TYPE src2)
 }
 
 /* { dg-final { scan-tree-dump-times "ivtmp.\[0-9_\]* = PHI <" 1 "ivopts"} } */
-/* { dg-final { cleanup-tree-dump "ivopts" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ivopt_infer_1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ivopt_infer_1.c
@@ -22,4 +22,3 @@ void foo (int i_width, TYPE dst, TYPE src1, TYPE src2)
 }
 
 /* { dg-final { scan-tree-dump-times "Replacing" 1 "ivopts"} } */
-/* { dg-final { cleanup-tree-dump "ivopts" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ivopt_infer_2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ivopt_infer_2.c
@@ -23,4 +23,3 @@ void foo (unsigned int i_width, TYPE dst)
 }
 
 /* { dg-final { scan-tree-dump-times "\[^:\]*if \\(.*j_\[0-9\]+.*\\)" 1 "ivopts"} } */
-/* { dg-final { cleanup-tree-dump "ivopts" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ivopt_mult_1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ivopt_mult_1.c
@@ -21,4 +21,3 @@ long foo(long* p, long* p2, int N1, int N2)
 }
 
 /* { dg-final { scan-tree-dump-times "Replacing" 1 "ivopts"} } */
-/* { dg-final { cleanup-tree-dump "ivopts" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ivopt_mult_2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ivopt_mult_2.c
@@ -22,4 +22,3 @@ long foo(long* p, long* p2, int N1, int N2)
 }
 
 /* { dg-final { scan-tree-dump-times "Replacing" 2 "ivopts"} } */
-/* { dg-final { cleanup-tree-dump "ivopts" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ivopt_mult_3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ivopt_mult_3.c
@@ -19,4 +19,3 @@ long foo(long* p, long* p2, int N1, int N2)
 }
 
 /* { dg-final { scan-tree-dump-times "Replacing exit test: if \\(.*p2.*\\)" 1 "ivopts"} } */
-/* { dg-final { cleanup-tree-dump "ivopts" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ivopt_mult_4.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ivopt_mult_4.c
@@ -22,4 +22,3 @@ long foo(long* p, long* p2, int N1, int N2)
 }
 
 /* { dg-final { scan-tree-dump-times "Replacing" 0 "ivopts"} } */
-/* { dg-final { cleanup-tree-dump "ivopts" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ivopts-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ivopts-2.c
@@ -23,4 +23,3 @@ f ()
 
 /* We should only have two IVs.  */
 /* { dg-final { scan-tree-dump-not "\\n  candidates \\d+, \\d+,\[^\\n\]*\\n\[^\\n\]*\\nFinal cost" "ivopts" } }  */
-/* { dg-final { cleanup-tree-dump "ivopts" } }  */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ivopts-3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ivopts-3.c
@@ -11,4 +11,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "!= 0" 5 "ivopts" } }  */
-/* { dg-final { cleanup-tree-dump "ivopts" } }  */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ivopts-lower_base.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ivopts-lower_base.c
@@ -58,4 +58,3 @@ sort_pointers (size_t n, void **pointers, void **work)
 }
 
 /* { dg-final { scan-tree-dump-not "base \[^\\n\]*&MEM\\\[" "ivopts" } }  */
-/* { dg-final { cleanup-tree-dump "ivopts" } }  */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ivopts-lt-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ivopts-lt-2.c
@@ -17,4 +17,3 @@ f1 (int *p, unsigned int i)
 /* { dg-final { scan-tree-dump-times "PHI" 1 "ivopts" } } */
 /* { dg-final { scan-tree-dump-times "PHI <p_" 1 "ivopts"} } */
 /* { dg-final { scan-tree-dump-times "p_\[0-9\]* <" 1 "ivopts" } } */
-/* { dg-final { cleanup-tree-dump "ivopts" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ivopts-lt.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ivopts-lt.c
@@ -20,4 +20,3 @@ f1 (char *p, uintptr_t i, uintptr_t n)
 /* { dg-final { scan-tree-dump-times "PHI" 1 "ivopts" } } */
 /* { dg-final { scan-tree-dump-times "PHI <p_" 1 "ivopts"} } */
 /* { dg-final { scan-tree-dump-times "p_\[0-9\]* <" 1 "ivopts" } } */
-/* { dg-final { cleanup-tree-dump "ivopts" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ldist-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ldist-1.c
@@ -35,4 +35,3 @@ void foo (int * __restrict__ ia,
 }
 
 /* { dg-final { scan-tree-dump-times "distributed: split to 2 loops" 0 "ldist" } } */
-/* { dg-final { cleanup-tree-dump "ldist" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ldist-10.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ldist-10.c
@@ -21,4 +21,3 @@ int loop1 (int k)
 }
 
 /* { dg-final { scan-tree-dump-times "distributed: split to 2 loops" 0 "ldist" } } */
-/* { dg-final { cleanup-tree-dump "ldist" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ldist-11.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ldist-11.c
@@ -30,4 +30,3 @@ void foo (int * __restrict__ ia,
 
 /* { dg-final { scan-tree-dump-times "distributed: split to 1 loops and 1 library calls" 1 "ldist" } } */
 /* { dg-final { scan-tree-dump-times "generated memset zero" 1 "ldist" } } */
-/* { dg-final { cleanup-tree-dump "ldist" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ldist-12.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ldist-12.c
@@ -19,4 +19,3 @@ int foo (int * __restrict__ ia,
 }
 
 /* { dg-final { scan-tree-dump-times "distributed: split to 2 loops" 1 "ldist" } } */
-/* { dg-final { cleanup-tree-dump "ldist" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ldist-13.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ldist-13.c
@@ -19,4 +19,3 @@ float foo (int n)
 /* We should apply loop distribution.  */
 
 /* { dg-final { scan-tree-dump "Loop 1 distributed: split to 2 loops" "ldist" } } */
-/* { dg-final { cleanup-tree-dump "ldist" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ldist-14.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ldist-14.c
@@ -24,4 +24,3 @@ float foo (int n)
 /* We should apply loop distribution.  */
 
 /* { dg-final { scan-tree-dump "Loop 1 distributed: split to 2 loops" "ldist" } } */
-/* { dg-final { cleanup-tree-dump "ldist" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ldist-15.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ldist-15.c
@@ -20,4 +20,3 @@ void foo (int n)
 
 /* { dg-final { scan-tree-dump-not "distributed: split to" "ldist" } } */
 /* { dg-final { scan-tree-dump-not "__builtin_memset" "ldist" } } */
-/* { dg-final { cleanup-tree-dump "ldist" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ldist-16.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ldist-16.c
@@ -18,4 +18,3 @@ void foo (int n)
 
 /* { dg-final { scan-tree-dump "Loop 1 is the same" "ldist" } } */
 /* { dg-final { scan-tree-dump-times "generated memset zero" 0 "ldist" } } */
-/* { dg-final { cleanup-tree-dump "ldist" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ldist-17.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ldist-17.c
@@ -47,4 +47,3 @@ mad_synth_mute (struct mad_synth *synth)
 
 /* { dg-final { scan-tree-dump "distributed: split to 0 loops and 4 library calls" "ldist" } } */
 /* { dg-final { scan-tree-dump-times "generated memset zero" 4 "ldist" } } */
-/* { dg-final { cleanup-tree-dump "ldist" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ldist-18.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ldist-18.c
@@ -9,4 +9,3 @@ void foo (int *p, int n)
 }
 
 /* { dg-final { scan-tree-dump "generated memset zero" "ldist" } } */
-/* { dg-final { cleanup-tree-dump "ldist" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ldist-19.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ldist-19.c
@@ -68,4 +68,3 @@ int main()
 
 /* { dg-final { scan-tree-dump-times "generated memset zero" 1 "ldist" } } */
 /* { dg-final { scan-tree-dump-times "generated memset" 5 "ldist" } } */
-/* { dg-final { cleanup-tree-dump "ldist" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ldist-1a.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ldist-1a.c
@@ -19,4 +19,3 @@ int foo (int * __restrict__ ia,
 }
 
 /* { dg-final { scan-tree-dump-times "distributed: split to 2 loops" 0 "ldist" } } */
-/* { dg-final { cleanup-tree-dump "ldist" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ldist-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ldist-2.c
@@ -28,4 +28,3 @@ void foo (int * __restrict__ a,
 }
 
 /* { dg-final { scan-tree-dump-times "distributed: split to 2 loops" 0 "ldist" } } */
-/* { dg-final { cleanup-tree-dump "ldist" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ldist-20.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ldist-20.c
@@ -34,4 +34,3 @@ void my_memmove (unsigned int n)
 
 /* { dg-final { scan-tree-dump-times "generated memcpy" 2 "ldist" } } */
 /* { dg-final { scan-tree-dump-times "generated memmove" 1 "ldist" } } */
-/* { dg-final { cleanup-tree-dump "ldist" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ldist-21.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ldist-21.c
@@ -9,4 +9,3 @@ void bar(char *p, int n)
 }
 
 /* { dg-final { scan-tree-dump "generated memmove" "ldist" } } */
-/* { dg-final { cleanup-tree-dump "ldist" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ldist-22.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ldist-22.c
@@ -29,4 +29,3 @@ int main()
 }
 
 /* { dg-final { scan-tree-dump "generated memset zero" "ldist" } } */
-/* { dg-final { cleanup-tree-dump "ldist" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ldist-23.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ldist-23.c
@@ -31,4 +31,3 @@ int main()
 
 /* { dg-final { scan-tree-dump "split to 1 loops and 1 library call" "ldist" } } */
 /* { dg-final { scan-tree-dump "generated memcpy" "ldist" } } */
-/* { dg-final { cleanup-tree-dump "ldist" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ldist-3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ldist-3.c
@@ -31,4 +31,3 @@ int loop1 (int k)
 }
 
 /* { dg-final { scan-tree-dump-times "distributed: split to 3 loops" 0 "ldist" } } */
-/* { dg-final { cleanup-tree-dump "ldist" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ldist-4.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ldist-4.c
@@ -24,4 +24,3 @@ int loop1 (int k)
    similar memory accesses.  */
 /* { dg-final { scan-tree-dump "similar memory accesses" "ldist" } } */
 /* { dg-final { scan-tree-dump-times "distributed: split to 2 loops" 0 "ldist" } } */
-/* { dg-final { cleanup-tree-dump "ldist" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ldist-5.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ldist-5.c
@@ -30,4 +30,3 @@ int loop1 (int k)
    problem: the dependence test fails with a "don't know" relation.  */
 
 /* { dg-final { scan-tree-dump-times "distributed: split to 2 loops" 1 "ldist" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "ldist" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ldist-6.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ldist-6.c
@@ -35,4 +35,3 @@ int loop1 (int k)
 }
 
 /* { dg-final { scan-tree-dump-times "distributed: split to 2 loops" 0 "ldist" } } */
-/* { dg-final { cleanup-tree-dump "ldist" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ldist-7.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ldist-7.c
@@ -29,4 +29,3 @@ int loop1 (int k)
 }
 
 /* { dg-final { scan-tree-dump-times "distributed" 0 "ldist" } } */
-/* { dg-final { cleanup-tree-dump "ldist" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ldist-8.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ldist-8.c
@@ -31,4 +31,3 @@ int loop1 (int k)
 }
 
 /* { dg-final { scan-tree-dump-times "distributed: split to 2 loops" 0 "ldist" } } */
-/* { dg-final { cleanup-tree-dump "ldist" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ldist-9.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ldist-9.c
@@ -23,4 +23,3 @@ int loop1 (int k)
 }
 
 /* { dg-final { scan-tree-dump-times "distributed: split to 2 loops" 0 "ldist" } } */
-/* { dg-final { cleanup-tree-dump "ldist" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ldist-pr45948.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ldist-pr45948.c
@@ -20,4 +20,3 @@ foo (int i, int n)
 
 /* { dg-final { scan-tree-dump "distributed: split to 0 loops and 2 library calls" "ldist" } } */
 /* { dg-final { scan-tree-dump-times "generated memset zero" 2 "ldist" } } */
-/* { dg-final { cleanup-tree-dump "ldist" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/leaf.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/leaf.c
@@ -17,4 +17,3 @@ test (void)
 }
 /* { dg-final { scan-tree-dump-times "return 9" 1 "optimized"} } */
  
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loadpre1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loadpre1.c
@@ -15,4 +15,3 @@ int foo(int *a, int argc)
   return d + e;
 }
 /* { dg-final { scan-tree-dump-times "Eliminated: 1" 1 "pre" } } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loadpre10.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loadpre10.c
@@ -45,5 +45,4 @@ L23:
   return expr; 
 } 
 /* { dg-final { scan-tree-dump-times "Eliminated: 1" 1 "pre"} } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loadpre11.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loadpre11.c
@@ -10,5 +10,4 @@ int f(int tt)
     return g(*t1);
 } 
 /* { dg-final { scan-tree-dump-times "Eliminated: 1" 1 "pre"} } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loadpre12.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loadpre12.c
@@ -12,4 +12,3 @@ int f(int tt)
 }
 
 /* { dg-final { scan-tree-dump-times "Eliminated: 1" 1 "pre" } } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loadpre13.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loadpre13.c
@@ -10,4 +10,3 @@ int f(int tt)
 }
 
 /* { dg-final { scan-tree-dump-times "Eliminated: 1" 1 "pre"} } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loadpre14.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loadpre14.c
@@ -16,4 +16,3 @@ int foo(type *a, int argc)
   return d + e;
 }
 /* { dg-final { scan-tree-dump-times "Eliminated: 1" 1 "pre"} } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loadpre15.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loadpre15.c
@@ -16,4 +16,3 @@ int foo(type *a, int argc, int t)
   return d + e;
 }
 /* { dg-final { scan-tree-dump-times "Eliminated: 1" 1 "pre"} } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loadpre16.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loadpre16.c
@@ -13,4 +13,3 @@ int foo(type *a, int argc)
   return d + e;
 }
 /* { dg-final { scan-tree-dump-times "Eliminated: 1" 1 "pre"} } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loadpre17.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loadpre17.c
@@ -13,4 +13,3 @@ int foo(type *a, int argc)
   return d + e;
 }
 /* { dg-final { scan-tree-dump-times "Eliminated: 1" 1 "pre"} } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loadpre18.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loadpre18.c
@@ -13,4 +13,3 @@ int main(type *a, int argc)
   return d + e;
 }
 /* { dg-final { scan-tree-dump-times "Eliminated: 1" 1 "pre" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loadpre19.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loadpre19.c
@@ -13,4 +13,3 @@ int foo(type *a, int argc)
   return e;
 }
 /* { dg-final { scan-tree-dump-times "Eliminated: 1" 1 "pre"  } } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loadpre2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loadpre2.c
@@ -15,4 +15,3 @@ int main(int *a, int argc)
 }
 
 /* { dg-final { scan-tree-dump-times "Eliminated: 1" 1 "pre"} } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loadpre20.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loadpre20.c
@@ -13,4 +13,3 @@ int foo(type *a, int argc)
   return e;
 }
 /* { dg-final { scan-tree-dump-times "Eliminated: 1" 1 "pre"  } } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loadpre21.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loadpre21.c
@@ -16,4 +16,3 @@ int main(type *a, int argc)
 }
 
 /* { dg-final { scan-tree-dump-times "Eliminated: 1" 1 "pre"} } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loadpre22.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loadpre22.c
@@ -16,4 +16,3 @@ int main(type *a, int argc)
 }
 
 /* { dg-final { scan-tree-dump-times "Eliminated: 1" 1 "pre"} } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loadpre23.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loadpre23.c
@@ -22,4 +22,3 @@ int foo(int argc)
 }
 
 /* { dg-final { scan-tree-dump-times "Eliminated: 1" 1 "pre"  } } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loadpre24.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loadpre24.c
@@ -21,4 +21,3 @@ int foo(int argc)
 /* We will move the load of a out of the loop.  */
 
 /* { dg-final { scan-tree-dump-times "Eliminated: 1" 1 "pre" } } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loadpre25.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loadpre25.c
@@ -17,4 +17,3 @@ int foo(struct X *a, int argc)
 }
 
 /* { dg-final { scan-tree-dump-times "Eliminated: 1" 1 "pre"  } } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loadpre3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loadpre3.c
@@ -21,4 +21,3 @@ int foo(int **a,int argc)
 }
 
 /* { dg-final { scan-tree-dump-times "Eliminated: 2" 1 "pre"} } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loadpre4.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loadpre4.c
@@ -16,4 +16,3 @@ int main(int *a, int argc)
 }
 
 /* { dg-final { scan-tree-dump-times "Eliminated: 1" 1 "pre"  } } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loadpre5.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loadpre5.c
@@ -21,4 +21,3 @@ int foo(int argc)
   return q + a();
 }
 /* { dg-final { scan-tree-dump-times "Eliminated: 1" 1 "pre"} } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loadpre6.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loadpre6.c
@@ -76,5 +76,3 @@ main (void)
 /* { dg-final { scan-tree-dump-not "= unexpanded_var_list;" "fre1" } } */
 /* { dg-final { scan-tree-dump-times "Eliminated: 1" 1 "pre" } } */
 /* { dg-final { scan-tree-dump-times "Insertions: 2" 1 "pre" } } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loadpre7.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loadpre7.c
@@ -17,4 +17,3 @@ enormlz (x)
     }
 }
 /* { dg-final { scan-tree-dump-not "Eliminated:" "pre"} } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loadpre8.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loadpre8.c
@@ -94,4 +94,3 @@ rewrite_add_phi_arguments (basic_block bb)
     }
 }
 /* { dg-final { scan-tree-dump-times "Eliminated: 1" 1 "pre" } } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/local-pure-const.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/local-pure-const.c
@@ -14,4 +14,3 @@ t(int a, int b, int c)
 }
 /* { dg-final { scan-tree-dump-times "local memory is OK" 1 "local-pure-const1"} } */
 /* { dg-final { scan-tree-dump-times "found to be const" 1 "local-pure-const1"} } */
-/* { dg-final { cleanup-tree-dump "local-pure-const1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loop-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loop-1.c
@@ -34,11 +34,8 @@ int xxx(void)
 /* We should be able to find out that the loop iterates four times and unroll it completely.  */
 
 /* { dg-final { scan-tree-dump-times "Added canonical iv to loop 1, 4 iterations" 1 "ivcanon"} } */
-/* { dg-final { cleanup-tree-dump "ivcanon" } } */
 /* { dg-final { scan-tree-dump-times "loop with 5 iterations completely unrolled" 1 "cunroll"} } */
-/* { dg-final { cleanup-tree-dump "cunroll" } } */
 /* { dg-final { scan-tree-dump-times "foo" 5 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
 /* Because hppa, ia64 and Windows targets include an external declaration
    for foo as well as the calls we need to look for something more specific
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loop-10.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loop-10.c
@@ -30,4 +30,3 @@ void foo (void)
 /* { dg-final { scan-tree-dump-times "if " 3 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "bar " 2 "optimized" } } */
 
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loop-11.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loop-11.c
@@ -24,5 +24,4 @@ void foo (void)
 
 /* { dg-final { scan-tree-dump-times "if " 0 "optimized" } } */
 
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loop-14.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loop-14.c
@@ -16,4 +16,3 @@ int bla(void)
 }
 
 /* { dg-final { scan-tree-dump-times "\\+ 100" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loop-15.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loop-15.c
@@ -24,4 +24,3 @@ int bla(void)
 
 /* The if from the loop header copying remains in the code.  */
 /* { dg-final { scan-tree-dump-times "if " 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loop-16.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loop-16.c
@@ -21,4 +21,3 @@ void foo(unsigned n)
 /* { dg-final { scan-tree-dump-times "MEM" 1 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "\[^\\n\\r\]*= \\* " 0 "optimized" } } */
 
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loop-17.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loop-17.c
@@ -16,4 +16,3 @@ int foo (int *p)
 }
 
 /* { dg-final { scan-tree-dump "# of iterations 1, bounded by 1" "sccp" } } */
-/* { dg-final { cleanup-tree-dump "sccp" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loop-18.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loop-18.c
@@ -21,4 +21,3 @@ void foo(unsigned *p, unsigned n)
 /* { dg-final { scan-tree-dump-times "MEM" 1 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "\[^\\n\\r\]*= \\* " 0 "optimized" } } */
 
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loop-19.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loop-19.c
@@ -25,4 +25,3 @@ void tuned_STREAM_Copy()
 /* { dg-final { scan-tree-dump-times "MEM.(base: &|symbol: )a," 2 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "MEM.(base: &|symbol: )c," 2 "optimized" } } */
 
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loop-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loop-2.c
@@ -41,4 +41,3 @@ void xxx(void)
 /* { dg-final { scan-tree-dump-times "= 99" 0 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "< 100" 0 "optimized" } } */
 
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loop-20.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loop-20.c
@@ -24,4 +24,3 @@ gfc_conv_array_transpose (gfc_se * se) {
 /* Ivopts should not produce multiplication by a pointer constant.  */
 
 /* { dg-final { scan-tree-dump-times "\\* \[0-9\]*B;" 0 "ivopts" } } */
-/* { dg-final { cleanup-tree-dump "ivopts" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loop-21.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loop-21.c
@@ -14,4 +14,3 @@ void foo(int f0, int f1, int e0, int e1)
 }
 
 /* { dg-final { scan-tree-dump-times "~" 0 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loop-22.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loop-22.c
@@ -14,4 +14,3 @@ void test (int n)
    correct, this transformation is obviously harmful.  */
 
 /* { dg-final { scan-tree-dump-times "/" 0 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loop-23.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loop-23.c
@@ -26,4 +26,3 @@ int foo(void)
 
 /* { dg-final { scan-tree-dump-times "loop with 4 iterations completely unrolled" 1 "cunroll" } } */
 
-/* { dg-final { cleanup-tree-dump "cunroll" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loop-24.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loop-24.c
@@ -14,4 +14,3 @@ void foo4(int*a, int*b)
 { for(;a!=b;a++); }
 
 /* { dg-final { scan-tree-dump-not "if" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loop-25.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loop-25.c
@@ -126,4 +126,3 @@ void test5 (void)
 /* { dg-final { scan-tree-dump-times "3 loops found" 2 "profile_estimate" { xfail *-*-* } } } */
 /* { dg-final { scan-tree-dump-times "2 loops found" 1 "profile_estimate" { xfail *-*-* } } } */
 
-/* { dg-final { cleanup-tree-dump "profile_estimate" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loop-26.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loop-26.c
@@ -26,4 +26,3 @@ int foo0(int i0, int i1)
 }
 
 /* { dg-final { scan-tree-dump-times "if" 2 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loop-28.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loop-28.c
@@ -19,5 +19,3 @@ void foo(int n)
 /* There should be no i_a = i_b assignments.  */
 /* { dg-final { scan-tree-dump-times "i_.*= i_\[0-9\]*;" 0 "aprefetch" } } */
 
-/* { dg-final { cleanup-tree-dump "optimized" } } */
-/* { dg-final { cleanup-tree-dump "aprefetch" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loop-29.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loop-29.c
@@ -18,4 +18,3 @@ foo (struct s *p)
 }
 
 /* { dg-final { scan-tree-dump-not "if" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loop-3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loop-3.c
@@ -27,4 +27,3 @@ void xxx(void)
 
 /* { dg-final { scan-tree-dump-times "int iter" 1 "optimized" } } */
 
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loop-31.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loop-31.c
@@ -18,4 +18,3 @@ short foo (int len, int v)
 /* { dg-final { scan-tree-dump-times " \\+ 2;" 1 "optimized" { target arm*-*-* } } } */
 /* { dg-final { scan-tree-dump-times " \\+ 2;" 1 "optimized" { target { ia64-*-* && ilp32 } } } } */
 /* { dg-final { scan-tree-dump-times " \\+ 2;" 2 "optimized" { target { ia64-*-* && lp64 } } } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loop-32.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loop-32.c
@@ -43,4 +43,3 @@ void test3(struct a *A)
 }
 
 /* { dg-final { scan-tree-dump-times "Executing store motion of" 3 "lim1" } } */
-/* { dg-final { cleanup-tree-dump "lim1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loop-33.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loop-33.c
@@ -37,4 +37,3 @@ void test5(struct a *A, unsigned b)
 }
 
 /* { dg-final { scan-tree-dump-times "Executing store motion of" 4 "lim1" { xfail { lp64 || llp64 } } } } */
-/* { dg-final { cleanup-tree-dump "lim1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loop-34.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loop-34.c
@@ -18,4 +18,3 @@ void f (int n)
 
 
 /* { dg-final { scan-tree-dump-times "Executing store motion of r" 6 "lim1" } } */
-/* { dg-final { cleanup-tree-dump "lim1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loop-35.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loop-35.c
@@ -69,4 +69,3 @@ void test4(struct a *A, unsigned LONG b)
 /* long index not hoisted for avr target PR 36561 */
 /* { dg-final { scan-tree-dump-times "Executing store motion of" 8 "lim1" { xfail { "avr-*-*" } } } } */
 /* { dg-final { scan-tree-dump-times "Executing store motion of" 6 "lim1" { target { "avr-*-*" } } } } */
-/* { dg-final { cleanup-tree-dump "lim1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loop-36.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loop-36.c
@@ -19,4 +19,3 @@ float foobar () {
 /* The temporary structure should have been promoted to registers
    by FRE after the loops have been unrolled by the early unrolling pass.  */
 /* { dg-final { scan-tree-dump-not "c\.array" "dce2" } } */
-/* { dg-final { cleanup-tree-dump "dce2" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loop-37.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loop-37.c
@@ -24,4 +24,3 @@ int f1 (int a [])
 int main() { }
 
 /* { dg-final { scan-tree-dump-not "my_array" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loop-38.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loop-38.c
@@ -16,4 +16,3 @@ t(int n)
   return sum;
 }
 /* { dg-final { scan-tree-dump "Loop 1 iterates at most 11 times" "cunrolli" } } */
-/* { dg-final { cleanup-tree-dump "cunrolli" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loop-39.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loop-39.c
@@ -23,4 +23,3 @@ foo (unsigned int n)
 }
 
 /* { dg-final { scan-tree-dump "# of iterations \[^\n\r]*, bounded by 8" "sccp" } } */
-/* { dg-final { cleanup-tree-dump "sccp" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loop-4.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loop-4.c
@@ -43,4 +43,3 @@ void xxx(void)
 
 /* { dg-final { scan-tree-dump-times "iter" 0 "optimized" } } */
 
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loop-40.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loop-40.c
@@ -11,4 +11,3 @@ int mymax2(int *it, int *end)
 }
 
 /* { dg-final { scan-tree-dump "Duplicating header" "ch" } } */
-/* { dg-final { cleanup-tree-dump "ch" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loop-5.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loop-5.c
@@ -27,4 +27,3 @@ void xxx(void)
 
 /* { dg-final { scan-tree-dump-times " \\+ 2" 1 "optimized" } } */
 
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loop-6.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loop-6.c
@@ -20,9 +20,7 @@ void xxx(void)
 /* Loop should be unswitched.  */
 
 /* { dg-final { scan-tree-dump-times "Unswitching loop" 1 "unswitch" } } */
-/* { dg-final { cleanup-tree-dump "unswitch" } } */
 
 /* In effect there should be exactly three conditional jumps in the final program.  */
 
 /* { dg-final { scan-tree-dump-times "else" 3 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loop-7.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loop-7.c
@@ -32,4 +32,3 @@ int xxx (void)
    with k = 0 may be invalid.  */
 
 /* { dg-final { scan-tree-dump-times "Moving statement" 2 "lim1" } } */
-/* { dg-final { cleanup-tree-dump "lim1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loop-8.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loop-8.c
@@ -22,4 +22,3 @@ void xxx (void)
 /* { dg-final { scan-tree-dump-times "step \\* \[^0-9\]" 0 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "\[^0-9\] \\* step" 0 "optimized" } } */
 
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loop-bound-1.c
@@ -0,0 +1,22 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-ivopts-details" } */
+
+int *a;
+
+int
+foo (unsigned char s, unsigned char l)
+{
+  unsigned char i;
+  int sum = 0;
+
+  for (i = s; i < l; i += 1)
+    {
+      sum += a[i];
+    }
+
+  return sum;
+}
+
+/* Check loop niter bound information.  */
+/* { dg-final { scan-tree-dump "bounded by 254" "ivopts" } } */
+/* { dg-final { scan-tree-dump-not "bounded by 255" "ivopts" } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loop-bound-3.c
@@ -0,0 +1,22 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-ivopts-details" } */
+
+int *a;
+
+int
+foo (unsigned char s, unsigned char l)
+{
+  unsigned char i;
+  int sum = 0;
+
+  for (i = s; i > l; i -= 1)
+    {
+      sum += a[i];
+    }
+
+  return sum;
+}
+
+/* Check loop niter bound information.  */
+/* { dg-final { scan-tree-dump "bounded by 254" "ivopts" } } */
+/* { dg-final { scan-tree-dump-not "bounded by 255" "ivopts" } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loop-bound-5.c
@@ -0,0 +1,22 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-ivopts-details" } */
+
+int *a;
+
+int
+foo (unsigned char s)
+{
+  unsigned char i;
+  int sum = 0;
+
+  for (i = s; i > 0; i -= 1)
+    {
+      sum += a[i];
+    }
+
+  return sum;
+}
+
+/* Check loop niter bound information.  */
+/* { dg-final { scan-tree-dump "bounded by 254" "ivopts" } } */
+/* { dg-final { scan-tree-dump-not "bounded by 255" "ivopts" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/negate.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/negate.c
@@ -24,4 +24,3 @@ int g (int a, int b)
 
 /* There should be an addition now.  */
 /* { dg-final { scan-tree-dump-times "\\+" 1 "reassoc1"} } */
-/* { dg-final { cleanup-tree-dump "reassoc1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/phi-opt-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/phi-opt-1.c
@@ -16,4 +16,3 @@ temp:
    optimize this before because PHI-OPT did not look at 
    PHIs which have more than two arguments.  */
 /* { dg-final { scan-tree-dump-times "if" 0 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/phi-opt-10.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/phi-opt-10.c
@@ -8,4 +8,3 @@ int spaceship1 (long a) { return a > 0 ? 1 : a < 0 ? -1 : 0; }
 int spaceship2 (long a) { return a > 0 ? 1 : a == 0 ? 0 : -1; }
 
 /* { dg-final { scan-tree-dump-times " = -\[^\r\n\]*_.;" 4 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/phi-opt-11.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/phi-opt-11.c
@@ -22,4 +22,3 @@ int h(int a, int b, int c, int d)
  return a;
 }
 /* { dg-final { scan-tree-dump-times "if" 0 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/phi-opt-12.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/phi-opt-12.c
@@ -20,4 +20,3 @@ unsigned m(unsigned a, unsigned b) {
 }
 
 /* { dg-final { scan-tree-dump-times "goto" 2 "phiopt1" } } */
-/* { dg-final { cleanup-tree-dump "phiopt1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/phi-opt-13.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/phi-opt-13.c
@@ -8,4 +8,3 @@ long f(long a, long b) {
 }
 
 /* { dg-final { scan-tree-dump-times "goto " 2 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/phi-opt-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/phi-opt-2.c
@@ -22,4 +22,3 @@ _Bool f1(_Bool a, _Bool b)
    Test this only when known to be !LOGICAL_OP_NON_SHORT_CIRCUIT,
    otherwise ifcombine may convert this into return a & b;.  */
 /* { dg-final { scan-tree-dump-times "if" 1 "optimized" { target { i?86-*-* x86_64-*-* mips*-*-* s390*-*-* avr*-*-* } } } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/phi-opt-3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/phi-opt-3.c
@@ -14,4 +14,3 @@ int f(int a, int b)
    optimize this before because PHI-OPT did not look at 
    PHIs which have more than two arguments.  */
 /* { dg-final { scan-tree-dump-times "if" 0 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/phi-opt-4.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/phi-opt-4.c
@@ -14,4 +14,3 @@ _Bool f1()
    value of b (except that we don't fold ! (b != 0) into b
    which means that we miss a sib calling opportunity).  */
 /* { dg-final { scan-tree-dump-times "if " 1 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/phi-opt-5.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/phi-opt-5.c
@@ -56,4 +56,3 @@ float repl3 (float varz, float vara, float varb)
 
 /* { dg-final { scan-tree-dump "if .*varz" "phiopt1"} } */
 /* { dg-final { scan-tree-dump "vara.*MAX_EXPR" "phiopt1"} } */
-/* { dg-final { cleanup-tree-dump "phiopt1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/phi-opt-6.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/phi-opt-6.c
@@ -10,4 +10,3 @@ int *g(struct C *p)
 }
 
 /* { dg-final { scan-tree-dump-not "if" "phiopt1" } } */
-/* { dg-final { cleanup-tree-dump "phiopt1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/phi-opt-7.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/phi-opt-7.c
@@ -19,5 +19,4 @@ int f(int t, int c)
    a conditional and the other should be there still.  */
 /* { dg-final { scan-tree-dump-times "if" 1 "optimized" }  }*/
 /* { dg-final { scan-tree-dump-times "\[^\r\n\]*_. = c_\[0-9\]*.D. != 0" 1 "optimized"  } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/phi-opt-8.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/phi-opt-8.c
@@ -22,5 +22,3 @@ int f(int t, int c)
 /* { dg-final { scan-tree-dump-not "if" "phiopt1" } } */
 /* { dg-final { scan-tree-dump "g .t_\[0-9\]*.D.," "optimized" } } */
 /* { dg-final { scan-tree-dump-not "PHI" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "phiopt1" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/phi-opt-9.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/phi-opt-9.c
@@ -19,4 +19,3 @@ int f(int t, int c)
 /* The value e should have been replaced with t and there should be only one PHI. */
 /* { dg-final { scan-tree-dump "g .t_\[0-9\]*.D.," "optimized" } } */
 /* { dg-final { scan-tree-dump-times "PHI" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr13146.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr13146.c
@@ -19,4 +19,3 @@ int foo (struct A *p, struct B *q)
 }
 
 /* { dg-final { scan-tree-dump "return 0;" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr14341.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr14341.c
@@ -14,4 +14,3 @@ void t()
 }
 
 /* { dg-final { scan-tree-dump-times "fn_call \\(1\\)" 1 "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr14490-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr14490-1.c
@@ -7,5 +7,4 @@ int g(int x)
 /* There should be only x <= 9 and no x - 10. */
 /* { dg-final { scan-tree-dump-times "<= 9" 1 "gimple"} } */
 /* { dg-final { scan-tree-dump-times "\\+ -10" 0 "gimple"} } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr14490-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr14490-2.c
@@ -7,4 +7,3 @@ int g(int x)
 /* There should be no x >= 9 and one x - 10. */
 /* { dg-final { scan-tree-dump-times "<= 9" 0 "gimple"} } */
 /* { dg-final { scan-tree-dump-times "\\+ -10" 1 "gimple"} } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr14490-3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr14490-3.c
@@ -7,4 +7,3 @@ int g(int x)
 /* There should be only x < -10 and no x + 10. */
 /* { dg-final { scan-tree-dump-times "< -10" 1 "gimple"} } */
 /* { dg-final { scan-tree-dump-times "\\+ 10" 0 "gimple"} } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr14490-4.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr14490-4.c
@@ -7,4 +7,3 @@ int g(int x)
 /* There should be no x < -10 and one x + 10. */
 /* { dg-final { scan-tree-dump-times "< -10" 0 "gimple"} } */
 /* { dg-final { scan-tree-dump-times "\\+ 10" 1 "gimple"} } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr14814.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr14814.c
@@ -19,4 +19,3 @@ int foo(const struct XX* r) {
 }
 
 /* { dg-final { scan-tree-dump-times "= &" 0 "forwprop2" } } */
-/* { dg-final { cleanup-tree-dump "forwprop2" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr15349.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr15349.c
@@ -23,4 +23,3 @@ foo (int a, int b)
 }
 
 /* { dg-final { scan-tree-dump-times "PHI" 1 "mergephi2"} } */
-/* { dg-final { cleanup-tree-dump "mergephi2" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr15791-3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr15791-3.c
@@ -10,4 +10,3 @@ int f(int i, unsigned j)
 }
 
 /* { dg-final { scan-tree-dump-times "i == j" 0 "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr15791-4.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr15791-4.c
@@ -10,4 +10,3 @@ int f(int i, int j)
 }
 
 /* { dg-final { scan-tree-dump-times "i == j" 0 "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr15791-5.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr15791-5.c
@@ -10,4 +10,3 @@ int foo(int i, int j)
 }
 
 /* { dg-final { scan-tree-dump-times "i == j" 1 "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr16721.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr16721.c
@@ -13,4 +13,3 @@ int test()
 
 /* The load from p->addr should not disappear.  */
 /* { dg-final { scan-tree-dump-times "\->addr" 1 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr17141-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr17141-1.c
@@ -14,4 +14,3 @@ foo(struct A *locp, int str)
 /* We should have propagated &locp->i into its dereference.  */
 
 /* { dg-final { scan-tree-dump "locp_\[^\\n\]* =" "forwprop1" } } */
-/* { dg-final { cleanup-tree-dump "forwprop1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr17141-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr17141-2.c
@@ -27,4 +27,3 @@ l2:
 
 /* { dg-final { scan-tree-dump-times "&" 0 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "abort" 0 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr17598.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr17598.c
@@ -39,4 +39,3 @@ int foobar2(struct g *x)
 /* { dg-final { scan-tree-dump-times "x == &y" 2 "gimple" } } */
 /* { dg-final { scan-tree-dump "x->k" "gimple" } } */
 /* { dg-final { scan-tree-dump "yy.k" "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr18133-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr18133-1.c
@@ -25,4 +25,3 @@ return;
    scan for 3 instances of "FALLTHRU".  */
 
 /* { dg-final { scan-tree-dump-times "FALLTHRU" 3 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr18133-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr18133-2.c
@@ -40,4 +40,3 @@ bar (int a)
    computed goto.  */
 
 /* { dg-final { scan-tree-dump-times "ab" 0 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr18134.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr18134.c
@@ -23,4 +23,3 @@ return 0;
    computed gotos.  */
 
 /* { dg-final { scan-tree-dump-times "ab" 0 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr18589-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr18589-1.c
@@ -7,4 +7,3 @@ double baz (double x, double y)
 }
 
 /* { dg-final { scan-tree-dump-times " \\* " 3 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr18589-10.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr18589-10.c
@@ -8,4 +8,3 @@ double baz (double x, double y, double z)
 }
 
 /* { dg-final { scan-tree-dump-times " \\* " 5 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr18589-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr18589-2.c
@@ -7,4 +7,3 @@ double baz (double x, double y)
 }
 
 /* { dg-final { scan-tree-dump-times " \\* " 3 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr18589-3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr18589-3.c
@@ -7,4 +7,3 @@ double baz (double x, double y, double z)
 }
 
 /* { dg-final { scan-tree-dump-times " \\* " 5 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr18589-4.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr18589-4.c
@@ -7,4 +7,3 @@ double baz (double x, double y, double z, double u)
 }
 
 /* { dg-final { scan-tree-dump-times " \\* " 6 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr18589-5.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr18589-5.c
@@ -7,4 +7,3 @@ double baz (double x, double y, double z, double u)
 }
 
 /* { dg-final { scan-tree-dump-times " \\* " 6 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr18589-6.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr18589-6.c
@@ -7,4 +7,3 @@ double baz (double x, double y)
 }
 
 /* { dg-final { scan-tree-dump-times " \\* " 4 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr18589-7.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr18589-7.c
@@ -7,4 +7,3 @@ float baz (float x, float y)
 }
 
 /* { dg-final { scan-tree-dump-times " \\* " 3 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr18589-8.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr18589-8.c
@@ -7,4 +7,3 @@ long double baz (long double x, long double y)
 }
 
 /* { dg-final { scan-tree-dump-times " \\* " 3 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr18589-9.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr18589-9.c
@@ -8,4 +8,3 @@ double baz (double x, double y, double z)
 }
 
 /* { dg-final { scan-tree-dump-times " \\* " 6 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr18908.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr18908.c
@@ -6,4 +6,3 @@ _Bool f3(_Bool *p) { *p ^= 1; }
 /* We should be able to canonicalize the above to use bitwise not.  */
 /* { dg-final { scan-tree-dump "~\[^\n\r\]*_.;" "forwprop1" } } */
 /* { dg-final { scan-tree-dump-not "\\\^ 1" "forwprop1" } } */
-/* { dg-final { cleanup-tree-dump "forwprop1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr19055-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr19055-2.c
@@ -24,4 +24,3 @@ int f4(int a,int b,int c,int d)
 /* { dg-final { scan-tree-dump-times "\\^" 0 "gimple"} } */
 /* { dg-final { scan-tree-dump-times "~" 4 "gimple"} } */
 /* { dg-final { scan-tree-dump-times "&" 12 "gimple"} } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr19055.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr19055.c
@@ -20,4 +20,3 @@ int f4(int a,int b)
 /* { dg-final { scan-tree-dump-times "\\^" 0 "gimple"} } */
 /* { dg-final { scan-tree-dump-times "~" 4 "gimple"} } */
 /* { dg-final { scan-tree-dump-times "&" 4 "gimple"} } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr19431.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr19431.c
@@ -25,4 +25,3 @@ int f(int k, int i1, int j1)
 }
 
 /* { dg-final { scan-tree-dump "\[^\r\n\]*_. = PHI <i1_\[^,\]*, j1_\[^>\]*>" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr19590.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr19590.c
@@ -34,4 +34,3 @@ void vnum_test8(int *data)
 
 /* { dg-final { scan-tree-dump-times "= 0;" 1 "ivopts"} } */
 /* { dg-final { scan-tree-dump-times "= 2;" 1 "ivopts"} } */
-/* { dg-final { cleanup-tree-dump "ivopts" } }  */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr19633.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr19633.c
@@ -23,4 +23,3 @@ foo (int a, struct T b)
 /* Make sure that .GLOBAL_VAR is not created when there are no
    clobbering calls.  */
 /* { dg-final { scan-tree-dump-times "GLOBAL_VAR" 0 "ssa"} } */
-/* { dg-final { cleanup-tree-dump "ssa" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr19831-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr19831-1.c
@@ -29,4 +29,3 @@ void test4(int b)
 
 /* { dg-final { scan-tree-dump-times "free" 0 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "malloc" 0 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr19831-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr19831-2.c
@@ -12,4 +12,3 @@ void test1(void)
 
 /* { dg-final { scan-tree-dump-times "free" 1 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "malloc" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr19831-3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr19831-3.c
@@ -36,4 +36,3 @@ void test6(void)
 
 /* { dg-final { scan-tree-dump-times "free" 3 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "malloc" 3 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr20139.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr20139.c
@@ -20,4 +20,3 @@ foo (double x)
 }
 
 /* { dg-final { scan-tree-dump-times "link_error" 0 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr20318.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr20318.c
@@ -15,5 +15,3 @@ void h () {
 
 /* { dg-final { scan-tree-dump-times "== 0" 1 "original" } } */
 /* { dg-final { scan-tree-dump-times "Folding predicate\[^\\n\]*to 0" 1 "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr20470.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr20470.c
@@ -12,4 +12,3 @@ void f1()
 }
 
 /* { dg-final { scan-tree-dump-times "ABS_EXPR" 1 "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr20657.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr20657.c
@@ -15,4 +15,3 @@ foo (int a)
 }
 
 /* { dg-final { scan-tree-dump-times "Folding predicate" 1 "vrp1"} } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr20701.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr20701.c
@@ -38,4 +38,3 @@ can_combine_p (rtx insn, rtx elt)
 /* Target with fno-delete-null-pointer-checks should not fold checks */
 /* { dg-final { scan-tree-dump-times "Folding predicate.*to 0" 1 "vrp1" { target { ! keeps_null_pointer_checks } } } } */
 /* { dg-final { scan-tree-dump-times "Folding predicate.*to 0" 0 "vrp1" { target {   keeps_null_pointer_checks } } } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr20702.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr20702.c
@@ -28,4 +28,3 @@ foo (int *p, int b)
 /* Target with fno-delete-null-pointer-checks should not fold checks */
 /* { dg-final { scan-tree-dump-times "Folding predicate" 1 "vrp1" { target { ! keeps_null_pointer_checks } } } } */
 /* { dg-final { scan-tree-dump-times "Folding predicate" 0 "vrp1" { target {   keeps_null_pointer_checks } } } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr21001.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr21001.c
@@ -18,4 +18,3 @@ foo (int a)
 }
 
 /* { dg-final { scan-tree-dump-times "Folding predicate" 1 "vrp1"} } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr21031.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr21031.c
@@ -17,4 +17,3 @@ foo (int a)
 }
 
 /* { dg-final { scan-tree-dump-times "Replaced" 2 "forwprop1" } } */
-/* { dg-final { cleanup-tree-dump "forwprop1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr21086.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr21086.c
@@ -20,5 +20,3 @@ foo (int *p)
 /* { dg-final { scan-tree-dump-times "Folding predicate " 0 "vrp1" { target {   keeps_null_pointer_checks } } } } */
 /* { dg-final { scan-tree-dump-not "b_. =" "dce1" { target { ! avr-*-* } } } } */
 /* { dg-final { scan-tree-dump "b_. =" "dce1" { target { avr-*-* } } } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "dce1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr21090.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr21090.c
@@ -20,4 +20,3 @@ foo (int a)
 }
 
 /* { dg-final { scan-tree-dump-times "Folding predicate.*to 1" 1 "vrp1" { target { ! keeps_null_pointer_checks } } } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr21171.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr21171.c
@@ -26,4 +26,3 @@ int main()
 }
 
 /* { dg-final { scan-tree-dump-times "SVR" 1 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr21294.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr21294.c
@@ -20,4 +20,3 @@ foo (struct f *p)
 }
 
 /* { dg-final { scan-tree-dump-times "Folding predicate" 1 "vrp1"} } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr21417.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr21417.c
@@ -50,5 +50,4 @@ L23:
    execute the if (expr->common.code != 142) test once per loop
    iteration.  */
 /* { dg-final { scan-tree-dump-times "Threaded jump" 1 "dom2" } } */
-/* { dg-final { cleanup-tree-dump "dom2" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr21458.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr21458.c
@@ -17,4 +17,3 @@ foo (int a)
 }
 
 /* { dg-final { scan-tree-dump-times "Folding predicate.*to 1" 1 "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr21463.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr21463.c
@@ -17,4 +17,3 @@ int g(int i, int c, struct f *ff, int g)
 }
 
 /* { dg-final { scan-tree-dump-times "Inserting PHI for result of load" 1 "phiprop" } } */
-/* { dg-final { cleanup-tree-dump "phiprop" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr21559.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr21559.c
@@ -41,5 +41,4 @@ void foo (void)
    entering while loop and thread over it.  */
 /* { dg-final { scan-tree-dump-times "Threaded jump" 3 "vrp1" } } */
 
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr21563.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr21563.c
@@ -14,4 +14,3 @@ foo (int a)
 }
 
 /* { dg-final { scan-tree-dump-times "Folding predicate" 1 "vrp1"} } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr21574.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr21574.c
@@ -10,4 +10,3 @@ foo (int *p)
 
 /* The store to *p should be propagated to the load statement.  */
 /* { dg-final { scan-tree-dump "Replaced \\\*p_.\\\(D\\\) with 0" "fre1" } } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr21582.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr21582.c
@@ -28,4 +28,3 @@ main()
 }
 
 /* { dg-final { scan-tree-dump-times "Folding predicate p_.*" 0 "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr21658.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr21658.c
@@ -18,4 +18,3 @@ f (void)
 }
 
 /* { dg-final { scan-tree-dump-times "Folded into: if " 1 "ccp1"} } */
-/* { dg-final { cleanup-tree-dump "ccp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr21829.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr21829.c
@@ -19,4 +19,3 @@ int test(int v)
 /* This should be unrolled and optimized into conditional set of return value "v < 0".  */
 
 /* { dg-final { scan-tree-dump-not "if \\(" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr21959.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr21959.c
@@ -17,4 +17,3 @@ void f(void)
 }
 
 /* { dg-final { scan-tree-dump-times "Folding predicate " 0 "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr21985.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr21985.c
@@ -31,4 +31,3 @@ main (void)
 /* Two of the calls to foo should be folded to just foo(constant).  */
 
 /* { dg-final { scan-tree-dump-times "foo \\(\[0-9\]*\\)" 2 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr22026.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr22026.c
@@ -46,4 +46,3 @@ mult (unsigned x, unsigned y)
 
 /* None of the predicates can be folded in these functions.  */
 /* { dg-final { scan-tree-dump-times "Folding predicate" 0 "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr22051-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr22051-1.c
@@ -18,6 +18,5 @@ foo()
    are complete so that function pointer canonicalization works on those
    targets which require it.  */
 /* { dg-final { scan-tree-dump-times "= \\(void \\(\\*<.*>\\) \\(void\\)\\) p_" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr22051-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr22051-2.c
@@ -21,5 +21,4 @@ foo()
    so that we do not try to canonicalize a function pointer for the
    comparison when no such canonicalization is wanted.  */
 /* { dg-final { scan-tree-dump-times "r_. = \\(int\\) q" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr22117.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr22117.c
@@ -22,4 +22,3 @@ foo (int *p, int q)
 }
 
 /* { dg-final { scan-tree-dump-times "Folding predicate r_.* != 0B to 0" 1 "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr22321.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr22321.c
@@ -16,5 +16,4 @@ int main ()
 }
 
 /* { dg-final { scan-tree-dump-times "return 0" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr23086.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr23086.c
@@ -32,4 +32,3 @@ int main(void)
 }
 
 /* { dg-final { scan-tree-dump-not "link_error" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr23109.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr23109.c
@@ -31,6 +31,4 @@ int main()
    this is not wrongly optimized.  */
 /* { dg-final { scan-tree-dump-not "reciptmp" "lim1" } } */
 /* { dg-final { scan-tree-dump-not "reciptmp" "recip" } } */
-/* { dg-final { cleanup-tree-dump "recip" } } */
-/* { dg-final { cleanup-tree-dump "lim1" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr23294.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr23294.c
@@ -34,4 +34,3 @@ int f6(int a, int b)
 /* { dg-final { scan-tree-dump-times "a_..D. \\\* 5" 3 "optimized" } } */
 /* { dg-final { scan-tree-dump-times " \\\* 2" 3 "optimized" } } */
 /* { dg-final { scan-tree-dump-not "\\\* 6" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr23401.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr23401.c
@@ -21,4 +21,3 @@ int ffff(int i)
 
 /* { dg-final { scan-tree-dump-times "int" 5 "gimple" } } */
 /* { dg-final { scan-tree-dump-times "int D\\\." 1 "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr23455.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr23455.c
@@ -27,4 +27,3 @@ bi_windup(unsigned int *outbuf, unsigned int bi_buf)
    one add involving outcnt and outbuf.  */
 /* { dg-final { scan-tree-dump-times "Eliminated: 3" 1 "pre" {target { ! avr-*-* } } } } */
 /* { dg-final { scan-tree-dump-times "Eliminated: 4" 1 "pre" {target {   avr-*-* } } } } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr23744.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr23744.c
@@ -18,4 +18,3 @@ int g (int i, int j)
 }
 
 /* { dg-final { scan-tree-dump-times "Folding predicate.*to 1" 1 "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr23777.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr23777.c
@@ -16,4 +16,3 @@ void g (char **o)
     multilib_exclusions_raw.  */
 
 /* { dg-final { scan-tree-dump-not "multilib_exclusions_raw" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr23848-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr23848-1.c
@@ -29,4 +29,3 @@ void foo2 (int size)
 
 /* { dg-final { scan-tree-dump-not "__builtin_stack_save" "optimized"} } */
 /* { dg-final { scan-tree-dump-not "__builtin_stack_restore" "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr23848-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr23848-2.c
@@ -22,4 +22,3 @@ void foo (int size)
 
 /* { dg-final { scan-tree-dump-times "__builtin_stack_save" 1 "optimized"} } */
 /* { dg-final { scan-tree-dump-times "__builtin_stack_restore" 1 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr23848-3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr23848-3.c
@@ -25,4 +25,3 @@ void foo (int size)
 
 /* { dg-final { scan-tree-dump-times "__builtin_stack_save" 1 "optimized"} } */
 /* { dg-final { scan-tree-dump-times "__builtin_stack_restore" 1 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr23848-4.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr23848-4.c
@@ -22,4 +22,3 @@ void foo (int size)
 
 /* { dg-final { scan-tree-dump-times "__builtin_stack_save" 1 "optimized"} } */
 /* { dg-final { scan-tree-dump-times "__builtin_stack_restore" 1 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr24117.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr24117.c
@@ -23,4 +23,3 @@ void foo(void)
     link_error ();
 }
 /* { dg-final { scan-tree-dump-times "link_error" 1 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr24287.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr24287.c
@@ -26,4 +26,3 @@ int g(void)
 }
 /* We are allowed to optimize the first two link_error calls.  */
 /* { dg-final { scan-tree-dump-times "link_error" 2 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr24689.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr24689.c
@@ -21,4 +21,3 @@ foo (void)
 }
 
 /* { dg-final { scan-tree-dump "return 0;" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr24990-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr24990-1.c
@@ -17,5 +17,4 @@ int f1(int x)
 /* { dg-final { scan-tree-dump-times "== 0" 0 "optimized"} } */
 /* { dg-final { scan-tree-dump-times "== -1" 1 "optimized"} } */
 
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr25382.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr25382.c
@@ -16,4 +16,3 @@ foo (int a)
 }
 
 /* { dg-final { scan-tree-dump-times "Folding predicate b_.* > 300 to 0" 1 "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr25485.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr25485.c
@@ -14,4 +14,3 @@ foo (int a, int b)
 }
 
 /* { dg-final { scan-tree-dump-times "if" 1 "vrp1"} } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr25501.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr25501.c
@@ -33,4 +33,3 @@ foo (int a)
 }
 
 /* { dg-final { scan-tree-dump-times "Removing basic block" 0 "mergephi1"} } */
-/* { dg-final { cleanup-tree-dump "mergephi1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr26421.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr26421.c
@@ -19,4 +19,3 @@ int foo(void)
 /* Verify the call clobbers all of a.  */
 
 /* { dg-final { scan-tree-dump-not "return 1;" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr26899.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr26899.c
@@ -6,5 +6,4 @@ int foo (int i, int j)
 }
 
 /* { dg-final { scan-tree-dump "j >= i" "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr27236.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr27236.c
@@ -17,4 +17,3 @@ unsigned int foo(volatile int *mem)
 }
 
 /* { dg-final { scan-tree-dump-times "foo_read" 5 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr27498.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr27498.c
@@ -14,4 +14,3 @@ void zconfdump(void)
 }
 
 /* { dg-final { scan-tree-dump-not "goto" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr27781.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr27781.c
@@ -14,4 +14,3 @@ int main()
 }
 
 /* { dg-final { scan-tree-dump "func \\(\\);" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr27810.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr27810.c
@@ -15,4 +15,3 @@ int qqq (int a)
 
 /* { dg-final { scan-tree-dump-times "int" 3 "gimple" } } */
 /* { dg-final { scan-tree-dump-times "int D\\\." 1 "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr30375.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr30375.c
@@ -23,4 +23,3 @@ void test_signed_msg_encoding(void)
 }
 
 /* { dg-final { scan-tree-dump-times "signInfo = {}" 1 "dse1" } } */
-/* { dg-final { cleanup-tree-dump "dse*" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr30978.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr30978.c
@@ -14,4 +14,3 @@ int foo(int a)
 /* One comparison and one extension to int.  */
 /* { dg-final { scan-tree-dump " = a_..D. > 0;" "optimized" } } */
 /* { dg-final { scan-tree-dump "e_. = \\\(int\\\)" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr31261.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr31261.c
@@ -38,4 +38,3 @@ f5 (int e)
 /* { dg-final { scan-tree-dump-times "return \\(int\\) \\(12 - \\(unsigned int\\) d\\) \& 7;" 1 "original" { target { ! int16 } } } } */
 /* { dg-final { scan-tree-dump-times "return \\(int\\) \\(12 - \\(unsigned short\\) d\\) \& 7;" 1 "original" { target { int16 } } } } */
 /* { dg-final { scan-tree-dump-times "return 12 - \\(e \& 7\\) \& 15;" 1 "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr31521.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr31521.c
@@ -17,4 +17,3 @@ int foo(int x) {
 }
 
 /* { dg-final { scan-tree-dump-times " = i_.* >> 2" 1 "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr32044.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr32044.c
@@ -51,4 +51,3 @@ int baz (int n)
 /* { dg-final { scan-tree-dump-times "/" 0 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "%" 0 "optimized" } } */
 
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr32821.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr32821.c
@@ -12,4 +12,3 @@ main1 (int *arr, int n, int a, int b)
     }
 }
 
-/* { dg-final { cleanup-tree-dump "ifcvt" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr32901.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr32901.c
@@ -27,4 +27,3 @@ void setup_foo(void)
 /* { dg-final { scan-tree-dump-times "thefoo.* = 1" 1 "gimple"} } */
 /* { dg-final { scan-tree-dump-times "thefoo.* = 5" 1 "gimple"} } */
 /* { dg-final { scan-tree-dump-times "theotherfoo = volinit" 1 "gimple"} } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr32964.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr32964.c
@@ -23,4 +23,3 @@ float t(float a)
 }
 
 /* { dg-final { scan-tree-dump-times "union" 0 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr33172.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr33172.c
@@ -39,4 +39,3 @@ void func(void)
 }
 
 /* { dg-final { scan-tree-dump-not "call_func" "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr33723.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr33723.c
@@ -71,4 +71,3 @@ baz3 (void)
 }
 
 /* { dg-final { scan-tree-dump-not "t = D" "gimple"} } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr34146-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr34146-2.c
@@ -52,4 +52,3 @@ baz (void)
 /* { dg-final { scan-tree-dump-not "t = D" "gimple"} } */
 /* { dg-final { scan-tree-dump-not "t\.c\.h\[12\] = D" "gimple"} } */
 /* { dg-final { scan-tree-dump-not "\.g\[12\] = D" "gimple"} } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr34146.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr34146.c
@@ -52,4 +52,3 @@ baz (void)
 /* { dg-final { scan-tree-dump-not "t = D" "gimple"} } */
 /* { dg-final { scan-tree-dump-not "t\.c\.h\[12\] = D" "gimple"} } */
 /* { dg-final { scan-tree-dump-not "\.g\[12\] = D" "gimple"} } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr35286.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr35286.c
@@ -20,4 +20,3 @@ int foo(int a, int b)
 /* We will eliminate the g1.a from the return statement as fully redundant,
    and remove one calculation of a + b. */
 /* { dg-final { scan-tree-dump-times "Eliminated: 2" 1 "pre"} } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr35287.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr35287.c
@@ -12,4 +12,3 @@ int foo(int p)
 
 /* We will eliminate one load of gp and one indirect load of *gp. */
 /* { dg-final { scan-tree-dump-times "Eliminated: 2" 1 "pre"} } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr36326.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr36326.c
@@ -10,4 +10,3 @@ int foo (union X *p)
 }
 
 /* { dg-final { scan-tree-dump-not "x.0" "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr36881.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr36881.c
@@ -23,4 +23,3 @@ const char *foo (int i)
 
 /* { dg-final { scan-assembler-not "CSWTCH" } } */
 /* { dg-final { scan-tree-dump "need runtime relocations" "switchconv" } } */
-/* { dg-final { cleanup-tree-dump "switchconv" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr37508.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr37508.c
@@ -45,4 +45,3 @@ int test4 (struct foo2 *x)
 }
 
 /* { dg-final { scan-tree-dump-times "Folding" 3 "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr38533.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr38533.c
@@ -27,4 +27,3 @@ main (void)
    be exactly 2 (first) __asm__ stmts with no intervening stmts,
    all others should have some bitwise or in between.  */
 /* { dg-final { scan-tree-dump-times "__asm__\[^;\n]*;\n *__asm__" 1 "reassoc1"} } */
-/* { dg-final { cleanup-tree-dump "reassoc1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr38699.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr38699.c
@@ -78,4 +78,3 @@ void makeUseOfTimerWait( unsigned char val ) {
 /* We should not inline the delay loops.  */
 /* { dg-final { scan-tree-dump "delay_wait_us" "optimized"} } */
 /* { dg-final { scan-tree-dump "delay_wait_us_ms" "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr38895.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr38895.c
@@ -21,4 +21,3 @@ int foo(struct C *c, struct B *b)
 }
 
 /* { dg-final { scan-tree-dump "return 1;" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr41469-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr41469-1.c
@@ -13,4 +13,3 @@ bf (void)
 
 /* { dg-final { scan-tree-dump-not "__builtin_stack_save" "optimized"} } */
 /* { dg-final { scan-tree-dump-not "__builtin_stack_restore" "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr42585.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr42585.c
@@ -37,4 +37,3 @@ Cyc_string_ungetc (int ignore, struct _fat_ptr *sptr)
    not take place when using small values for MOVE_RATIO.  */
 /* { dg-final { scan-tree-dump-times "struct _fat_ptr _ans" 0 "optimized" { target { ! "aarch64*-*-* alpha*-*-* arm*-*-* avr-*-* nds32*-*-* powerpc*-*-* s390*-*-* sh*-*-*" } } } } */
 /* { dg-final { scan-tree-dump-times "struct _fat_ptr _T2" 0 "optimized" { target { ! "aarch64*-*-* alpha*-*-* arm*-*-* avr-*-* nds32*-*-* powerpc*-*-* s390*-*-* sh*-*-*" } } } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr42893.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr42893.c
@@ -26,5 +26,4 @@ tui_registers_changed_hook (void)
 /* No references to tui_refreshing_registers should remain.  */
 /* { dg-final { scan-tree-dump-not "tui_refreshing_registers" "optimized"} } */
 
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr43378.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr43378.c
@@ -14,4 +14,3 @@ void foo (int left, int rite, int element)
 
 /* { dg-final { scan-tree-dump-times "rite_\[0-9\]* = rite_\[0-9\]* - element" 1 "ivopts"} } */
 /* { dg-final { scan-tree-dump-times "left_\[0-9\]* = left_\[0-9\]* \\+ element|left_\[0-9\]* = element_\[0-9\]*\\(D\\) \\+ left" 1 "ivopts"} } */
-/* { dg-final { cleanup-tree-dump "ivopts" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr43491.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr43491.c
@@ -39,4 +39,3 @@ long foo(long data, long v)
    a single assignment.  */
 /* { dg-final { scan-tree-dump-times "Eliminated: 2" 1 "pre" { target { arm*-*-* i?86-*-* mips*-*-* x86_64-*-* } } } } */
 /* { dg-final { scan-tree-dump-times "Eliminated: 3" 1 "pre" { target { ! { arm*-*-* i?86-*-* mips*-*-* x86_64-*-* } } } } } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr44258.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr44258.c
@@ -42,4 +42,3 @@ int foo (int b)
 /* Epiphany has struct alignment/padding that avoids the overlap of
    str.b1 and val.b2.  */
 /* { dg-final { scan-tree-dump-times "Created a replacement" 0 "esra" { target { ! "epiphany-*-*" } } } } */
-/* { dg-final { cleanup-tree-dump "esra" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr44423.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr44423.c
@@ -44,4 +44,3 @@ int main()
   }
 
 /* { dg-final { scan-tree-dump-times "Created a replacement" 0 "esra"} } */
-/* { dg-final { cleanup-tree-dump "esra" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr45144.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr45144.c
@@ -44,4 +44,3 @@ bar (unsigned orig, unsigned *new)
 }
 
 /* { dg-final { scan-tree-dump-not "unnamed-unsigned:19" "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr45427.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr45427.c
@@ -26,4 +26,3 @@ int main()
 }
 
 /* { dg-final { scan-tree-dump-times "bounded by 0x0\[^0-9a-f\]" 0 "cunrolli"} } */
-/* { dg-final { cleanup-tree-dump "cunrolli" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr47286.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr47286.c
@@ -17,4 +17,3 @@ void testcase(void)
    to globals and thus the store not optimized away.  */
 
 /* { dg-final { scan-tree-dump "->preempt_count =" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr47392.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr47392.c
@@ -39,4 +39,3 @@ main ()
 }
 
 /* { dg-final { scan-tree-dump "Eliminated: 1" "pre" } } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr47477.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr47477.c
@@ -17,6 +17,5 @@ toto_t add (toto_t a, toto_t b) {
 /* { dg-final { scan-tree-dump-times "= \\(int\\)" 1 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "= \\(unsigned int\\)" 2 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "= \\(struct toto_s \\*\\)" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr49039.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr49039.c
@@ -28,4 +28,3 @@ foo (unsigned int x, unsigned int y)
 /* { dg-final { scan-tree-dump "Folding predicate minv_\[0-9\]* == 6 to 0" "vrp1" } } */
 /* { dg-final { scan-tree-dump "Folding predicate maxv_\[0-9\]* == 5 to 0" "vrp1" } } */
 /* { dg-final { scan-tree-dump "Folding predicate maxv_\[0-9\]* == 6 to 0" "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr49642-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr49642-1.c
@@ -48,4 +48,3 @@ int y(struct ehca_shca *shca)
 }
 
 /* { dg-final { scan-tree-dump-times "____ilog2_NaN" 0 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr49642-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr49642-2.c
@@ -50,4 +50,3 @@ int y(struct ehca_shca *shca)
 }
 
 /* { dg-final { scan-tree-dump-times "____ilog2_NaN" 0 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr49671-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr49671-1.c
@@ -12,6 +12,5 @@ void f(void)
 }
 
 /* { dg-final { scan-tree-dump "\{v\}" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr49671-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr49671-2.c
@@ -12,6 +12,5 @@ void f(void)
 }
 
 /* { dg-final { scan-tree-dump "\{v\}" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr52631.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr52631.c
@@ -14,5 +14,4 @@ unsigned f(unsigned a)
 /* We want to verify that we replace the b & 1 with b.  */
 /* { dg-final { scan-tree-dump-times "Replaced b_\[0-9\]+ & 1 with b_\[0-9\]+ in" 1 "fre1"} } */
  
-/* { dg-final { cleanup-tree-dump "fre1" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr54245.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr54245.c
@@ -46,4 +46,3 @@ int main(void)
    take place in a smaller type than originally.  This test may be deleted
    in future when this case is handled more precisely.  */
 /* { dg-final { scan-tree-dump-times "Inserting initializer" 0 "slsr" { target { ! int16 } } } } */
-/* { dg-final { cleanup-tree-dump "slsr" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr55579.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr55579.c
@@ -12,4 +12,3 @@ foo (int x)
 }
 
 /* { dg-final { scan-tree-dump "Created a debug-only replacement for s" "esra" } } */
-/* { dg-final { cleanup-tree-dump "esra" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr57361.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr57361.c
@@ -7,4 +7,3 @@ void f (struct A *a) {
 }
 
 /* { dg-final { scan-tree-dump "Deleted dead store" "dse1"} } */
-/* { dg-final { cleanup-tree-dump "dse1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr58480.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr58480.c
@@ -16,4 +16,3 @@ void g2 (void*p, void*q){
 }
 
 /* { dg-final { scan-tree-dump-times "Folding predicate\[^\\n\]*to 0" 2 "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr58958.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr58958.c
@@ -9,4 +9,3 @@ int f(int n){
 }
 
 /* { dg-final { scan-tree-dump " == 9" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr59597.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr59597.c
@@ -55,5 +55,4 @@ main (int argc, char argv[])
 }
 
 /* { dg-final { scan-tree-dump "Cancelling" "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr61144.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr61144.c
@@ -6,4 +6,3 @@ static int dummy = 0;
 extern int foo __attribute__((__weak__, __alias__("dummy")));
 int bar() { if (foo) return 1; return 0; }
 /* { dg-final { scan-tree-dump-not "return 0" "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr61607.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr61607.c
@@ -25,5 +25,4 @@ void f2(int dst[3], int R)
    the second conditional after the loop.  */
 /* { dg-final { scan-tree-dump-times "if" 2 "dom1"} } */
 
-/* { dg-final { cleanup-tree-dump "dom1" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr61743-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr61743-1.c
@@ -50,4 +50,3 @@ int foo1 (e_u8 a[4][N], int b1, int b2, e_u8 b[M+1][4][N])
 
 /* { dg-final { scan-tree-dump-times "loop with 4 iterations completely unrolled" 2 "cunroll" } } */
 /* { dg-final { scan-tree-dump-times "loop with 8 iterations completely unrolled" 2 "cunroll" } } */
-/* { dg-final { cleanup-tree-dump "cunroll" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr61743-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr61743-2.c
@@ -50,4 +50,3 @@ int foo1 (e_u8 a[4][N], int b1, int b2, e_u8 b[M+1][4][N])
 
 /* { dg-final { scan-tree-dump-times "loop with 4 iterations completely unrolled" 2 "cunroll" } } */
 /* { dg-final { scan-tree-dump-times "loop with 8 iterations completely unrolled" 2 "cunroll" } } */
-/* { dg-final { cleanup-tree-dump "cunroll" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr62112-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr62112-1.c
@@ -20,4 +20,3 @@ char*i(){
 }
 
 /* { dg-final { scan-tree-dump-times "Deleted dead call" 4 "dse1" } } */
-/* { dg-final { cleanup-tree-dump "dse1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr62112-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr62112-2.c
@@ -14,4 +14,3 @@ void h(){
 }
 
 /* { dg-final { scan-tree-dump-not "Deleted dead" "dse1" } } */
-/* { dg-final { cleanup-tree-dump "dse1" } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr64130.c
@@ -0,0 +1,18 @@
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-vrp1" } */
+
+int funsigned (unsigned a)
+{
+  return 0x1ffffffffL / a == 0;
+}
+
+int funsigned2 (unsigned a)
+{
+  if (a < 1) return 1;
+  return (-1 * 0x1ffffffffL) / a == 0;
+}
+
+/* { dg-final { scan-tree-dump ": \\\[2, 8589934591\\\]" "vrp1" } } */
+/* { dg-final { scan-tree-dump ": \\\[-8589934591, -2\\\]" "vrp1" } } */
+
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr64183.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr64183.c
@@ -18,4 +18,3 @@ test ()
 }
 
 /* { dg-final { scan-tree-dump "Loop 2 iterates at most 4 times" "cunroll"} } */
-/* { dg-final { cleanup-tree-dump "cunroll" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr64705.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr64705.c
@@ -24,4 +24,3 @@ int foo(char *flags, long len, long i, long steps)
 /* Don't expand iv {base+step, step}_loop into {base+x+y, step}_loop
    even if "step == x + y".  */
 /* { dg-final { scan-tree-dump "base step_\[0-9\]* \\+ iter|base iter_\[0-9\]* \\+ step" "ivopts"} } */
-/* { dg-final { cleanup-tree-dump "ivopts" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr64801.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr64801.c
@@ -18,4 +18,3 @@ psmouse_extensions (void)
   a = b ();
 }
 /* { dg-final { scan-tree-dump-not "fsp_detect" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr65136.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr65136.c
@@ -13,4 +13,3 @@ int foo(unsigned int cc )
 }
 
 /* { dg-final { scan-rtl-dump-not "_\[0-9\]* = 1;" "expand" } } */
-/* { dg-final { cleanup-rtl-dump "expand" } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr65447.c
@@ -0,0 +1,53 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-ivopts-details" } */
+
+void foo (double *p)
+{
+  int i;
+  for (i = -20000; i < 200000; i+= 40)
+    {
+      p[i+0] = 1.0;
+      p[i+1] = 1.0;
+      p[i+2] = 1.0;
+      p[i+3] = 1.0;
+      p[i+4] = 1.0;
+      p[i+5] = 1.0;
+      p[i+6] = 1.0;
+      p[i+7] = 1.0;
+      p[i+8] = 1.0;
+      p[i+9] = 1.0;
+      p[i+10] = 1.0;
+      p[i+11] = 1.0;
+      p[i+12] = 1.0;
+      p[i+13] = 1.0;
+      p[i+14] = 1.0;
+      p[i+15] = 1.0;
+      p[i+16] = 1.0;
+      p[i+17] = 1.0;
+      p[i+18] = 1.0;
+      p[i+19] = 1.0;
+      p[i+20] = 1.0;
+      p[i+21] = 1.0;
+      p[i+22] = 1.0;
+      p[i+23] = 1.0;
+      p[i+24] = 1.0;
+      p[i+25] = 1.0;
+      p[i+26] = 1.0;
+      p[i+27] = 1.0;
+      p[i+28] = 1.0;
+      p[i+29] = 1.0;
+      p[i+30] = 1.0;
+      p[i+31] = 1.0;
+      p[i+32] = 1.0;
+      p[i+33] = 1.0;
+      p[i+34] = 1.0;
+      p[i+35] = 1.0;
+      p[i+36] = 1.0;
+      p[i+37] = 1.0;
+      p[i+38] = 1.0;
+      p[i+39] = 1.0;
+    }
+}
+
+/* We should groups address type IV uses.  */
+/* { dg-final { scan-tree-dump-not "\\nuse 5\\n" "ivopts" } }  */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr66449.c
@@ -0,0 +1,18 @@
+/* { dg-do compile } */
+/* { dg-options "-O3" } */
+
+void *fn1(void *p1, void *p2, long p3)
+{
+  long a = (long)p1, b = (long)p2, c = p3;
+
+  while (c)
+    {
+      int d = ((int *)b)[0];
+
+      c--;
+      ((char *)a)[0] = d;
+      a++;
+    }
+  return 0;
+}
+
--- /dev/null
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr66726-2.c
@@ -0,0 +1,19 @@
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-phiopt1-details" } */
+
+extern void bar (char, char);
+int
+foo (char b)
+{
+  char a;
+  a = b;
+  b = 'b';
+  bar (a, b);
+  b = a;
+  if (b == 0)
+    a++;
+  return a + b;
+}
+
+/* { dg-final { scan-tree-dump-times "factor conversion out" 0 "phiopt1" } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr66726.c
@@ -0,0 +1,15 @@
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-phiopt1-details" } */
+
+extern unsigned short mode_size[];
+
+int
+oof (int mode)
+{
+  return (64 < mode_size[mode] ? 64 : mode_size[mode]);
+}
+
+/* { dg-final { scan-tree-dump-times "factor conversion out" 1 "phiopt1" } } */
+/* { dg-final { scan-tree-dump-times "MIN_EXPR" 1 "phiopt1" } } */
+
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/predcom-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/predcom-1.c
@@ -48,4 +48,3 @@ int main(void)
 /* Also check that we undid the transformation previously made by PRE.  */
 /* { dg-final { scan-tree-dump-times "looparound ref" 1 "pcom"} } */
 
-/* { dg-final { cleanup-tree-dump "pcom" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/predcom-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/predcom-2.c
@@ -44,4 +44,3 @@ int main(void)
 
 /* Verify that both loops were transformed and unrolled.  */
 /* { dg-final { scan-tree-dump-times "Unrolling 2 times." 2 "pcom"} } */
-/* { dg-final { cleanup-tree-dump "pcom" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/predcom-3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/predcom-3.c
@@ -13,4 +13,3 @@ void test(void)
 
 /* Verify that we used 3 temporary variables for the loop.  */
 /* { dg-final { scan-tree-dump-times "Unrolling 3 times." 1 "pcom"} } */
-/* { dg-final { cleanup-tree-dump "pcom" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/predcom-4.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/predcom-4.c
@@ -27,4 +27,3 @@ int main(void)
 
 /* { dg-final { scan-tree-dump-times "Combination" 1 "pcom"} } */
 /* { dg-final { scan-tree-dump-times "Unrolling 3 times." 1 "pcom"} } */
-/* { dg-final { cleanup-tree-dump "pcom" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/predcom-5.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/predcom-5.c
@@ -27,4 +27,3 @@ int main(void)
 
 /* { dg-final { scan-tree-dump-times "Combination" 2 "pcom"} } */
 /* { dg-final { scan-tree-dump-times "Unrolling 3 times." 1 "pcom"} } */
-/* { dg-final { cleanup-tree-dump "pcom" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/predcom-7.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/predcom-7.c
@@ -15,4 +15,3 @@ main ()
 }
 
 /* { dg-final { scan-tree-dump "Executing predictive commoning" "pcom" } } */
-/* { dg-final { cleanup-tree-dump "pcom" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/prefetch-3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/prefetch-3.c
@@ -19,4 +19,3 @@ double test(void)
 }
 
 /* { dg-final { scan-tree-dump-times "unroll factor 4" 1 "aprefetch" } } */
-/* { dg-final { cleanup-tree-dump "aprefetch" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/prefetch-4.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/prefetch-4.c
@@ -14,4 +14,3 @@ void foo (int n)
 }
 
 /* { dg-final { scan-tree-dump-times "prefetch" 0 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/prefetch-5.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/prefetch-5.c
@@ -56,4 +56,3 @@ int loop5 (int n, struct tail5 *x)
 
 /* { dg-final { scan-tree-dump-times "Issued prefetch" 2 "aprefetch" } } */
 /* { dg-final { scan-tree-dump-times "Not prefetching" 1 "aprefetch" } } */
-/* { dg-final { cleanup-tree-dump "aprefetch" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/prefetch-6.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/prefetch-6.c
@@ -51,4 +51,3 @@ double test(void)
 /* { dg-final { scan-assembler-times "prefetcht" 5 } } */
 /* { dg-final { scan-assembler-times "prefetchnta" 3 } } */
 
-/* { dg-final { cleanup-tree-dump "aprefetch" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/prefetch-7.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/prefetch-7.c
@@ -44,5 +44,3 @@ void test(int *p)
 /* { dg-final { scan-assembler-times "prefetcht" 1 } } */
 /* { dg-final { scan-assembler-times "prefetchnta" 1 } } */
 
-/* { dg-final { cleanup-tree-dump "aprefetch" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/prefetch-8.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/prefetch-8.c
@@ -23,5 +23,3 @@ void test()
 /* { dg-final { scan-assembler "movnti" } } */
 /* { dg-final { scan-assembler-times "mfence" 1 } } */
 
-/* { dg-final { cleanup-tree-dump "aprefetch" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/prefetch-9.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/prefetch-9.c
@@ -27,5 +27,3 @@ void test()
 /* { dg-final { scan-assembler "movnti" } } */
 /* { dg-final { scan-assembler-times "mfence" 1 } } */
 
-/* { dg-final { cleanup-tree-dump "aprefetch" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pta-callused.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pta-callused.c
@@ -23,5 +23,4 @@ int bar (int b)
 }
 
 /* { dg-final { scan-tree-dump "CALLUSED = { ESCAPED NONLOCAL f.* i q }" "alias" } } */
-/* { dg-final { cleanup-tree-dump "alias" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pta-escape-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pta-escape-1.c
@@ -35,4 +35,3 @@ int main()
 
 /* { dg-final { scan-tree-dump "ESCAPED = { NULL ESCAPED NONLOCAL x }" "alias" { target { ! keeps_null_pointer_checks } } } } */
 /* { dg-final { scan-tree-dump "ESCAPED = { ESCAPED NONLOCAL x }" "alias" { target { keeps_null_pointer_checks } } } } */
-/* { dg-final { cleanup-tree-dump "alias" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pta-escape-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pta-escape-2.c
@@ -36,4 +36,3 @@ int main()
 
 /* { dg-final { scan-tree-dump "ESCAPED = { NULL ESCAPED NONLOCAL x }" "alias" { target { ! keeps_null_pointer_checks } } } } */
 /* { dg-final { scan-tree-dump "ESCAPED = { ESCAPED NONLOCAL x }" "alias" { target { keeps_null_pointer_checks } } } } */
-/* { dg-final { cleanup-tree-dump "alias" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pta-escape-3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pta-escape-3.c
@@ -40,4 +40,3 @@ int main()
 
 /* { dg-final { scan-tree-dump "ESCAPED = { NULL ESCAPED NONLOCAL x }" "alias" { target { ! keeps_null_pointer_checks } } } } */
 /* { dg-final { scan-tree-dump "ESCAPED = { ESCAPED NONLOCAL x }" "alias" { target { keeps_null_pointer_checks } } } } */
-/* { dg-final { cleanup-tree-dump "alias" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pta-fp.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pta-fp.c
@@ -23,4 +23,3 @@ double f(double a)
 /* The points-to set of the final function pointer should be "sin cos" */
 
 /* { dg-final { scan-tree-dump-times "{ sin cos }" 1 "alias"} } */
-/* { dg-final { cleanup-tree-dump "alias" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pta-ptrarith-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pta-ptrarith-1.c
@@ -23,4 +23,3 @@ foo(int i, int j, int k, int off)
 }
 
 /* { dg-final { scan-tree-dump "q_. = { k }" "ealias" } } */
-/* { dg-final { cleanup-tree-dump "ealias" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pta-ptrarith-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pta-ptrarith-2.c
@@ -23,4 +23,3 @@ foo(int i, int j, int k, int off)
 }
 
 /* { dg-final { scan-tree-dump "q_. = { i }" "ealias" } } */
-/* { dg-final { cleanup-tree-dump "ealias" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-1.c
@@ -21,4 +21,3 @@ int main(void)
 
 /* { dg-final { scan-tree-dump-times "b.._. \\\+ a.._." 1 "optimized" { xfail *-*-* } } } */
 /* { dg-final { scan-tree-dump-times " \\\+ " 2 "optimized" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-10.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-10.c
@@ -8,4 +8,3 @@ int main(int a, int b, int c, int d)
   return e & f;
 }
 /* { dg-final { scan-tree-dump-times "\\\& " 3 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-11.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-11.c
@@ -8,4 +8,3 @@ int main(int a, int b, int c, int d)
   return e ^ f;
 }
 /* { dg-final { scan-tree-dump-times "= 0" 1 "reassoc1"} } */
-/* { dg-final { cleanup-tree-dump "reassoc1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-12.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-12.c
@@ -8,4 +8,3 @@ int f(int a, int b)
   return d;
 }
 /* { dg-final { scan-tree-dump-times "Equivalence:" 1 "reassoc1"} } */
-/* { dg-final { cleanup-tree-dump "reassoc1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-13.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-13.c
@@ -11,5 +11,3 @@ double foo(double a)
 
 /* { dg-final { scan-tree-dump-not "\\\+ 0.0" "reassoc1" } } */
 /* { dg-final { scan-tree-dump "return a_..D.;" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "reassoc1" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-14.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-14.c
@@ -22,4 +22,3 @@ unsigned int test2 (unsigned int x, unsigned int y, unsigned int z,
 /* There should be one multiplication left in test1 and three in test2.  */
 
 /* { dg-final { scan-tree-dump-times "\\\*" 4 "reassoc1" } } */
-/* { dg-final { cleanup-tree-dump "reassoc1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-15.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-15.c
@@ -18,4 +18,3 @@ unsigned int test3 (unsigned int x, unsigned int y, unsigned int z,
    ???  This pattern is not recognized currently.  */
 
 /* { dg-final { scan-tree-dump-times "\\\*" 4 "reassoc1" } } */
-/* { dg-final { cleanup-tree-dump "reassoc1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-16.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-16.c
@@ -13,4 +13,3 @@ double test1 (double x, double y, double z, double weight)
    be gone.  */
 
 /* { dg-final { scan-tree-dump-times "/" 1 "reassoc1" } } */
-/* { dg-final { cleanup-tree-dump "reassoc1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-17.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-17.c
@@ -13,4 +13,3 @@ double test2 (double x, double y, double ddj, int b)
 }
 
 /* { dg-final { scan-tree-dump-times "/" 1 "reassoc1" } } */
-/* { dg-final { cleanup-tree-dump "reassoc1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-18.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-18.c
@@ -9,4 +9,3 @@ ETree_nFactorEntriesInFront (unsigned int b, unsigned int m)
 }
 
 /* { dg-final { scan-tree-dump-times "\\\*" 2 "reassoc1" } } */
-/* { dg-final { cleanup-tree-dump "reassoc1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-19.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-19.c
@@ -19,4 +19,3 @@ void foo(char* left, char* rite, int element)
 /* { dg-final { scan-tree-dump-times "= \\\(sizetype\\\) element" 1 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "= -" 1 "optimized" } } */
 /* { dg-final { scan-tree-dump-times " \\\+ " 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-2.c
@@ -17,4 +17,3 @@ int b0, b1, b2, b3, b4,e;
 /* We can't reassociate the expressions due to undefined signed overflow.  */
 
 /* { dg-final { scan-tree-dump-times "return 0" 1 "optimized" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-20.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-20.c
@@ -17,4 +17,3 @@ int main(void)
 
 /* { dg-final { scan-tree-dump-times "\[ab\].._. \\\+ \[ab\].._." 1 "optimized" } } */
 /* { dg-final { scan-tree-dump-times " \\\+ " 2 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-21.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-21.c
@@ -16,4 +16,3 @@ unsigned int f (unsigned int a0, unsigned int a1, unsigned int a2,
 }
 
 /* { dg-final { scan-tree-dump-times "return 0" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-22.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-22.c
@@ -10,4 +10,3 @@ unsigned int foo(unsigned int a, unsigned int b, unsigned int c, unsigned int d)
 }
 
 /* { dg-final { scan-tree-dump-times "\\\+ 8" 1 "reassoc1"} } */
-/* { dg-final { cleanup-tree-dump "reassoc1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-23.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-23.c
@@ -14,4 +14,3 @@ foo(unsigned int a, unsigned int b, unsigned int c, unsigned int d,
 }
 
 /* { dg-final { scan-tree-dump-times "= 20" 1 "reassoc1"} } */
-/* { dg-final { cleanup-tree-dump "reassoc1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-24.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-24.c
@@ -22,4 +22,3 @@ foo (void)
 /* Verify there are two pairs of __asm__ statements with no
    intervening stmts.  */
 /* { dg-final { scan-tree-dump-times "__asm__\[^;\n]*;\n *__asm__" 2 "reassoc1"} } */
-/* { dg-final { cleanup-tree-dump "reassoc1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-25.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-25.c
@@ -16,4 +16,3 @@ foo (int a, int b, int c, int d)
 
 /* Verify reassociation width was chosen to be 2.  */
 /* { dg-final { scan-tree-dump-times "Width = 2" 1 "reassoc1"} } */
-/* { dg-final { cleanup-tree-dump "reassoc1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-27.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-27.c
@@ -8,4 +8,3 @@ double baz (double foo, double bar)
 
 /* We should re-associate this as (foo * bar)**3.  */
 /* { dg-final { scan-tree-dump-times " \\\* " 3 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-32.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-32.c
@@ -26,4 +26,3 @@ int main ()
 }
 
 /* { dg-final { scan-tree-dump-times "Optimizing range tests .* 26" 1 "reassoc1"} }*/
-/* { dg-final { cleanup-tree-dump "reassoc1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-33.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-33.c
@@ -24,4 +24,3 @@ main ()
   return 0;
 }
 /* { dg-final { scan-tree-dump-times "Optimizing range tests" 3 "reassoc1"} }*/
-/* { dg-final { cleanup-tree-dump "reassoc1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-34.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-34.c
@@ -21,4 +21,3 @@ int main ()
   return 0;
 }
 /* { dg-final { scan-tree-dump-times "Optimizing range tests" 1 "reassoc1"} }*/
-/* { dg-final { cleanup-tree-dump "reassoc1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-35.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-35.c
@@ -23,4 +23,3 @@ main ()
 }
 
 /* { dg-final { scan-tree-dump-times "Optimizing range tests" 1 "reassoc1"} }*/
-/* { dg-final { cleanup-tree-dump "reassoc1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-36.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-36.c
@@ -22,4 +22,3 @@ int main ()
 }
 
 /* { dg-final { scan-tree-dump-times "Optimizing range tests" 1 "reassoc1"} }*/
-/* { dg-final { cleanup-tree-dump "reassoc1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-37.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-37.c
@@ -14,4 +14,3 @@ foo (int x)
 /* Check if the tests have been folded into a bit test.  */
 /* { dg-final { scan-tree-dump "(8784908|0x0*860c0c)" "optimized" { target i?86-*-* x86_64-*-* } } } */
 /* { dg-final { scan-tree-dump "(<<|>>)" "optimized" { target i?86-*-* x86_64-*-* } } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-38.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-38.c
@@ -15,4 +15,3 @@ foo (int x)
 /* Check if the tests have been folded into a bit test.  */
 /* { dg-final { scan-tree-dump "(614180323407|0x0*8f0000004f)" "optimized" { target { { i?86-*-* x86_64-*-* } && { ! { ia32 } } } } } } */
 /* { dg-final { scan-tree-dump "(<<|>>)" "optimized" { target { { i?86-*-* x86_64-*-* } && { ! { ia32 } } } } } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-4.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-4.c
@@ -15,4 +15,3 @@ int main(void)
 }
 
 /* { dg-final { scan-tree-dump-times "\\\+" 2 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-5.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-5.c
@@ -14,4 +14,3 @@ int main(int argc, int b)
     }
 }
 /* { dg-final { scan-tree-dump-times "a - i" 0 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-6.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-6.c
@@ -12,4 +12,3 @@ int main(int a, int b, int c, int d)
 /* We cannot re-associate the additions due to undefined signed overflow.  */
 
 /* { dg-final { scan-tree-dump-times "\\\+ 8" 1 "reassoc1" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "reassoc1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-7.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-7.c
@@ -13,4 +13,3 @@ foo(unsigned int a, unsigned int b, unsigned int c, unsigned int d,
 }
 
 /* { dg-final { scan-tree-dump-times "\\\+ 15" 1 "reassoc1"} } */
-/* { dg-final { cleanup-tree-dump "reassoc1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-8.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-8.c
@@ -10,4 +10,3 @@ int main(int a, int b, int c, int d, int e, int f, int g, int h)
   return e;
 }
 /* { dg-final { scan-tree-dump-times "= 0" 1 "reassoc1"} } */
-/* { dg-final { cleanup-tree-dump "reassoc1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-9.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-9.c
@@ -15,4 +15,3 @@ int main(int a, int b, int c, int d, int e, int f, int g, int h)
    implementation does not allow easy roll-back without IL changes.  */
 
 /* { dg-final { scan-tree-dump-times "= 20" 1 "reassoc1" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "reassoc1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/recip-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/recip-1.c
@@ -11,4 +11,3 @@ float e(float *x, float *y, float *z)
 
 /* Look for only one division.  */
 /* { dg-final { scan-tree-dump-times "= .* /" 1 "recip" } } */
-/* { dg-final { cleanup-tree-dump "recip" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/recip-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/recip-2.c
@@ -32,4 +32,3 @@ void e(float a, float b, float c, float d, float e, float f)
 
 /* { dg-final { scan-tree-dump-times " / " 2 "recip" } } */
 /* { dg-final { scan-tree-dump-times " \\* " 5 "recip" } } */
-/* { dg-final { cleanup-tree-dump "recip" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/recip-3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/recip-3.c
@@ -24,4 +24,3 @@ float h ()
 }
 
 /* { dg-final { scan-tree-dump-times " / " 1 "recip" } } */
-/* { dg-final { cleanup-tree-dump "recip" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/recip-4.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/recip-4.c
@@ -42,4 +42,3 @@ float g ()
 }
 
 /* { dg-final { scan-tree-dump-not "reciptmp" "recip" } } */
-/* { dg-final { cleanup-tree-dump "recip" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/recip-5.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/recip-5.c
@@ -27,6 +27,4 @@ double f1(double y, double z, double w, double j, double k)
 
 /* { dg-final { scan-tree-dump-times " / " 3 "recip" } } */
 /* { dg-final { scan-tree-dump-times " / " 2 "optimized" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "recip" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/recip-6.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/recip-6.c
@@ -26,5 +26,4 @@ void f1(double y, double z, double w)
 }
 
 /* { dg-final { scan-tree-dump-times " / " 1 "recip" } } */
-/* { dg-final { cleanup-tree-dump "recip" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/recip-7.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/recip-7.c
@@ -27,5 +27,4 @@ void f(int x, double z, double w)
 }
 
 /* { dg-final { scan-tree-dump-times " / " 1 "recip" } } */
-/* { dg-final { cleanup-tree-dump "recip" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/restrict-3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/restrict-3.c
@@ -15,4 +15,3 @@ void f(int * __restrict__ r,
 /* We should apply store motion to the store to *r.  */
 
 /* { dg-final { scan-tree-dump "Executing store motion of \\\*r" "lim1" } } */
-/* { dg-final { cleanup-tree-dump "lim1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/restrict-4.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/restrict-4.c
@@ -23,4 +23,3 @@ bar (int *x, int y)
 }
 
 /* { dg-final { scan-tree-dump-times "return 1;" 2 "optimized" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/restrict-5.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/restrict-5.c
@@ -21,4 +21,3 @@ void g(int *r, int a[16][16], int b[16][16], int i, int j)
 /* We should apply store motion to the store to *r.  */
 
 /* { dg-final { scan-tree-dump "Executing store motion of \\\*r" "lim1" } } */
-/* { dg-final { cleanup-tree-dump "lim1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/sccp-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/sccp-1.c
@@ -12,4 +12,3 @@ int main(int argc, char* argv[])
 /* There should be no loop left.  */
 
 /* { dg-final { scan-tree-dump-times "goto" 0 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/scev-10.c
@@ -0,0 +1,23 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-ivopts-details" } */
+
+int *a;
+
+int
+foo (signed char s, signed char l)
+{
+  signed char i;
+  int sum = 0;
+
+  for (i = s; i < l; i++)
+    {
+      sum += a[i];
+    }
+
+  return sum;
+}
+
+/* Address of array reference is scev.  */
+/* { dg-final { scan-tree-dump-times "use \[0-9\]\n  address" 1 "ivopts" } } */
+
+
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/scev-3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/scev-3.c
@@ -15,5 +15,4 @@ f(int k)
         }
 }
 
-/* { dg-final { scan-tree-dump-times "&a" 1 "optimized" { xfail { lp64 || llp64 } } } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
+/* { dg-final { scan-tree-dump-times "&a" 1 "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/scev-4.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/scev-4.c
@@ -20,5 +20,4 @@ f(int k)
         }
 }
 
-/* { dg-final { scan-tree-dump-times "&a" 1 "optimized" { xfail { lp64 || llp64 } } } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
+/* { dg-final { scan-tree-dump-times "&a" 1 "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/scev-5.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/scev-5.c
@@ -16,4 +16,3 @@ f(int k)
 }
 
 /* { dg-final { scan-tree-dump-times "&a" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/scev-6.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/scev-6.c
@@ -20,4 +20,3 @@ int main()
    of the loop.  */
 
 /* { dg-final { scan-tree-dump-not "abort" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/scev-7.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/scev-7.c
@@ -15,4 +15,3 @@ void foo (struct struct_t* sp, int start, int end)
 }
 
 /* { dg-final { scan-tree-dump-times "Simplify PEELED_CHREC into POLYNOMIAL_CHREC" 1 "sccp" } } */
-/* { dg-final { cleanup-tree-dump "sccp" } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/scev-8.c
@@ -0,0 +1,62 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-ivopts-details" } */
+
+int *a;
+
+int
+foo1 (long long s, long long l)
+{
+  long long i;
+
+  for (i = s; i < l; i++)
+    {
+      a[(short)i] = 0;
+    }
+  return 0;
+}
+
+int
+foo2 (unsigned char s, unsigned char l, unsigned char c)
+{
+  unsigned char i, step = 1;
+  int sum = 0;
+
+  for (i = s; i < l; i++)
+    {
+      sum += a[c];
+      c += step;
+    }
+
+  return sum;
+}
+
+int
+foo3 (unsigned char s, unsigned char l, unsigned char c)
+{
+  unsigned char i;
+  int sum = 0;
+
+  for (i = s; i != l; i += c)
+    {
+      sum += a[i];
+    }
+
+  return sum;
+}
+
+int
+foo4 (unsigned char s, unsigned char l)
+{
+  unsigned char i;
+  int sum = 0;
+
+  for (i = s; i != l; i++)
+    {
+      sum += a[i];
+    }
+
+  return sum;
+}
+
+/* Address of array references are not scevs.  */
+/* { dg-final { scan-tree-dump-not "use \[0-9\]\n  address" "ivopts" } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/scev-9.c
@@ -0,0 +1,22 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-ivopts-details" } */
+
+int *a;
+
+int
+foo (unsigned char s, unsigned char l)
+{
+  unsigned char i;
+  int sum = 0;
+
+  for (i = s; i < l; i += 1)
+    {
+      sum += a[i];
+    }
+
+  return sum;
+}
+
+/* Address of array reference is scev.  */
+/* { dg-final { scan-tree-dump-times "use \[0-9\]\n  address" 1 "ivopts" } } */
+
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/scev-cast.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/scev-cast.c
@@ -25,4 +25,3 @@ void tst(void)
 /* { dg-final { scan-tree-dump-times "& 255" 1 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "= \\(signed char\\)" 1 "optimized" } } */
 
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-1.c
@@ -19,4 +19,3 @@ f (int *p, unsigned int n)
 /* { dg-final { scan-tree-dump-times "\\+ 32|\\, 32>" 1 "optimized" { target { int16 } } } } */
 /* { dg-final { scan-tree-dump-times "\\+ 192|\\, 192>" 1 "optimized" { target { int32 } } } } */
 /* { dg-final { scan-tree-dump-times "\\+ 96|\\, 96>" 1 "optimized" { target { int16 } } } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-10.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-10.c
@@ -20,4 +20,3 @@ f (int s, int c)
 }
 
 /* { dg-final { scan-tree-dump-times " \\* " 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-11.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-11.c
@@ -21,4 +21,3 @@ f (int s, long c)
 }
 
 /* { dg-final { scan-tree-dump-times " \\* " 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-12.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-12.c
@@ -27,4 +27,3 @@ f (int s, int c)
 }
 
 /* { dg-final { scan-tree-dump-times " \\* " 3 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-13.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-13.c
@@ -22,4 +22,3 @@ f (int s, int c)
 
 /* { dg-final { scan-tree-dump-times " \\* 4" 2 "optimized" } } */
 /* { dg-final { scan-tree-dump-times " \\* 5" 0 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-14.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-14.c
@@ -29,4 +29,3 @@ f (int n, int c, int s)
 }
 
 /* { dg-final { scan-tree-dump-times " \\* " 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-15.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-15.c
@@ -24,4 +24,3 @@ f (int n, int c, int s)
 }
 
 /* { dg-final { scan-tree-dump-times " \\* " 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-16.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-16.c
@@ -25,4 +25,3 @@ f (int n, int c, int s)
 }
 
 /* { dg-final { scan-tree-dump-times " \\* " 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-17.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-17.c
@@ -28,4 +28,3 @@ f (int n, int c, int s)
 }
 
 /* { dg-final { scan-tree-dump-times " \\* " 0 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-18.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-18.c
@@ -29,4 +29,3 @@ f (int n, int c, int s)
 }
 
 /* { dg-final { scan-tree-dump-times " \\* " 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-19.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-19.c
@@ -18,5 +18,4 @@ f (int c, int s)
 
 /* { dg-final { scan-tree-dump-times " \\* " 2 "optimized" } } */
 /* { dg-final { scan-tree-dump-times " \\* 2;" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-2.c
@@ -15,4 +15,3 @@ f (int *p, int n)
 /* { dg-final { scan-tree-dump-times "\\+ 72|\\, 72>" 1 "optimized" { target { int16 } } } } */
 /* { dg-final { scan-tree-dump-times "\\+ 96|\\, 96>" 1 "optimized" { target { int32 } } } } */
 /* { dg-final { scan-tree-dump-times "\\+ 48|\\, 48>" 1 "optimized" { target { int16 } } } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-20.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-20.c
@@ -18,4 +18,3 @@ f (int c, int s)
 
 /* { dg-final { scan-tree-dump-times " \\* s" 1 "optimized" } } */
 /* { dg-final { scan-tree-dump-times " \\* 2" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-21.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-21.c
@@ -29,4 +29,3 @@ f (int n, int x, int stride)
 
 /* { dg-final { scan-tree-dump-times " \\* stride" 1 "optimized" } } */
 /* { dg-final { scan-tree-dump-times " \\* 3" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-22.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-22.c
@@ -26,4 +26,3 @@ f (int n, int x, int stride)
 
 /* { dg-final { scan-tree-dump-times " \\* stride" 1 "optimized" } } */
 /* { dg-final { scan-tree-dump-times " \\* 3" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-23.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-23.c
@@ -26,4 +26,3 @@ f (int n, int x, int stride)
 
 /* { dg-final { scan-tree-dump-times " \\* stride" 1 "optimized" } } */
 /* { dg-final { scan-tree-dump-times " \\* 3" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-24.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-24.c
@@ -28,4 +28,3 @@ f (int n, int x, int stride)
 }
 
 /* { dg-final { scan-tree-dump-times " \\* " 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-25.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-25.c
@@ -28,4 +28,3 @@ f (int n, int x, int stride)
 }
 
 /* { dg-final { scan-tree-dump-times " \\* " 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-26.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-26.c
@@ -29,4 +29,3 @@ f (int n, int x, int stride)
 
 /* { dg-final { scan-tree-dump-times " \\* stride" 1 "optimized" } } */
 /* { dg-final { scan-tree-dump-times " \\* 3" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-27.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-27.c
@@ -20,4 +20,3 @@ f (struct x *p, unsigned int n)
 /* { dg-final { scan-tree-dump-times "\\* 2;" 1 "dom2" { target { int16 } } } } */
 /* { dg-final { scan-tree-dump-times "p_\\d\+\\(D\\) \\+ \[^\r\n\]*_\\d\+;" 1 "dom2" } } */
 /* { dg-final { scan-tree-dump-times "MEM\\\[\\(struct x \\*\\)\[^\r\n\]*_\\d\+" 3 "dom2" } } */
-/* { dg-final { cleanup-tree-dump "dom2" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-28.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-28.c
@@ -24,4 +24,3 @@ f (struct x *p, unsigned int n)
 /* { dg-final { scan-tree-dump-times "\\* 2;" 1 "dom2" { target { int16 } } } } */
 /* { dg-final { scan-tree-dump-times "p_\\d\+\\(D\\) \\+ \[^\r\n\]*_\\d\+" 1 "dom2" } } */
 /* { dg-final { scan-tree-dump-times "MEM\\\[\\(struct x \\*\\)\[^\r\n\]*_\\d\+" 9 "dom2" } } */
-/* { dg-final { cleanup-tree-dump "dom2" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-29.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-29.c
@@ -26,4 +26,3 @@ f (struct x *p, unsigned int n)
 /* { dg-final { scan-tree-dump-times "\\* 2;" 1 "dom2" { target { int16 } } } } */
 /* { dg-final { scan-tree-dump-times "p_\\d\+\\(D\\) \\+ \[^\r\n\]*_\\d\+" 1 "dom2" } } */
 /* { dg-final { scan-tree-dump-times "MEM\\\[\\(struct x \\*\\)\[^\r\n\]*_\\d\+" 9 "dom2" } } */
-/* { dg-final { cleanup-tree-dump "dom2" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-3.c
@@ -22,4 +22,3 @@ foo (int a[], int b[], int i)
 /* { dg-final { scan-tree-dump-times "\\+ 8|\\, 8>" 1 "optimized" { target { int32plus } } } } */
 /* { dg-final { scan-tree-dump-times "\\+ 6|\\, 6>" 1 "optimized" { target { int16 } } } } */
 /* { dg-final { scan-tree-dump-times "\\+ 12|\\, 12>" 1 "optimized" { target { int32 } } } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-30.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-30.c
@@ -21,4 +21,3 @@ f (int s, long c)
 }
 
 /* { dg-final { scan-tree-dump-times " \\* " 3 "dom2" } } */
-/* { dg-final { cleanup-tree-dump "dom2" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-31.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-31.c
@@ -24,4 +24,3 @@ f (int s, int c)
 
 /* { dg-final { scan-tree-dump-times " \\* 2" 1 "optimized" } } */
 /* { dg-final { scan-tree-dump-times " \\* -2" 0 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-32.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-32.c
@@ -29,4 +29,3 @@ f (int s, int c, int i)
 
 /* { dg-final { scan-tree-dump-times " \\* s" 1 "optimized" } } */
 /* { dg-final { scan-tree-dump-times " \\* 2" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-33.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-33.c
@@ -28,4 +28,3 @@ f (int c, int i)
 }
 
 /* { dg-final { scan-tree-dump-times " \\* " 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-34.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-34.c
@@ -40,4 +40,3 @@ f (int c, int i)
 
 /* { dg-final { scan-tree-dump-times " \\* " 1 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "PHI" 2 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-35.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-35.c
@@ -25,4 +25,3 @@ f (int c, int i)
 }
 
 /* { dg-final { scan-tree-dump-times " \\* " 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-36.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-36.c
@@ -26,4 +26,3 @@ f (int s, int c, int i)
 
 /* { dg-final { scan-tree-dump-times " \\* s" 1 "optimized" } } */
 /* { dg-final { scan-tree-dump-times " \\* 2" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-37.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-37.c
@@ -30,4 +30,3 @@ f (int s, int c, int i)
 
 /* { dg-final { scan-tree-dump-times " \\* s" 1 "optimized" } } */
 /* { dg-final { scan-tree-dump-times " \\* 2" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-38.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-38.c
@@ -29,4 +29,3 @@ f (int c, int i)
 }
 
 /* { dg-final { scan-tree-dump-times " \\* " 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-39.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-39.c
@@ -23,4 +23,3 @@ void foo (arr_2 a2, int v1)
 }
 
 /* { dg-final { scan-tree-dump-times "Replacing reference: " 4 "slsr" } } */
-/* { dg-final { cleanup-tree-dump "slsr" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-4.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-4.c
@@ -33,5 +33,3 @@ f (int i)
 /* { dg-final { scan-tree-dump-times "\\* 10" 1 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "\\+ 200" 1 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "\\+ 40" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "slsr" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-41.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-41.c
@@ -21,4 +21,3 @@ void foo (arr_2 a2, int v1)
 }
 
 /* { dg-final { scan-tree-dump-times "Replacing reference: " 5 "slsr" } } */
-/* { dg-final { cleanup-tree-dump "slsr" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-5.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-5.c
@@ -19,4 +19,3 @@ f (int s, int c)
 }
 
 /* { dg-final { scan-tree-dump-times " \\* " 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-6.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-6.c
@@ -22,4 +22,3 @@ f (int s, char *c, char *x1, char *x2, char *x3)
 
 /* There will be four ' * ' instances for the parms, one in the code.  */
 /* { dg-final { scan-tree-dump-times " \\* " 5 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-7.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-7.c
@@ -19,4 +19,3 @@ f (int s, int c)
 }
 
 /* { dg-final { scan-tree-dump-times " \\* " 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-8.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-8.c
@@ -21,4 +21,3 @@ f (int s, int *c)
    added), 1 parm, 2 in the code.  The second one in the code can be
    a widening mult.  */
 /* { dg-final { scan-tree-dump-times " w?\\* " 7 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-9.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/slsr-9.c
@@ -20,4 +20,3 @@ f (int s, int c)
 }
 
 /* { dg-final { scan-tree-dump-times " \\* " 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/sra-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/sra-1.c
@@ -72,4 +72,3 @@ copystruct111111 (teststruct param)
 
 /* There should be no referenc to link_error. */
 /* { dg-final { scan-tree-dump-times "link_error" 0 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/sra-10.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/sra-10.c
@@ -16,4 +16,3 @@ void foo (struct S *s, int i)
 }
 
 /* { dg-final { scan-tree-dump-times "disappear" 0 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/sra-11.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/sra-11.c
@@ -30,4 +30,3 @@ int foo2 (void)
 
 /* { dg-final { scan-tree-dump-times "Created a replacement for s1" 0 "esra"} } */
 /* { dg-final { scan-tree-dump-times "Created a replacement for s2" 1 "esra"} } */
-/* { dg-final { cleanup-tree-dump "esra" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/sra-12.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/sra-12.c
@@ -22,4 +22,3 @@ int foo (struct S *p)
 }
 
 /* { dg-final { scan-tree-dump-times "l;" 0 "release_ssa" { target { ! "aarch64*-*-* avr*-*-* nds32*-*-* sh*-*-*" } } } } */
-/* { dg-final { cleanup-tree-dump "release_ssa" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/sra-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/sra-2.c
@@ -25,4 +25,3 @@ copystruct11 (teststruct *param)
 
 /* There should be no reference to link_error. */
 /* { dg-final { scan-tree-dump-times "link_error" 0 "optimized" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/sra-3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/sra-3.c
@@ -25,4 +25,3 @@ copystruct1 (void)
 
 /* There should be no reference to link_error. */
 /* { dg-final { scan-tree-dump-times "link_error" 0 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/sra-4.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/sra-4.c
@@ -22,4 +22,3 @@ vector int f(vector int t1, vector int t2)
 }
 
 /* { dg-final { scan-tree-dump-times "st" 0 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/sra-5.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/sra-5.c
@@ -72,4 +72,3 @@ copyunion111111 (testunion param)
 
 /* There should be no reference to link_error. */
 /* { dg-final { scan-tree-dump-times "link_error" 0 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/sra-6.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/sra-6.c
@@ -34,8 +34,6 @@ void cow (int i)
 /* { dg-final { scan-tree-dump "expr = b.i1"  "esra"} } */
 /* { dg-final { scan-tree-dump "expr = c.d"  "esra"} } */
 /* { dg-final { scan-tree-dump "expr = c.i1"  "esra"} } */
-/* { dg-final { cleanup-tree-dump "esra" } } */
 
 /* There should be no reference to link_error.  */
 /* { dg-final { scan-tree-dump-times "link_error" 0 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/sra-7.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/sra-7.c
@@ -10,4 +10,3 @@ void a(s *s1, s *s2)
 
 /* Struct copies should not be split into members.  */
 /* { dg-final { scan-tree-dump "\\\*s1_.\\\(D\\\) = \\\*s2"  "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/sra-8.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/sra-8.c
@@ -32,4 +32,3 @@ void bar2(int i, int j)
 }
 
 /* { dg-final { scan-tree-dump-times "Created a replacement" 0 "esra"} } */
-/* { dg-final { cleanup-tree-dump "esra" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/sra-9.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/sra-9.c
@@ -17,4 +17,3 @@ int foo (int d)
 
 /* There should be no reference to s.b.  */
 /* { dg-final { scan-tree-dump-times "= s\.b" 0 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-1.c
@@ -72,4 +72,3 @@ void test11111 (int p, int q, int r)
 /* There should be not link_error calls, if there is any the
    optimization has failed */
 /* { dg-final { scan-tree-dump-times "link_error" 0 "ccp1"} } */
-/* { dg-final { cleanup-tree-dump "ccp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-10.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-10.c
@@ -33,4 +33,3 @@ middle:
 
 /* There should be no calls to strlen.  */
 /* { dg-final { scan-tree-dump-times "strlen" 0 "fab1"} } */
-/* { dg-final { cleanup-tree-dump "fab1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-11.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-11.c
@@ -39,4 +39,3 @@ int test1111 (int param)
 
 /* All ifs should be eliminated. */
 /* { dg-final { scan-tree-dump-times "if " 0 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-13.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-13.c
@@ -10,5 +10,4 @@ int foo()
 }
 
 /* { dg-final { scan-tree-dump "return 0;" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-14.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-14.c
@@ -18,4 +18,3 @@ void bar (void)
 
 /* Everything except for the "i = 0" assignment should get removed.  */
 /* { dg-final { scan-tree-dump-times "if" 0 "optimized" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-15.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-15.c
@@ -46,4 +46,3 @@ void test3 (int param1, int param2)
 }
 
 /* { dg-final { scan-tree-dump-times "link_error" 2 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-16.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-16.c
@@ -19,4 +19,3 @@ int test2 (void)
 }
 
 /* { dg-final { scan-tree-dump-times "return 0;" 2 "ccp1" } } */
-/* { dg-final { cleanup-tree-dump "ccp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-17.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-17.c
@@ -29,4 +29,3 @@ int foobar(void)
 /* { dg-final { scan-tree-dump "= i_.;" "ccp1" } } */
 /* { dg-final { scan-tree-dump "= f.i;" "ccp1" } } */
 /* { dg-final { scan-tree-dump "= g.i;" "ccp1" } } */
-/* { dg-final { cleanup-tree-dump "ccp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-18.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-18.c
@@ -17,4 +17,3 @@ void func2(int* val)
 
 /* { dg-final { scan-tree-dump-not "a \\\(" "ccp1" } } */
 /* { dg-final { scan-tree-dump-not "b \\\(" "ccp1" } } */
-/* { dg-final { cleanup-tree-dump "ccp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-19.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-19.c
@@ -13,4 +13,3 @@ int g()
 }
 
 /* { dg-final { scan-tree-dump "= MEM\\\[\\\(int \\\*\\\)&a\\\];" "ccp1" } } */
-/* { dg-final { cleanup-tree-dump "ccp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-2.c
@@ -169,4 +169,3 @@ int test99999 (void)
 /* There should be not link_error calls, if there is any the
    optimization has failed */
 /* { dg-final { scan-tree-dump-times "link_error" 0 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-20.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-20.c
@@ -12,4 +12,3 @@ int foo (void)
 }
 
 /* { dg-final { scan-tree-dump "return 10;" "ccp1" } } */
-/* { dg-final { cleanup-tree-dump "ccp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-21.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-21.c
@@ -26,4 +26,3 @@ int bar (void)
 
 /* { dg-final { scan-tree-dump-times "a.b.i" 1 "ccp1" } } */
 /* { dg-final { scan-tree-dump-times "MEM\\\[\\\(struct B \\\*\\\)&a\\\].i" 1 "ccp1" } } */
-/* { dg-final { cleanup-tree-dump "ccp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-22.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-22.c
@@ -12,4 +12,3 @@ int foo (unsigned b)
 }
 
 /* { dg-final { scan-tree-dump "return 1;" "ccp1" } } */
-/* { dg-final { cleanup-tree-dump "ccp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-23.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-23.c
@@ -17,4 +17,3 @@ int foo (void)
 
 /* { dg-final { scan-tree-dump "MEM\\\[\\\(int \\\*\\\)&a \\\+ 2B\\\]" "ccp1" { target { int16 } } } } */
 /* { dg-final { scan-tree-dump "MEM\\\[\\\(int \\\*\\\)&a \\\+ 4B\\\]" "ccp1" { target { int32 } } } } */
-/* { dg-final { cleanup-tree-dump "ccp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-24.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-24.c
@@ -19,5 +19,4 @@ int bar()
 }
 
 /* { dg-final { scan-tree-dump-times "return 1;" 2 "ccp1" } } */
-/* { dg-final { cleanup-tree-dump "ccp1" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-27.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-27.c
@@ -21,4 +21,3 @@ f2 ()
 }
 
 /* { dg-final { scan-tree-dump-times "memcpy\[^\n\]*123456" 2 "ccp1" } } */
-/* { dg-final { cleanup-tree-dump "ccp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-28.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-28.c
@@ -23,4 +23,3 @@ int main(void)
 
 /* { dg-final { scan-tree-dump-times "= p;" 0 "ccp1" } } */
 /* { dg-final { scan-tree-dump-times "= q;" 0 "ccp1" } } */
-/* { dg-final { cleanup-tree-dump "ccp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-29.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-29.c
@@ -8,4 +8,3 @@ int foo (void)
 }
 
 /* { dg-final { scan-tree-dump "return 0;" "ccp2" } } */
-/* { dg-final { cleanup-tree-dump "ccp2" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-3.c
@@ -134,4 +134,3 @@ int* test666 (int * __restrict__ rp1, int * __restrict__ rp2, int *p1)
 /* ??? While we indeed don't handle some of these, a couple of the
    restrict tests are incorrect.  */
 /* { dg-final { scan-tree-dump-times "link_error" 0 "ccp2" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "ccp2" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-30.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-30.c
@@ -12,4 +12,3 @@ foo (int a)
 }
 
 /* { dg-final { scan-tree-dump-times "Folding predicate b_.* > 300 to 0" 1 "ccp1" } } */
-/* { dg-final { cleanup-tree-dump "ccp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-31.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-31.c
@@ -18,4 +18,3 @@ int g (int i, int j)
 }
 
 /* { dg-final { scan-tree-dump-times "Folding predicate.*to 1" 1 "ccp1" } } */
-/* { dg-final { cleanup-tree-dump "ccp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-34.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-34.c
@@ -9,4 +9,3 @@ int foo (int x)
 }
 
 /* { dg-final { scan-tree-dump-times "\\+" 1 "ccp1" } } */
-/* { dg-final { cleanup-tree-dump "ccp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-7.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-7.c
@@ -24,4 +24,3 @@ int test7 (int a)
 /* There should be not link_error calls, if there is any the
    optimization has failed */
 /* { dg-final { scan-tree-dump-times "link_error" 0 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-9.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-9.c
@@ -52,4 +52,3 @@ test99999 (int *arr, int j)
 /* There should be no link_error calls, if there is any, the
    optimization has failed */
 /* { dg-final { scan-tree-dump-times "link_error" 0 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-copyprop-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-copyprop-1.c
@@ -9,4 +9,3 @@ int foo(A *a, int i)
 }
 
 /* { dg-final { scan-tree-dump "return i" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-copyprop-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-copyprop-2.c
@@ -10,4 +10,3 @@ f(void)
 }
 
 /* { dg-final { scan-tree-dump-not "PHI" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dce-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dce-1.c
@@ -11,4 +11,3 @@ q()
 }
 /* There should be no IF conditionals.  */
 /* { dg-final { scan-tree-dump-times "if " 0 "dce2"} } */
-/* { dg-final { cleanup-tree-dump "dce2" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dce-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dce-2.c
@@ -14,4 +14,3 @@ void q(void)
 }
 /* There should be no IF conditionals.  */
 /* { dg-final { scan-tree-dump-times "if " 0 "dce2"} } */
-/* { dg-final { cleanup-tree-dump "dce2" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dce-3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dce-3.c
@@ -32,4 +32,3 @@ int main(void)
 /* And one if (for the exit condition of the loop):  */
 /* { dg-final { scan-tree-dump-times "if " 1 "cddce1" } } */
 
-/* { dg-final { cleanup-tree-dump "cddce1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dce-4.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dce-4.c
@@ -17,4 +17,3 @@ int foo(int b)
 /* Verify DCE removes all accesses to a but the last store and the
    read from a[2].  */
 /* { dg-final { scan-tree-dump-times "a\\\[\[^\n\]\\\]" 2 "cddce1" } } */
-/* { dg-final { cleanup-tree-dump "cddce1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dce-5.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dce-5.c
@@ -12,4 +12,3 @@ struct X foo(int b)
 }
 
 /* { dg-final { scan-tree-dump-times "x.i =" 1 "cddce1" } } */
-/* { dg-final { cleanup-tree-dump "cddce1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dce-6.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dce-6.c
@@ -21,4 +21,3 @@ void t(int x)
 /* The global store should not prevent deleting the store to p->field.  */
 
 /* { dg-final { scan-tree-dump-not "p_.->field" "cddce1" } } */
-/* { dg-final { cleanup-tree-dump "cddce1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dce-7.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dce-7.c
@@ -30,4 +30,3 @@ int main()
    to the allocated memory.  */
 
 /* { dg-final { scan-tree-dump-times "\\\*D" 0 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dce-8.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dce-8.c
@@ -9,4 +9,3 @@ int main()
 }
 
 /* { dg-final { scan-tree-dump-not "malloc" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-ccp-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-ccp-1.c
@@ -15,4 +15,3 @@ ccp(int b)
 }
 /* We should propagate constant 4 into return.  */
 /* { dg-final { scan-tree-dump-times "return 4" 1 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-cse-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-cse-1.c
@@ -13,4 +13,3 @@ threading(int a,int b)
 }
 /* We should thread the jump twice and eliminate it.  */
 /* { dg-final { scan-tree-dump-times "Replaced.* t " 1 "fre1"} } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-cse-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-cse-2.c
@@ -21,4 +21,3 @@ foo ()
    DOM is not able to perform this optimization.  */
 
 /* { dg-final { scan-tree-dump "return 28;" "optimized" { xfail aarch64*-*-* alpha*-*-* hppa*-*-* powerpc*-*-* sparc*-*-* s390*-*-* } } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-cse-3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-cse-3.c
@@ -28,4 +28,3 @@ main()
 }
 
 /* { dg-final { scan-tree-dump "= PHI <\[01\]\\\(.\\\), \[01\]\\\(.\\\)>" "dom1" } } */
-/* { dg-final { cleanup-tree-dump "dom1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-dse-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-dse-1.c
@@ -16,4 +16,3 @@ bar (int i)
 }
 
 /* { dg-final { scan-tree-dump-not "x =" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-1.c
@@ -15,4 +15,3 @@ threading(int a,int b)
 }
 /* We should thread the jump twice and elliminate it.  */
 /* { dg-final { scan-tree-dump-times "Threaded" 2 "dom1"} } */
-/* { dg-final { cleanup-tree-dump "dom1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-2.c
@@ -115,5 +115,3 @@ void dont_thread_4 (int a, int nfirst)
 /* { dg-final { scan-tree-dump-times "Jumps threaded: 2" 0 "vrp1"} } */
 /* { dg-final { scan-tree-dump-times "Jumps threaded: 1" 0 "dom1"} } */
 /* { dg-final { scan-tree-dump-times "Jumps threaded: 2" 1 "dom1"} } */
-/* { dg-final { cleanup-tree-dump "dom1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-4.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-4.c
@@ -76,5 +76,4 @@ bitmap_ior_and_compl (bitmap dst, const_bitmap a, const_bitmap b,
 	 skipping the known-true "b_elt && kill_elt" in the second
 	 condition.  */
 /* { dg-final { scan-tree-dump-times "Threaded" 4 "dom1" { target logical_op_short_circuit } } } */
-/* { dg-final { cleanup-tree-dump "dom1" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-5.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-5.c
@@ -20,4 +20,3 @@ void f2(int dst[3], int R)
 }
 
 /* { dg-final { scan-tree-dump "Threaded jump" "dom1" } } */
-/* { dg-final { cleanup-tree-dump "dom1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-6.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-6.c
@@ -1,7 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-O2 -fdump-tree-dom1-details" } */
 /* { dg-final { scan-tree-dump-times "FSM" 6 "dom1" } } */
-/* { dg-final { cleanup-tree-dump "dom1" } } */
 
 int sum0, sum1, sum2, sum3;
 int foo (char *s, char **ret)
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-7.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-7.c
@@ -1,7 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-O2 -fdump-tree-dom1-details" } */
 /* { dg-final { scan-tree-dump-times "FSM" 19 "dom1" } } */
-/* { dg-final { cleanup-tree-dump "dom1" } } */
 
 enum STATE {
   S0=0,
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-1.c
@@ -23,4 +23,3 @@ foo (int a, int b, int c)
 /* The return *p should be turned into return 4.  */
 /* { dg-final { scan-tree-dump-times " return 4" 1 "dse1"} } */
 
-/* { dg-final { cleanup-tree-dump "dse1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-10.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-10.c
@@ -1520,4 +1520,3 @@ void func_encode(void)
 }
 
 /* { dg-final { scan-tree-dump-times " xxxinfo = {}" 1 "dse1"} } */
-/* { dg-final { cleanup-tree-dump "dse1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-11.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-11.c
@@ -18,4 +18,3 @@ void bar(int *p)
 }
 
 /* { dg-final { scan-tree-dump-times "Deleted dead store" 2 "dse1" } } */
-/* { dg-final { cleanup-tree-dump "dse1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-12.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-12.c
@@ -9,4 +9,3 @@ void foo (int *p, int b)
 }
 
 /* { dg-final { scan-tree-dump-times "\\\*p" 1 "dse1" } } */
-/* { dg-final { cleanup-tree-dump "dse1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-13.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-13.c
@@ -18,4 +18,3 @@ f2 (void)
 }
 
 /* { dg-final { scan-tree-dump-times "Deleted dead store" 2 "dse1" } } */
-/* { dg-final { cleanup-tree-dump "dse1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-14.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-14.c
@@ -18,4 +18,3 @@ f2 (void)
 }
 
 /* { dg-final { scan-tree-dump-times "Deleted dead store" 2 "dse1" } } */
-/* { dg-final { cleanup-tree-dump "dse1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-15.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-15.c
@@ -21,4 +21,3 @@ void bar (int *i)
 }
 
 /* { dg-final { scan-tree-dump-times "Deleted dead store" 2 "dse1" } } */
-/* { dg-final { cleanup-tree-dump "dse1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-16.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-16.c
@@ -15,4 +15,3 @@ void foo (struct X *x, int i)
 }
 
 /* { dg-final { scan-tree-dump "Deleted dead store" "dse1" } } */
-/* { dg-final { cleanup-tree-dump "dse1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-2.c
@@ -21,4 +21,3 @@ foo ()
 /* { dg-final { scan-tree-dump-times " = 3" 0 "dse1"} } */
 /* { dg-final { scan-tree-dump-times " = 4" 1 "dse1"} } */
 
-/* { dg-final { cleanup-tree-dump "dse1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-3.c
@@ -12,5 +12,4 @@ void f(void)
 /* { dg-final { scan-tree-dump-times "Bool_Glob = 0" 0 "dse1"} } */
 /* { dg-final { scan-tree-dump-times "Bool_Glob = 1" 1 "dse1"} } */
 
-/* { dg-final { cleanup-tree-dump "dse1" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-4.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-4.c
@@ -12,4 +12,3 @@ foo( int *a)
 /* { dg-final { scan-tree-dump-times "= 5" 0 "dse1"} } */
 /* { dg-final { scan-tree-dump-times "= 3" 1 "dse1"} } */
 
-/* { dg-final { cleanup-tree-dump "dse1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-5.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-5.c
@@ -29,5 +29,4 @@ f1 (int i, int j, int k)
 /* { dg-final { scan-tree-dump-times "i = 5" 1 "optimized" { xfail *-*-* }} } */
 /* { dg-final { scan-tree-dump-times "<L.*>:;\[\n\t \]*\\*p = 5" 1 "optimized" { xfail *-*-*}} } */
 
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-6.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-6.c
@@ -16,4 +16,3 @@ int foo11 (int c)
 /* { dg-final { scan-tree-dump-times "local1 = " 1 "dse1"} } */
 /* { dg-final { scan-tree-dump-times "local2 = " 1 "dse1"} } */
 
-/* { dg-final { cleanup-tree-dump "dse1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-7.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-7.c
@@ -20,4 +20,3 @@ int foo1 (void)
 /* { dg-final { scan-tree-dump-times "glob2 = " 1 "dse1"} } */
 /* { dg-final { scan-tree-dump-times "return 5" 1 "dse1"} } */
 
-/* { dg-final { cleanup-tree-dump "dse1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-9.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-9.c
@@ -12,4 +12,3 @@ foo ()
 
 /* We should eliminate the first assignment.  */
 /* { dg-final { scan-tree-dump-times "VDEF" 2 "dse1" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "dse1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-1.c
@@ -12,4 +12,3 @@ int f(int *a)
 }
 
 /* { dg-final { scan-tree-dump "Replaced \\\*\[ac\]_\[^\n\].*with t_" "fre1" } } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-10.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-10.c
@@ -23,4 +23,3 @@ void __frame_state_for (volatile char *state_in, int x)
    first store.  Thus, this is XFAILed.  */
 
 /* { dg-final { scan-tree-dump "Insertions: 2" "pre" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-11.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-11.c
@@ -23,4 +23,3 @@ foo (int y)
 }
 
 /* { dg-final { scan-tree-dump "Replaced S\\\[5\\\].x with 4" "fre1" } } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-12.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-12.c
@@ -23,4 +23,3 @@ foo (int y)
 }
 
 /* { dg-final { scan-tree-dump "Replaced S\\\[5\\\].x with 4" "fre1" } } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-13.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-13.c
@@ -24,4 +24,3 @@ void foo(double (*q)[4], struct Foo *tmp1)
 }
 
 /* { dg-final { scan-tree-dump "Replaced tmp1_.\\\(D\\\)->data with &a" "fre1" } } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-14.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-14.c
@@ -28,4 +28,3 @@ void foo(double (*q)[4])
 }
 
 /* { dg-final { scan-tree-dump "Replaced tmp1.data with &a" "fre1" } } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-15.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-15.c
@@ -27,4 +27,3 @@ void foo(double (*q)[4])
 }
 
 /* { dg-final { scan-tree-dump "Replaced" "fre1" } } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-16.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-16.c
@@ -15,4 +15,3 @@ int foo(int b, int c)
 }
 
 /* { dg-final { scan-tree-dump-not "link_error" "fre1" } } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-17.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-17.c
@@ -19,5 +19,4 @@ int foo(int i, int j, int k)
 }
 
 /* { dg-final { scan-tree-dump "Replaced f.doms\\\[0\\\].dom with i_" "fre1" } } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-18.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-18.c
@@ -25,4 +25,3 @@ int f(struct a *c)
 /* We should have CSEd the load from c->a.  */
 
 /* { dg-final { scan-tree-dump-times "c_.*\\\.a" 1 "fre1" } } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-19.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-19.c
@@ -28,4 +28,3 @@ int f(struct a *c)
 /* We should have CSEd the load from c->a.  */
 
 /* { dg-final { scan-tree-dump-times "c_.*\\\.a" 1 "fre1" } } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-2.c
@@ -15,4 +15,3 @@ foo (long a)
 }
 
 /* { dg-final { scan-tree-dump "Replaced \\\(short int\\\) c_.*with b_" "fre1" } } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-20.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-20.c
@@ -17,4 +17,3 @@ L2:
 }
 
 /* { dg-final { scan-tree-dump "return 0;" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-21.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-21.c
@@ -23,4 +23,3 @@ void g(void)
 }
 
 /* { dg-final { scan-tree-dump-not "a\\\.? = " "fre1" } } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-22.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-22.c
@@ -12,4 +12,3 @@ int foo (void)
 /* We should eliminate the redundant load of i.  */
 
 /* { dg-final { scan-tree-dump-not "= i;" "fre1" } } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-23.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-23.c
@@ -18,4 +18,3 @@ int f(int t, int a, int b)
 }
 
 /* { dg-final { scan-tree-dump-times "PHI" 1 "fre1" } } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-24.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-24.c
@@ -31,4 +31,3 @@ int bazzoo (void)
 }
 
 /* { dg-final { scan-tree-dump-times "return 0;" 4 "fre1" } } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-25.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-25.c
@@ -15,4 +15,3 @@ int foo (struct X *p)
 /* We should optimize this to return 0.  */
 
 /* { dg-final { scan-tree-dump "return 0;" "fre1" } } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-26.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-26.c
@@ -16,4 +16,3 @@ int foo (union U *p)
 
 /* avr has 16 bit int and 32 bit float */
 /* { dg-final { scan-tree-dump "Replaced u.i with 0 in" "fre1" {xfail avr-*-* } } } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-27.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-27.c
@@ -22,4 +22,3 @@ int foo(int which_p)
 }
 
 /* { dg-final { scan-tree-dump "Replaced x with 0" "fre1" } } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-3.c
@@ -19,4 +19,3 @@ foo (int a, int b)
 }
 
 /* { dg-final { scan-tree-dump "Replaced \\\(int\\\) aa_.*with a_" "fre1" } } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-30.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-30.c
@@ -9,4 +9,3 @@ float foo(float x, float y, float z)
 }
 
 /* { dg-final { scan-tree-dump "return 0" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-31.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-31.c
@@ -44,4 +44,3 @@ void test4 (unsigned char x)
 
 /* { dg-final { scan-tree-dump-times "Replaced \{" 4 "fre1" } } */
 /* { dg-final { scan-tree-dump-times "Deleted redundant store" 4 "fre1" } } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-32.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-32.c
@@ -27,4 +27,3 @@ bar (_Complex float x)
 
 /* We should CSE all the way to replace the stored value with x.  */
 /* { dg-final { scan-tree-dump-times "m = x_\\d\+\\(D\\);" 2 "fre1" } } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-33.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-33.c
@@ -19,4 +19,3 @@ int main(int argc)
 }
 
 /* { dg-final { scan-tree-dump "Replaced BIT_FIELD_REF.*with 2" "fre1" } } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-34.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-34.c
@@ -16,4 +16,3 @@ float foo(float f)
 }
 
 /* { dg-final { scan-tree-dump "Replaced BIT_FIELD_REF.*with f" "fre1" } } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-35.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-35.c
@@ -14,4 +14,3 @@ float a1 (float dd)
 }
 
 /* { dg-final { scan-tree-dump "Replaced REALPART_EXPR.*with dd" "fre1" } } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-36.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-36.c
@@ -23,4 +23,3 @@ void PreEvaluate(int wtm)
 /* We should be able to CSE the second load of opening.  */
 
 /* { dg-final { scan-tree-dump "Replaced opening" "fre1" } } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-37.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-37.c
@@ -12,4 +12,3 @@ void foo (int i, int j)
 /* We should remove the redundant address computation.  */
 
 /* { dg-final { scan-tree-dump-times " = &a" 1 "fre1" } } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-38.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-38.c
@@ -18,4 +18,3 @@ int foo (int n, int i, int j)
 /* We should remove the redundant load.  */
 
 /* { dg-final { scan-tree-dump-not "= u.a\\\[n_2\\(D\\)\\\].i" "fre1" } } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-39.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-39.c
@@ -16,4 +16,3 @@ int foo (int i)
 /* We should be able to value-number the final assignment to k to 1.  */
 
 /* { dg-final { scan-tree-dump "return 1;" "fre1" } } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-4.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-4.c
@@ -12,4 +12,3 @@ char bar(char f)
 }
 
 /* { dg-final { scan-tree-dump "Replaced \\\(char\\\) .*with " "fre1" } } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-40.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-40.c
@@ -14,4 +14,3 @@ int foo (int *p)
    aliasing store via *p is not reachable.  */
 
 /* { dg-final { scan-tree-dump-not "= x;" "fre1" } } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-41.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-41.c
@@ -9,4 +9,3 @@ int foo (void)
 }
 
 /* { dg-final { scan-tree-dump-not "ffs" "fre1" } } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-42.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-42.c
@@ -31,4 +31,3 @@ int main()
 /* { dg-final { scan-tree-dump "b = A;" "fre1" } } */
 /* Verify we have propagated the element read all the way to the return.  */
 /* { dg-final { scan-tree-dump "return 2" "fre1" } } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-43.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-43.c
@@ -26,4 +26,3 @@ L10:
 
 /* { dg-final { scan-tree-dump-times "Removing dead stmt" 15 "fre1" } } */
 /* { dg-final { scan-tree-dump-not "Not changing value number" "fre1" } } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-5.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-5.c
@@ -11,4 +11,3 @@ bar (unsigned int t)
 }
 
 /* { dg-final { scan-tree-dump "Replaced \\\(unsigned int\\\) a_.*with t_" "fre1" } } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-6.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-6.c
@@ -3,4 +3,3 @@
 
  int i; int foo(void) { i = 2; int j = i * 2; int k = i + 2; return j == k; }
 /* { dg-final { scan-tree-dump-times "Replaced " 6 "fre1" } } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-7.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-7.c
@@ -34,5 +34,3 @@ intflt foo(intflt j)
 /* { dg-final { scan-tree-dump-times "Replaced a.u.k with j" 1 "fre1" } } */
 /* { dg-final { scan-tree-dump "= VIEW_CONVERT_EXPR<float>\\\(j_" "fre1" } } */
 /* { dg-final { scan-tree-dump "return j" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-8.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-8.c
@@ -30,4 +30,3 @@ intflt foo(int i, int b)
 
 /* { dg-final { scan-tree-dump-times "Replaced u.f with pretmp" 2 "fre1" } } */
 /* { dg-final { scan-tree-dump-times "Inserted pretmp" 2 "fre1" } } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-9.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-9.c
@@ -25,4 +25,3 @@ void __frame_state_for1 (volatile char *state_in)
 
 /* { dg-final { scan-tree-dump-times "Eliminated: 2" 2 "fre1" } } */
 /* { dg-final { scan-tree-dump-times "Insertions: 1" 2 "fre1" } } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ifcombine-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ifcombine-1.c
@@ -14,4 +14,3 @@ int foo (int x, int a, int b)
 }
 
 /* { dg-final { scan-tree-dump "\\|" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ifcombine-10.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ifcombine-10.c
@@ -17,4 +17,3 @@ int f(int x, int a, int b)
   return t;
 }
 /* { dg-final { scan-tree-dump "& 5" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ifcombine-11.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ifcombine-11.c
@@ -18,4 +18,3 @@ int f(int x, int a, int b)
 }
 
 /* { dg-final { scan-tree-dump "& 5" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ifcombine-12.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ifcombine-12.c
@@ -17,4 +17,3 @@ int f(int x, int a, int b)
   return t;
 }
 /* { dg-final { scan-tree-dump "& 5" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ifcombine-13.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ifcombine-13.c
@@ -18,4 +18,3 @@ _Bool f1(_Bool a, _Bool b)
 /* For LOGICAL_OP_NON_SHORT_CIRCUIT, this should be optimized
    into return a & b;, with no ifs.  */
 /* { dg-final { scan-tree-dump-not "if" "optimized" { target { i?86-*-* x86_64-*-* s390*-*-* avr*-*-* } } } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ifcombine-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ifcombine-2.c
@@ -20,4 +20,3 @@ doit:
 }
 
 /* { dg-final { scan-tree-dump "\\|" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ifcombine-3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ifcombine-3.c
@@ -20,4 +20,3 @@ doit:
 }
 
 /* { dg-final { scan-tree-dump ">=" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ifcombine-4.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ifcombine-4.c
@@ -18,4 +18,3 @@ void foo (int x, int a)
 }
 
 /* { dg-final { scan-tree-dump "!=" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ifcombine-5.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ifcombine-5.c
@@ -17,4 +17,3 @@ int f(int *i, int *j)
 }
 
 /* { dg-final { scan-tree-dump ">=" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ifcombine-6.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ifcombine-6.c
@@ -34,4 +34,3 @@ foo2 (unsigned int a)
 
 /* { dg-final { scan-tree-dump "optimizing bits or bits test" "ifcombine" } } */
 /* { dg-final { scan-tree-dump "optimizing double bit test" "ifcombine" } } */
-/* { dg-final { cleanup-tree-dump "ifcombine" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ifcombine-7.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ifcombine-7.c
@@ -12,4 +12,3 @@ int test1 (int i, int j)
 /* The above should be optimized to a i > j test by ifcombine.  */
 
 /* { dg-final { scan-tree-dump " > " "ifcombine" } } */
-/* { dg-final { cleanup-tree-dump "ifcombine" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ifcombine-8.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ifcombine-8.c
@@ -22,4 +22,3 @@ plouf:
    Instead we get u<=, which is acceptable with -fno-trapping-math.  */
 
 /* { dg-final { scan-tree-dump " u<= " "ifcombine" } } */
-/* { dg-final { cleanup-tree-dump "ifcombine" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ifcombine-9.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ifcombine-9.c
@@ -19,4 +19,3 @@ void g (double x)
    The transformation would also be legal with -ftrapping-math.  */
 
 /* { dg-final { scan-tree-dump "optimizing.* < " "ifcombine" } } */
-/* { dg-final { cleanup-tree-dump "ifcombine" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ifcombine-ccmp-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ifcombine-ccmp-1.c
@@ -11,4 +11,3 @@ int t (int a, int b)
   return 1;
 }
 /* { dg-final { scan-tree-dump "\&" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ifcombine-ccmp-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ifcombine-ccmp-2.c
@@ -14,4 +14,3 @@ L1:
   return 1;
 }
 /* { dg-final { scan-tree-dump "\|" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ifcombine-ccmp-3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ifcombine-ccmp-3.c
@@ -17,4 +17,3 @@ L2:
   return 6;
 }
 /* { dg-final { scan-tree-dump "\|" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ifcombine-ccmp-4.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ifcombine-ccmp-4.c
@@ -15,4 +15,3 @@ L2:
   return 1;
 }
 /* { dg-final { scan-tree-dump "\&" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ifcombine-ccmp-5.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ifcombine-ccmp-5.c
@@ -10,4 +10,3 @@ int t (int a, int b, int c)
   return 1;
 }
 /* { dg-final { scan-tree-dump-times "\&" 2 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ifcombine-ccmp-6.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-ifcombine-ccmp-6.c
@@ -10,4 +10,3 @@ int t (int a, int b, int c)
   return 1;
 }
 /* { dg-final { scan-tree-dump-times "\\|" 2 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-lim-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-lim-1.c
@@ -19,4 +19,3 @@ quantum_toffoli (int control1, int control2, int target,
 }
 
 /* { dg-final { scan-tree-dump-times "1 <<" 3 "lim1" } } */
-/* { dg-final { cleanup-tree-dump "lim1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-lim-10.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-lim-10.c
@@ -28,4 +28,3 @@ int test_func(void)
 }
 
 /* { dg-final { scan-tree-dump "Executing store motion of pos" "lim1" } } */
-/* { dg-final { cleanup-tree-dump "lim1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-lim-11.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-lim-11.c
@@ -22,4 +22,3 @@ void access_buf(struct thread_param* p)
 }
 
 /* { dg-final { scan-tree-dump-times "Executing store motion of __gcov0.access_buf\\\[\[01\]\\\] from loop 1" 2 "lim1" } } */
-/* { dg-final { cleanup-tree-dump "lim1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-lim-12.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-lim-12.c
@@ -24,4 +24,3 @@ void bar (int x, int z)
 }
 
 /* { dg-final { scan-tree-dump-times "!= 0 ? " 2 "lim1" } } */
-/* { dg-final { cleanup-tree-dump "lim1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-lim-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-lim-2.c
@@ -19,4 +19,3 @@ int size)
 }
 
 /* { dg-final { scan-tree-dump-times "1 <<" 3 "lim1" } } */
-/* { dg-final { cleanup-tree-dump "lim1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-lim-3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-lim-3.c
@@ -11,4 +11,3 @@ void foo(int n)
 
 /* { dg-final { scan-tree-dump "Executing store motion of global.y" "lim1" } } */
 /* { dg-final { scan-tree-dump "Moving statement.*global.x.*out of loop 1" "lim1" } } */
-/* { dg-final { cleanup-tree-dump "lim1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-lim-6.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-lim-6.c
@@ -11,4 +11,3 @@ void foo(void)
 }
 
 /* { dg-final { scan-tree-dump "Executing store motion of y" "lim1" } } */
-/* { dg-final { cleanup-tree-dump "lim1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-lim-7.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-lim-7.c
@@ -12,4 +12,3 @@ void foo (int *srcdata, int *dstdata)
 }
 
 /* { dg-final { scan-tree-dump "Moving statement" "lim1" } } */
-/* { dg-final { cleanup-tree-dump "lim1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-lim-8.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-lim-8.c
@@ -17,4 +17,3 @@ void foo (int n, int m)
 }
 
 /* { dg-final { scan-tree-dump-times "Moving PHI node" 1 "lim1"  } } */
-/* { dg-final { cleanup-tree-dump "lim1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-lim-9.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-lim-9.c
@@ -17,4 +17,3 @@ void foo (int n, int m)
 }
 
 /* { dg-final { scan-tree-dump-times "Moving PHI node" 1 "lim1"  } } */
-/* { dg-final { cleanup-tree-dump "lim1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-1.c
@@ -18,4 +18,3 @@ int foo(int argc, char **argv)
 /* We should eliminate one evaluation of b + c along the main path,
    causing one reload. */
 /* { dg-final { scan-tree-dump-times "Eliminated: 1" 1 "pre"} } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-10.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-10.c
@@ -12,4 +12,3 @@ void f(double a)
 }
 
 /* { dg-final { scan-tree-dump-times "Eliminated: 1" 1 "fre1"} } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-11.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-11.c
@@ -18,4 +18,3 @@ double f(double a)
 }
 
 /* { dg-final { scan-tree-dump-times "Eliminated: 1" 1 "pre"} } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-12.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-12.c
@@ -24,4 +24,3 @@ double f(double a)
 }
 
 /* { dg-final { scan-tree-dump-times "Eliminated: 1" 1 "pre"} } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-13.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-13.c
@@ -23,4 +23,3 @@ double f(double a)
 }
 
 /* { dg-final { scan-tree-dump-times "Eliminated: 1" 1 "pre"} } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-14.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-14.c
@@ -12,4 +12,3 @@ foo (const char *str)
     link_error ();
 }
 /* { dg-final { scan-tree-dump-times "link_error" 0 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-15.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-15.c
@@ -13,4 +13,3 @@ __SIZE_TYPE__ mystrlen (const char *s)
 }
 
 /* { dg-final { scan-rtl-dump "PART.. = 0" "expand" } } */
-/* { dg-final { cleanup-rtl-dump "expand" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-16.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-16.c
@@ -12,4 +12,3 @@ int foo(int k, int *x)
   return res;
 }
 /* { dg-final { scan-tree-dump-times "Eliminated: 1" 1 "pre"} } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-17.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-17.c
@@ -15,4 +15,3 @@ int foo(U *u, int b, int i)
 }
 
 /* { dg-final { scan-tree-dump "Eliminated: 1" "pre" } } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-18.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-18.c
@@ -18,4 +18,3 @@ int bar (int b)
 }
 
 /* { dg-final { scan-tree-dump "Replaced foo \\(f.y\\)" "pre" } } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-19.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-19.c
@@ -36,4 +36,3 @@ int foo (int i, int j, int k, int b)
 
 /* All three loads should be eliminated.  */
 /* { dg-final { scan-tree-dump "Eliminated: 3" "pre" } } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-2.c
@@ -21,4 +21,3 @@ int motion_test1(int data, int data_0, int data_3, int v)
    the main path. */
 /* { dg-final { scan-tree-dump-times "Eliminated: 2" 1 "pre" { xfail *-*-* } } } */
 /* { dg-final { scan-tree-dump-times "Eliminated: 1" 1 "pre" } } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-20.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-20.c
@@ -32,4 +32,3 @@ bb18:
 
 /* { dg-final { scan-tree-dump "New PHIs: 2" "pre" } } */
 /* { dg-final { scan-tree-dump "PHI <.*0\\\.0" "pre" } } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-21.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-21.c
@@ -12,4 +12,3 @@ NumSift (long *array, unsigned long k)
 /* There should be only two loads left.  */
 
 /* { dg-final { scan-tree-dump-times "= \\\*\[^\n;\]*;" 2 "pre" { xfail { ! size32plus } } } } */ /* xfail: PR tree-optimization/58169 */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-22.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-22.c
@@ -10,4 +10,3 @@ int foo (int i, int b)
 }
 
 /* { dg-final { scan-tree-dump "Eliminated: 1" "pre" } } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-23.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-23.c
@@ -10,4 +10,3 @@ void foo(int n)
 }
 
 /* { dg-final { scan-tree-dump "Eliminated: 3" "pre" } } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-24.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-24.c
@@ -12,4 +12,3 @@ void foo(int *p, double *x, int n)
    _not_ end up using the phi result for replacement *p.  */
 
 /* { dg-final { scan-tree-dump-not "= prephitmp" "pre" } } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-25.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-25.c
@@ -20,4 +20,3 @@ int foo (int x)
 /* We should eliminate the load from p for a PHI node with values 1 and 2.  */
 
 /* { dg-final { scan-tree-dump "Eliminated: 1" "pre" } } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-26.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-26.c
@@ -24,4 +24,3 @@ void foo(SA* pResult, SB* method, SC* self)
 }
 
 /* { dg-final { scan-tree-dump "Deleted redundant store" "fre1" } } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-27.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-27.c
@@ -25,4 +25,3 @@ int foo2 (int i, int j, int b)
 }
 
 /* { dg-final { scan-tree-dump-times "# prephitmp" 2 "pre" } } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-28.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-28.c
@@ -18,4 +18,3 @@ int foo (int i, int b, int result)
    i + 1 & -2 expression.  And do replacement with two PHI temps.  */
 
 /* { dg-final { scan-tree-dump-times "with prephitmp" 2 "pre" } } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-29.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-29.c
@@ -19,4 +19,3 @@ foo (void)
    about bark () possibly clobbering hoist.  */
 
 /* { dg-final { scan-tree-dump "Replaced hoist" "pre" } } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-3.c
@@ -12,4 +12,3 @@ unsigned foo1 (unsigned a, unsigned b)
 }
 /* We should eliminate both 4*b and 4*a from the main body of the loop */
 /* { dg-final { scan-tree-dump-times "Eliminated: 2" 1 "pre"} } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-30.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-30.c
@@ -25,4 +25,3 @@ bar (int b, int x)
    are using different types (of the same size).  */
 
 /* { dg-final { scan-tree-dump-times "Replaced MEM" 2 "pre" } } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-31.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-31.c
@@ -44,4 +44,3 @@ int foo (S1 *root, int N)
 } 
 
 /* { dg-final { scan-tree-dump-times "key" 4 "pre" } } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-4.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-4.c
@@ -12,4 +12,3 @@ int foo(void)
 /* We should eliminate the x+1 computation from this routine, replacing
    it with a phi of 3, 4 */
 /* { dg-final { scan-tree-dump-times "Eliminated: 1" 1 "pre"} } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-5.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-5.c
@@ -14,4 +14,3 @@ foo (int i)
    5  */
 /* { dg-final { scan-tree-dump-times "Eliminated: 1" 1 "pre"} } */
 /* { dg-final { scan-tree-dump-times "Insertions" 0 "pre"} } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-6.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-6.c
@@ -11,4 +11,3 @@ int foo(int x)
 /* We should eliminate one evaluation of x + 1 along the x = 2 path,
    causing one elimination.  */
 /* { dg-final { scan-tree-dump-times "Eliminated: 1" 1 "pre"} } */
-/* { dg-final { cleanup-tree-dump "pre" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-7.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-7.c
@@ -9,4 +9,3 @@ foo (int *array)
 }
 /* We should eliminate one load.  */
 /* { dg-final { scan-tree-dump-times "Eliminated: 1" 1 "fre1"} } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-8.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-8.c
@@ -22,4 +22,3 @@ foo (__SIZE_TYPE__ i, struct s *array)
 /* We used to eliminate a cast but that was before POINTER_PLUS_EXPR
    was added.  */
 /* { dg-final { scan-tree-dump-times "Eliminated: 4" 1 "fre1"} } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-9.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-9.c
@@ -10,4 +10,3 @@ foo (unsigned long a)
   return 0;
 }
 /* { dg-final { scan-tree-dump-times "return 0;" 0 "fre1"} } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-sccvn-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-sccvn-1.c
@@ -18,4 +18,3 @@ void vnum_test8(int *data)
 } 
 /* We should eliminate m - n, and set n = n + k into n = m. */
 /* { dg-final { scan-tree-dump-times "Eliminated: 3" 1 "fre1"} } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-sccvn-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-sccvn-2.c
@@ -22,4 +22,3 @@ int vnum_test8(int *data)
 /* We should eliminate m - n, and set n = n + k into n = m, and
    set p to 0 */
 /* { dg-final { scan-tree-dump-times "Eliminated: 4" 1 "fre1"} } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-sccvn-3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-sccvn-3.c
@@ -12,4 +12,3 @@ int main(int argc, char **argv)
 }
 /* We should eliminate result = *p by saying it has the value 2.  */
 /* { dg-final { scan-tree-dump-times "Eliminated: 1" 1 "fre1"} } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-sccvn-4.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-sccvn-4.c
@@ -24,4 +24,3 @@ int vnum_test8(int *data)
 /* We should eliminate m - n, n + k, set data[5] = 0, eliminate the
    address arithmetic for data[5], and set p = 0.
 /* { dg-final { scan-tree-dump-times "Eliminated: 5" 1 "fre1"} } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-sink-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-sink-1.c
@@ -8,4 +8,3 @@ foo (int a, int b, int c)
 }
 /* We should sink the x = a * b calculation into the branch that returns x. */
 /* { dg-final { scan-tree-dump-times "Sunk statements: 1" 1 "sink" } } */
-/* { dg-final { cleanup-tree-dump "sink" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-sink-10.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-sink-10.c
@@ -17,4 +17,3 @@ void foo (void)
 }
 
 /* { dg-final { scan-tree-dump-times "Sinking # VUSE" 4 "sink" } } */
-/* { dg-final { cleanup-tree-dump "sink" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-sink-11.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-sink-11.c
@@ -14,4 +14,3 @@ int foo (int v[], int a)
 }
 
 /* { dg-final { scan-tree-dump "MEM\\\[.* \\+ 252B\\\]" "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-sink-12.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-sink-12.c
@@ -15,4 +15,3 @@ int foo (int v1[], int v2[])
 }
 
 /* { dg-final { scan-tree-dump "MEM\\\[.* \\+ 252B\\\]" "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-sink-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-sink-2.c
@@ -10,4 +10,3 @@ bar (int a, int b, int c)
 }
 /* We should sink the x = a * b calculation into the else branch  */
 /* { dg-final { scan-tree-dump-times "Sunk statements: 1" 1 "sink" } } */
-/* { dg-final { cleanup-tree-dump "sink" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-sink-3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-sink-3.c
@@ -13,4 +13,3 @@ main (int argc)
 }
 /* We should sink the a = argc + 1 calculation into the if branch  */
 /* { dg-final { scan-tree-dump-times "Sunk statements: 1" 1 "sink" } } */
-/* { dg-final { cleanup-tree-dump "sink" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-sink-4.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-sink-4.c
@@ -18,4 +18,3 @@ main (int argc)
 }
 /* We should sink the first a = b + c calculation into the else branch  */
 /* { dg-final { scan-tree-dump-times "Sunk statements: 1" 1 "sink" } } */
-/* { dg-final { cleanup-tree-dump "sink" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-sink-5.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-sink-5.c
@@ -45,4 +45,3 @@ void foo(int16_t runs[], uint8_t alpha[], int x, int count)
 
 /* We should not sink the next_runs = runs + x calculation after the loop.  */
 /* { dg-final { scan-tree-dump-times "Sunk statements:" 0 "sink" } } */
-/* { dg-final { cleanup-tree-dump "sink" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-sink-6.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-sink-6.c
@@ -15,4 +15,3 @@ int foo(int *a, int r)
 /* *a = 1 should be sunk to the else block.  */
 
 /* { dg-final { scan-tree-dump-times "Sinking" 1 "sink" } } */
-/* { dg-final { cleanup-tree-dump "sink" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-sink-7.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-sink-7.c
@@ -16,4 +16,3 @@ int foo(int *a, int r, short *b)
 /* *a = 1 should be sunk to the else block.  */
 
 /* { dg-final { scan-tree-dump-times "Sinking" 1 "sink" } } */
-/* { dg-final { cleanup-tree-dump "sink" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-sink-8.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-sink-8.c
@@ -25,4 +25,3 @@ int foo(int *a, int r, short *b)
 /* *a = 1 should be sunk into the default case.  */
 
 /* { dg-final { scan-tree-dump-times "Sinking" 1 "sink" } } */
-/* { dg-final { cleanup-tree-dump "sink" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-sink-9.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-sink-9.c
@@ -16,4 +16,3 @@ int foo(int *a, int r, int *b)
 /* *a = 1 should be sunk to the else block.  */
 
 /* { dg-final { scan-tree-dump-times "Sinking" 1 "sink" } } */
-/* { dg-final { cleanup-tree-dump "sink" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-store-ccp-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-store-ccp-1.c
@@ -11,4 +11,3 @@ int f(void)
 /* There should be no reference to conststaticvariable as we should have
    inlined the 0. */
 /* { dg-final { scan-tree-dump-times "conststaticvariable" 0 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-store-ccp-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-store-ccp-2.c
@@ -11,4 +11,3 @@ int f(void)
 /* There should be a reference to conststaticvariable since it may
    may be overriden at link time.  */
 /* { dg-final { scan-tree-dump-times "conststaticvariable" 1 "optimized" { xfail { *-*-mingw* *-*-cygwin* } } } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-store-ccp-3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-store-ccp-3.c
@@ -15,4 +15,3 @@ int f(void)
    conststaticvariable as we should have inlined the 0. */
 /* { dg-final { scan-tree-dump-times "conststaticvariable" 0 "optimized" { target { pie_enabled || nonpic } } } } */
 /* { dg-final { scan-tree-dump-times "conststaticvariable" 1 "optimized" { target { { ! pie_enabled } && { ! nonpic } } } } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-store-ccp-4.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-store-ccp-4.c
@@ -13,4 +13,3 @@ int f(void)
 /* There should be a reference to conststaticvariable since it may
    may be overriden at run time.  */
 /* { dg-final { scan-tree-dump-times "conststaticvariable" 1 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-vrp-thread-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-vrp-thread-1.c
@@ -29,5 +29,4 @@ build_omp_regions_1 (basic_block bb, struct omp_region *parent,
 /* ARM Cortex-M defined LOGICAL_OP_NON_SHORT_CIRCUIT to false,
    so skip below test.  */
 /* { dg-final { scan-tree-dump-times "Threaded" 1 "vrp1" { target { ! arm_cortex_m } } } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/stdarg-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/stdarg-1.c
@@ -10,4 +10,3 @@ f1 (int i, ...)
 {
 }
 /* { dg-final { scan-tree-dump "f1: va_list escapes 0, needs to save 0 GPR units and 0 FPR units" "stdarg" } } */
-/* { dg-final { cleanup-tree-dump "stdarg" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/stdarg-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/stdarg-2.c
@@ -295,4 +295,3 @@ f15 (int i, ...)
 /* { dg-final { scan-tree-dump-not "f15: va_list escapes 0, needs to save 0 GPR units" "stdarg" { target { { i?86-*-* x86_64-*-* } && ia32 } } } } */
 /* { dg-final { scan-tree-dump-not "f15: va_list escapes 0, needs to save 0 GPR units" "stdarg" { target ia64-*-* } } } */
 /* { dg-final { scan-tree-dump-not "f15: va_list escapes 0, needs to save 0 GPR units" "stdarg" { target { powerpc*-*-* && lp64 } } } } */
-/* { dg-final { cleanup-tree-dump "stdarg" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/stdarg-3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/stdarg-3.c
@@ -190,4 +190,3 @@ f12 (int i, ...)
 /* { dg-final { scan-tree-dump "f12: va_list escapes 1, needs to save all GPR units" "stdarg" { target { { i?86-*-* x86_64-*-* } && ia32 } } } } */
 /* { dg-final { scan-tree-dump "f12: va_list escapes 1, needs to save all GPR units" "stdarg" { target ia64-*-* } } } */
 /* { dg-final { scan-tree-dump "f12: va_list escapes 1, needs to save all GPR units" "stdarg" { target { powerpc*-*-* && lp64 } } } } */
-/* { dg-final { cleanup-tree-dump "stdarg" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/stdarg-4.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/stdarg-4.c
@@ -91,4 +91,3 @@ f4 (int i, ...)
 /* { dg-final { scan-tree-dump "f4: va_list escapes 0, needs to save \[148\] GPR units" "stdarg" { target { { i?86-*-* x86_64-*-* } && ia32 } } } } */
 /* { dg-final { scan-tree-dump "f4: va_list escapes 0, needs to save \[148\] GPR units" "stdarg" { target ia64-*-* } } } */
 /* { dg-final { scan-tree-dump "f4: va_list escapes 0, needs to save \[148\] GPR units" "stdarg" { target { powerpc*-*-* && lp64 } } } } */
-/* { dg-final { cleanup-tree-dump "stdarg" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/stdarg-5.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/stdarg-5.c
@@ -116,4 +116,3 @@ f7 (int i, ...)
 /* { dg-final { scan-tree-dump "f7: va_list escapes 0, needs to save 0 GPR units and 64 FPR units" "stdarg" { target { { i?86-*-* x86_64-*-* } && { ! { ia32 || llp64 } } } } } } */
 /* { dg-final { scan-tree-dump "f7: va_list escapes 0, needs to save 32 GPR units and 2" "stdarg" { target alpha*-*-linux* } } } */
 /* { dg-final { scan-tree-dump "f7: va_list escapes 0, needs to save 2 GPR units and 0 FPR units" "stdarg" { target s390*-*-linux* } } } */
-/* { dg-final { cleanup-tree-dump "stdarg" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/stdarg-6.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/stdarg-6.c
@@ -33,4 +33,3 @@ bar (int x, char const *y, ...)
 /* { dg-final { scan-tree-dump "bar: va_list escapes 1, needs to save all GPR units" "stdarg" { target { { i?86-*-* x86_64-*-* } && ia32 } } } } */
 /* { dg-final { scan-tree-dump "bar: va_list escapes 1, needs to save all GPR units" "stdarg" { target ia64-*-* } } } */
 /* { dg-final { scan-tree-dump "bar: va_list escapes 1, needs to save all GPR units" "stdarg" { target { powerpc*-*-* && lp64 } } } } */
-/* { dg-final { cleanup-tree-dump "stdarg" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/stdarg-7.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/stdarg-7.c
@@ -19,4 +19,3 @@ foo (int x, ...)
 }
 
 /* { dg-final { scan-tree-dump "foo: va_list escapes 1, needs to save all GPR units and all FPR units" "stdarg" } } */
-/* { dg-final { cleanup-tree-dump "stdarg" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/strlen-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/strlen-1.c
@@ -14,4 +14,3 @@ void wreg_twice(void)
 
 /* We should not remove the second null character store to (base+42) address. */
 /* { dg-final { scan-tree-dump-times " ={v} 0;" 2 "optimized" } }  */
-/* { dg-final { cleanup-tree-dump "optimized" } }  */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/struct-aliasing-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/struct-aliasing-1.c
@@ -12,4 +12,3 @@ foo (float *r, struct S *p)
 }
 
 /* { dg-final { scan-tree-dump "Replaced\[^\n\]*with i_." "fre1" } } */
-/* { dg-final { cleanup-tree-dump "fre1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/struct-aliasing-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/struct-aliasing-2.c
@@ -15,5 +15,4 @@ foo ( struct S *p)
 /* There should only be one load of p->f because FRE removes the redundancy
    by realizing it can cast the result of either to the other.  */
 /* { dg-final { scan-tree-dump-times "= \[^\n\]*p_.\\\(D\\\)" 1 "cddce1" } } */
-/* { dg-final { cleanup-tree-dump "cddce1" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/structopt-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/structopt-1.c
@@ -12,4 +12,3 @@ int foo() {
 
 /* { dg-final { scan-tree-dump-times "Executing store motion of global.y" 1 "lim1" } } */
 /* XXX: We should also check for the load motion of global.x, but there is no easy way to do this.  */
-/* { dg-final { cleanup-tree-dump "lim1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/structopt-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/structopt-2.c
@@ -43,4 +43,3 @@ int main(void)
 /* { dg-final { scan-tree-dump-times "a.f" 0 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "a.g" 0 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "b.e" 0 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/structopt-3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/structopt-3.c
@@ -14,4 +14,3 @@ int main(void)
 	return temp.a + temp.b;
 }
 /* { dg-final { scan-tree-dump-times "return 11" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/tailcall-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/tailcall-1.c
@@ -17,4 +17,3 @@ t(int a)
 	return r;
 }
 /* { dg-final { scan-tree-dump-times "Found tail call" 1 "tailc"} } */
-/* { dg-final { cleanup-tree-dump "tailc" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/tailcall-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/tailcall-2.c
@@ -21,4 +21,3 @@ foo (int *x)
    variables, they ought to be ignored.  There should be two tail
    calls here.  */
 /* { dg-final { scan-tree-dump-times "Found tail call" 2 "tailc"} } */
-/* { dg-final { cleanup-tree-dump "tailc" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/tailcall-4.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/tailcall-4.c
@@ -12,5 +12,4 @@ longValue ()
 
 /* We should not tail call doubleValue in longValue as the mode changes. */
 /* { dg-final { scan-tree-dump-times "Found tail call" 0 "tailc"} } */
-/* { dg-final { cleanup-tree-dump "tailc" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/tailcall-5.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/tailcall-5.c
@@ -9,4 +9,3 @@ set_integer (void *dest, int value, int length)
 }
 
 /* { dg-final { scan-tree-dump-not "tail call" "tailc" } } */
-/* { dg-final { cleanup-tree-dump "tailc" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/tailrecursion-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/tailrecursion-1.c
@@ -9,4 +9,3 @@ t(int a)
 		return 0;
 }
 /* { dg-final { scan-tree-dump-times "Eliminated tail recursion" 1 "tailr1"} } */
-/* { dg-final { cleanup-tree-dump "tailr1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/tailrecursion-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/tailrecursion-2.c
@@ -10,4 +10,3 @@ t(char *a)
 		return 0;
 }
 /* { dg-final { scan-tree-dump-times "Eliminated tail recursion" 1 "tailr1"} } */
-/* { dg-final { cleanup-tree-dump "tailr1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/tailrecursion-3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/tailrecursion-3.c
@@ -13,4 +13,3 @@ t(int a)
 	return r;
 }
 /* { dg-final { scan-tree-dump-times "Eliminated tail recursion" 1 "tailr1"} } */
-/* { dg-final { cleanup-tree-dump "tailr1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/tailrecursion-4.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/tailrecursion-4.c
@@ -15,4 +15,3 @@ t(int a)
 	return r;
 }
 /* { dg-final { scan-tree-dump-times "Eliminated tail recursion" 2 "tailr1"} } */
-/* { dg-final { cleanup-tree-dump "tailr1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/tailrecursion-5.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/tailrecursion-5.c
@@ -74,4 +74,3 @@ int main(void)
 /* There is one recursive call to fib.  */
 /* { dg-final { scan-tree-dump-times "\\mfib\\M" 5 "optimized"} } */
 
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/tailrecursion-6.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/tailrecursion-6.c
@@ -9,4 +9,3 @@ foo (int a)
 		return 0;
 }
 /* { dg-final { scan-tree-dump-times "Eliminated tail recursion" 1 "tailr1"} } */
-/* { dg-final { cleanup-tree-dump "tailr1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/tailrecursion-7.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/tailrecursion-7.c
@@ -37,4 +37,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "\\mbar\\M" 4 "optimized"} } */
 /* { dg-final { scan-tree-dump-times "\\mbaz\\M" 4 "optimized"} } */
 
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/unreachable.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/unreachable.c
@@ -12,4 +12,3 @@ main()
   return 0;
 }
 /* { dg-final { scan-tree-dump-not "bad_boy" "optimized" { target { ! keeps_null_pointer_checks } } } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/upcast-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/upcast-1.c
@@ -9,4 +9,3 @@ Foo *bar(void)
 }
 
 /* { dg-final { scan-tree-dump "&foo;" "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/update-cunroll.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/update-cunroll.c
@@ -10,4 +10,3 @@ int t()
 	return i;
 }
 /* { dg-final { scan-tree-dump-times "Invalid sum" 0 "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/update-threading.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/update-threading.c
@@ -21,4 +21,3 @@ main (int argc, char **argv)
   exit (0);
 }
 /* { dg-final { scan-tree-dump-times "Invalid sum" 0 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/update-unroll-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/update-unroll-1.c
@@ -18,4 +18,3 @@ int foo(unsigned n)
 
 /* { dg-final { scan-tree-dump-not "Invalid sum" "aprefetch"} } */
 /* { dg-final { scan-tree-dump-not "SUCC: 7 .100.0%" "aprefetch"} } */
-/* { dg-final { cleanup-tree-dump "aprefetch" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/update-unswitch-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/update-unswitch-1.c
@@ -21,4 +21,3 @@ int bla(int p)
 
 /* { dg-final { scan-tree-dump-not "Invalid sum" "unswitch"} } */
 /* { dg-final { scan-tree-dump-not "SUCC: 3 .100.0%" "unswitch"} } */
-/* { dg-final { cleanup-tree-dump "unswitch" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/useless-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/useless-1.c
@@ -14,4 +14,3 @@ foo (void)
    GIMPLE lowering, at the cost of an extra statement, label,
    and basic block.  */
 /* { dg-final { scan-tree-dump-times "goto" 3 "gimple"} } */ 
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vector-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vector-1.c
@@ -28,6 +28,5 @@ float f3(vector float t)
 
 /* { dg-final { scan-tree-dump-times "BIT_FIELD_REF" 4 "gimple"} } */
 
-/* { dg-final { cleanup-tree-dump "gimple" } } */
 
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vector-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vector-2.c
@@ -20,4 +20,3 @@ float f(vector float a, int b, vector float c)
 /* { dg-final { scan-tree-dump-not "BIT_FIELD_REF" "optimized"} } */
 /* { dg-final { scan-tree-dump-times "return 0.0" 1 "optimized"} } */
 
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vector-3.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vector-3.c
@@ -16,5 +16,4 @@ float f(float b)
 /* { dg-final { scan-tree-dump-times "BIT_FIELD_REF" 0 "optimized"} } */
 /* { dg-final { scan-tree-dump-times "0\\\.0" 1 "optimized"} } */
 
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vector-4.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vector-4.c
@@ -13,4 +13,3 @@ v4si vs (v4si a, v4si b)
 /* Test is xfailed on 32-bit hppa*-*-* because target-callee-copies.  */
 /* { dg-final { scan-tree-dump-times "VEC_PERM_EXPR <a, b, { 0, 4, 1, 5 }>;" 1 "gimple" { xfail { hppa*-*-* && { ! lp64 } } } } } */
 
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp01.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp01.c
@@ -26,4 +26,3 @@ foo (int *p, int i)
 }
 
 /* { dg-final { scan-tree-dump-times "Folding predicate p_.*to 1" 1 "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp02.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp02.c
@@ -23,4 +23,3 @@ foo (struct A *p, struct A *q)
 /* Target with fno-delete-null-pointer-checks should not fold check */
 /* { dg-final { scan-tree-dump-times "Folding predicate p_.*to 1" 1 "vrp1" { target { ! keeps_null_pointer_checks } } } } */
 /* { dg-final { scan-tree-dump-times "Folding predicate p_.*to 1" 0 "vrp1" { target {   keeps_null_pointer_checks } } } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp03.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp03.c
@@ -33,4 +33,3 @@ foo (struct A *p, struct A *q)
 
 /* { dg-final { scan-tree-dump-times "Folding predicate q_.*to 1" 1 "vrp1" } } */
 /* { dg-final { scan-tree-dump-times "Folding predicate r_.*to 1" 1 "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp04.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp04.c
@@ -11,4 +11,3 @@ foo (int a, int b)
 }
 
 /* { dg-final { scan-tree-dump-times "Folding predicate a_.*to 1" 1 "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp05.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp05.c
@@ -28,4 +28,3 @@ foo (int k, int j)
 }
 
 /* { dg-final { scan-tree-dump-times "Folding predicate j_.*to 1" 1 "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp06.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp06.c
@@ -31,4 +31,3 @@ foo (int i, int j, int a)
 /* { dg-final { scan-tree-dump-times "Folding predicate i_\[0-9\]+.*0 to 0" 1 "vrp1" } } */
 /* { dg-final { scan-tree-dump-times "Folding predicate j_\[0-9\]+.*0 to 1" 1 "vrp1" } } */
 /* { dg-final { scan-tree-dump-times "Folding predicate i_\[0-9]+.*j_\[0-9\]+.* to 0" 1 "vrp1" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp07.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp07.c
@@ -37,4 +37,3 @@ foo (int i, int *p)
 
 /* { dg-final { scan-tree-dump-times "PREDICATE: p_\[0-9\]" 2 "vrp1" { target { ! keeps_null_pointer_checks } } } } */
 /* { dg-final { scan-tree-dump-times "PREDICATE: p_\[0-9\]" 1 "vrp1" { target {   keeps_null_pointer_checks } } } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp08.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp08.c
@@ -22,4 +22,3 @@ foo (int a, int *p)
 /* { dg-final { scan-tree-dump-times "Folding predicate p_.*to 1" 1 "vrp1" { target { ! keeps_null_pointer_checks } } } } */
 /* { dg-final { scan-tree-dump-times "PREDICATE: p_.* ne_expr 0" 1 "vrp1" { target { ! keeps_null_pointer_checks } } } } */
 /* { dg-final { scan-tree-dump-times "Folding predicate p_.*to 1" 0 "vrp1" { target {   keeps_null_pointer_checks } } } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp09.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp09.c
@@ -28,4 +28,3 @@ L78:
 }
 
 /* { dg-final { scan-tree-dump-times "Folding predicate p_.. != 0B to 1" 2 "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp11.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp11.c
@@ -24,4 +24,3 @@ foo (int k, int j, int z)
 }
 
 /* { dg-final { scan-tree-dump-times "Folding predicate.*to 1" 1 "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp15.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp15.c
@@ -30,5 +30,4 @@ blah (tree t)
 }
 
 /* { dg-final { scan-tree-dump-times "tree_code_length.42." 1 "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp16.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp16.c
@@ -19,5 +19,4 @@ nonlocal_mentioned_p (rtx x)
 }
 
 /* { dg-final { scan-tree-dump-times "Folding predicate .*to 0" 1 "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp17.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp17.c
@@ -28,5 +28,4 @@ gimplify_for_stmt (tree stmt)
 }
 
 /* { dg-final { scan-tree-dump-times "Simplified relational" 1 "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp18.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp18.c
@@ -31,4 +31,3 @@ void foo (void)
 }
 
 /* { dg-final { scan-tree-dump-times "Simplified relational" 1 "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp19.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp19.c
@@ -24,4 +24,3 @@ int g (int b) {
 }
 /* { dg-final { scan-tree-dump "Folding predicate a_. < 0 to 0" "vrp1" } } */
 /* { dg-final { scan-tree-dump "Folding predicate b_. >= 0 to 1" "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp20.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp20.c
@@ -25,4 +25,3 @@ int g (int b) {
 
 /* { dg-final { scan-tree-dump "Folding predicate a_. == 0 to 0" "vrp1" } } */
 /* { dg-final { scan-tree-dump "Folding predicate b_. != 0 to 1" "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp21.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp21.c
@@ -24,4 +24,3 @@ void test02(unsigned int a, unsigned int b)
 }
 
 /* { dg-final { scan-tree-dump-times "link_error" 0 "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp22.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp22.c
@@ -14,4 +14,3 @@ void test02(unsigned int a, unsigned int b)
 }
 
 /* { dg-final { scan-tree-dump-times "link_error" 0 "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp23.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp23.c
@@ -46,5 +46,4 @@ L8:
    only way to reach the test is when n_sets <= 1, and the only value
    which satisfies both conditions is n_sets == 1.  */
 /* { dg-final { scan-tree-dump-times "Simplified relational" 1 "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp24.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp24.c
@@ -92,5 +92,4 @@ L7:
    as the only way to reach the tests is when n_sets <= 1 and the only
    value which satisfies both conditions is n_sets == 1.  */
 /* { dg-final { scan-tree-dump-times "Simplified relational" 2 "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp25.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp25.c
@@ -50,5 +50,4 @@ L9:
    both totally subsumed by earlier tests and thus should be folded
    away using VRP.  */
 /* { dg-final { scan-tree-dump-times "Folding predicate" 2 "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp26.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp26.c
@@ -9,8 +9,7 @@ foo(int a)
 }
 
 /* VRP should optimize this to a trivial "return 1".   */
-/* { dg-final { scan-tree-dump-times "return 1" 1 "vrp1" } } * /
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
+/* { dg-final { scan-tree-dump-times "return 1" 1 "vrp1" } } */
 
 
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp28.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp28.c
@@ -26,7 +26,6 @@ int f3 (unsigned char c)
     return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "if " 0 "vrp1" } } * /
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
+/* { dg-final { scan-tree-dump-times "if " 0 "vrp1" } } */
 
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp31.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp31.c
@@ -10,5 +10,4 @@ int f(int i)
 }
 
 /* { dg-final { scan-tree-dump "return 0;" "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp32.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp32.c
@@ -10,5 +10,4 @@ int f(int i)
 }
 
 /* { dg-final { scan-tree-dump "return 0;" "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp33.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp33.c
@@ -6,4 +6,3 @@
 int f2(int x) { return x == 1 || x == 3 || x == 1; }
 
 /* { dg-final { scan-tree-dump "Folding predicate.*== 1 to 0" "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp34.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp34.c
@@ -17,4 +17,3 @@ foo (int a)
 
 /* { dg-final { scan-tree-dump "Folding predicate a_. > 2 to 1" "vrp1" } } */
 /* { dg-final { scan-tree-dump "Folding predicate a_. <= 5 to 1" "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp35.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp35.c
@@ -12,4 +12,3 @@ int test1(int i, int k)
 }
 
 /* { dg-final { scan-tree-dump "Folding predicate j_.* == 10 to 0" "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp36.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp36.c
@@ -9,4 +9,3 @@ int foo(int i)
 }
 
 /* { dg-final { scan-tree-dump "Folding predicate i_.* == 1 to 0" "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp40.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp40.c
@@ -15,4 +15,3 @@ int f(int a) {
 }
 
 /* { dg-final { scan-tree-dump "return 3;" "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp41.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp41.c
@@ -24,4 +24,3 @@ foo (int a)
 }
 
 /* { dg-final { scan-tree-dump-not "case 99:" "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp46.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp46.c
@@ -28,4 +28,3 @@ func_18 ( int t )
 /* There should be a single if left.  */
 
 /* { dg-final { scan-tree-dump-times "if" 1 "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp47.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp47.c
@@ -44,6 +44,3 @@ int f(int x)
    either 0 or 1.  */
 /* { dg-final { scan-tree-dump-times " & 1;" 0 "vrp2" } } */
 
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "dom1" } } */
-/* { dg-final { cleanup-tree-dump "vrp2" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp50.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp50.c
@@ -31,4 +31,3 @@ int baz (int x, int y)
 }
 
 /* { dg-final { scan-tree-dump-times "return 1;" 3 "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp52.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp52.c
@@ -13,4 +13,3 @@ foo (unsigned int i, unsigned int j)
 }
 
 /* { dg-final { scan-tree-dump-times "return 1;" 1 "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp53.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp53.c
@@ -21,4 +21,3 @@ f2 (int x)
 
 /* { dg-final { scan-tree-dump-not "\& (2047|0x7ff)" "vrp1" } } */
 /* { dg-final { scan-tree-dump-not "\\| (17408|0x4400)" "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp54.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp54.c
@@ -31,4 +31,3 @@ void bar (void)
 }
 
 /* { dg-final { scan-tree-dump-not "link_error" "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp55.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp55.c
@@ -14,5 +14,4 @@ fu (char *p, int x)
 
 /* { dg-final { scan-tree-dump-times "Threaded jump" 1 "vrp1" { target { ! keeps_null_pointer_checks } } } } */
 /* { dg-final { scan-tree-dump-times "Threaded jump" 0 "vrp1" { target {   keeps_null_pointer_checks } } } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp56.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp56.c
@@ -39,5 +39,4 @@ cleanup_empty_eh (basic_block bb)
     }
 }
 /* { dg-final { scan-tree-dump-times "Threaded" 1 "vrp1"} } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp57.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp57.c
@@ -14,4 +14,3 @@ int bar(_Bool b)
 
 /* { dg-final { scan-tree-dump "return 0;" "optimized" } } */
 /* { dg-final { scan-tree-dump "return 1;" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp58.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp58.c
@@ -10,4 +10,3 @@ foo (long long a, signed char b, signed char c)
 
 /* { dg-final { scan-tree-dump "Folded into" "vrp1" { target int32plus } } } */
 /* { dg-final { scan-tree-dump "Folding statement: _\[0-9\]\* = \\(long long int\\) bc_\[0-9\]\*;" "vrp1" { target int16 } } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp59.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp59.c
@@ -32,4 +32,3 @@ int h(int x)
 }
 
 /* { dg-final { scan-tree-dump-not " & 3;" "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp60.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp60.c
@@ -28,4 +28,3 @@ int bar (int x, int b)
 }
 
 /* { dg-final { scan-tree-dump-not "12345" "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp61.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp61.c
@@ -13,4 +13,3 @@ int f (int x, int y)
 }
 
 /* { dg-final { scan-tree-dump-not "1234" "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp67.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp67.c
@@ -37,4 +37,3 @@ unsigned baz (unsigned i)
 }
 
 /* { dg-final { scan-tree-dump-times "Folding predicate" 3 "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp68.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp68.c
@@ -15,4 +15,3 @@ int main() { }
 /* VRP will arbitrarily choose ~[1, 1] when merging [2, 6] with ~[1, 7].  */
 
 /* { dg-final { scan-tree-dump-times "link_error" 0 "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp69.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp69.c
@@ -35,4 +35,3 @@ void test5(unsigned int i)
 int main() {}
 
 /* { dg-final { scan-tree-dump-times "link_error" 0 "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp70.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp70.c
@@ -25,4 +25,3 @@ bar (unsigned int s)
 }
 
 /* { dg-final { scan-tree-dump-not "link_error" "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp71.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp71.c
@@ -19,4 +19,3 @@ int bar(char c)
 }
 
 /* { dg-final { scan-tree-dump-times "return 0;" 2 "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp77.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp77.c
@@ -44,4 +44,3 @@ void g(unsigned T x)
 }
 
 /* { dg-final { scan-tree-dump-not "impossible" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp79.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp79.c
@@ -20,4 +20,3 @@ void f (NT x, NT y)
 }
 
 /* { dg-final { scan-tree-dump "do_not_go_away" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp81.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp81.c
@@ -33,6 +33,5 @@ main ()
 }
 
 /* { dg-final { scan-tree-dump-times "vrp_keep \\(" 2 "vrp1"} } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
 
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp83.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp83.c
@@ -57,4 +57,3 @@ f4 (unsigned int s, unsigned int b)
 }
 
 /* { dg-final { scan-tree-dump-times "vrp_keep \\(" 6 "vrp1"} } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp84.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp84.c
@@ -18,4 +18,3 @@ f2 (int s, int b)
 }
 
 /* { dg-final { scan-tree-dump-times "vrp_keep \\(" 1 "vrp1"} } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp85.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp85.c
@@ -37,4 +37,3 @@ main ()
 }
 
 /* { dg-final { scan-tree-dump-not "link_error" "vrp1"} } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp86.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp86.c
@@ -25,4 +25,3 @@ foo (unsigned T x)
 
 /* { dg-final { scan-tree-dump "fn1call" "vrp1"} } */
 /* { dg-final { scan-tree-dump "fn2call" "vrp1"} } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp87.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp87.c
@@ -79,6 +79,4 @@ bitmap_ior_into (bitmap a, const_bitmap b)
 /* Verify that DCE after VRP2 eliminates a dead conversion
    to a (Bool).  */
 /* { dg-final { scan-tree-dump "Deleting.*_Bool.*;" "cddce2"} } */
-/* { dg-final { cleanup-tree-dump "vrp2" } } */
-/* { dg-final { cleanup-tree-dump "cddce2" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp88.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp88.c
@@ -34,6 +34,5 @@ bitmap_single_bit_set_p (const_bitmap a)
 
 /* Verify that VRP simplified an "if" statement.  */
 /* { dg-final { scan-tree-dump "Folded into: if.*" "vrp1"} } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
 
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp89.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp89.c
@@ -2,7 +2,6 @@
 /* { dg-do compile } */
 /* { dg-options "-O2 -fdump-tree-vrp1" } */
 /* { dg-final { scan-tree-dump-not "link_error" "vrp1"} } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
 
 #define A(fn, arg, min, max) \
   if (__builtin_##fn (arg) < min || __builtin_##fn (arg) > max) \
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp90.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp90.c
@@ -1,7 +1,6 @@
 /* { dg-do link } */
 /* { dg-options "-O2 -fdump-tree-vrp1" } */
 /* { dg-final { scan-tree-dump-not "link_error" "vrp1"} } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
 
 extern void link_error (void);
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp91.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp91.c
@@ -19,4 +19,3 @@ void foo ()
 }
 
 /* { dg-final { scan-tree-dump "\\\[0, 7\\\]" "vrp2" } } */
-/* { dg-final { cleanup-tree-dump "vrp2" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp92.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp92.c
@@ -20,4 +20,3 @@ int foo (int i, int j)
 
 /* { dg-final { scan-tree-dump "res_.: \\\[1, 1\\\]" "vrp1" } } */
 /* { dg-final { scan-tree-dump-not "Threaded" "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp93.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp93.c
@@ -3,7 +3,6 @@
 /* { dg-do compile } */
 /* { dg-options "-O2 -fdump-tree-vrp1" } */
 /* { dg-final { scan-tree-dump-not "link_error" "vrp1"} } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
 
 #define A(fn, arg, min, max) \
   if (__builtin_##fn (arg) < min || __builtin_##fn (arg) > max) \
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp94.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp94.c
@@ -34,4 +34,3 @@ foo2 (unsigned int x, unsigned int y)
 }
 
 /* { dg-final { scan-tree-dump-not "abort" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp95.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp95.c
@@ -47,4 +47,3 @@ range (unsigned long long int x, int y)
 
 /* { dg-final { scan-tree-dump-not "link_error" "vrp1" } } */
 /* { dg-final { scan-tree-dump "required_check" "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/vrp96.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp96.c
@@ -50,4 +50,3 @@ baz (T b, T c)
 
 /* { dg-final { scan-tree-dump-not "link_error" "vrp1" } } */
 /* { dg-final { scan-tree-dump-times "required_check" 2 "vrp1" } } */
-/* { dg-final { cleanup-tree-dump "vrp1" } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/vrp97.c
@@ -0,0 +1,18 @@
+/* PR tree-optimization/64454 */
+/* { dg-options "-O2 -fdump-tree-vrp1" } */
+
+int f(int a, int b)
+{
+    if (a < -3 || a > 13) __builtin_unreachable();
+    if (b < -6 || b > 9) __builtin_unreachable();
+    int c = a % b;
+    return c >= -3 && c <= 8;
+}
+
+int g(int a, int b)
+{
+  int c = a % b;
+  return c != -__INT_MAX__ - 1;
+}
+
+/* { dg-final { scan-tree-dump-times "return 1;" 2 "vrp1" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/wholeprogram-1.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/wholeprogram-1.c
@@ -20,5 +20,4 @@ main ()
 /* Function should be inlined as called once.  */
 /* { dg-final { scan-tree-dump-not "large_function" "optimized"} } */
 
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/wholeprogram-2.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/wholeprogram-2.c
@@ -5,4 +5,3 @@ externally_visible_function ()
 {
 }
 /* { dg-final { scan-tree-dump "externally_visible_function" "optimized"} } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/writeonly.c
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/writeonly.c
@@ -18,4 +18,3 @@ t()
 /* { dg-final { scan-tree-dump "magic2" "optimized"} } */
 /* { dg-final { scan-tree-dump "foo" "optimized"} } */
  
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/ucnid-6.c
+++ b/src/gcc/testsuite/gcc.dg/ucnid-6.c
@@ -26,4 +26,3 @@ int main (void)
   
   return 0;
 }
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.dg/union-4.c
+++ b/src/gcc/testsuite/gcc.dg/union-4.c
@@ -20,4 +20,3 @@ void foo(void)
 }
 
 /* { dg-final { scan-rtl-dump-not "abort" "cse1" { target i?86-*-* x86_64-*-* } } } */
-/* { dg-final { cleanup-rtl-dump "cse1" } } */
--- a/src/gcc/testsuite/gcc.dg/unroll-3.c
+++ b/src/gcc/testsuite/gcc.dg/unroll-3.c
@@ -29,4 +29,3 @@ int foo2(void)
 }
 
 /* { dg-final { scan-tree-dump-times "loop with 3 iterations completely unrolled" 1 "cunrolli" } } */
-/* { dg-final { cleanup-tree-dump "cunrolli" } } */
--- a/src/gcc/testsuite/gcc.dg/unroll-4.c
+++ b/src/gcc/testsuite/gcc.dg/unroll-4.c
@@ -29,4 +29,3 @@ int foo2(void)
 }
 
 /* { dg-final { scan-tree-dump-times "loop with 3 iterations completely unrolled" 1 "cunrolli" } } */
-/* { dg-final { cleanup-tree-dump "cunrolli" } } */
--- a/src/gcc/testsuite/gcc.dg/unroll-5.c
+++ b/src/gcc/testsuite/gcc.dg/unroll-5.c
@@ -29,4 +29,3 @@ int foo2(void)
 }
 
 /* { dg-final { scan-tree-dump-times "loop with 3 iterations completely unrolled" 1 "cunrolli" } } */
-/* { dg-final { cleanup-tree-dump "cunrolli" } } */
--- a/src/gcc/testsuite/gcc.dg/unroll-6.c
+++ b/src/gcc/testsuite/gcc.dg/unroll-6.c
@@ -32,4 +32,3 @@ int t2()
 /* { dg-final { scan-rtl-dump-not "realistic bound: 999999" "loop2_unroll" } } */
 /* { dg-final { scan-rtl-dump-times "upper bound: 2999999" 1 "loop2_unroll" } } */
 /* { dg-final { scan-rtl-dump-times "realistic bound: 2999999" 1 "loop2_unroll" } } */
-/* { dg-final { cleanup-rtl-dump "loop2_unroll" } } */
--- a/src/gcc/testsuite/gcc.dg/var-expand1.c
+++ b/src/gcc/testsuite/gcc.dg/var-expand1.c
@@ -26,4 +26,3 @@ int main (void)
 }
 
 /* { dg-final { scan-rtl-dump "Expanding Accumulator" "loop2_unroll" } } */
-/* { dg-final { cleanup-rtl-dump "loop2_unroll" } } */
--- a/src/gcc/testsuite/gcc.dg/var-expand3.c
+++ b/src/gcc/testsuite/gcc.dg/var-expand3.c
@@ -51,7 +51,6 @@ main (void)
 }
 
 /* { dg-final { scan-rtl-dump "Expanding Accumulator" "loop2_unroll" } } */
-/* { dg-final { cleanup-rtl-dump "loop2_unroll" } } */
 
 
 
--- a/src/gcc/testsuite/gcc.dg/vect/O-pr46167.c
+++ b/src/gcc/testsuite/gcc.dg/vect/O-pr46167.c
@@ -8,4 +8,3 @@ int foo (char c, int i)
   return s;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/O1-pr33854.c
+++ b/src/gcc/testsuite/gcc.dg/vect/O1-pr33854.c
@@ -18,5 +18,4 @@ void uniform_correlation_matrix (VMatrix * v)
     xbar[i] /= m;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/O1-pr41008.c
+++ b/src/gcc/testsuite/gcc.dg/vect/O1-pr41008.c
@@ -19,5 +19,4 @@ void map_do()
   foo (jsav, ksav);
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/O3-pr36098.c
+++ b/src/gcc/testsuite/gcc.dg/vect/O3-pr36098.c
@@ -18,4 +18,3 @@ void foo (int ncons, t_sortblock *sb, int *iatom)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 0 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/O3-pr39675-2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/O3-pr39675-2.c
@@ -28,5 +28,4 @@ foo ()
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  { target vect_strided4 } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect" { target vect_strided4 } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/O3-pr41881.c
+++ b/src/gcc/testsuite/gcc.dg/vect/O3-pr41881.c
@@ -26,5 +26,4 @@ TYPE fun2(TYPE *x, TYPE *y, unsigned int n)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 2 "vect" { target { vect_int_mult && {! vect_no_align } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/O3-pr45971.c
+++ b/src/gcc/testsuite/gcc.dg/vect/O3-pr45971.c
@@ -9,5 +9,4 @@ foo (int *x, int *y)
     y[i] = (x[i] == 1) ? i + 1 : -(i + 1);
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/O3-pr46077.c
+++ b/src/gcc/testsuite/gcc.dg/vect/O3-pr46077.c
@@ -7,4 +7,3 @@ void intf_pcmPlayEffect(int *src, int *dst, int size) {
   *dst++ = *src & 0x80 ? (*src++ & 0x7f) : -*src++;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/O3-pr49087.c
+++ b/src/gcc/testsuite/gcc.dg/vect/O3-pr49087.c
@@ -34,4 +34,3 @@ foo (int arg)
     }
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/O3-slp-reduc-10.c
+++ b/src/gcc/testsuite/gcc.dg/vect/O3-slp-reduc-10.c
@@ -40,4 +40,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 2 "vect" { target { vect_int_mult && {! vect_no_align } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/O3-vect-pr32243.c
+++ b/src/gcc/testsuite/gcc.dg/vect/O3-vect-pr32243.c
@@ -24,4 +24,3 @@ put_mono_values_s8 (GLcontext * ctx, struct gl_renderbuffer *s8rb,
   dsrb->PutValues (ctx, dsrb, count, x, y, temp, mask);
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/O3-vect-pr34223.c
+++ b/src/gcc/testsuite/gcc.dg/vect/O3-vect-pr34223.c
@@ -30,4 +30,3 @@ int main()
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_int_mult } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/O3-vect-pr61917.c
+++ b/src/gcc/testsuite/gcc.dg/vect/O3-vect-pr61917.c
@@ -11,4 +11,3 @@ fn1 ()
   return d; 
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/Os-vect-95.c
+++ b/src/gcc/testsuite/gcc.dg/vect/Os-vect-95.c
@@ -57,4 +57,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 0 loops" 2 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 0 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/aligned-section-anchors-nest-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/aligned-section-anchors-nest-1.c
@@ -31,4 +31,3 @@ int *foo(void)
 }
 
 /* { dg-final { scan-ipa-dump-times "Increasing alignment of decl" 3 "increase_alignment" } } */
-/* { dg-final { cleanup-ipa-dump "increase_alignment" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/bb-slp-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/bb-slp-1.c
@@ -57,6 +57,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "basic block vectorized" 1 "slp1" } } */
-/* { dg-final { cleanup-tree-dump "slp1" } } */
-/* { dg-final { cleanup-tree-dump "slp2" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/bb-slp-10.c
+++ b/src/gcc/testsuite/gcc.dg/vect/bb-slp-10.c
@@ -51,5 +51,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump "unsupported alignment in basic block." "slp2" { xfail vect_element_align } } } */
 /* { dg-final { scan-tree-dump-times "basic block vectorized" 1 "slp2" { target vect_element_align } } } */
-/* { dg-final { cleanup-tree-dump "slp2" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/bb-slp-11.c
+++ b/src/gcc/testsuite/gcc.dg/vect/bb-slp-11.c
@@ -50,5 +50,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "basic block vectorized" 1 "slp2" { target vect64 } } } */
-/* { dg-final { cleanup-tree-dump "slp2" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/bb-slp-13.c
+++ b/src/gcc/testsuite/gcc.dg/vect/bb-slp-13.c
@@ -47,5 +47,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "basic block vectorized" 1 "slp2" { target vect_int_mult } } } */
-/* { dg-final { cleanup-tree-dump "slp2" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/bb-slp-14.c
+++ b/src/gcc/testsuite/gcc.dg/vect/bb-slp-14.c
@@ -48,5 +48,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "basic block vectorized" 0 "slp2"  } } */
-/* { dg-final { cleanup-tree-dump "slp2" } } */
-  
--- a/src/gcc/testsuite/gcc.dg/vect/bb-slp-15.c
+++ b/src/gcc/testsuite/gcc.dg/vect/bb-slp-15.c
@@ -52,5 +52,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "basic block vectorized" 1 "slp2" { target vect_int_mult } } } */
-/* { dg-final { cleanup-tree-dump "slp2" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/bb-slp-16.c
+++ b/src/gcc/testsuite/gcc.dg/vect/bb-slp-16.c
@@ -66,6 +66,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "basic block vectorized" 1 "slp1" } } */
-/* { dg-final { cleanup-tree-dump "slp1" } } */
-/* { dg-final { cleanup-tree-dump "slp2" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/bb-slp-17.c
+++ b/src/gcc/testsuite/gcc.dg/vect/bb-slp-17.c
@@ -58,5 +58,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "basic block vectorized" 1 "slp2" { target vect_int_mult } } } */
-/* { dg-final { cleanup-tree-dump "slp2" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/bb-slp-18.c
+++ b/src/gcc/testsuite/gcc.dg/vect/bb-slp-18.c
@@ -47,5 +47,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "basic block vectorized" 1 "slp2" { target vect_int_mult } } } */
-/* { dg-final { cleanup-tree-dump "slp2" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/bb-slp-19.c
+++ b/src/gcc/testsuite/gcc.dg/vect/bb-slp-19.c
@@ -54,5 +54,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "basic block vectorized" 1 "slp2"  { xfail *-*-* }  } } */
-/* { dg-final { cleanup-tree-dump "slp2" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/bb-slp-2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/bb-slp-2.c
@@ -54,6 +54,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "basic block vectorized" 1 "slp1" } } */
-/* { dg-final { cleanup-tree-dump "slp1" } } */
-/* { dg-final { cleanup-tree-dump "slp2" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/bb-slp-20.c
+++ b/src/gcc/testsuite/gcc.dg/vect/bb-slp-20.c
@@ -65,5 +65,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "basic block vectorized" 1 "slp2" { target vect_int_mult } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 2 "slp2" { target vect_int_mult } } } */
-/* { dg-final { cleanup-tree-dump "slp2" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/bb-slp-21.c
+++ b/src/gcc/testsuite/gcc.dg/vect/bb-slp-21.c
@@ -66,5 +66,4 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "basic block vectorized" 1 "slp2"  } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "slp2" { target { ! {vect_int_mult } } } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 2 "slp2" { target vect_int_mult } } } */
-/* { dg-final { cleanup-tree-dump "slp2" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/bb-slp-22.c
+++ b/src/gcc/testsuite/gcc.dg/vect/bb-slp-22.c
@@ -65,5 +65,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "basic block vectorized" 1 "slp2"  { target { ! {vect_int_mult } } } } } */
 /* { dg-final { scan-tree-dump-times "basic block vectorized" 2 "slp2"  { target vect_int_mult  } } } */
-/* { dg-final { cleanup-tree-dump "slp2" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/bb-slp-23.c
+++ b/src/gcc/testsuite/gcc.dg/vect/bb-slp-23.c
@@ -52,5 +52,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "basic block vectorized" 1 "slp2" { target vect_int_mult } } } */
-/* { dg-final { cleanup-tree-dump "slp2" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/bb-slp-24.c
+++ b/src/gcc/testsuite/gcc.dg/vect/bb-slp-24.c
@@ -57,6 +57,4 @@ int main (void)
 /* Exclude POWER8 (only POWER cpu for which vect_element_align is true)
    because loops have vectorized before SLP gets a shot.  */
 /* { dg-final { scan-tree-dump-times "basic block vectorized" 1 "slp1" { target { vect_element_align && { ! powerpc*-*-* } } } } } */
-/* { dg-final { cleanup-tree-dump "slp1" } } */
-/* { dg-final { cleanup-tree-dump "slp2" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/bb-slp-25.c
+++ b/src/gcc/testsuite/gcc.dg/vect/bb-slp-25.c
@@ -57,6 +57,4 @@ int main (void)
 /* Exclude POWER8 (only POWER cpu for which vect_element_align is true)
    because loops have vectorized before SLP gets a shot.  */
 /* { dg-final { scan-tree-dump-times "basic block vectorized" 1 "slp1" { target { vect_element_align && { ! powerpc*-*-* } } } } } */
-/* { dg-final { cleanup-tree-dump "slp1" } } */
-/* { dg-final { cleanup-tree-dump "slp2" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/bb-slp-26.c
+++ b/src/gcc/testsuite/gcc.dg/vect/bb-slp-26.c
@@ -57,6 +57,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "basic block vectorized" 1 "slp1" { target { vect64 && vect_hw_misalign } } } } */
-/* { dg-final { cleanup-tree-dump "slp1" } } */
-/* { dg-final { cleanup-tree-dump "slp2" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/bb-slp-27.c
+++ b/src/gcc/testsuite/gcc.dg/vect/bb-slp-27.c
@@ -45,6 +45,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "basic block vectorized" 1 "slp2" { target { vect_int_mult && { vect_unpack && vect_pack_trunc } } } } } */
-/* { dg-final { cleanup-tree-dump "slp1" } } */
-/* { dg-final { cleanup-tree-dump "slp2" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/bb-slp-28.c
+++ b/src/gcc/testsuite/gcc.dg/vect/bb-slp-28.c
@@ -67,6 +67,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "basic block vectorized" 1 "slp2" { target { vect_int_mult &&  { vect_pack_trunc && vect_unpack } } } } } */
-/* { dg-final { cleanup-tree-dump "slp1" } } */
-/* { dg-final { cleanup-tree-dump "slp2" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/bb-slp-29.c
+++ b/src/gcc/testsuite/gcc.dg/vect/bb-slp-29.c
@@ -57,6 +57,4 @@ int main (void)
 /* Exclude POWER8 (only POWER cpu for which vect_element_align is true)
    because loops have vectorized before SLP gets a shot.  */
 /* { dg-final { scan-tree-dump-times "basic block vectorized" 1 "slp1"  { target { { vect_int_mult && vect_element_align } && { ! powerpc*-*-* } } } } } */
-/* { dg-final { cleanup-tree-dump "slp1" } } */
-/* { dg-final { cleanup-tree-dump "slp2" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/bb-slp-3.c
+++ b/src/gcc/testsuite/gcc.dg/vect/bb-slp-3.c
@@ -43,5 +43,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "basic block vectorized" 1 "slp2" } } */
-/* { dg-final { cleanup-tree-dump "slp2" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/bb-slp-30.c
+++ b/src/gcc/testsuite/gcc.dg/vect/bb-slp-30.c
@@ -44,4 +44,3 @@ test1(void)
 int main() { test1(); return a[21]; }
 
 /* { dg-final { scan-tree-dump-times "basic block vectorized" 1 "slp2" } } */
-/* { dg-final { cleanup-tree-dump "slp2" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/bb-slp-31.c
+++ b/src/gcc/testsuite/gcc.dg/vect/bb-slp-31.c
@@ -10,4 +10,3 @@ void f(){
 }
 
 /* { dg-final { scan-tree-dump "basic block vectorized" "slp2" } } */
-/* { dg-final { cleanup-tree-dump "slp2" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/bb-slp-32.c
+++ b/src/gcc/testsuite/gcc.dg/vect/bb-slp-32.c
@@ -20,4 +20,3 @@ int foo (int *p)
 }
 
 /* { dg-final { scan-tree-dump "vectorization is not profitable" "slp2" { xfail  { vect_no_align && { ! vect_hw_misalign } } } } } */
-/* { dg-final { cleanup-tree-dump "slp2" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/bb-slp-4.c
+++ b/src/gcc/testsuite/gcc.dg/vect/bb-slp-4.c
@@ -39,5 +39,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "basic block vectorized" 0 "slp2" } } */
-/* { dg-final { cleanup-tree-dump "slp2" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/bb-slp-5.c
+++ b/src/gcc/testsuite/gcc.dg/vect/bb-slp-5.c
@@ -48,5 +48,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "basic block vectorized" 1 "slp2" } } */
-/* { dg-final { cleanup-tree-dump "slp2" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/bb-slp-6.c
+++ b/src/gcc/testsuite/gcc.dg/vect/bb-slp-6.c
@@ -46,5 +46,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "basic block vectorized" 1 "slp2" { target vect_int_mult } } } */
-/* { dg-final { cleanup-tree-dump "slp2" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/bb-slp-7.c
+++ b/src/gcc/testsuite/gcc.dg/vect/bb-slp-7.c
@@ -47,5 +47,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "basic block vectorized" 0 "slp2" } } */
-/* { dg-final { cleanup-tree-dump "slp2" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/bb-slp-8.c
+++ b/src/gcc/testsuite/gcc.dg/vect/bb-slp-8.c
@@ -49,5 +49,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "basic block vectorized" 1 "slp2"  { target vect_hw_misalign } } } */
-/* { dg-final { cleanup-tree-dump "slp2" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/bb-slp-8a.c
+++ b/src/gcc/testsuite/gcc.dg/vect/bb-slp-8a.c
@@ -48,5 +48,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "basic block vectorized" 0 "slp2" } } */
-/* { dg-final { cleanup-tree-dump "slp2" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/bb-slp-8b.c
+++ b/src/gcc/testsuite/gcc.dg/vect/bb-slp-8b.c
@@ -50,5 +50,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "basic block vectorized" 1 "slp2"  { target vect_hw_misalign } } } */
-/* { dg-final { cleanup-tree-dump "slp2" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/bb-slp-9.c
+++ b/src/gcc/testsuite/gcc.dg/vect/bb-slp-9.c
@@ -47,5 +47,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "basic block vectorized" 1 "slp2"  { xfail  { vect_no_align && { ! vect_hw_misalign } } } } } */
-/* { dg-final { cleanup-tree-dump "slp2" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/bb-slp-cond-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/bb-slp-cond-1.c
@@ -42,6 +42,4 @@ int main ()
 }
 
 /* { dg-final { scan-tree-dump-times "basic block vectorized" 1 "slp1" { target vect_element_align } } } */
-/* { dg-final { cleanup-tree-dump "slp1" } } */
-/* { dg-final { cleanup-tree-dump "slp2" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/bb-slp-pattern-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/bb-slp-pattern-1.c
@@ -51,5 +51,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "slp2" { target { vect_widen_mult_hi_to_si || vect_unpack } } } } */
 /* { dg-final { scan-tree-dump-times "vect_recog_widen_mult_pattern: detected" 8 "slp2" { target vect_widen_mult_hi_to_si_pattern } } } */
 /* { dg-final { scan-tree-dump-times "pattern recognized" 8 "slp2" { target vect_widen_mult_hi_to_si_pattern } } } */
-/* { dg-final { cleanup-tree-dump "slp1" } } */
-/* { dg-final { cleanup-tree-dump "slp2" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/bb-slp-pattern-2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/bb-slp-pattern-2.c
@@ -49,5 +49,3 @@ int main ()
 }
 
 /* { dg-final { scan-tree-dump-times "basic block vectorized" 1 "slp1" { target { vect_element_align && vect_pack_trunc } } } } */
-/* { dg-final { cleanup-tree-dump "slp1" } } */
-/* { dg-final { cleanup-tree-dump "slp2" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/costmodel/i386/costmodel-fast-math-vect-pr29925.c
+++ b/src/gcc/testsuite/gcc.dg/vect/costmodel/i386/costmodel-fast-math-vect-pr29925.c
@@ -36,5 +36,4 @@ int main()
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/costmodel/i386/costmodel-vect-31.c
+++ b/src/gcc/testsuite/gcc.dg/vect/costmodel/i386/costmodel-vect-31.c
@@ -87,4 +87,3 @@ int main (void)
 } 
 
 /* { dg-final { scan-tree-dump-times "vectorized 4 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/costmodel/i386/costmodel-vect-33.c
+++ b/src/gcc/testsuite/gcc.dg/vect/costmodel/i386/costmodel-vect-33.c
@@ -37,4 +37,3 @@ int main (void)
 } 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/costmodel/i386/costmodel-vect-68.c
+++ b/src/gcc/testsuite/gcc.dg/vect/costmodel/i386/costmodel-vect-68.c
@@ -85,4 +85,3 @@ int main (void)
 } 
 
 /* { dg-final { scan-tree-dump-times "vectorized 4 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/costmodel/i386/costmodel-vect-reduc-1char.c
+++ b/src/gcc/testsuite/gcc.dg/vect/costmodel/i386/costmodel-vect-reduc-1char.c
@@ -49,4 +49,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 3 loops" 1 "vect" { xfail vect_no_int_max } } } */
 /* { dg-final { scan-tree-dump-times "vectorization not profitable" 0 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-bb-slp-9a-pr63175.c
+++ b/src/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-bb-slp-9a-pr63175.c
@@ -1,5 +1,5 @@
-/* { dg-require-effective-target vect_int } */
 /* { dg-do compile } */
+/* { dg-require-effective-target vect_int } */
 
 #define N 16 
 
--- a/src/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-bb-slp-9a.c
+++ b/src/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-bb-slp-9a.c
@@ -39,4 +39,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "basic block vectorized" 1 "slp2"  { xfail  { vect_no_align && { ! vect_hw_misalign } } } } } */
-/* { dg-final { cleanup-tree-dump "slp2" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-fast-math-vect-pr29925.c
+++ b/src/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-fast-math-vect-pr29925.c
@@ -36,5 +36,4 @@ int main()
 }
 
 /* { dg-final { scan-tree-dump-times "vectorization not profitable" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-pr37194.c
+++ b/src/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-pr37194.c
@@ -1,5 +1,5 @@
-/* { dg-require-effective-target vect_float } */
 /* { dg-do compile } */
+/* { dg-require-effective-target vect_float } */
 
 #include <stdlib.h>
 #include "../../tree-vect.h"
@@ -24,5 +24,4 @@ ggSpectrum_Set20(float * data, float d)
 
 /* { dg-final { scan-tree-dump-times "vectorization not profitable" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-slp-12.c
+++ b/src/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-slp-12.c
@@ -115,5 +115,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 3 loops" 1 "vect"  {target { vect_strided8 && vect_int_mult } } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 3 "vect" {target { vect_strided8 && vect_int_mult } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-slp-33.c
+++ b/src/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-slp-33.c
@@ -41,4 +41,3 @@ int main (void)
 } 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 0 "vect" { target { ! vect_hw_misalign } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-slp-34.c
+++ b/src/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-slp-34.c
@@ -72,4 +72,3 @@ main (void)
 /* { dg-final { scan-tree-dump-times "vectorization not profitable" 0 "vect" } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect"  } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-31a.c
+++ b/src/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-31a.c
@@ -48,4 +48,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorization not profitable" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 0 "vect" { target { ! vect_hw_misalign } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-31b.c
+++ b/src/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-31b.c
@@ -47,4 +47,3 @@ int main (void)
 } 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-31c.c
+++ b/src/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-31c.c
@@ -47,4 +47,3 @@ int main (void)
 } 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-33.c
+++ b/src/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-33.c
@@ -40,4 +40,3 @@ int main (void)
 
 /* Versioning to align the store is used. Overhead of versioning is not too high.  */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target {! vector_alignment_reachable} } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-68a.c
+++ b/src/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-68a.c
@@ -46,4 +46,3 @@ int main (void)
 } 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-68b.c
+++ b/src/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-68b.c
@@ -46,4 +46,3 @@ int main (void)
 } 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-68c.c
+++ b/src/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-68c.c
@@ -46,4 +46,3 @@ int main (void)
 } 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-76a.c
+++ b/src/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-76a.c
@@ -44,4 +44,3 @@ int main (void)
 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-76b.c
+++ b/src/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-76b.c
@@ -48,4 +48,3 @@ int main (void)
 
 /* Versioning to align the store is used. Overhead of versioning is not too high.  */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { vect_no_align || {! vector_alignment_reachable} } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-76c.c
+++ b/src/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-76c.c
@@ -44,4 +44,3 @@ int main (void)
 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-outer-fir.c
+++ b/src/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-outer-fir.c
@@ -68,4 +68,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 2 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-reduc-1char.c
+++ b/src/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-reduc-1char.c
@@ -48,4 +48,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 3 loops" 1 "vect" { xfail vect_no_int_max } } } */
 /* { dg-final { scan-tree-dump-times "vectorization not profitable" 0 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-fast-math-vect-pr29925.c
+++ b/src/gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-fast-math-vect-pr29925.c
@@ -36,5 +36,4 @@ int main()
 }
 
 /* { dg-final { scan-tree-dump-times "vectorization not profitable" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-vect-31a.c
+++ b/src/gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-vect-31a.c
@@ -48,4 +48,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorization not profitable" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 0 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-vect-31b.c
+++ b/src/gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-vect-31b.c
@@ -47,4 +47,3 @@ int main (void)
 } 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-vect-31c.c
+++ b/src/gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-vect-31c.c
@@ -47,4 +47,3 @@ int main (void)
 } 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-vect-31d.c
+++ b/src/gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-vect-31d.c
@@ -48,4 +48,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorization not profitable" 0 "vect" } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-vect-33.c
+++ b/src/gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-vect-33.c
@@ -40,4 +40,3 @@ int main (void)
 
 /* Versioning to align the store is used. Overhead of versioning is not too high.  */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target {! vector_alignment_reachable} } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-vect-68a.c
+++ b/src/gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-vect-68a.c
@@ -46,4 +46,3 @@ int main (void)
 } 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-vect-68b.c
+++ b/src/gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-vect-68b.c
@@ -46,4 +46,3 @@ int main (void)
 } 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-vect-68c.c
+++ b/src/gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-vect-68c.c
@@ -46,4 +46,3 @@ int main (void)
 } 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-vect-68d.c
+++ b/src/gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-vect-68d.c
@@ -47,4 +47,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorization not profitable" 0 "vect" } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-vect-76a.c
+++ b/src/gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-vect-76a.c
@@ -44,4 +44,3 @@ int main (void)
 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-vect-76b.c
+++ b/src/gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-vect-76b.c
@@ -44,4 +44,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "vectorization not profitable" 0 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-vect-76c.c
+++ b/src/gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-vect-76c.c
@@ -44,4 +44,3 @@ int main (void)
 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-vect-iv-9.c
+++ b/src/gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-vect-iv-9.c
@@ -35,4 +35,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 2 "vect" { target vect_int_mult } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target {! vect_int_mult } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/costmodel/x86_64/costmodel-fast-math-vect-pr29925.c
+++ b/src/gcc/testsuite/gcc.dg/vect/costmodel/x86_64/costmodel-fast-math-vect-pr29925.c
@@ -36,5 +36,4 @@ int main()
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/costmodel/x86_64/costmodel-pr30843.c
+++ b/src/gcc/testsuite/gcc.dg/vect/costmodel/x86_64/costmodel-pr30843.c
@@ -22,5 +22,4 @@ void dacP98FillRGBMap (unsigned char *pBuffer)
 
 /* { dg-final { scan-tree-dump-times "vectorization not profitable" 1 "vect" { target vect_interleave
 } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/costmodel/x86_64/costmodel-pr64909.c
+++ b/src/gcc/testsuite/gcc.dg/vect/costmodel/x86_64/costmodel-pr64909.c
@@ -12,4 +12,3 @@ void t()
 }
 
 /* { dg-final { scan-tree-dump "vectorized 1 loops in function" "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/costmodel/x86_64/costmodel-vect-31.c
+++ b/src/gcc/testsuite/gcc.dg/vect/costmodel/x86_64/costmodel-vect-31.c
@@ -87,4 +87,3 @@ int main (void)
 } 
 
 /* { dg-final { scan-tree-dump-times "vectorized 4 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/costmodel/x86_64/costmodel-vect-33.c
+++ b/src/gcc/testsuite/gcc.dg/vect/costmodel/x86_64/costmodel-vect-33.c
@@ -37,4 +37,3 @@ int main (void)
 } 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/costmodel/x86_64/costmodel-vect-68.c
+++ b/src/gcc/testsuite/gcc.dg/vect/costmodel/x86_64/costmodel-vect-68.c
@@ -85,4 +85,3 @@ int main (void)
 } 
 
 /* { dg-final { scan-tree-dump-times "vectorized 4 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/costmodel/x86_64/costmodel-vect-reduc-1char.c
+++ b/src/gcc/testsuite/gcc.dg/vect/costmodel/x86_64/costmodel-vect-reduc-1char.c
@@ -49,4 +49,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 3 loops" 1 "vect" { xfail vect_no_int_max } } } */
 /* { dg-final { scan-tree-dump-times "vectorization not profitable" 0 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/fast-math-bb-slp-call-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/fast-math-bb-slp-call-1.c
@@ -46,5 +46,3 @@ main ()
 }
 
 /* { dg-final { scan-tree-dump-times "basic block vectorized" 1 "slp2" { target { vect_call_copysignf && vect_call_sqrtf } } } } */
-/* { dg-final { cleanup-tree-dump "slp1" } } */
-/* { dg-final { cleanup-tree-dump "slp2" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/fast-math-bb-slp-call-2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/fast-math-bb-slp-call-2.c
@@ -64,5 +64,3 @@ main ()
 }
 
 /* { dg-final { scan-tree-dump-times "basic block vectorized" 2 "slp2" { target vect_call_lrint } } } */
-/* { dg-final { cleanup-tree-dump "slp1" } } */
-/* { dg-final { cleanup-tree-dump "slp2" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/fast-math-bb-slp-call-3.c
+++ b/src/gcc/testsuite/gcc.dg/vect/fast-math-bb-slp-call-3.c
@@ -65,5 +65,3 @@ int main()
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "slp1" } } */
-/* { dg-final { cleanup-tree-dump "slp2" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/fast-math-ifcvt-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/fast-math-ifcvt-1.c
@@ -15,4 +15,3 @@ bestseries9 (float * __restrict__ arr, int len)
 }
 
 /* { dg-final { scan-tree-dump "vectorized 1 loops" "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/fast-math-pr35982.c
+++ b/src/gcc/testsuite/gcc.dg/vect/fast-math-pr35982.c
@@ -22,4 +22,3 @@ float method2_int16 (struct mem *mem)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { vect_extract_even_odd || vect_strided2 } } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 0 loops" 1 "vect" { target { ! { vect_extract_even_odd || vect_strided2 } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/fast-math-pr43074.c
+++ b/src/gcc/testsuite/gcc.dg/vect/fast-math-pr43074.c
@@ -13,4 +13,3 @@ pvslockprocess(float *fout, float *fin, int framesize)
   return mag;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/fast-math-pr44152.c
+++ b/src/gcc/testsuite/gcc.dg/vect/fast-math-pr44152.c
@@ -34,4 +34,3 @@ foo (int x)
 }
 
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/fast-math-pr55281.c
+++ b/src/gcc/testsuite/gcc.dg/vect/fast-math-pr55281.c
@@ -27,4 +27,3 @@ foo (int *a, int b, float *d, float *e, int *f)
       f[i] = e[i] + bar (a[i], d[i]);
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/fast-math-slp-27.c
+++ b/src/gcc/testsuite/gcc.dg/vect/fast-math-slp-27.c
@@ -14,4 +14,3 @@ void foo(void)
 }
 
 /* { dg-final { scan-tree-dump "vectorized 1 loops" "vect" { target vect_strided2 } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/fast-math-slp-38.c
+++ b/src/gcc/testsuite/gcc.dg/vect/fast-math-slp-38.c
@@ -19,4 +19,3 @@ foo (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/fast-math-vect-call-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/fast-math-vect-call-1.c
@@ -96,4 +96,3 @@ main ()
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 4 "vect" { target { vect_call_copysignf && vect_call_sqrtf } } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 3 "vect" { target { vect_call_copysignf && vect_call_sqrtf } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/fast-math-vect-call-2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/fast-math-vect-call-2.c
@@ -127,4 +127,3 @@ main ()
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 6 "vect" { target vect_call_lrint } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 4 "vect" { target vect_call_lrint } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/fast-math-vect-complex-3.c
+++ b/src/gcc/testsuite/gcc.dg/vect/fast-math-vect-complex-3.c
@@ -57,4 +57,3 @@ main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_strided2 } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/fast-math-vect-outer-7.c
+++ b/src/gcc/testsuite/gcc.dg/vect/fast-math-vect-outer-7.c
@@ -20,4 +20,3 @@ void test2 (float x)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 2 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/fast-math-vect-pow-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/fast-math-vect-pow-1.c
@@ -11,4 +11,3 @@ void foo(void)
 }
 
 /* { dg-final { scan-tree-dump "vectorized 1 loops" "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/fast-math-vect-pow-2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/fast-math-vect-pow-2.c
@@ -29,5 +29,4 @@ main (void)
 {
   d_type tmp = main1 ();
 }
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/fast-math-vect-pr25911.c
+++ b/src/gcc/testsuite/gcc.dg/vect/fast-math-vect-pr25911.c
@@ -12,4 +12,3 @@ float bessel_Kn_scaled_small_x(int n)
   return sum1;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/fast-math-vect-pr29925.c
+++ b/src/gcc/testsuite/gcc.dg/vect/fast-math-vect-pr29925.c
@@ -36,5 +36,4 @@ int main()
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/fast-math-vect-reduc-5.c
+++ b/src/gcc/testsuite/gcc.dg/vect/fast-math-vect-reduc-5.c
@@ -52,4 +52,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 3 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/fast-math-vect-reduc-7.c
+++ b/src/gcc/testsuite/gcc.dg/vect/fast-math-vect-reduc-7.c
@@ -52,4 +52,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 3 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/fast-math-vect-reduc-8.c
+++ b/src/gcc/testsuite/gcc.dg/vect/fast-math-vect-reduc-8.c
@@ -20,4 +20,3 @@ float f (unsigned n)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/fast-math-vect-reduc-9.c
+++ b/src/gcc/testsuite/gcc.dg/vect/fast-math-vect-reduc-9.c
@@ -27,4 +27,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump "vectorized 1 loops" "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/ggc-pr37574.c
+++ b/src/gcc/testsuite/gcc.dg/vect/ggc-pr37574.c
@@ -19,4 +19,3 @@ int main (void) {
    return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/if-cvt-stores-vect-ifcvt-18.c
+++ b/src/gcc/testsuite/gcc.dg/vect/if-cvt-stores-vect-ifcvt-18.c
@@ -66,4 +66,3 @@ main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  { xfail { { vect_no_align && { ! vect_hw_misalign } } || { ! vect_strided2 } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-fast-math-vect16.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-fast-math-vect16.c
@@ -35,4 +35,3 @@ int main (void)
 
 /* Requires fast-math.  */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-fre-pre-pr50208.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-fre-pre-pr50208.c
@@ -14,4 +14,3 @@ void foo (int j)
     }
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-math-errno-slp-32.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-math-errno-slp-32.c
@@ -14,4 +14,3 @@ void foo(void)
 }
 
 /* { dg-final { scan-tree-dump "pattern recognized" "vect" { xfail spu*-*-* } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-math-errno-vect-pow-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-math-errno-vect-pow-1.c
@@ -11,4 +11,3 @@ void foo(void)
 }
 
 /* { dg-final { scan-tree-dump "pattern recognized" "vect" { xfail spu*-*-* } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-scevccp-noreassoc-outer-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-scevccp-noreassoc-outer-1.c
@@ -47,4 +47,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED." 1 "vect" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-scevccp-noreassoc-outer-2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-scevccp-noreassoc-outer-2.c
@@ -46,4 +46,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED." 1 "vect" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-scevccp-noreassoc-outer-3.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-scevccp-noreassoc-outer-3.c
@@ -45,4 +45,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED." 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-scevccp-noreassoc-outer-4.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-scevccp-noreassoc-outer-4.c
@@ -54,4 +54,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED." 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-scevccp-noreassoc-outer-5.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-scevccp-noreassoc-outer-5.c
@@ -51,4 +51,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED." 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-scevccp-noreassoc-slp-reduc-7.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-scevccp-noreassoc-slp-reduc-7.c
@@ -38,5 +38,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail vect_no_int_max } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect" { xfail vect_no_int_max } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-1.c
@@ -20,4 +20,3 @@ foo (){
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-10.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-10.c
@@ -51,4 +51,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED." 1 "vect" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-10a.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-10a.c
@@ -55,4 +55,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED." 1 "vect" { target vect_strided2 } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-10b.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-10b.c
@@ -54,4 +54,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED." 1 "vect" { target vect_strided2 } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-11.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-11.c
@@ -47,4 +47,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED." 1 "vect" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-12.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-12.c
@@ -47,4 +47,3 @@ int main (void)
 
 /* Until we support multiple types in the inner loop  */
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED." 1 "vect" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-13.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-13.c
@@ -64,4 +64,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED." 1 "vect" { target vect_widen_mult_hi_to_si } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-14.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-14.c
@@ -58,4 +58,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED." 1 "vect" { target vect_widen_mult_hi_to_si } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-15.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-15.c
@@ -45,4 +45,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED." 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-16.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-16.c
@@ -59,4 +59,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED." 1 "vect" { xfail { ! {vect_unpack } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-17.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-17.c
@@ -65,4 +65,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED." 1 "vect" { xfail { ! {vect_unpack } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-18.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-18.c
@@ -48,4 +48,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED." 1 "vect" { target { vect_interleave || vect_strided2 } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-19.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-19.c
@@ -49,4 +49,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED." 1 "vect" { xfail { ! {vect_unpack } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-2.c
@@ -17,4 +17,3 @@ foo (){
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect"  } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-20.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-20.c
@@ -51,4 +51,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED." 1 "vect" { target vect_strided2 } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-21.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-21.c
@@ -59,4 +59,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED." 1 "vect" { xfail { ! { vect_pack_trunc } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-22.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-22.c
@@ -51,4 +51,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED." 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-3.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-3.c
@@ -48,4 +48,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED." 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-4.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-4.c
@@ -52,4 +52,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED." 1 "vect" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-5.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-5.c
@@ -50,4 +50,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED." 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-6-global.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-6-global.c
@@ -53,4 +53,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED." 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-6.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-6.c
@@ -53,4 +53,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED." 1 "vect" { xfail { unaligned_stack || { vect_no_align && { ! vect_hw_misalign } } } } } } */
 /* { dg-final { scan-tree-dump-times "vect_recog_widen_mult_pattern: detected" 1 "vect" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-7.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-7.c
@@ -72,4 +72,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED." 1 "vect" { target vect_widen_mult_hi_to_si } } } */
 /* { dg-final { scan-tree-dump-times "vect_recog_widen_mult_pattern: detected" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-8.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-8.c
@@ -47,4 +47,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED." 1 "vect" { xfail { ! { vect_element_align } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-9.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-9.c
@@ -47,4 +47,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED." 1 "vect" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-9a.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-9a.c
@@ -51,4 +51,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED." 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-9b.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-scevccp-outer-9b.c
@@ -50,4 +50,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED." 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-scevccp-pr49199.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-scevccp-pr49199.c
@@ -15,4 +15,3 @@ int foo (void)
   return x;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-scevccp-slp-30.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-scevccp-slp-30.c
@@ -53,5 +53,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect"  } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/no-scevccp-slp-31.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-scevccp-slp-31.c
@@ -53,5 +53,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 0 "vect"  } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/no-scevccp-vect-iv-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-scevccp-vect-iv-1.c
@@ -31,4 +31,3 @@ int main (void)
 } 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-scevccp-vect-iv-2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-scevccp-vect-iv-2.c
@@ -47,4 +47,3 @@ int main (void)
 } 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-scevccp-vect-iv-3.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-scevccp-vect-iv-3.c
@@ -25,4 +25,3 @@ unsigned int main1 ()
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_widen_sum_hi_to_si } } } */
 /* { dg-final { scan-tree-dump-times "vect_recog_widen_sum_pattern: detected" 1 "vect" { target vect_widen_sum_hi_to_si } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-31.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-31.c
@@ -90,4 +90,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 4 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 2 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-34.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-34.c
@@ -40,4 +40,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-36.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-36.c
@@ -47,4 +47,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-64.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-64.c
@@ -86,4 +86,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 3 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 2 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-65.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-65.c
@@ -83,4 +83,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 2 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-66.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-66.c
@@ -81,4 +81,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 2 "vect" { target { {! vect_aligned_arrays} && {vect_sizes_32B_16B} } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { target { {vect_aligned_arrays} && {! vect_sizes_32B_16B} } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-68.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-68.c
@@ -92,4 +92,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 4 "vect" { target { {! vect_aligned_arrays} && {vect_sizes_32B_16B} } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 2 "vect" { target { {vect_aligned_arrays} && {! vect_sizes_32B_16B} } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-69.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-69.c
@@ -118,4 +118,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 2 "vect" { xfail { {! vector_alignment_reachable} || { vect_sizes_32B_16B} } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 1 "vect" { target { {! vector_alignment_reachable} && {! vect_hw_misalign} } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { target { {! vector_alignment_reachable} && {! vect_hw_misalign} } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-outer-4h.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-outer-4h.c
@@ -45,4 +45,3 @@ int main (void)
 
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-trapping-math-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-trapping-math-1.c
@@ -9,4 +9,3 @@ foo (float a[32], float b[2][32])
     a[i] = (b[0][i] > b[1][i]) ? b[0][i] : b[1][i];
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-trapping-math-2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-trapping-math-2.c
@@ -36,4 +36,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_condition } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-trapping-math-vect-111.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-trapping-math-vect-111.c
@@ -36,4 +36,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target powerpc*-*-* } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target i?86-*-* x86_64-*-* ia64-*-* } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-trapping-math-vect-ifcvt-11.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-trapping-math-vect-ifcvt-11.c
@@ -31,4 +31,3 @@ int main ()
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-trapping-math-vect-ifcvt-12.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-trapping-math-vect-ifcvt-12.c
@@ -30,4 +30,3 @@ int main ()
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-trapping-math-vect-ifcvt-13.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-trapping-math-vect-ifcvt-13.c
@@ -31,4 +31,3 @@ int main ()
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-trapping-math-vect-ifcvt-14.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-trapping-math-vect-ifcvt-14.c
@@ -31,4 +31,3 @@ int main ()
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-trapping-math-vect-ifcvt-15.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-trapping-math-vect-ifcvt-15.c
@@ -31,4 +31,3 @@ int main ()
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-tree-dom-vect-bug.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-tree-dom-vect-bug.c
@@ -27,4 +27,3 @@ int main ()
 
   return 0;
 }
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-tree-fre-pr50039.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-tree-fre-pr50039.c
@@ -11,5 +11,4 @@ int main(void) {
     }
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/no-tree-pre-pr45241.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-tree-pre-pr45241.c
@@ -17,4 +17,3 @@ foo (short x)
   return sum;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-tree-pre-slp-29.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-tree-pre-slp-29.c
@@ -74,5 +74,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 2 "vect" } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 2 "vect"  } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/no-tree-reassoc-bb-slp-12.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-tree-reassoc-bb-slp-12.c
@@ -48,6 +48,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "basic block vectorized" 1 "slp2" { target vect_int_mult } } } */
-/* { dg-final { cleanup-tree-dump "slp1" } } */
-/* { dg-final { cleanup-tree-dump "slp2" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/no-tree-sra-bb-slp-pr50730.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-tree-sra-bb-slp-pr50730.c
@@ -14,4 +14,3 @@ A sum(A a,A b)
 }
 
 /* { dg-final { scan-tree-dump-times "not vectorized: more than one data ref in stmt" 0 "slp2" } } */
-/* { dg-final { cleanup-tree-dump "slp2" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-vfa-pr29145.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-vfa-pr29145.c
@@ -50,4 +50,3 @@ int main(void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 0 loops" 2 "vect" } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-vfa-vect-101.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-vfa-vect-101.c
@@ -47,5 +47,4 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 0 "vect" } } */
 /* { dg-final { scan-tree-dump-times "can't determine dependence" 1 "vect" { target { ! vect_multiple_sizes } } } } */
 /* { dg-final { scan-tree-dump-times "can't determine dependence" 2 "vect" { target vect_multiple_sizes } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/no-vfa-vect-102.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-vfa-vect-102.c
@@ -55,5 +55,4 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 0 "vect" } } */
 /* { dg-final { scan-tree-dump-times "possible dependence between data-refs" 1 "vect" { target { ! vect_multiple_sizes } } } } */
 /* { dg-final { scan-tree-dump-times "possible dependence between data-refs" 2 "vect" { target vect_multiple_sizes } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/no-vfa-vect-102a.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-vfa-vect-102a.c
@@ -55,5 +55,4 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 0 "vect" } } */
 /* { dg-final { scan-tree-dump-times "possible dependence between data-refs" 1 "vect" { target { ! vect_multiple_sizes } } } } */
 /* { dg-final { scan-tree-dump-times "possible dependence between data-refs" 2 "vect" { target vect_multiple_sizes } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/no-vfa-vect-37.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-vfa-vect-37.c
@@ -60,4 +60,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 2 loops" 1 "vect" { xfail *-*-* } } } */
 /* { dg-final { scan-tree-dump-times "can't determine dependence" 2 "vect" { target { ! vect_multiple_sizes } } } } */
 /* { dg-final { scan-tree-dump-times "can't determine dependence" 4 "vect" { target vect_multiple_sizes } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-vfa-vect-43.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-vfa-vect-43.c
@@ -91,4 +91,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 2 loops" 2 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 6 "vect" { target { vect_no_align && { ! vect_hw_misalign } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-vfa-vect-45.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-vfa-vect-45.c
@@ -57,4 +57,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-vfa-vect-49.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-vfa-vect-49.c
@@ -59,4 +59,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-vfa-vect-51.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-vfa-vect-51.c
@@ -57,4 +57,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-vfa-vect-53.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-vfa-vect-53.c
@@ -60,4 +60,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-vfa-vect-57.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-vfa-vect-57.c
@@ -72,4 +72,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-vfa-vect-61.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-vfa-vect-61.c
@@ -74,4 +74,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-vfa-vect-79.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-vfa-vect-79.c
@@ -48,4 +48,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  { xfail *-*-* } } } */
 /* { dg-final { scan-tree-dump-times "can't determine dependence" 1 "vect" { target { ! vect_multiple_sizes } } } } */
 /* { dg-final { scan-tree-dump-times "can't determine dependence" 2 "vect" { target vect_multiple_sizes } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-vfa-vect-depend-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-vfa-vect-depend-1.c
@@ -52,5 +52,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" {xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
 /* { dg-final { scan-tree-dump-times "dependence distance negative" 1 "vect"  } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/no-vfa-vect-depend-2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-vfa-vect-depend-2.c
@@ -52,4 +52,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" {xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
 /* { dg-final { scan-tree-dump-times "dependence distance negative" 1 "vect"  } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-vfa-vect-depend-3.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-vfa-vect-depend-3.c
@@ -184,4 +184,3 @@ int main ()
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 4 "vect" {xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
 /* { dg-final { scan-tree-dump-times "dependence distance negative" 4 "vect"  } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/no-vfa-vect-dv-2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/no-vfa-vect-dv-2.c
@@ -76,4 +76,3 @@ int main ()
 /* { dg-final { scan-tree-dump-times "vectorized 3 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "accesses have the same alignment." 2 "vect" { target { { vect_aligned_arrays } && {! vect_sizes_32B_16B} } } } } */
 /* { dg-final { scan-tree-dump-times "accesses have the same alignment." 1 "vect" { target { {! vect_aligned_arrays } && {vect_sizes_32B_16B} } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/nodump-forwprop-22.c
+++ b/src/gcc/testsuite/gcc.dg/vect/nodump-forwprop-22.c
@@ -17,4 +17,3 @@ void f (vec *px, vec *y, vec *z)
 
 /* { dg-final { scan-tree-dump-times "VEC_PERM_EXPR" 1 "cddce1" } } */
 /* { dg-final { scan-tree-dump-not "BIT_FIELD_REF" "cddce1" } } */
-/* { dg-final { cleanup-tree-dump "cddce1" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr16105.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr16105.c
@@ -19,4 +19,3 @@ void square(const float * __restrict__ a,
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 2 "vect" { target { vect_no_align && { ! vect_hw_misalign } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr18308.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr18308.c
@@ -11,4 +11,3 @@ void bar(int j)
   if (k) foo();
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr18400.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr18400.c
@@ -36,4 +36,3 @@ int main (void)
 } 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr18425.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr18425.c
@@ -14,4 +14,3 @@ _M_fill_insert(unsigned int __n)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr18536.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr18536.c
@@ -32,4 +32,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr20122.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr20122.c
@@ -53,4 +53,3 @@ int main (int argc, char **argv)
    The loop in main is aligned.  */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 3 "vect" } } */
 /*  { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 2 "vect" { target { vect_no_align && { ! vect_hw_misalign } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr21591.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr21591.c
@@ -34,5 +34,4 @@ void f(void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 2 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/pr22480.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr22480.c
@@ -29,4 +29,3 @@ test_3 (void)
    bm[j] <<= am[j];
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr22506.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr22506.c
@@ -11,4 +11,3 @@ void foo()
     for (i=0; i<2; ++i) ;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr23816-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr23816-1.c
@@ -9,4 +9,3 @@ foo (float a[32], float b[2][32])
     a[i] = (b[0][i] > b[1][i]) ? b[0][i] : b[1][i];
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr23816-2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr23816-2.c
@@ -9,4 +9,3 @@ foo (double a[32], double b[2][32])
     a[i] = (b[0][i] > b[1][i]) ? b[0][i] : b[1][i];
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr23831.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr23831.c
@@ -9,4 +9,3 @@ void foo (void)
     bm[j] = bm[j] * 8;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr24059.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr24059.c
@@ -13,4 +13,3 @@ void compute_predicate_codes (char *codes, struct pred_data *p)
     codes[i] = p->codes[i] ? 2 : 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr24300.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr24300.c
@@ -34,4 +34,3 @@ foo (int Fc)
   return (tc);
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr25371.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr25371.c
@@ -10,4 +10,3 @@ void slow_close(int n)
       *(mm+i*2*n+i) = 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr25413.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr25413.c
@@ -36,4 +36,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 0 "vect" { target { {! vector_alignment_reachable_for_64bit} && {! vect_hw_misalign} } } } } */
 /* { dg-final { scan-tree-dump-times "vector alignment may not be reachable" 1 "vect" { target { {! vector_alignment_reachable_for_64bit} && {! vect_hw_misalign} } } } } */
 /* { dg-final { scan-tree-dump-times "not vectorized: unsupported unaligned store" 1 "vect" { target { {! vector_alignment_reachable_for_64bit} && {! vect_hw_misalign} } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr25413a.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr25413a.c
@@ -126,4 +126,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "vector alignment may not be reachable" 1 "vect" { target { ! vector_alignment_reachable  } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 1 "vect" { target { ! vector_alignment_reachable } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr26359.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr26359.c
@@ -14,5 +14,3 @@ foo () {
 }
 
 /* { dg-final { scan-tree-dump-times "Deleting : vect_" 0 "dce5" } } */
-/* { dg-final { cleanup-tree-dump "dce5" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr27151.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr27151.c
@@ -13,4 +13,3 @@ void vis_clear_data ()
     }
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr28952.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr28952.c
@@ -30,4 +30,3 @@ send_spaceship_info (void)
   lsend_packet_spaceship_info (&info);
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr30771.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr30771.c
@@ -15,4 +15,3 @@ main()
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_unpack } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr30784.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr30784.c
@@ -27,4 +27,3 @@ int main ()
 
   return 0;
 }
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr30795.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr30795.c
@@ -16,4 +16,3 @@ main()
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr30843.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr30843.c
@@ -21,5 +21,4 @@ void dacP98FillRGBMap (unsigned char *pBuffer)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { vect_interleave || vect_strided4 } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/pr30858.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr30858.c
@@ -12,4 +12,3 @@ foo (int ko)
 
 /* { dg-final { scan-tree-dump-times "vectorized 0 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump "Unknown def-use cycle pattern." "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr31041.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr31041.c
@@ -24,4 +24,3 @@ utrie_open_3_4 ()
       while (i < 5);
     }
 }
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr31343.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr31343.c
@@ -32,4 +32,3 @@ main1 ()
     }
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr31699.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr31699.c
@@ -36,4 +36,3 @@ int main()
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 2 "vect" { target vect_intfloat_cvt } } } */
 /* { dg-final { scan-tree-dump-times "vector alignment may not be reachable" 1 "vect" { target { ! vector_alignment_reachable } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 1 "vect" { target { ! vector_alignment_reachable } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr32216.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr32216.c
@@ -12,4 +12,3 @@ SetSoundVariables (int x)
   }
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr32224.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr32224.c
@@ -15,4 +15,3 @@ gmpz_export (void *data)
     __src++;
   }
 }
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr32230.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr32230.c
@@ -19,6 +19,5 @@ const_f (filter_buffer_t *buf)
     ((float*) (&((sbuf_header_t *) (__PTRDIFF_TYPE__)((buf) == (filter_buffer_t *)&(buf)->buf[0]))->buf[0]))[i] = val;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
 
--- a/src/gcc/testsuite/gcc.dg/vect/pr32366.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr32366.c
@@ -12,4 +12,3 @@ stream_test (void)
     input[k] = k * 1.0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr32421.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr32421.c
@@ -8,5 +8,4 @@ int f(int **__restrict a, int ** __restrict b)
     a[i] = b[i] + 1;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/pr32824.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr32824.c
@@ -11,5 +11,4 @@ void foo(void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/pr33369.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr33369.c
@@ -19,4 +19,3 @@ f (POINT * ptBuf)
     }
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr33373.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr33373.c
@@ -5,4 +5,3 @@ void DOSMEM_FillIsrTable(int*isr) {
     for (i=0; i<256; i++)
         isr[i]=(((short)((i*4) & 0xFFFF)) | (0xf000 & 0xFFFF) << 16);
 }
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr33373b.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr33373b.c
@@ -5,4 +5,3 @@ void f (unsigned int *d, unsigned int *s, int w)
   for (i = 0; i < w; ++i)
     d [i] = s [i] * (unsigned short) (~d [i] >> 24);
 }
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr33597.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr33597.c
@@ -21,4 +21,3 @@ rgb15to24_C (const uint8_t * src, uint8_t * dst, long src_size)
     }
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr33804.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr33804.c
@@ -13,4 +13,3 @@ void f(unsigned char *s, unsigned char *d, int n) {
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr33833.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr33833.c
@@ -32,4 +32,3 @@ void sched_init (uintptr_t __ptr)
   }
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr33846.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr33846.c
@@ -21,4 +21,3 @@ void _mix_some_samples (intptr_t buf, int *mix_buffer, int mix_size)
   }
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr33866.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr33866.c
@@ -28,5 +28,4 @@ void test_select_fill_hyper_simple (long *offset)
 
 /* Needs interleaving support.  */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { vect_interleave || vect_strided2 } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/pr33953.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr33953.c
@@ -30,6 +30,5 @@ void blockmove_NtoN_blend_noremap32 (const UINT32 *srcdata, int srcwidth,
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
 
--- a/src/gcc/testsuite/gcc.dg/vect/pr34005.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr34005.c
@@ -13,4 +13,3 @@ void XdmcpUnwrap (unsigned char *output, int k)
     output[i] = blocks[k][i];
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr34407.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr34407.c
@@ -13,4 +13,3 @@ void ReadRLEImage (unsigned char *p)
     *p++ = background_color[j];
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr34591.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr34591.c
@@ -9,4 +9,3 @@ int av_resample(int filter_length, short *src, short *filter)
     return val;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr36228.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr36228.c
@@ -28,4 +28,3 @@ t_run_test()
 }
 
 /* { dg-final { scan-tree-dump-times "versioning for alias required" 0 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr36493.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr36493.c
@@ -21,5 +21,4 @@ main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/pr36630.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr36630.c
@@ -14,4 +14,3 @@ foo (unsigned char *x, short y)
     }
 }
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr37027.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr37027.c
@@ -33,5 +33,4 @@ foo (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail vect_no_int_add } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect" { xfail vect_no_int_add } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/pr37385.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr37385.c
@@ -17,4 +17,3 @@ bar ()
       fun_tab[i] = foo;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr37474.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr37474.c
@@ -34,5 +34,4 @@ void foo (unsigned int *__restrict__ pInput, unsigned int *__restrict__ pOutput)
     }
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/pr37482.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr37482.c
@@ -17,5 +17,4 @@ void SexiALI_Convert(void *vdest, void *vsrc, unsigned int frames)
   *dest++ = tmp;
  }
 }
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/pr37539.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr37539.c
@@ -41,7 +41,6 @@ int main ()
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 2 "vect" { target { vect_strided4 && vect_strided2 } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
 
 
--- a/src/gcc/testsuite/gcc.dg/vect/pr37730.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr37730.c
@@ -15,4 +15,3 @@ add_opush (void)
   sdp_seq_alloc (dtds);
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr38529.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr38529.c
@@ -13,6 +13,5 @@ void foo()
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect"  } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
 
--- a/src/gcc/testsuite/gcc.dg/vect/pr39529.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr39529.c
@@ -16,6 +16,5 @@ foo (void)
     } while (p < p2);
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
 
--- a/src/gcc/testsuite/gcc.dg/vect/pr40074.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr40074.c
@@ -50,5 +50,4 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/pr40238.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr40238.c
@@ -31,5 +31,4 @@ int xgp_ahd_interpolate (int tile)
  return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/pr40254.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr40254.c
@@ -35,5 +35,4 @@ main (void)
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/pr40542.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr40542.c
@@ -10,5 +10,4 @@ volarr_cpy(char *d, volatile char *s)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/pr41956.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr41956.c
@@ -10,4 +10,3 @@ void K (int *gpwgts, int *badminpwgt, int *badmaxpwgt)
   }
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr42193.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr42193.c
@@ -24,5 +24,4 @@ void foo ()
   out[5] = 17 * a + 15 * b + 13  * c + 14 * d + 11 * e + 9 * f;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/pr42604.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr42604.c
@@ -32,4 +32,3 @@ test (unsigned short *b)
     }
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr42709.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr42709.c
@@ -24,5 +24,4 @@ main1 (int *a, int *b, int *c, int *d, int dummy)
     } 
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/pr43430-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr43430-1.c
@@ -36,4 +36,3 @@ main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_condition } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr43430-2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr43430-2.c
@@ -14,4 +14,3 @@ vsad16_c (void *c, uint8_t * s1, uint8_t * s2, int stride, int h)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_condition } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr43432.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr43432.c
@@ -11,4 +11,3 @@ int len){
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { vect_perm && vect_hw_misalign } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr43842.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr43842.c
@@ -53,5 +53,4 @@ int81 (void)
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/pr44507.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr44507.c
@@ -51,5 +51,4 @@ int main(int argc, char** argv)
   return seeIf256ByteArrayIsConstant(&array1[0]);
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/pr45633.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr45633.c
@@ -12,4 +12,3 @@ foo (void)
     t[i] -= s[i];
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr45752.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr45752.c
@@ -104,5 +104,4 @@ int main (int argc, const char* argv[])
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 0 "vect"  } } */
 /* { dg-final { scan-tree-dump "permutation requires at least three vectors" "vect" { target vect_perm } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 0 "vect"  } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/pr45847.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr45847.c
@@ -11,5 +11,4 @@ long long foo (long long *__restrict a,  int *__restrict b, int *__restrict c )
   return sum;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/pr45902.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr45902.c
@@ -40,4 +40,3 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr46009.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr46009.c
@@ -71,4 +71,3 @@ main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 2 "vect" { target vect_int_mult } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr46049.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr46049.c
@@ -18,4 +18,3 @@ void foo (int16_t i, int16_t *p, int16_t x)
       p++;
     }
 }
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr46052.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr46052.c
@@ -30,4 +30,3 @@ void foo1 (int n)
     }
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr46126.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr46126.c
@@ -22,4 +22,3 @@ EvTab[(((uintptr_t)(((TypHandle*)((hdCall)->ptr))[1]) & 1) ? 1 :
      ptApp[2] = ((TypHandle) (uintptr_t) (((long)(lc) << 2) + 1));
  }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr46663.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr46663.c
@@ -11,4 +11,3 @@ int foo (bart bar, int m)
   return j;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr47001.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr47001.c
@@ -24,4 +24,3 @@ int main1 (int res0, int res1)
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr47139.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr47139.c
@@ -14,5 +14,4 @@ foo ()
     }
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- /dev/null
+++ b/src/gcc/testsuite/gcc.dg/vect/pr48052.c
@@ -0,0 +1,26 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target vect_int_mult } */
+
+int foo(int* A, int* B,  unsigned start, unsigned BS)
+{
+  int s = 0;
+  for (unsigned k = start;  k < start + BS; k++)
+    {
+      s += A[k] * B[k];
+    }
+
+  return s;
+}
+
+int bar(int* A, int* B, unsigned BS)
+{
+  int s = 0;
+  for (unsigned k = 0;  k < BS; k++)
+    {
+      s += A[k] * B[k];
+    }
+
+  return s;
+}
+
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 2 "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr48172.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr48172.c
@@ -28,4 +28,3 @@ int main() {
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr48377.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr48377.c
@@ -22,4 +22,3 @@ main (void)
   return foo (buf + 1, 26) != 26;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr48765.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr48765.c
@@ -82,4 +82,3 @@ stupid_find_reg (call_preserved, class, mode, born_insn, dead_insn,
     }
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr49038.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr49038.c
@@ -41,4 +41,3 @@ main (void)
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr49093.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr49093.c
@@ -19,4 +19,3 @@ lbl_473:
     }
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr49318.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr49318.c
@@ -19,4 +19,3 @@ void gl_GetDoublev( GLcontext *ctx, GLenum pname, GLdouble *params ) {
     params[i] = (GLint) ctx->TextureMatrix[i];
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr49478.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr49478.c
@@ -20,5 +20,4 @@ foo (int len) {
   return result;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/pr49610.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr49610.c
@@ -9,4 +9,3 @@ void func_13(int p_17) {
     }
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr49771.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr49771.c
@@ -23,4 +23,3 @@ main (void)
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr49926.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr49926.c
@@ -20,4 +20,3 @@ foo (unsigned int x, int y, int z, int *w)
   while (1);
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr50014.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr50014.c
@@ -12,5 +12,4 @@ int f(unsigned char *s, int n)
   return sum;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/pr50451.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr50451.c
@@ -14,5 +14,4 @@ foo (int integral, int decimal, int power_ten)
   return integral+decimal;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/pr50635.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr50635.c
@@ -17,5 +17,4 @@ void f0a(int32_t * result, int32_t * arg1, int8_t * arg2, int32_t temp_3)
     }
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/pr50727.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr50727.c
@@ -17,5 +17,4 @@ f0a (uint32_t * __restrict__ result, uint32_t * arg2,
     }
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/pr51000.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr51000.c
@@ -16,4 +16,3 @@ foo ()
     }
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr51015.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr51015.c
@@ -16,4 +16,3 @@ void e2fsck_pass1()
  }
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr51074.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr51074.c
@@ -21,4 +21,3 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr51301.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr51301.c
@@ -12,4 +12,3 @@ f0a (int8_t * __restrict__ arg1)
   return result;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr51581-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr51581-1.c
@@ -15,4 +15,3 @@ main ()
   return main1 ();
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr51581-2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr51581-2.c
@@ -15,4 +15,3 @@ main ()
   return main1 ();
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr51581-3.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr51581-3.c
@@ -115,4 +115,3 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr51581-4.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr51581-4.c
@@ -163,4 +163,3 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr51590.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr51590.c
@@ -32,4 +32,3 @@ foo (const char *x, struct S *y)
   bar (&d);
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr51799.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr51799.c
@@ -15,4 +15,3 @@ f0a (uint32_t * __restrict__ result, int8_t * __restrict__ arg1,
     }
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr52091.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr52091.c
@@ -27,5 +27,4 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/pr52252-ld.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr52252-ld.c
@@ -26,4 +26,3 @@ matrix_mul (byte *in, byte *out, int size)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { i?86-*-* x86_64-*-* } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr52252-st.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr52252-st.c
@@ -18,4 +18,3 @@ matrix_mul (byte *in, byte *out, int size)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { i?86-*-* x86_64-*-* } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr53185-2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr53185-2.c
@@ -24,4 +24,3 @@ int main ()
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr53773.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr53773.c
@@ -15,6 +15,4 @@ foo (int integral, int decimal, int power_ten)
 }
 
 /* { dg-final { scan-tree-dump-times "\\* 10" 2 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/pr55857-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr55857-1.c
@@ -14,4 +14,3 @@ foo (int *data, unsigned len, const int qlp_coeff[], int lp, int residual[])
     }    
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr55857-2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr55857-2.c
@@ -18,4 +18,3 @@ void foo (int *data, unsigned len, const int qlp_coeff[],
       residual[i] = data[i] - ((qlp_coeff[0] * data[i-1]) >> lp);
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr56695.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr56695.c
@@ -11,4 +11,3 @@ f (void)
     a |= !(i |= b %= 1);
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr56787.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr56787.c
@@ -32,4 +32,3 @@ foo (unsigned long n, const float *__restrict u0,
 }
 
 /* { dg-final { scan-tree-dump "vectorized 1 loops" "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr56826.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr56826.c
@@ -38,4 +38,3 @@ int main()
   return 0;
 } 
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr56918.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr56918.c
@@ -28,4 +28,3 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr56920.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr56920.c
@@ -18,4 +18,3 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr56933.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr56933.c
@@ -42,4 +42,3 @@ int main()
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr57705.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr57705.c
@@ -63,4 +63,3 @@ main ()
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loop" 3 "vect" { target vect_pack_trunc } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loop" 2 "vect" { target { ! vect_pack_trunc } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr57741-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr57741-1.c
@@ -18,4 +18,3 @@ foo (float *p, float *q, float x)
     }
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr57741-2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr57741-2.c
@@ -41,4 +41,3 @@ main ()
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 2 loop" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr57741-3.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr57741-3.c
@@ -40,4 +40,3 @@ main ()
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loop" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr58508.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr58508.c
@@ -68,4 +68,3 @@ void test5 (int* a, int* b)
 
 /* { dg-final { scan-tree-dump-times "hoist" 8 "vect" { xfail *-*-* } } } */
 /* { dg-final { scan-tree-dump-times "hoist" 3 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr59354.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr59354.c
@@ -1,4 +1,3 @@
-/* { dg-do run } */
 /* { dg-additional-options "-O3" } */
 
 #include "tree-vect.h"
@@ -38,4 +37,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump "vectorized 1 loop" "vect" { target { vect_pack_trunc } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr59519-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr59519-1.c
@@ -16,4 +16,3 @@ foo (void)
       }
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr59519-2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr59519-2.c
@@ -17,4 +17,3 @@ foo (void)
       }
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr59591-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr59591-1.c
@@ -51,4 +51,3 @@ main ()
 }
 #endif
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr59591-2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr59591-2.c
@@ -52,4 +52,3 @@ main ()
 }
 #endif
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr59594.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr59594.c
@@ -28,4 +28,3 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr59651.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr59651.c
@@ -1,4 +1,3 @@
 /* PR tree-optimization/59561 */
 #include "../torture/pr59651.c"
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr59984.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr59984.c
@@ -62,4 +62,3 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr60012.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr60012.c
@@ -19,4 +19,3 @@ libvector_AccSquareNorm_ref (unsigned int *acc,
 }
 
 /* { dg-final { scan-tree-dump "LOOP VECTORIZED" "vect" { target { vect_extract_even_odd } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr60092-2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr60092-2.c
@@ -25,4 +25,3 @@ int *foo (int n)
 /* { dg-final { scan-tree-dump "LOOP VECTORIZED" "vect" } } */
 /* { dg-final { scan-tree-dump-not "Peeling for alignment will be applied" "vect" } } */
 /* { dg-final { scan-tree-dump-not "Vectorizing an unaligned access" "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr60092.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr60092.c
@@ -17,4 +17,3 @@ int *foo (int n)
 /* { dg-final { scan-tree-dump "LOOP VECTORIZED" "vect" } } */
 /* { dg-final { scan-tree-dump-not "Peeling for alignment will be applied" "vect" } } */
 /* { dg-final { scan-tree-dump-not "Vectorizing an unaligned access" "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr60196-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr60196-1.c
@@ -30,4 +30,3 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr60196-2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr60196-2.c
@@ -29,4 +29,3 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr60276.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr60276.c
@@ -48,4 +48,3 @@ int main(void)
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr60382.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr60382.c
@@ -29,4 +29,3 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr60482.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr60482.c
@@ -17,4 +17,3 @@ foo (double *x, int n)
 }
 
 /* { dg-final { scan-tree-dump-not "epilog loop required" "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr60505.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr60505.c
@@ -11,4 +11,3 @@ void foo(char *in, char *out, int num)
   out[num] = ovec[num/2];
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr60656.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr60656.c
@@ -44,4 +44,3 @@ int main()
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_widen_mult_si_to_di_pattern } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr60841.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr60841.c
@@ -180,4 +180,3 @@ foo (struct T *p, struct T *q, int x, int w)
     }
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr61194.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr61194.c
@@ -39,4 +39,3 @@ int main()
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr61634.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr61634.c
@@ -21,4 +21,3 @@ void fn1 (int p1[], int p2, int p3[], int p4[], int p5[], int *p6)
     ;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr61680.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr61680.c
@@ -49,4 +49,3 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr62021.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr62021.c
@@ -27,4 +27,3 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr62073.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr62073.c
@@ -37,4 +37,3 @@ int foo (long long p_56, int * p_57)
   return *l_77;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr62075.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr62075.c
@@ -19,4 +19,3 @@ foo (struct A *x)
     }
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr63148.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr63148.c
@@ -89,4 +89,3 @@ int main(int argc, char *argv[])
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr63189.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr63189.c
@@ -22,4 +22,3 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr63341-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr63341-1.c
@@ -28,4 +28,3 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr63341-2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr63341-2.c
@@ -31,4 +31,3 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr63379.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr63379.c
@@ -39,4 +39,3 @@ int main()
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr63605.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr63605.c
@@ -19,4 +19,3 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr64252.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr64252.c
@@ -1,6 +1,5 @@
 /* PR target/64252 */
 /* Test correctness of size 3 store groups permutation.  */
-/* { dg-do run } */
 /* { dg-additional-options "-O3" } */
 /* { dg-additional-options "-mavx" { target avx_runtime } } */
 
@@ -63,4 +62,3 @@ int main()
       abort ();
   return 0;
 }
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr64404.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr64404.c
@@ -1,4 +1,3 @@
-/* { dg-do run } */
 /* { dg-additional-options "--param=sccvn-max-alias-queries-per-access=1" } */
 
 #include "tree-vect.h"
@@ -56,4 +55,3 @@ main (void)
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr64421.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr64421.c
@@ -33,4 +33,3 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr64493.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr64493.c
@@ -1,5 +1,3 @@
-/* { dg-do run } */
-
 #include "tree-vect.h"
 
 int a, b, c, d, e, f, g, h;
@@ -28,4 +26,3 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr64495.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr64495.c
@@ -1,5 +1,3 @@
-/* { dg-do run } */
-
 #include <assert.h>
 #include "tree-vect.h"
 
@@ -32,4 +30,3 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr64829.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr64829.c
@@ -63,4 +63,3 @@ int fail ( const RMColorData * pInColor,
   return (0);
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr64844.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr64844.c
@@ -1,4 +1,3 @@
-/* { dg-do run } */
 /* { dg-require-effective-target vect_double } */
 /* { dg-additional-options "-ffast-math" } */
 
@@ -49,4 +48,3 @@ main()
    dealing with the known misalignment in loop 2.  */
 
 /* { dg-final { scan-tree-dump-times "loop vectorized" 2 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr65310.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr65310.c
@@ -20,4 +20,3 @@ int t(b *a)
 
 /* { dg-final { scan-tree-dump "can't force alignment" "vect" } } */
 /* { dg-final { scan-tree-dump-not "misalign = 0" "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr65494.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr65494.c
@@ -25,4 +25,3 @@ void foo(int n)
 }
 
 /* { dg-final { scan-tree-dump "vectorized 1 loops in function" "vect" { target { vect_float && vect_intfloat_cvt } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr65518.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr65518.c
@@ -1,5 +1,3 @@
-/* { dg-do run } */
-
 extern void abort (void);
 
 typedef struct giga
@@ -40,4 +38,3 @@ int main ()
    should reject that in the end).  */
 
 /* { dg-final { scan-tree-dump-times "vectorized 0 loops in function" 2 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/pr66251.c
+++ b/src/gcc/testsuite/gcc.dg/vect/pr66251.c
@@ -75,4 +75,3 @@ int main ()
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/section-anchors-pr27770.c
+++ b/src/gcc/testsuite/gcc.dg/vect/section-anchors-pr27770.c
@@ -28,4 +28,3 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/section-anchors-vect-69.c
+++ b/src/gcc/testsuite/gcc.dg/vect/section-anchors-vect-69.c
@@ -117,4 +117,3 @@ int main (void)
   is extended to handle structs.  */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 2 "vect" { target {vect_int && vector_alignment_reachable } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 4 "vect" { target {vect_int && {! vector_alignment_reachable} } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/slp-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-1.c
@@ -119,5 +119,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 4 loops" 1 "vect"  } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 4 "vect"  } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/slp-10.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-10.c
@@ -109,5 +109,4 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 3 "vect" {target {vect_uintfloat_cvt && vect_int_mult} } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 2 "vect"  {target {{! { vect_uintfloat_cvt}} && vect_int_mult} } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 0 "vect"  {target {{! { vect_uintfloat_cvt}} && { ! {vect_int_mult}}} } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/slp-11a.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-11a.c
@@ -72,4 +72,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { vect_strided8 && vect_int_mult } } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 0 loops" 1 "vect" { target { ! { vect_strided8 && vect_int_mult } } } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 0 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/slp-11b.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-11b.c
@@ -46,4 +46,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { vect_strided4 && vect_int_mult } } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 0 loops" 1 "vect" { target { ! { vect_strided4 && vect_int_mult } } } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 0 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/slp-11c.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-11c.c
@@ -43,4 +43,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { { vect_uintfloat_cvt && vect_strided2 } && vect_int_mult } } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 0 loops" 1 "vect" { target { ! { { vect_uintfloat_cvt && vect_strided2 } && vect_int_mult } } } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 0  "vect"  } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/slp-12a.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-12a.c
@@ -77,4 +77,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 0 loops" 1 "vect" { target { ! { vect_strided8 && vect_int_mult } } } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect" { target { vect_strided8 && vect_int_mult } } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 0 "vect" { target { ! { vect_strided8 && vect_int_mult } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/slp-12b.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-12b.c
@@ -47,5 +47,4 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 0 loops" 1 "vect"  { target { ! { vect_strided2 && vect_int_mult } } } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect"  { target { vect_strided2 && vect_int_mult } } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 0 "vect"  { target { ! { vect_strided2 && vect_int_mult } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/slp-12c.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-12c.c
@@ -50,4 +50,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 0 loops" 1 "vect"  { target { ! vect_int_mult } } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect" { target vect_int_mult } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 0 "vect" { target { ! vect_int_mult } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/slp-13-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-13-big-array.c
@@ -137,5 +137,4 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 2 loops" 1 "vect" { target { vect_interleave && vect_extract_even_odd } } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 3 "vect" { xfail *-*-* }  } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/slp-13.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-13.c
@@ -129,5 +129,4 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 2 loops" 1 "vect" { target { vect_interleave && vect_extract_even_odd } } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 3 "vect" { xfail *-*-* }  } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/slp-14.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-14.c
@@ -112,5 +112,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  { target vect_int_mult } } }  */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 2 "vect" { target vect_int_mult } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/slp-15.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-15.c
@@ -114,5 +114,4 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 0 loops" 1 "vect"  {target  { ! { vect_int_mult } } } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 2 "vect" {target vect_int_mult } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 0 "vect" {target { ! { vect_int_mult } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/slp-16.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-16.c
@@ -67,5 +67,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  { target vect_int_mult } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 2 "vect" { target vect_int_mult } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/slp-17.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-17.c
@@ -52,5 +52,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 2 "vect"  } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/slp-18.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-18.c
@@ -93,5 +93,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_strided8 } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 2 "vect" { target vect_strided8 } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/slp-19a.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-19a.c
@@ -58,4 +58,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 0 loops" 1 "vect" { target { ! vect_strided8 } } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect" { target vect_strided8 } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 0 "vect" { target { ! vect_strided8} } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/slp-19b.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-19b.c
@@ -55,4 +55,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 0 loops" 1 "vect" { target { ! vect_strided4 } } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect" { target vect_strided4 } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 0 "vect" { target { ! vect_strided4 } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/slp-19c.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-19c.c
@@ -92,4 +92,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/slp-2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-2.c
@@ -141,5 +141,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 4 loops" 1 "vect"  } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 4 "vect"  } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/slp-20.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-20.c
@@ -111,5 +111,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 2 loops" 1 "vect"  } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 4 "vect"  } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/slp-21.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-21.c
@@ -203,5 +203,4 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  { target  { ! { vect_strided4 || vect_extract_even_odd } } } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 2 "vect" { target vect_strided4 }  } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 0 "vect"  { target { ! { vect_strided4 } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/slp-22.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-22.c
@@ -130,5 +130,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 2 loops" 1 "vect"  } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 6 "vect"  } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/slp-23.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-23.c
@@ -109,5 +109,4 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 2 loops" 1 "vect" { target { vect_strided8 && { ! { vect_no_align} } } } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { ! { vect_strided8 || vect_no_align } } } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/slp-24-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-24-big-array.c
@@ -96,4 +96,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail { vect_no_align && ilp32 } } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 2 "vect" { xfail { vect_no_align && ilp32 } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/slp-24.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-24.c
@@ -81,4 +81,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail { vect_no_align && ilp32 } } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 2 "vect" { xfail { vect_no_align && ilp32 } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/slp-25.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-25.c
@@ -58,4 +58,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 2 loops" 1 "vect"  } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 2 "vect" { xfail { { vect_no_align && { ! vect_hw_misalign } } || { ! vect_natural_alignment } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/slp-26.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-26.c
@@ -48,5 +48,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 0 loops" 1 "vect"  } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 0 "vect"  } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/slp-28.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-28.c
@@ -82,5 +82,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect"  } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/slp-3-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-3-big-array.c
@@ -151,5 +151,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 4 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 4 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/slp-3.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-3.c
@@ -143,5 +143,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 3 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 3 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/slp-33.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-33.c
@@ -107,5 +107,4 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 3 "vect" {target {vect_uintfloat_cvt && vect_int_mult} } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 2 "vect"  {target {{! { vect_uintfloat_cvt}} && vect_int_mult} } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 0 "vect"  {target {{! { vect_uintfloat_cvt}} && {! {vect_int_mult}}} } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/slp-34-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-34-big-array.c
@@ -65,5 +65,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 2 "vect"  } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/slp-34.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-34.c
@@ -57,5 +57,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 2 "vect"  } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/slp-35.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-35.c
@@ -69,5 +69,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/slp-36.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-36.c
@@ -73,4 +73,3 @@ test_3 (void)
 
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/slp-37.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-37.c
@@ -63,5 +63,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 0 "vect"  } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 0 "vect"  } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/slp-38.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-38.c
@@ -21,4 +21,3 @@ void Compute(void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops in function" 1 "vect" { target { vect_float && vect_perm } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/slp-39.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-39.c
@@ -22,4 +22,3 @@ void bar (double w)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 2 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/slp-4-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-4-big-array.c
@@ -131,5 +131,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 3 loops" 1 "vect"  } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 3 "vect"  } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/slp-4.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-4.c
@@ -123,5 +123,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 3 loops" 1 "vect"  } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 3 "vect"  } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/slp-5.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-5.c
@@ -122,5 +122,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 3 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 3 "vect"  } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/slp-6.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-6.c
@@ -118,5 +118,4 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 2 loops" 1 "vect"  {target  { ! { vect_int_mult } } } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 3 "vect" {target vect_int_mult  } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 2 "vect" {target  { ! { vect_int_mult } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/slp-7.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-7.c
@@ -124,5 +124,4 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 2 loops" 1 "vect"  { target { ! { vect_short_mult } } } } }*/
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 3 "vect"  { target vect_short_mult } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 2 "vect"  { target { ! { vect_short_mult } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
  
--- a/src/gcc/testsuite/gcc.dg/vect/slp-8.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-8.c
@@ -43,4 +43,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target powerpc*-*-* i?86-*-* x86_64-*-* } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect" { target powerpc*-*-* i?86-*-* x86_64-*-* } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/slp-9.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-9.c
@@ -45,5 +45,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_widen_mult_hi_to_si } } }*/
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect" { target vect_widen_mult_hi_to_si } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/slp-cond-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-cond-1.c
@@ -123,4 +123,3 @@ main ()
 }
 
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 3 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/slp-cond-2-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-cond-2-big-array.c
@@ -124,4 +124,3 @@ main ()
 }
 
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 3 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/slp-cond-2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-cond-2.c
@@ -124,4 +124,3 @@ main ()
 }
 
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 3 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/slp-cond-3.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-cond-3.c
@@ -80,5 +80,4 @@ int main ()
 }
 
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/slp-cond-4.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-cond-4.c
@@ -83,4 +83,3 @@ int main ()
 }
 
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/slp-multitypes-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-multitypes-1.c
@@ -53,5 +53,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 2 "vect"  } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/slp-multitypes-10.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-multitypes-10.c
@@ -47,5 +47,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  { target vect_pack_trunc } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect"  { target vect_pack_trunc } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/slp-multitypes-11-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-multitypes-11-big-array.c
@@ -58,5 +58,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  { target vect_unpack } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect"  { target vect_unpack } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/slp-multitypes-11.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-multitypes-11.c
@@ -50,5 +50,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  { target vect_unpack } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect"  { target vect_unpack } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/slp-multitypes-12.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-multitypes-12.c
@@ -63,5 +63,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 3 "vect"  } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/slp-multitypes-2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-multitypes-2.c
@@ -78,5 +78,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 2 "vect"  } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/slp-multitypes-3.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-multitypes-3.c
@@ -89,4 +89,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail sparc*-*-* } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 2 "vect" { xfail sparc*-*-* } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/slp-multitypes-4.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-multitypes-4.c
@@ -53,5 +53,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  { target vect_unpack } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect"  { target vect_unpack } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/slp-multitypes-5.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-multitypes-5.c
@@ -53,5 +53,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_pack_trunc } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect" { target vect_pack_trunc } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/slp-multitypes-6.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-multitypes-6.c
@@ -53,5 +53,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  { target vect_pack_trunc } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect"  { target vect_pack_trunc } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/slp-multitypes-7.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-multitypes-7.c
@@ -53,5 +53,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  { target vect_unpack } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect"  { target vect_unpack } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/slp-multitypes-8.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-multitypes-8.c
@@ -41,5 +41,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  { target vect_unpack } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect"  { target vect_unpack } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/slp-multitypes-9.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-multitypes-9.c
@@ -41,5 +41,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  { target vect_pack_trunc } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect"  { target vect_pack_trunc } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/slp-perm-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-perm-1.c
@@ -59,5 +59,4 @@ int main (int argc, const char* argv[])
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  { target vect_perm } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect" { target vect_perm } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/slp-perm-2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-perm-2.c
@@ -55,5 +55,4 @@ int main (int argc, const char* argv[])
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  { target vect_perm } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect" { target vect_perm } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/slp-perm-3.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-perm-3.c
@@ -68,6 +68,5 @@ int main (int argc, const char* argv[])
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  { target vect_perm } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect" { target vect_perm } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
 
--- a/src/gcc/testsuite/gcc.dg/vect/slp-perm-4.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-perm-4.c
@@ -83,5 +83,4 @@ int main (int argc, const char* argv[])
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 0 "vect"  } } */
 /* { dg-final { scan-tree-dump "permutation requires at least three vectors" "vect" { target vect_perm} } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 0 "vect"  } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/slp-perm-5.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-perm-5.c
@@ -74,6 +74,5 @@ int main (int argc, const char* argv[])
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  { target vect_perm } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 2 "vect" { target vect_perm } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
 
--- a/src/gcc/testsuite/gcc.dg/vect/slp-perm-6.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-perm-6.c
@@ -73,5 +73,4 @@ int main (int argc, const char* argv[])
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  { target vect_perm } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 2 "vect" { target vect_perm } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/slp-perm-7.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-perm-7.c
@@ -70,8 +70,7 @@ int main (int argc, const char* argv[])
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  { target vect_perm } } } */
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 2 "vect"  { target vect_perm } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect" { target vect_perm } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
 
--- a/src/gcc/testsuite/gcc.dg/vect/slp-perm-8.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-perm-8.c
@@ -55,5 +55,4 @@ int main (int argc, const char* argv[])
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 2 "vect" { target { vect_perm_byte && vect_char_mult } } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { vect_perm_byte && {! vect_char_mult } } } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect" { target vect_perm_byte } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/slp-perm-9.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-perm-9.c
@@ -58,5 +58,4 @@ int main (int argc, const char* argv[])
 /* { dg-final { scan-tree-dump-times "permutation requires at least three vectors" 1 "vect" { target vect_perm_short } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 0 "vect" { target { {! vect_perm } || {! vect_sizes_32B_16B } } } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect" { target { { vect_perm } && { vect_sizes_32B_16B } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/slp-reduc-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-reduc-1.c
@@ -44,5 +44,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail vect_no_int_add } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect" { xfail vect_no_int_add } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/slp-reduc-2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-reduc-2.c
@@ -39,5 +39,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail vect_no_int_add } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect" { xfail vect_no_int_add } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/slp-reduc-3.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-reduc-3.c
@@ -59,4 +59,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vect_recog_dot_prod_pattern: detected" 1 "vect" { xfail *-*-* } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 2 "vect" { target { vect_short_mult && { vect_widen_sum_hi_to_si  && vect_unpack } } } } } */ 
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect" { xfail { vect_widen_sum_hi_to_si_pattern ||  { ! vect_unpack } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/slp-reduc-4.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-reduc-4.c
@@ -58,5 +58,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail vect_no_int_max } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect" { xfail vect_no_int_max } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/slp-reduc-5.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-reduc-5.c
@@ -44,5 +44,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 2 "vect" { xfail vect_no_int_max } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect" { xfail vect_no_int_max } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/slp-reduc-6.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-reduc-6.c
@@ -45,5 +45,4 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 2 "vect" { xfail { vect_no_int_add || { ! { vect_unpack || vect_strided2 } } } } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 0 "vect" } } */
 /* { dg-final { scan-tree-dump-times "different interleaving chains in one node" 1 "vect" { target { ! vect_no_int_add } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/slp-widen-mult-half.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-widen-mult-half.c
@@ -48,5 +48,4 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 2 "vect" { target vect_widen_mult_hi_to_si } } } */
 /* { dg-final { scan-tree-dump-times "vect_recog_widen_mult_pattern: detected" 2 "vect" { target vect_widen_mult_hi_to_si_pattern } } } */
 /* { dg-final { scan-tree-dump-times "pattern recognized" 2 "vect" { target vect_widen_mult_hi_to_si_pattern } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/slp-widen-mult-s16.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-widen-mult-s16.c
@@ -39,5 +39,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { vect_widen_mult_hi_to_si || vect_unpack } } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect" { target { vect_widen_mult_hi_to_si || vect_unpack } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/slp-widen-mult-u8.c
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-widen-mult-u8.c
@@ -39,5 +39,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { vect_widen_mult_qi_to_hi || vect_unpack } } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect" { target { vect_widen_mult_hi_to_si || vect_unpack } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/trapv-vect-reduc-4.c
+++ b/src/gcc/testsuite/gcc.dg/vect/trapv-vect-reduc-4.c
@@ -1,5 +1,5 @@
-/* { dg-require-effective-target vect_int } */
 /* { dg-do compile } */
+/* { dg-require-effective-target vect_int } */
 
 #include <stdarg.h>
 #include "tree-vect.h"
@@ -47,4 +47,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 0 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/unswitch-loops-pr26969.c
+++ b/src/gcc/testsuite/gcc.dg/vect/unswitch-loops-pr26969.c
@@ -12,4 +12,3 @@ ruby_re_compile_fastmap (char *fastmap, int options)
     }
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vec-scal-opt.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vec-scal-opt.c
@@ -20,4 +20,3 @@ int main (int argc, char *argv[]) {
 }
 
 /* { dg-final { scan-tree-dump-times ">> k.\[0-9_\]*" 1 "veclower21" } } */
-/* { dg-final { cleanup-tree-dump "veclower21" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vec-scal-opt1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vec-scal-opt1.c
@@ -18,4 +18,3 @@ int main (int argc, char *argv[]) {
 }
 
 /* { dg-final { scan-tree-dump-times ">> 2" 1 "veclower21" } } */
-/* { dg-final { cleanup-tree-dump "veclower21" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vec-scal-opt2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vec-scal-opt2.c
@@ -17,4 +17,3 @@ int main (int argc, char *argv[]) {
 }
 
 /* { dg-final { scan-tree-dump-times ">> 2" 1 "veclower21" } } */
-/* { dg-final { cleanup-tree-dump "veclower21" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-1-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-1-big-array.c
@@ -88,4 +88,3 @@ foo (int n)
 
 /* { dg-final { scan-tree-dump-times "vectorized 6 loops" 1 "vect" { target vect_strided2 } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 5 loops" 1 "vect" { xfail vect_strided2 } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-1.c
@@ -88,4 +88,3 @@ foo (int n)
 
 /* { dg-final { scan-tree-dump-times "vectorized 6 loops" 1 "vect" { target vect_strided2 } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 5 loops" 1 "vect" { xfail vect_strided2 } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-10-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-10-big-array.c
@@ -35,4 +35,3 @@ int foo ()
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail { ! vect_strided2 } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-10.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-10.c
@@ -23,4 +23,3 @@ int foo ()
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail { ! vect_strided2 } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-100.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-100.c
@@ -76,5 +76,4 @@ int main (void)
 
 /* Requires versioning.  */
 /* { dg-final { scan-tree-dump-times "vectorized 2 loops" 0 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-103.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-103.c
@@ -56,5 +56,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "dependence distance modulo vf == 0" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-104.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-104.c
@@ -66,5 +66,4 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 0 "vect" } } */
 /* { dg-final { scan-tree-dump-times "possible dependence between data-refs" 1 "vect" { target { ! vect_multiple_sizes } } } } */
 /* { dg-final { scan-tree-dump-times "possible dependence between data-refs" 2 "vect" { target vect_multiple_sizes } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-105-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-105-big-array.c
@@ -102,5 +102,4 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 2 "vect" { target { vect_no_align && { ! vect_hw_misalign } } } } } */
 /* { dg-final { scan-tree-dump-times "possible dependence between data-refs" 0 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-105.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-105.c
@@ -68,5 +68,4 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 2 "vect" { target { vect_no_align && { ! vect_hw_misalign } } } } } */
 /* { dg-final { scan-tree-dump-times "possible dependence between data-refs" 0 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-106.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-106.c
@@ -69,5 +69,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 2 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-107.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-107.c
@@ -42,4 +42,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_strided2 } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 0 loops" 1 "vect" { xfail vect_strided2 } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-108.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-108.c
@@ -37,5 +37,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-109.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-109.c
@@ -77,5 +77,4 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 2 "vect" { target vect_element_align } } } */
 /* { dg-final { scan-tree-dump-times "not vectorized: unsupported unaligned store" 2 "vect" { xfail vect_element_align } } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 3 "vect" { target vect_element_align } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-11.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-11.c
@@ -39,4 +39,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-110.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-110.c
@@ -35,6 +35,5 @@ int main (void)
 }
      
 /* { dg-final { scan-tree-dump-times "vectorized 0 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-112-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-112-big-array.c
@@ -45,6 +45,5 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_unpack } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-112.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-112.c
@@ -34,6 +34,5 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_unpack } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-113.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-113.c
@@ -33,4 +33,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target powerpc*-*-* i?86-*-* x86_64-*-* } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-114.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-114.c
@@ -36,5 +36,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 0 loops" 1 "vect" { target { ! { vect_perm  } } } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_perm } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-115.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-115.c
@@ -72,6 +72,5 @@ int main (void)
 }
           
 /* { dg-final { scan-tree-dump-times "vectorized 2 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-116.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-116.c
@@ -30,4 +30,3 @@ int main()
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-117.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-117.c
@@ -62,5 +62,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "possible dependence between data-refs" 0 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-118.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-118.c
@@ -9,4 +9,3 @@ void f(short * __restrict__ a, short * __restrict__ b, short * __restrict__ x)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-119.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-119.c
@@ -26,4 +26,3 @@ unsigned int foo (const unsigned int x[OUTER][INNER][2])
 }
 
 /* { dg-final { scan-tree-dump-times "Detected interleaving of size 2" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-11a.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-11a.c
@@ -62,4 +62,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 2 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-12.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-12.c
@@ -41,4 +41,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-120.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-120.c
@@ -34,4 +34,3 @@ tV()
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-121.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-121.c
@@ -15,4 +15,3 @@ test (int start, int end)
 }
 
 /* { dg-final { scan-tree-dump "vectorized 1 loops" "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-122.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-122.c
@@ -56,4 +56,3 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-123.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-123.c
@@ -12,4 +12,3 @@ void foo (int s)
 }
 
 /* { dg-final { scan-tree-dump "vectorized 1 loops" "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-124.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-124.c
@@ -27,4 +27,3 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-13.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-13.c
@@ -40,4 +40,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail vect_no_int_max } } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-14.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-14.c
@@ -34,4 +34,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-15-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-15-big-array.c
@@ -45,4 +45,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { vect_perm && vect_hw_misalign } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-15.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-15.c
@@ -36,4 +36,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { vect_perm && vect_hw_misalign } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-17.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-17.c
@@ -127,4 +127,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 3 loops" 1 "vect" { xfail vect_no_bitwise } } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-18.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-18.c
@@ -126,4 +126,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 3 loops" 1 "vect" { xfail vect_no_bitwise } } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-19.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-19.c
@@ -126,4 +126,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 3 loops" 1 "vect" { xfail vect_no_bitwise } } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-2-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-2-big-array.c
@@ -48,4 +48,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-2.c
@@ -38,4 +38,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-20.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-20.c
@@ -98,4 +98,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 3 loops" 1 "vect" { xfail vect_no_bitwise } } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-21.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-21.c
@@ -127,4 +127,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 3 loops" 1 "vect" { target vect_condition } } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-22.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-22.c
@@ -124,4 +124,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 4 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-23.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-23.c
@@ -125,4 +125,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 3 loops" 1 "vect" { xfail *-*-* } } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-24.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-24.c
@@ -125,4 +125,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 3 loops" 1 "vect" { xfail *-*-* } } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-25.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-25.c
@@ -52,4 +52,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 2 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-26.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-26.c
@@ -38,4 +38,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-27.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-27.c
@@ -48,4 +48,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { vect_no_align && { ! vect_hw_misalign } } } } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-28.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-28.c
@@ -42,4 +42,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { target { vector_alignment_reachable } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 1 "vect" { target { {! vector_alignment_reachable} && {! vect_hw_misalign} } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-29.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-29.c
@@ -54,4 +54,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 1 "vect" {target { vect_no_align && { ! vect_hw_misalign } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-3.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-3.c
@@ -49,4 +49,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-30.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-30.c
@@ -62,4 +62,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 2 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-31-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-31-big-array.c
@@ -87,4 +87,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 4 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-31.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-31.c
@@ -87,4 +87,3 @@ int main (void)
 } 
 
 /* { dg-final { scan-tree-dump-times "vectorized 4 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-32-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-32-big-array.c
@@ -37,4 +37,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-32.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-32.c
@@ -37,4 +37,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-33-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-33-big-array.c
@@ -41,4 +41,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { target vector_alignment_reachable } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 1 "vect" { target { {! vector_alignment_reachable} && {! vect_hw_misalign} } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-33.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-33.c
@@ -40,4 +40,3 @@ int main (void)
 /* { dg-final { scan-tree-dump "Vectorizing an unaligned access" "vect" { target { { { ! powerpc*-*-* } && vect_hw_misalign } && { { ! vect64 } || vect_multiple_sizes } } } } }  */
 /* { dg-final { scan-tree-dump "Alignment of access forced using peeling" "vect" { target { vector_alignment_reachable && { vect64 && {! vect_multiple_sizes} } } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 1 "vect" { target { { {! vector_alignment_reachable} || {! vect64} } && {! vect_hw_misalign} } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-34-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-34-big-array.c
@@ -47,4 +47,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-34.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-34.c
@@ -38,4 +38,3 @@ int main (void)
 } 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-35-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-35-big-array.c
@@ -47,4 +47,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 2 loops" 1 "vect"  { xfail { ia64-*-* sparc*-*-* } } } } */
 /* { dg-final { scan-tree-dump-times "can't determine dependence between" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-35.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-35.c
@@ -47,4 +47,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 2 loops" 1 "vect"  { xfail { ia64-*-* sparc*-*-* } } } } */
 /* { dg-final { scan-tree-dump "can't determine dependence between" "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-36-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-36-big-array.c
@@ -44,4 +44,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-36.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-36.c
@@ -44,4 +44,3 @@ int main (void)
 } 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-38.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-38.c
@@ -37,4 +37,3 @@ int main (void)
 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-4.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-4.c
@@ -39,4 +39,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-40.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-40.c
@@ -60,4 +60,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"} } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-42.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-42.c
@@ -69,4 +69,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 4 "vect" { xfail { vect_no_align || { { !  vector_alignment_reachable } || vect_element_align  } } } } }  */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 3 "vect" { target vect_element_align } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { xfail { vect_no_align || { { ! vector_alignment_reachable } || vect_element_align } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-44.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-44.c
@@ -69,4 +69,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { xfail { { vect_no_align && { ! vect_hw_misalign } } || {! vector_alignment_reachable} } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 3 "vect" { target { vect_no_align && { ! vect_hw_misalign } } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 1 "vect" { target { {! vector_alignment_reachable} && {{! vect_no_align} && {! vect_hw_misalign} } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-46.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-46.c
@@ -62,4 +62,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-48.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-48.c
@@ -58,4 +58,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 2 "vect" { target { vect_no_align && { ! vect_hw_misalign } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-5.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-5.c
@@ -56,4 +56,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 2 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-50.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-50.c
@@ -66,4 +66,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { xfail { { vect_no_align && { ! vect_hw_misalign } } || {! vector_alignment_reachable} } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 3 "vect" { target { vect_no_align && { ! vect_hw_misalign } } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 1 "vect" { target { {! vector_alignment_reachable} && { {! vect_no_align } && {! vect_hw_misalign } } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-52.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-52.c
@@ -59,4 +59,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 2 "vect" { target { vect_no_align && { ! vect_hw_misalign } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-54.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-54.c
@@ -62,4 +62,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-56.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-56.c
@@ -72,4 +72,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { target { vect_element_align } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" { xfail { vect_element_align } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { target { vect_element_align } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-58.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-58.c
@@ -60,4 +60,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-6-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-6-big-array.c
@@ -77,4 +77,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 2 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" { target { { vect_aligned_arrays } && {! vect_sizes_32B_16B} } } } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { target { {! vect_aligned_arrays } && {vect_sizes_32B_16B} } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-6.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-6.c
@@ -56,4 +56,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 2 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" { target { { vect_aligned_arrays } && {! vect_sizes_32B_16B} } } } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { target { {! vect_aligned_arrays } && {vect_sizes_32B_16B} } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-60.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-60.c
@@ -73,4 +73,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { target { vect_element_align } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" { xfail { vect_element_align } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { target { vect_element_align } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-62.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-62.c
@@ -67,4 +67,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-63.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-63.c
@@ -43,4 +43,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-64.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-64.c
@@ -83,4 +83,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 3 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-65.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-65.c
@@ -80,4 +80,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 2 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-66.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-66.c
@@ -93,4 +93,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 3 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-67.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-67.c
@@ -44,4 +44,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-68.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-68.c
@@ -86,4 +86,3 @@ int main (void)
 } 
 
 /* { dg-final { scan-tree-dump-times "vectorized 4 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-7.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-7.c
@@ -50,4 +50,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 2 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-70.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-70.c
@@ -66,4 +66,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" {target { vector_alignment_reachable} } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 1 "vect" {target {{! vector_alignment_reachable} && {! vect_hw_misalign} } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-71.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-71.c
@@ -37,4 +37,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-72.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-72.c
@@ -49,4 +49,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-73-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-73-big-array.c
@@ -49,4 +49,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-73.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-73.c
@@ -40,4 +40,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-74-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-74-big-array.c
@@ -65,4 +65,3 @@ int main (void)
  dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail vect_no_align } }
  dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { xfail vect_no_align } }
 */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-74.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-74.c
@@ -49,4 +49,3 @@ int main (void)
  dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail vect_no_align } } 
  dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { xfail vect_no_align } }  
 */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-75-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-75-big-array.c
@@ -54,4 +54,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /*  { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 1 "vect" { target { vect_no_align && { ! vect_hw_misalign } } } } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-75.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-75.c
@@ -46,4 +46,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 1 "vect" { target { vect_no_align && { ! vect_hw_misalign } } } } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-76-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-76-big-array.c
@@ -80,4 +80,3 @@ int main (void)
 
 
 /* { dg-final { scan-tree-dump-times "vectorized 3 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-76.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-76.c
@@ -71,4 +71,3 @@ int main (void)
 
 
 /* { dg-final { scan-tree-dump-times "vectorized 3 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-77-alignchecks.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-77-alignchecks.c
@@ -53,4 +53,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { target { {! vect_no_align} && { unaligned_stack && vector_alignment_reachable } } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 1 "vect" { target { { {! unaligned_stack} && { vect_no_align && { ! vect_hw_misalign } } } || {unaligned_stack && { {! vector_alignment_reachable} && {! vect_no_align } } } } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 2 "vect" { target { { unaligned_stack && { vector_alignment_reachable && vect_no_align } } || {unaligned_stack && { {! vector_alignment_reachable} && vect_no_align } } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-77-global.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-77-global.c
@@ -51,4 +51,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 1 "vect" { target { vect_no_align && { ! vect_hw_misalign } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-77.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-77.c
@@ -43,4 +43,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-78-alignchecks.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-78-alignchecks.c
@@ -54,4 +54,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { target { {! vect_no_align} && { unaligned_stack && vector_alignment_reachable } } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 1 "vect" { target { { {! unaligned_stack} && { vect_no_align && { ! vect_hw_misalign } } } || {unaligned_stack && { {! vector_alignment_reachable} && { ! vect_no_align } } } } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 2 "vect" { target { { unaligned_stack && { vector_alignment_reachable && vect_no_align } } || {unaligned_stack && { {! vector_alignment_reachable} && vect_no_align } } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-78-global.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-78-global.c
@@ -51,4 +51,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 1 "vect" { target { vect_no_align && { ! vect_hw_misalign } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-78.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-78.c
@@ -43,4 +43,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-8.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-8.c
@@ -36,4 +36,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-80-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-80-big-array.c
@@ -68,4 +68,3 @@ int main (void)
  dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { xfail vect_no_align } }
  dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 3 "vect" { target vect_no_align } }
 */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-80.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-80.c
@@ -53,4 +53,3 @@ int main (void)
  dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { xfail vect_no_align } } 
  dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 3 "vect" { target vect_no_align } } 
 */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-82.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-82.c
@@ -34,4 +34,3 @@ int main (void)
 } 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-82_64.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-82_64.c
@@ -37,4 +37,3 @@ int main (void)
 } 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-83.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-83.c
@@ -34,4 +34,3 @@ int main (void)
 } 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-83_64.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-83_64.c
@@ -37,4 +37,3 @@ int main (void)
 } 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-85-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-85-big-array.c
@@ -46,4 +46,3 @@ int main (void)
 
 /* Fails for targets that don't vectorize PLUS (e.g alpha).  */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-85.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-85.c
@@ -46,4 +46,3 @@ int main (void)
 
 /* Fails for targets that don't vectorize PLUS (e.g alpha).  */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-86.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-86.c
@@ -53,4 +53,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-87.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-87.c
@@ -53,4 +53,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" {target vector_alignment_reachable} } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 1 "vect" {target { {! vector_alignment_reachable} && {! vect_hw_misalign} } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-88.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-88.c
@@ -53,4 +53,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" {target vector_alignment_reachable } } }  */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 1 "vect" {target { {! vector_alignment_reachable} && {! vect_hw_misalign} } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-89-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-89-big-array.c
@@ -47,4 +47,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-89.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-89.c
@@ -47,4 +47,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-9.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-9.c
@@ -37,4 +37,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_unpack } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-91.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-91.c
@@ -62,4 +62,3 @@ main3 ()
 /* { dg-final { scan-tree-dump-times "accesses have the same alignment." 2 "vect" { target { {! vect_aligned_arrays } && {vect_sizes_32B_16B} } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 3 "vect" {target { vector_alignment_reachable } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 3 "vect" {target { {! vector_alignment_reachable} && {! vect_hw_misalign} } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-92.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-92.c
@@ -93,4 +93,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 3 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 3 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-93.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-93.c
@@ -82,4 +82,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { vect_no_align && { ! vect_hw_misalign } } } } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-95.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-95.c
@@ -66,4 +66,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 2 "vect" { xfail { vect_no_align || vect_element_align } } } } */
 /*  { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" { target { vect_no_align && { ! vect_hw_misalign } } } } } */
 /*  { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 4 "vect" { target { vect_no_align && { ! vect_hw_misalign } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-96.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-96.c
@@ -47,4 +47,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { target { {! vect_no_align} && vector_alignment_reachable } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { xfail { { vect_no_align } || { { ! vector_alignment_reachable} || vect_element_align } } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 1 "vect" { target { { vect_no_align && { ! vect_hw_misalign } } || { {! vector_alignment_reachable} && {! vect_element_align} } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-97-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-97-big-array.c
@@ -70,4 +70,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 2 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-97.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-97.c
@@ -62,4 +62,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 2 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-98-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-98-big-array.c
@@ -54,4 +54,3 @@ int main (void)
 /* Needs interleaving support.  */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_strided4 } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 0 "vect" { xfail  vect_strided4 } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-98.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-98.c
@@ -40,4 +40,3 @@ int main (void)
 /* Needs interleaving support.  */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_strided4 } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 0 "vect" { xfail  vect_strided4 } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-99.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-99.c
@@ -30,4 +30,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-aggressive-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-aggressive-1.c
@@ -1,4 +1,3 @@
-/* { dg-do run } */
 /* { dg-require-effective-target vect_condition } */
 /* { dg-require-effective-target vect_simd_clones } */
 /* { dg-additional-options "-fopenmp-simd" } */
@@ -60,4 +59,3 @@ default:
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-alias-check.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-alias-check.c
@@ -15,4 +15,3 @@ void foo (int *a, int *b)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-align-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-align-1.c
@@ -50,4 +50,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { target vect_hw_misalign } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 1 "vect" { xfail vect_hw_misalign} } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-align-2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-align-2.c
@@ -45,4 +45,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 1 "vect" { xfail vect_hw_misalign} } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-align-3.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-align-3.c
@@ -52,4 +52,3 @@ f4 (int x, int y)
 
 /* { dg-final { scan-tree-dump-not "vect_do_peeling_for_loop_bound" "vect" } } */
 /* { dg-final { scan-tree-dump-not "loop peeled for vectorization" "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-all-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-all-big-array.c
@@ -253,4 +253,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" { target { { vect_aligned_arrays } && {! vect_sizes_32B_16B} } } } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { target { {! vect_aligned_arrays } && {vect_sizes_32B_16B} } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-all.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-all.c
@@ -219,4 +219,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" { target { { vect_aligned_arrays } && {! vect_sizes_32B_16B} } } } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { target { {! vect_aligned_arrays } && {vect_sizes_32B_16B} } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-bool-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-bool-1.c
@@ -12,4 +12,3 @@ void foo (void)
 }
 
 /* { dg-final { scan-tree-dump "vectorized 1 loops" "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-bswap16.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-bswap16.c
@@ -41,4 +41,3 @@ main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-bswap32.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-bswap32.c
@@ -41,4 +41,3 @@ main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-bswap64.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-bswap64.c
@@ -41,4 +41,3 @@ main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-complex-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-complex-1.c
@@ -52,4 +52,3 @@ main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-complex-2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-complex-2.c
@@ -52,4 +52,3 @@ main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-complex-4.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-complex-4.c
@@ -105,4 +105,3 @@ main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-complex-5.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-complex-5.c
@@ -41,4 +41,3 @@ main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 0 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-cond-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-cond-1.c
@@ -52,6 +52,5 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-cond-10.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-cond-10.c
@@ -163,4 +163,3 @@ main ()
 }
 
 /* { dg-final { scan-tree-dump-times "note: vectorized 1 loops" 8 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-cond-11.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-cond-11.c
@@ -113,4 +113,3 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-cond-2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-cond-2.c
@@ -43,6 +43,5 @@ int main (void)
 /* The order of computation should not be changed for cond_expr, therefore, 
    it cannot be vectorized in reduction.  */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-cond-3.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-cond-3.c
@@ -60,6 +60,5 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-cond-4.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-cond-4.c
@@ -57,6 +57,5 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-cond-5.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-cond-5.c
@@ -57,5 +57,4 @@ int main ()
    of computation is the same, but vector results should be reduced to scalar
    result, which can'be done for cond_expr.  */
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
       
--- a/src/gcc/testsuite/gcc.dg/vect/vect-cond-6.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-cond-6.c
@@ -55,5 +55,4 @@ int main ()
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
       
--- a/src/gcc/testsuite/gcc.dg/vect/vect-cond-7.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-cond-7.c
@@ -65,4 +65,3 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-cond-8.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-cond-8.c
@@ -119,4 +119,3 @@ main ()
 }
 
 /* { dg-final { scan-tree-dump-times "note: vectorized 1 loops" 5 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-cond-9.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-cond-9.c
@@ -198,4 +198,3 @@ main ()
 }
 
 /* { dg-final { scan-tree-dump-times "note: vectorized 1 loops" 10 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-cond-reduc-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-cond-reduc-1.c
@@ -16,5 +16,4 @@ int foo()
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-cond-reduc-2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-cond-reduc-2.c
@@ -15,5 +15,4 @@ void foo(int k)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-cselim-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-cselim-1.c
@@ -83,4 +83,3 @@ main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  { xfail { { vect_no_align && { ! vect_hw_misalign } } || { ! vect_strided2 } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-cselim-2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-cselim-2.c
@@ -62,4 +62,3 @@ main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 0 "vect"  } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-double-reduc-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-double-reduc-1.c
@@ -51,5 +51,4 @@ int main ()
 }
         
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
       
--- a/src/gcc/testsuite/gcc.dg/vect/vect-double-reduc-2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-double-reduc-2.c
@@ -51,5 +51,4 @@ int main ()
 }
         
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
       
--- a/src/gcc/testsuite/gcc.dg/vect/vect-double-reduc-3.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-double-reduc-3.c
@@ -62,5 +62,4 @@ int main ()
 }
         
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" { xfail vect_no_int_max } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
       
--- a/src/gcc/testsuite/gcc.dg/vect/vect-double-reduc-4.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-double-reduc-4.c
@@ -51,5 +51,4 @@ int main ()
 }
         
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
       
--- a/src/gcc/testsuite/gcc.dg/vect/vect-double-reduc-5.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-double-reduc-5.c
@@ -53,5 +53,4 @@ int main ()
 /* Vectorization of loops with multiple types and double reduction is not 
    supported yet.  */       
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
       
--- a/src/gcc/testsuite/gcc.dg/vect/vect-double-reduc-6-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-double-reduc-6-big-array.c
@@ -61,5 +61,4 @@ int main ()
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-double-reduc-6.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-double-reduc-6.c
@@ -45,5 +45,4 @@ int main ()
 }
         
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
       
--- a/src/gcc/testsuite/gcc.dg/vect/vect-double-reduc-7.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-double-reduc-7.c
@@ -60,5 +60,4 @@ int main ()
 }
         
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 3 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
       
--- a/src/gcc/testsuite/gcc.dg/vect/vect-dv-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-dv-1.c
@@ -19,4 +19,3 @@ void foo()
 	x[j-63]=x[j-3]-x[j];
       }
 }
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-float-extend-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-float-extend-1.c
@@ -38,4 +38,3 @@ main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail spu*-*-* } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-float-truncate-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-float-truncate-1.c
@@ -37,4 +37,3 @@ main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail spu*-*-* } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-floatint-conversion-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-floatint-conversion-1.c
@@ -38,4 +38,3 @@ main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_floatint_cvt } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-floatint-conversion-2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-floatint-conversion-2.c
@@ -37,4 +37,3 @@ main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_floatint_cvt } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-fold-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-fold-1.c
@@ -13,4 +13,3 @@ void foo()
 }
 
 /* { dg-final { scan-tree-dump-times "c =.* { 6, 8, 10, 12 }" 1 "ccp1" } } */
-/* { dg-final { cleanup-tree-dump "ccp1" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-ifcvt-10.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-ifcvt-10.c
@@ -9,4 +9,3 @@ foo (int j, double *v, double x)
       x = v[i];
   return x;
 }
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-ifcvt-11.c
@@ -0,0 +1,36 @@
+/* { dg-require-effective-target vect_condition } */
+/* { dg-require-effective-target vect_int } */
+
+#include "tree-vect.h"
+
+#define N 16
+
+extern void abort (void);
+
+int A[N] = {36, 39, 42, 45, 43, 32, 21, 12, 23, 34, 45, 56, 67, 78, 81, 11};
+int B[N] = {144,195,210,225,172,128,105,60, 92, 136,225,280,268,390,324,55};
+
+__attribute__((noinline))
+void foo ()
+{
+  for (int i = 0; i < N; i++)
+    {
+      int m = (A[i] & i) ? 5 : 4;
+      A[i] = A[i] * m;
+    }
+}
+
+int main ()
+{
+
+  check_vect ();
+  foo ();
+  /* check results:  */
+  for (int i = 0; i < N; i++)
+    if (A[i] != B[i])
+      abort ();
+
+  return 0;
+}
+
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-ifcvt-16.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-ifcvt-16.c
@@ -31,4 +31,3 @@ int main ()
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-ifcvt-17.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-ifcvt-17.c
@@ -31,4 +31,3 @@ int main ()
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-ifcvt-2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-ifcvt-2.c
@@ -33,4 +33,3 @@ int main ()
 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-ifcvt-3.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-ifcvt-3.c
@@ -33,4 +33,3 @@ int main ()
 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-ifcvt-4.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-ifcvt-4.c
@@ -33,4 +33,3 @@ int main ()
 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-ifcvt-5.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-ifcvt-5.c
@@ -33,4 +33,3 @@ int main ()
 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-ifcvt-6.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-ifcvt-6.c
@@ -33,4 +33,3 @@ int main ()
 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-ifcvt-7.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-ifcvt-7.c
@@ -33,4 +33,3 @@ int main ()
 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-ifcvt-9.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-ifcvt-9.c
@@ -36,4 +36,3 @@ int main ()
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 2 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-intfloat-conversion-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-intfloat-conversion-1.c
@@ -36,4 +36,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_intfloat_cvt } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-intfloat-conversion-2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-intfloat-conversion-2.c
@@ -38,4 +38,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_intfloat_cvt } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-intfloat-conversion-3.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-intfloat-conversion-3.c
@@ -36,4 +36,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_intfloat_cvt } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-intfloat-conversion-4a.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-intfloat-conversion-4a.c
@@ -36,4 +36,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_intfloat_cvt } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-intfloat-conversion-4b.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-intfloat-conversion-4b.c
@@ -36,4 +36,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_intfloat_cvt } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-iv-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-iv-1.c
@@ -39,4 +39,3 @@ int main (void)
 } 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-iv-10.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-iv-10.c
@@ -33,4 +33,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-iv-11.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-iv-11.c
@@ -29,4 +29,3 @@ int main (void)
 } 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-iv-2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-iv-2.c
@@ -46,4 +46,3 @@ int main (void)
 } 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-iv-3.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-iv-3.c
@@ -41,4 +41,3 @@ int main (void)
 } 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-iv-4.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-iv-4.c
@@ -41,4 +41,3 @@ int main (void)
 } 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_pack_trunc } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-iv-5.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-iv-5.c
@@ -37,4 +37,3 @@ int main (void)
 } 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail {! arm_neon_ok } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-iv-6.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-iv-6.c
@@ -46,4 +46,3 @@ int main (void)
 } 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-iv-7.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-iv-7.c
@@ -39,4 +39,3 @@ int main (void)
 } 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-iv-8-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-iv-8-big-array.c
@@ -40,4 +40,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { vect_pack_trunc && vect_unpack } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-iv-8.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-iv-8.c
@@ -40,4 +40,3 @@ int main (void)
 } 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { vect_pack_trunc && vect_unpack } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-iv-8a-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-iv-8a-big-array.c
@@ -40,4 +40,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { vect_pack_trunc && vect_unpack } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-iv-8a.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-iv-8a.c
@@ -40,4 +40,3 @@ int main (void)
 } 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { vect_pack_trunc && vect_unpack } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-iv-9.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-iv-9.c
@@ -35,4 +35,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 2 "vect" { target vect_int_mult } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target {! vect_int_mult } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-ivdep-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-ivdep-1.c
@@ -15,4 +15,3 @@ void foo(int n, int *a, int *b, int *c, int *d, int *e) {
 
 /* { dg-message "loop vectorized" "" { target *-*-* } 0 } */
 /* { dg-bogus " version\[^\n\r]* alias" "" { target *-*-* } 0 } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-ivdep-2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-ivdep-2.c
@@ -31,4 +31,3 @@ void bar(int n, int *a, int *b, int *c) {
 
 /* { dg-message "loop vectorized" "" { target *-*-* } 0 } */
 /* { dg-bogus " version\[^\n\r]* alias" "" { target *-*-* } 0 } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-mask-load-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-mask-load-1.c
@@ -48,4 +48,3 @@ main ()
 }
 
 /* { dg-final { scan-tree-dump-times "note: vectorized 1 loops" 1 "vect" { target avx_runtime } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-mask-loadstore-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-mask-loadstore-1.c
@@ -46,4 +46,3 @@ main ()
 }
 
 /* { dg-final { scan-tree-dump-times "note: vectorized 1 loops" 1 "vect" { target avx_runtime } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-multitypes-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-multitypes-1.c
@@ -84,5 +84,4 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 2 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 2 "vect" { xfail {{ vect_no_align && { ! vect_hw_misalign } } || {vect_sizes_32B_16B }}} } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 4 "vect" { xfail {{ vect_no_align && { ! vect_hw_misalign } } || {vect_sizes_32B_16B }}} } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-multitypes-10.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-multitypes-10.c
@@ -64,5 +64,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 2 "vect" { target vect_unpack } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-multitypes-11.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-multitypes-11.c
@@ -40,5 +40,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 2 "vect" { target vect_unpack } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { ! vect_unpack } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-multitypes-12.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-multitypes-12.c
@@ -42,5 +42,4 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 2 "vect" { target vect_unpack } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target sparc*-*-* xfail ilp32 } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { { ! sparc*-*-* }  && { ! vect_unpack } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-multitypes-13.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-multitypes-13.c
@@ -60,5 +60,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 2 "vect" { target vect_unpack } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-multitypes-14.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-multitypes-14.c
@@ -47,5 +47,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_pack_trunc } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-multitypes-15.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-multitypes-15.c
@@ -46,5 +46,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { vect_sdot_hi  || vect_unpack } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-multitypes-16.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-multitypes-16.c
@@ -36,5 +36,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_unpack } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 0 "vect" { target { ! vect_unpack } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-multitypes-17.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-multitypes-17.c
@@ -41,5 +41,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_pack_trunc } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-multitypes-2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-multitypes-2.c
@@ -45,5 +45,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-multitypes-3.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-multitypes-3.c
@@ -56,5 +56,4 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 3 "vect" { target { vect_no_align && { ! vect_hw_misalign } } } } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 3 "vect" {xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-multitypes-4.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-multitypes-4.c
@@ -97,5 +97,4 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 2 "vect" { xfail { vect_no_align || vect_element_align } } } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 8 "vect" { xfail { vect_no_align || vect_element_align } } } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 4 "vect" { target { vect_element_align  } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-multitypes-5.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-multitypes-5.c
@@ -49,5 +49,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail { sparc*-*-* && ilp32 } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-multitypes-6.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-multitypes-6.c
@@ -63,5 +63,4 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail { sparc*-*-* && ilp32 } }} } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 6 "vect" { target { vect_no_align && { ! vect_hw_misalign } } } } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 6 "vect" {xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-multitypes-7.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-multitypes-7.c
@@ -47,5 +47,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_sdot_hi } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-multitypes-8.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-multitypes-8.c
@@ -47,5 +47,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_pack_trunc } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-multitypes-9.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-multitypes-9.c
@@ -60,5 +60,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 2 "vect" { target vect_unpack } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-neg-store-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-neg-store-1.c
@@ -36,4 +36,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-neg-store-2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-neg-store-2.c
@@ -36,4 +36,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-nest-cycle-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-nest-cycle-1.c
@@ -44,5 +44,4 @@ int main ()
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-nest-cycle-2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-nest-cycle-2.c
@@ -43,5 +43,4 @@ int main ()
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-nest-cycle-3.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-nest-cycle-3.c
@@ -53,4 +53,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-nop-move.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-nop-move.c
@@ -78,5 +78,3 @@ main ()
 }
 
 /* { dg-final { scan-rtl-dump "deleting noop move" "combine" { target aarch64*-*-* } } } */
-/* { dg-final { cleanup-rtl-dump "combine" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-outer-1-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-outer-1-big-array.c
@@ -24,4 +24,3 @@ foo (){
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" { xfail *-*-* } } } */
 /* { dg-final { scan-tree-dump-times "grouped access in outer loop" 1 "vect" { target { ! vect_multiple_sizes } } } } */
 /* { dg-final { scan-tree-dump-times "grouped access in outer loop" 2 "vect" { target vect_multiple_sizes } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-outer-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-outer-1.c
@@ -24,4 +24,3 @@ foo (){
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" { xfail *-*-* } } } */
 /* { dg-final { scan-tree-dump-times "grouped access in outer loop" 1 "vect" { target { ! vect_multiple_sizes } } } } */
 /* { dg-final { scan-tree-dump-times "grouped access in outer loop" 2 "vect" { target vect_multiple_sizes } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-outer-1a-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-outer-1a-big-array.c
@@ -22,4 +22,3 @@ foo (){
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" { xfail *-*-* } } } */
 /* { dg-final { scan-tree-dump-times "grouped access in outer loop" 1 "vect" { target { ! vect_multiple_sizes } } } } */
 /* { dg-final { scan-tree-dump-times "grouped access in outer loop" 2 "vect" { target vect_multiple_sizes } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-outer-1a.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-outer-1a.c
@@ -22,4 +22,3 @@ foo (){
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" { xfail *-*-* } } } */
 /* { dg-final { scan-tree-dump-times "grouped access in outer loop" 1 "vect" { target { ! vect_multiple_sizes } } } } */
 /* { dg-final { scan-tree-dump-times "grouped access in outer loop" 2 "vect" { target vect_multiple_sizes } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-outer-1b-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-outer-1b-big-array.c
@@ -24,4 +24,3 @@ foo (){
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" { xfail *-*-* } } } */
 /* { dg-final { scan-tree-dump-times "grouped access in outer loop" 1 "vect" { target { ! vect_multiple_sizes } } } } */
 /* { dg-final { scan-tree-dump-times "grouped access in outer loop" 2 "vect" { target vect_multiple_sizes } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-outer-1b.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-outer-1b.c
@@ -24,4 +24,3 @@ foo (){
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" { xfail *-*-* } } } */
 /* { dg-final { scan-tree-dump-times "grouped access in outer loop" 1 "vect" { target { ! vect_multiple_sizes } } } } */
 /* { dg-final { scan-tree-dump-times "grouped access in outer loop" 2 "vect" { target vect_multiple_sizes } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-outer-2-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-outer-2-big-array.c
@@ -38,4 +38,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-outer-2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-outer-2.c
@@ -38,4 +38,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-outer-2a-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-outer-2a-big-array.c
@@ -39,4 +39,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-outer-2a.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-outer-2a.c
@@ -39,4 +39,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-outer-2b.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-outer-2b.c
@@ -39,4 +39,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "grouped access in outer loop" 1 "vect" { target { ! vect_multiple_sizes } } } } */
 /* { dg-final { scan-tree-dump-times "grouped access in outer loop" 2 "vect" { target vect_multiple_sizes } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-outer-2c-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-outer-2c-big-array.c
@@ -39,4 +39,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-outer-2c.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-outer-2c.c
@@ -39,4 +39,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-outer-2d.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-outer-2d.c
@@ -38,4 +38,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 0 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-outer-3-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-outer-3-big-array.c
@@ -49,4 +49,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-outer-3.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-outer-3.c
@@ -49,4 +49,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-outer-3a-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-outer-3a-big-array.c
@@ -50,4 +50,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
 /* { dg-final { scan-tree-dump-times "step doesn't divide the vector-size" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-outer-3a.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-outer-3a.c
@@ -50,4 +50,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
 /* { dg-final { scan-tree-dump-times "step doesn't divide the vector-size" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-outer-3b.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-outer-3b.c
@@ -51,4 +51,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" { xfail *-*-* } } } */
 /* { dg-final { scan-tree-dump-times "grouped access in outer loop" 2 "vect" { target { ! vect_multiple_sizes } } } } */
 /* { dg-final { scan-tree-dump-times "grouped access in outer loop" 4 "vect" { target vect_multiple_sizes } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-outer-3c.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-outer-3c.c
@@ -49,4 +49,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-outer-4.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-outer-4.c
@@ -52,4 +52,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "zero step in outer loop." 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-outer-4a-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-outer-4a-big-array.c
@@ -23,4 +23,3 @@ foo (){
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" { target { vect_widen_mult_hi_to_si && vect_pack_trunc } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-outer-4a.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-outer-4a.c
@@ -23,4 +23,3 @@ foo (){
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" { target { vect_widen_mult_hi_to_si && vect_pack_trunc } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-outer-4b-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-outer-4b-big-array.c
@@ -23,4 +23,3 @@ foo (){
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" { target vect_widen_mult_hi_to_si } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-outer-4b.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-outer-4b.c
@@ -23,4 +23,3 @@ foo (){
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" { target vect_widen_mult_hi_to_si } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-outer-4c-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-outer-4c-big-array.c
@@ -25,4 +25,3 @@ foo (){
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" { target { vect_short_mult && { ! vect_no_align } } } } } */
 /* { dg-final { scan-tree-dump-times "zero step in outer loop." 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-outer-4c.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-outer-4c.c
@@ -25,4 +25,3 @@ foo (){
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" { target { vect_short_mult && { ! vect_no_align } } } } } */
 /* { dg-final { scan-tree-dump "zero step in outer loop." "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-outer-4d-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-outer-4d-big-array.c
@@ -48,4 +48,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect"  } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-outer-4d.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-outer-4d.c
@@ -48,4 +48,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect"  } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-outer-4e.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-outer-4e.c
@@ -24,4 +24,3 @@ foo (){
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-outer-4f.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-outer-4f.c
@@ -66,4 +66,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-outer-4g.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-outer-4g.c
@@ -66,4 +66,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-outer-4i.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-outer-4i.c
@@ -46,4 +46,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" { target vect_unpack } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-outer-4j.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-outer-4j.c
@@ -22,4 +22,3 @@ foo (){
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" { target vect_unpack } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-outer-4k.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-outer-4k.c
@@ -66,4 +66,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-outer-4l.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-outer-4l.c
@@ -66,4 +66,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-outer-4m-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-outer-4m-big-array.c
@@ -55,4 +55,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect"  { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-outer-4m.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-outer-4m.c
@@ -55,4 +55,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect"  { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-outer-5.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-outer-5.c
@@ -79,4 +79,3 @@ int main ()
 /* { dg-final { scan-tree-dump-times "not vectorized: possible dependence between data-refs" 1 "vect" { xfail *-*-* } } } */
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" } } */
 /* { dg-final { scan-tree-dump "zero step in outer loop." "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-outer-6.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-outer-6.c
@@ -63,4 +63,3 @@ int main ()
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "zero step in outer loop." 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-outer-fir-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-outer-fir-big-array.c
@@ -71,4 +71,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 2 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-outer-fir-lb-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-outer-fir-lb-big-array.c
@@ -75,4 +75,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 2 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-outer-fir-lb.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-outer-fir-lb.c
@@ -75,4 +75,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 2 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-outer-fir.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-outer-fir.c
@@ -71,4 +71,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "OUTER LOOP VECTORIZED" 2 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-over-widen-1-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-over-widen-1-big-array.c
@@ -62,5 +62,4 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vect_recog_over_widening_pattern: detected" 2 "vect" { target vect_widen_shift } } } */
 /* { dg-final { scan-tree-dump-times "vect_recog_over_widening_pattern: detected" 4 "vect" { target { ! vect_widen_shift } } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-over-widen-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-over-widen-1.c
@@ -63,5 +63,4 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vect_recog_over_widening_pattern: detected" 4 "vect" { target { { ! vect_sizes_32B_16B } && { ! vect_widen_shift } } } } } */
 /* { dg-final { scan-tree-dump-times "vect_recog_over_widening_pattern: detected" 8 "vect" { target vect_sizes_32B_16B } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-over-widen-2-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-over-widen-2-big-array.c
@@ -61,5 +61,4 @@ int main (void)
 /* Final value stays in int, so no over-widening is detected at the moment.  */
 /* { dg-final { scan-tree-dump-times "vect_recog_over_widening_pattern: detected" 0 "vect" } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-over-widen-2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-over-widen-2.c
@@ -61,5 +61,4 @@ int main (void)
 /* Final value stays in int, so no over-widening is detected at the moment.  */
 /* { dg-final { scan-tree-dump-times "vect_recog_over_widening_pattern: detected" 0 "vect" } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-over-widen-3-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-over-widen-3-big-array.c
@@ -60,5 +60,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vect_recog_over_widening_pattern: detected" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-over-widen-3.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-over-widen-3.c
@@ -60,5 +60,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump "vect_recog_over_widening_pattern: detected" "vect" } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-over-widen-4-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-over-widen-4-big-array.c
@@ -66,5 +66,4 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vect_recog_over_widening_pattern: detected" 2 "vect" { target vect_widen_shift } } } */
 /* { dg-final { scan-tree-dump-times "vect_recog_over_widening_pattern: detected" 4 "vect" { target { ! vect_widen_shift } } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-over-widen-4.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-over-widen-4.c
@@ -67,5 +67,4 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vect_recog_over_widening_pattern: detected" 4 "vect" { target { { ! vect_sizes_32B_16B } && { ! vect_widen_shift } } } } } */
 /* { dg-final { scan-tree-dump-times "vect_recog_over_widening_pattern: detected" 8 "vect" { target vect_sizes_32B_16B } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-peel-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-peel-1.c
@@ -50,4 +50,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { target { { vect_element_align } && { vect_aligned_arrays } } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-peel-2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-peel-2.c
@@ -51,4 +51,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { target { { vect_element_align } && { vect_aligned_arrays } } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { target { { vect_element_align } && { vect_aligned_arrays } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-peel-3.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-peel-3.c
@@ -51,4 +51,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect"  { xfail { { vect_no_align && { ! vect_hw_misalign } } || {vect_sizes_32B_16B } } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { xfail { { vect_no_align && { ! vect_hw_misalign } } || {vect_sizes_32B_16B } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-peel-4.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-peel-4.c
@@ -48,4 +48,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect"  { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-pre-interact.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-pre-interact.c
@@ -13,4 +13,3 @@ void foo (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-recip.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-recip.c
@@ -17,4 +17,3 @@ void f(float *__restrict__ qa, float *__restrict__ qb,
   }
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-reduc-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-reduc-1.c
@@ -53,4 +53,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 3 loops" 1 "vect" { xfail { vect_no_int_add || vect_no_int_max } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-reduc-10.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-reduc-10.c
@@ -48,4 +48,3 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-reduc-1char-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-reduc-1char-big-array.c
@@ -68,4 +68,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 3 loops" 1 "vect" { xfail vect_no_int_max } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-reduc-1char.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-reduc-1char.c
@@ -48,4 +48,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 3 loops" 1 "vect" { xfail vect_no_int_max } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-reduc-1short.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-reduc-1short.c
@@ -48,4 +48,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 3 loops" 1 "vect" { xfail vect_no_int_max } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-reduc-2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-reduc-2.c
@@ -50,4 +50,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 3 loops" 1 "vect" { xfail { vect_no_int_add || vect_no_int_max } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-reduc-2char-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-reduc-2char-big-array.c
@@ -66,4 +66,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 3 loops" 1 "vect" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-reduc-2char.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-reduc-2char.c
@@ -47,4 +47,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 3 loops" 1 "vect" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-reduc-2short.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-reduc-2short.c
@@ -46,4 +46,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 3 loops" 1 "vect" { xfail *-*-* } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-reduc-3.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-reduc-3.c
@@ -39,4 +39,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail vect_no_int_add } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-reduc-6.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-reduc-6.c
@@ -51,4 +51,3 @@ int main (void)
 /* need -ffast-math to vectorizer these loops.  */
 /* ARM NEON passes -ffast-math to these tests, so expect this to fail.  */
 /* { dg-final { scan-tree-dump-times "vectorized 0 loops" 1 "vect" { xfail arm_neon_ok } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-reduc-7.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-reduc-7.c
@@ -75,4 +75,3 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-reduc-8.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-reduc-8.c
@@ -75,4 +75,3 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-reduc-9.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-reduc-9.c
@@ -75,4 +75,3 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-reduc-dot-s16a.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-reduc-dot-s16a.c
@@ -52,5 +52,4 @@ main (void)
 /* { dg-final { scan-tree-dump-times "vect_recog_dot_prod_pattern: detected" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_sdot_hi } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_widen_mult_hi_to_si } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-reduc-dot-s16b.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-reduc-dot-s16b.c
@@ -53,5 +53,4 @@ main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 0 "vect" { target { ! vect_short_mult } } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 0 "vect" { target { { ! vect_widen_sum_hi_to_si } && { ! vect_unpack } } } } } */
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-reduc-dot-s16c.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-reduc-dot-s16c.c
@@ -69,5 +69,4 @@ main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 2 "vect" { target vect_unpack } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-reduc-dot-s8a.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-reduc-dot-s8a.c
@@ -55,4 +55,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_sdot_qi } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { vect_widen_mult_qi_to_hi && vect_widen_sum_hi_to_si } } } } */
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-reduc-dot-s8b.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-reduc-dot-s8b.c
@@ -63,4 +63,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail *-*-* } } } */
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-reduc-dot-s8c.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-reduc-dot-s8c.c
@@ -43,4 +43,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_unpack } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-reduc-dot-u16a.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-reduc-dot-u16a.c
@@ -49,4 +49,3 @@ int main (void)
 /* The initialization loop in main also gets vectorized.  */
 /* { dg-final { scan-tree-dump-times "vect_recog_dot_prod_pattern: detected" 1 "vect" { xfail *-*-* } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 2 "vect" { target { vect_short_mult && vect_widen_sum_hi_to_si } } } } */ 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-reduc-dot-u16b.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-reduc-dot-u16b.c
@@ -56,4 +56,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 2 "vect" { xfail *-*-* } } } */ 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_pack_trunc } } } */ 
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-reduc-dot-u8a.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-reduc-dot-u8a.c
@@ -52,5 +52,4 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_udot_qi } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { vect_widen_mult_qi_to_hi && vect_widen_sum_qi_to_si } } } } */
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-reduc-dot-u8b.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-reduc-dot-u8b.c
@@ -51,5 +51,4 @@ dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_udot
 */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" {target { vect_widen_mult_qi_to_hi || vect_unpack } } } } */
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-reduc-mul_1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-reduc-mul_1.c
@@ -32,5 +32,4 @@ main (unsigned char argc, char **argv)
 }
 
 /* { dg-final { scan-tree-dump "Reduce using vector shifts" "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-reduc-mul_2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-reduc-mul_2.c
@@ -28,5 +28,4 @@ main (unsigned char argc, char **argv)
 }
 
 /* { dg-final { scan-tree-dump "Reduce using vector shifts" "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-reduc-or_1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-reduc-or_1.c
@@ -31,5 +31,4 @@ main (unsigned char argc, char **argv)
 }
 
 /* { dg-final { scan-tree-dump "Reduce using vector shifts" "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-reduc-or_2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-reduc-or_2.c
@@ -27,5 +27,4 @@ main (unsigned char argc, char **argv)
 }
 
 /* { dg-final { scan-tree-dump "Reduce using vector shifts" "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-reduc-pattern-1a.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-reduc-pattern-1a.c
@@ -37,4 +37,3 @@ main (void)
 /* { dg-final { scan-tree-dump-times "vect_recog_widen_sum_pattern: detected" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_widen_sum_hi_to_si } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 0 "vect" { target { ! vect_widen_sum_hi_to_si } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-reduc-pattern-1b-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-reduc-pattern-1b-big-array.c
@@ -46,4 +46,3 @@ main (void)
 /* { dg-final { scan-tree-dump-times "vect_recog_widen_sum_pattern: detected" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { vect_widen_sum_qi_to_si || vect_unpack } } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 0 "vect" { target { { ! vect_widen_sum_qi_to_si } && { ! vect_unpack } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-reduc-pattern-1b.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-reduc-pattern-1b.c
@@ -37,4 +37,3 @@ main (void)
 /* { dg-final { scan-tree-dump "vect_recog_widen_sum_pattern: detected" "vect"} } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { vect_widen_sum_qi_to_si || vect_unpack } } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 0 "vect" { target { { ! vect_widen_sum_qi_to_si } && { ! vect_unpack } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-reduc-pattern-1c-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-reduc-pattern-1c-big-array.c
@@ -46,4 +46,3 @@ main (void)
 /* { dg-final { scan-tree-dump-times "vect_recog_widen_sum_pattern: detected" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_widen_sum_qi_to_hi } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 0 "vect" { target { ! vect_widen_sum_qi_to_hi } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-reduc-pattern-1c.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-reduc-pattern-1c.c
@@ -37,4 +37,3 @@ main (void)
 /* { dg-final { scan-tree-dump "vect_recog_widen_sum_pattern: detected" "vect" } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_widen_sum_qi_to_hi } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 0 "vect" { target { ! vect_widen_sum_qi_to_hi } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-reduc-pattern-2a.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-reduc-pattern-2a.c
@@ -37,4 +37,3 @@ main (void)
 /* { dg-final { scan-tree-dump-times "vect_recog_widen_sum_pattern: detected" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_widen_sum_hi_to_si } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 0 "vect" { target { ! vect_widen_sum_hi_to_si } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-reduc-pattern-2b-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-reduc-pattern-2b-big-array.c
@@ -47,4 +47,3 @@ main (void)
 /* { dg-final { scan-tree-dump-times "vect_recog_widen_sum_pattern: detected" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { vect_widen_sum_qi_to_si && vect_unpack } } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 0 "vect" { target { { ! vect_widen_sum_qi_to_si } && { ! vect_unpack } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-reduc-pattern-2b.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-reduc-pattern-2b.c
@@ -37,4 +37,3 @@ main (void)
 /* { dg-final { scan-tree-dump "vect_recog_widen_sum_pattern: detected" "vect" } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { vect_widen_sum_qi_to_si && vect_unpack } } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 0 "vect" { target { { ! vect_widen_sum_qi_to_si } && { ! vect_unpack } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-reduc-pattern-2c.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-reduc-pattern-2c.c
@@ -45,4 +45,3 @@ main (void)
 /* { dg-final { scan-tree-dump-times "vect_recog_widen_sum_pattern: detected" 1 "vect" { xfail *-*-* } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail *-*-* } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 0 "vect" { target { ! vect_widen_sum_qi_to_hi } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-reduc-pattern-3.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-reduc-pattern-3.c
@@ -37,5 +37,4 @@ main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-reduc-sad.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-reduc-sad.c
@@ -51,5 +51,4 @@ main (void)
 
 /* { dg-final { scan-tree-dump-times "vect_recog_sad_pattern: detected" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-rounding-btrunc.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-rounding-btrunc.c
@@ -14,4 +14,3 @@ foo (double *output, double *input)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_call_btrunc } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-rounding-btruncf.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-rounding-btruncf.c
@@ -14,4 +14,3 @@ foo (float *output, float *input)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_call_btruncf } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-rounding-ceil.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-rounding-ceil.c
@@ -14,4 +14,3 @@ foo (double *output, double *input)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_call_ceil } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-rounding-ceilf.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-rounding-ceilf.c
@@ -14,4 +14,3 @@ foo (float *output, float *input)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_call_ceilf } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-rounding-floor.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-rounding-floor.c
@@ -14,4 +14,3 @@ foo (double *output, double *input)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_call_floor } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-rounding-floorf.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-rounding-floorf.c
@@ -14,4 +14,3 @@ foo (float *output, float *input)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_call_floorf } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-rounding-lceil.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-rounding-lceil.c
@@ -14,4 +14,3 @@ foo (long *output, double *input)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_call_lceil } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-rounding-lfloor.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-rounding-lfloor.c
@@ -14,4 +14,3 @@ foo (long *output, double *input)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_call_lfloor } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-rounding-nearbyint.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-rounding-nearbyint.c
@@ -14,4 +14,3 @@ foo (double *output, double *input)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_call_nearbyint } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-rounding-nearbyintf.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-rounding-nearbyintf.c
@@ -14,4 +14,3 @@ foo (float *output, float *input)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_call_nearbyintf } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-rounding-round.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-rounding-round.c
@@ -14,4 +14,3 @@ foo (double *output, double *input)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_call_round } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-rounding-roundf.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-rounding-roundf.c
@@ -14,4 +14,3 @@ foo (float *output, float *input)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_call_roundf } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-sdivmod-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-sdivmod-1.c
@@ -95,4 +95,3 @@ main ()
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 4 "vect" { target vect_condition } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-shift-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-shift-1.c
@@ -29,4 +29,3 @@ int main ()
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-shift-2-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-shift-2-big-array.c
@@ -187,4 +187,3 @@ int main ()
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-shift-2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-shift-2.c
@@ -187,4 +187,3 @@ int main ()
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-shift-3.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-shift-3.c
@@ -34,4 +34,3 @@ int main()
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-shift-4.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-shift-4.c
@@ -34,4 +34,3 @@ int main()
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-simd-clone-1.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-simd-clone-1.c
@@ -56,4 +56,3 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-simd-clone-10.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-simd-clone-10.c
@@ -81,4 +81,3 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-simd-clone-10a.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-simd-clone-10a.c
@@ -16,4 +16,3 @@ bar (int a, int b, long int c)
   return a + b + c;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-simd-clone-11.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-simd-clone-11.c
@@ -64,4 +64,3 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-simd-clone-12.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-simd-clone-12.c
@@ -5,4 +5,3 @@
 
 #include "vect-simd-clone-10.c"
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-simd-clone-12a.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-simd-clone-12a.c
@@ -16,4 +16,3 @@ bar (int a, int b, long int c)
   return a + b + c;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-simd-clone-13.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-simd-clone-13.c
@@ -4,4 +4,3 @@
 
 #include "vect-simd-clone-6.c"
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-simd-clone-14.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-simd-clone-14.c
@@ -4,4 +4,3 @@
 
 #include "vect-simd-clone-11.c"
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-simd-clone-2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-simd-clone-2.c
@@ -50,4 +50,3 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-simd-clone-3.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-simd-clone-3.c
@@ -43,4 +43,3 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-simd-clone-4.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-simd-clone-4.c
@@ -46,4 +46,3 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-simd-clone-5.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-simd-clone-5.c
@@ -41,4 +41,3 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-simd-clone-6.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-simd-clone-6.c
@@ -72,4 +72,3 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-simd-clone-7.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-simd-clone-7.c
@@ -72,4 +72,3 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-simd-clone-8.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-simd-clone-8.c
@@ -92,4 +92,3 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-simd-clone-9.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-simd-clone-9.c
@@ -92,4 +92,3 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-strided-a-mult.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-strided-a-mult.c
@@ -74,5 +74,4 @@ int main (void)
 }   
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  { target vect_strided2 } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-strided-a-u16-i2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-strided-a-u16-i2.c
@@ -58,5 +58,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  { target vect_strided2 } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/vect-strided-a-u16-i4.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-strided-a-u16-i4.c
@@ -21,7 +21,6 @@ main1 ()
   s *ptr = arr;
   s res[N];
   int i;
-  unsigned short x, y, z, w;
 
   for (i = 0; i < N; i++)
     {
@@ -35,6 +34,7 @@ main1 ()
 
   for (i = 0; i < N; i++)
     {
+      unsigned short x, y, z, w;
       x = ptr->b - ptr->a;
       y = ptr->d - ptr->c;
       res[i].c = x + y;
@@ -71,5 +71,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  { target vect_strided4 } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/vect-strided-a-u16-mult.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-strided-a-u16-mult.c
@@ -65,5 +65,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  { target vect_strided2 } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-strided-a-u32-mult.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-strided-a-u32-mult.c
@@ -62,5 +62,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  { target vect_strided2 } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-strided-a-u8-i2-gap.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-strided-a-u8-i2-gap.c
@@ -72,5 +72,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  { target vect_strided2 } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/vect-strided-a-u8-i8-gap2-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-strided-a-u8-i8-gap2-big-array.c
@@ -90,5 +90,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_strided8 } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-strided-a-u8-i8-gap2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-strided-a-u8-i8-gap2.c
@@ -79,5 +79,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_strided8 } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/vect-strided-a-u8-i8-gap7-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-strided-a-u8-i8-gap7-big-array.c
@@ -99,5 +99,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_strided8 } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-strided-a-u8-i8-gap7.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-strided-a-u8-i8-gap7.c
@@ -84,5 +84,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_strided8 } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/vect-strided-float.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-strided-float.c
@@ -41,5 +41,4 @@ int main (void)
 /* Needs interleaving support.  */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_strided2 } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 0 loops" 1 "vect" { xfail vect_strided2 } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/vect-strided-mult-char-ls.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-strided-mult-char-ls.c
@@ -74,5 +74,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  { target vect_strided2 } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/vect-strided-mult.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-strided-mult.c
@@ -74,5 +74,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  { target vect_strided2 } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-strided-same-dr.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-strided-same-dr.c
@@ -75,4 +75,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  { target vect_strided2 } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-strided-store-a-u8-i2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-strided-store-a-u8-i2.c
@@ -56,5 +56,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  { target { vect_interleave || vect_strided2 } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-strided-store-u16-i4.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-strided-store-u16-i4.c
@@ -67,6 +67,5 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 2 "vect"  { target { { vect_interleave || vect_strided4 } && vect_pack_trunc } } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  { target { { ! { vect_interleave || vect_strided4 } } && { vect_pack_trunc } } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-strided-store-u32-i2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-strided-store-u32-i2.c
@@ -41,5 +41,4 @@ int main (void)
 /* Needs interleaving support.  */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { vect_interleave || vect_strided2 } } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 0 loops" 1 "vect" { xfail { vect_interleave || vect_strided2 } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-strided-u16-i2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-strided-u16-i2.c
@@ -58,5 +58,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  { target vect_strided2 } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/vect-strided-u16-i3.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-strided-u16-i3.c
@@ -109,4 +109,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 4 loops" 1 "vect"  { target vect_strided3 } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-strided-u16-i4.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-strided-u16-i4.c
@@ -71,5 +71,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  { target vect_strided4 } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/vect-strided-u32-i4.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-strided-u32-i4.c
@@ -66,5 +66,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  { target vect_strided4 } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/vect-strided-u32-i8.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-strided-u32-i8.c
@@ -80,5 +80,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_strided8 } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/vect-strided-u32-mult.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-strided-u32-mult.c
@@ -61,5 +61,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  { target vect_strided2 } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-strided-u8-i2-gap.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-strided-u8-i2-gap.c
@@ -74,5 +74,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  { target vect_strided2 } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/vect-strided-u8-i2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-strided-u8-i2.c
@@ -57,5 +57,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  { target vect_strided2 } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
    
--- a/src/gcc/testsuite/gcc.dg/vect/vect-strided-u8-i8-gap2-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-strided-u8-i8-gap2-big-array.c
@@ -93,5 +93,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_strided8 } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-strided-u8-i8-gap2.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-strided-u8-i8-gap2.c
@@ -81,5 +81,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_strided8 } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/vect-strided-u8-i8-gap4-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-strided-u8-i8-gap4-big-array.c
@@ -114,5 +114,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_strided8 } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-strided-u8-i8-gap4-unknown.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-strided-u8-i8-gap4-unknown.c
@@ -114,5 +114,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_strided8 } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/vect-strided-u8-i8-gap4.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-strided-u8-i8-gap4.c
@@ -101,5 +101,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_strided8 } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/vect-strided-u8-i8-gap7-big-array.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-strided-u8-i8-gap7-big-array.c
@@ -103,5 +103,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_strided8 } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-strided-u8-i8-gap7.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-strided-u8-i8-gap7.c
@@ -86,5 +86,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_strided8 } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/vect-strided-u8-i8.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-strided-u8-i8.c
@@ -88,5 +88,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_strided8 } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
   
--- a/src/gcc/testsuite/gcc.dg/vect/vect-vfa-01.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-vfa-01.c
@@ -36,4 +36,3 @@ main (void)
 } 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-vfa-02.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-vfa-02.c
@@ -44,4 +44,3 @@ main (void)
 } 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-vfa-03.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-vfa-03.c
@@ -55,4 +55,3 @@ main (void)
 /* Needs interleaving support.  */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_strided2 } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 0 "vect" { xfail  vect_strided2 } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-vfa-04.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-vfa-04.c
@@ -35,4 +35,3 @@ main (void)
 } 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-vfa-slp.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-vfa-slp.c
@@ -53,4 +53,3 @@ main (void)
 } 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-widen-mult-const-s16.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-widen-mult-const-s16.c
@@ -57,5 +57,4 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 2 "vect" { target vect_widen_mult_hi_to_si } } } */
 /* { dg-final { scan-tree-dump-times "vect_recog_widen_mult_pattern: detected" 2 "vect" { target vect_widen_mult_hi_to_si_pattern } } } */
 /* { dg-final { scan-tree-dump-times "pattern recognized" 2 "vect" { target vect_widen_mult_hi_to_si_pattern } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-widen-mult-const-u16.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-widen-mult-const-u16.c
@@ -74,4 +74,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 3 "vect" { target vect_widen_mult_hi_to_si } } } */
 /* { dg-final { scan-tree-dump-times "vect_recog_widen_mult_pattern: detected" 2 "vect" { target vect_widen_mult_hi_to_si_pattern } } } */
 /* { dg-final { scan-tree-dump-times "pattern recognized" 2 "vect" { target vect_widen_mult_hi_to_si_pattern } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-widen-mult-half-u8.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-widen-mult-half-u8.c
@@ -56,5 +56,4 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 2 "vect" { target vect_widen_mult_hi_to_si } } } */
 /* { dg-final { scan-tree-dump-times "vect_recog_widen_mult_pattern: detected" 2 "vect" { target vect_widen_mult_hi_to_si_pattern } } } */
 /* { dg-final { scan-tree-dump-times "pattern recognized" 2 "vect" { target vect_widen_mult_hi_to_si_pattern } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-widen-mult-half.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-widen-mult-half.c
@@ -45,5 +45,4 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_widen_mult_hi_to_si } } } */
 /* { dg-final { scan-tree-dump-times "vect_recog_widen_mult_pattern: detected" 1 "vect" { target vect_widen_mult_hi_to_si_pattern } } } */
 /* { dg-final { scan-tree-dump-times "pattern recognized" 1 "vect" { target vect_widen_mult_hi_to_si_pattern } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-widen-mult-s16.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-widen-mult-s16.c
@@ -42,5 +42,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_widen_mult_hi_to_si } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-widen-mult-s8.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-widen-mult-s8.c
@@ -42,5 +42,4 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_widen_mult_qi_to_hi } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-widen-mult-sum.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-widen-mult-sum.c
@@ -44,4 +44,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_widen_mult_hi_to_si } } } */
 /* { dg-final { scan-tree-dump-times "vect_recog_widen_mult_pattern: detected" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-widen-mult-u16.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-widen-mult-u16.c
@@ -44,5 +44,4 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { vect_widen_mult_hi_to_si || vect_unpack } } } } */
 /* { dg-final { scan-tree-dump-times "vect_recog_widen_mult_pattern: detected" 1 "vect" { target vect_widen_mult_hi_to_si_pattern } } } */
 /* { dg-final { scan-tree-dump-times "pattern recognized" 1 "vect" { target vect_widen_mult_hi_to_si_pattern } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-widen-mult-u8-s16-s32.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-widen-mult-u8-s16-s32.c
@@ -44,5 +44,4 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { vect_widen_mult_hi_to_si || vect_unpack } } } } */
 /* { dg-final { scan-tree-dump-times "vect_recog_widen_mult_pattern: detected" 1 "vect" { target vect_widen_mult_hi_to_si_pattern } } } */
 /* { dg-final { scan-tree-dump-times "pattern recognized" 1 "vect" { target vect_widen_mult_hi_to_si_pattern } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-widen-mult-u8-u32.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-widen-mult-u8-u32.c
@@ -44,5 +44,4 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { vect_widen_mult_qi_to_hi || vect_unpack } } } } */
 /* { dg-final { scan-tree-dump-times "vect_recog_widen_mult_pattern: detected" 1 "vect" { target vect_widen_mult_qi_to_hi_pattern } } } */
 /* { dg-final { scan-tree-dump-times "pattern recognized" 1 "vect" { target vect_widen_mult_qi_to_hi_pattern } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-widen-mult-u8.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-widen-mult-u8.c
@@ -44,5 +44,4 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { vect_widen_mult_qi_to_hi || vect_unpack } } } } */
 /* { dg-final { scan-tree-dump-times "vect_recog_widen_mult_pattern: detected" 1 "vect" { target vect_widen_mult_qi_to_hi_pattern } } } */
 /* { dg-final { scan-tree-dump-times "pattern recognized" 1 "vect" { target vect_widen_mult_qi_to_hi_pattern } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-widen-shift-s16.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-widen-shift-s16.c
@@ -103,5 +103,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vect_recog_widen_shift_pattern: detected" 8 "vect" { target vect_widen_shift } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 2 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-widen-shift-s8.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-widen-shift-s8.c
@@ -54,5 +54,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vect_recog_widen_shift_pattern: detected" 1 "vect" { target vect_widen_shift } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-widen-shift-u16.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-widen-shift-u16.c
@@ -54,5 +54,4 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vect_recog_widen_shift_pattern: detected" 1 "vect" { target vect_widen_shift } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.dg/vect/vect-widen-shift-u8.c
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-widen-shift-u8.c
@@ -61,4 +61,3 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vect_recog_widen_shift_pattern: detected" 2 "vect" { target vect_widen_shift } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/wrapv-vect-7.c
+++ b/src/gcc/testsuite/gcc.dg/vect/wrapv-vect-7.c
@@ -50,4 +50,3 @@ int main (void)
 /* Fails for 32-bit targets that don't vectorize PLUS.  */
 /* { dg-final { scan-tree-dump-times "vectorized 2 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/wrapv-vect-reduc-2char.c
+++ b/src/gcc/testsuite/gcc.dg/vect/wrapv-vect-reduc-2char.c
@@ -48,4 +48,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 3 loops" 1 "vect" { xfail vect_no_int_max } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/wrapv-vect-reduc-2short.c
+++ b/src/gcc/testsuite/gcc.dg/vect/wrapv-vect-reduc-2short.c
@@ -47,4 +47,3 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 3 loops" 1 "vect" { xfail vect_no_int_max } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/wrapv-vect-reduc-dot-s8b.c
+++ b/src/gcc/testsuite/gcc.dg/vect/wrapv-vect-reduc-dot-s8b.c
@@ -54,4 +54,3 @@ dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_sdot
 /* In the meantime expect: */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { vect_widen_mult_qi_to_hi || vect_unpack } } } } */
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/wrapv-vect-reduc-pattern-2c.c
+++ b/src/gcc/testsuite/gcc.dg/vect/wrapv-vect-reduc-pattern-2c.c
@@ -38,4 +38,3 @@ main (void)
 /* { dg-final { scan-tree-dump "vect_recog_widen_sum_pattern: detected" "vect" } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_widen_sum_qi_to_hi } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 0 "vect" { target { ! vect_widen_sum_qi_to_hi } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vector-shift-2.c
+++ b/src/gcc/testsuite/gcc.dg/vector-shift-2.c
@@ -10,4 +10,3 @@ f (vec *a)
 }
 
 /* { dg-final { scan-tree-dump "<< 5" "ccp1" } } */
-/* { dg-final { cleanup-tree-dump "ccp1" } } */
--- a/src/gcc/testsuite/gcc.dg/vector-shift.c
+++ b/src/gcc/testsuite/gcc.dg/vector-shift.c
@@ -10,4 +10,3 @@ f (vec *x)
 }
 
 /* { dg-final { scan-tree-dump "<< 7" "original" } } */
-/* { dg-final { cleanup-tree-dump "original" } } */
--- a/src/gcc/testsuite/gcc.dg/volatile2.c
+++ b/src/gcc/testsuite/gcc.dg/volatile2.c
@@ -19,4 +19,3 @@ void foo(struct GTeth_softc *sc)
 }
 
 /* { dg-final { scan-tree-dump "{v}" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.dg/volatile3.c
+++ b/src/gcc/testsuite/gcc.dg/volatile3.c
@@ -10,4 +10,3 @@ void foo(int i)
 }
 
 /* { dg-final { scan-tree-dump-not "{v}" "ssa" } } */
-/* { dg-final { cleanup-tree-dump "ssa" } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.dg/wide-shift-128.c
@@ -0,0 +1,11 @@
+/* { dg-do compile { target aarch64*-*-* mips64*-*-* sparc64*-*-* } } */
+/* { dg-require-effective-target int128 } */
+/* { dg-options "-O2 -fdump-rtl-combine" } */
+
+__int128_t
+load2 (int data)
+{
+    return (__int128_t) data << 50;
+}
+
+/* { dg-final { scan-rtl-dump-not "ior" "combine" } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.dg/wide-shift-64.c
@@ -0,0 +1,10 @@
+/* { dg-do compile { target mips*-*-* sparc*-*-* } } */
+/* { dg-options "-O2 -fdump-rtl-combine" } */
+
+long long
+load1 (int data)
+{
+    return (long long) data << 12;
+}
+
+/* { dg-final { scan-rtl-dump-not "ior" "combine" } } */
--- a/src/gcc/testsuite/gcc.dg/wmul-1.c
+++ b/src/gcc/testsuite/gcc.dg/wmul-1.c
@@ -16,4 +16,3 @@ foo (ArrT Arr, int Idx)
 }
 
 /* { dg-final { scan-tree-dump-not "WIDEN_MULT_PLUS_EXPR" "widening_mul" } } */
-/* { dg-final { cleanup-tree-dump "widening_mul" } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/aapcs64/func-ret-1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/aapcs64/func-ret-1.c
@@ -12,6 +12,8 @@
 
 vf2_t vf2 = (vf2_t){ 17.f, 18.f };
 vi4_t vi4 = (vi4_t){ 0xdeadbabe, 0xbabecafe, 0xcafebeef, 0xbeefdead };
+vlf1_t vlf1 = (vlf1_t) { 17.0 };
+
 union int128_t qword;
 
 int *int_ptr = (int *)0xabcdef0123456789ULL;
@@ -41,4 +43,5 @@ FUNC_VAL_CHECK (11,   long double, 98765432123456789.987654321L, Q0, flat)
 FUNC_VAL_CHECK (12,         vf2_t,        vf2, D0, f32in64)
 FUNC_VAL_CHECK (13,         vi4_t,        vi4, Q0, i32in128)
 FUNC_VAL_CHECK (14,         int *,    int_ptr, X0, flat)
+FUNC_VAL_CHECK (15,         vlf1_t,    vlf1, Q0, flat)
 #endif
--- a/src/gcc/testsuite/gcc.target/aarch64/aapcs64/type-def.h
+++ b/src/gcc/testsuite/gcc.target/aarch64/aapcs64/type-def.h
@@ -10,6 +10,9 @@ typedef float vf4_t __attribute__((vector_size (16)));
 /* 128-bit vector of 4 ints.  */
 typedef int vi4_t __attribute__((vector_size (16)));
 
+/* 128-bit vector of 1 quad precision float.  */
+typedef long double vlf1_t __attribute__((vector_size (16)));
+
 /* signed quad-word (in an union for the convenience of initialization).  */
 union int128_t
 {
--- a/src/gcc/testsuite/gcc.target/aarch64/abs_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/abs_1.c
@@ -7,15 +7,14 @@ extern void abort (void);
 long long
 abs64 (long long a)
 {
-  /* { dg-final { scan-assembler "eor\t" } } */
-  /* { dg-final { scan-assembler "sub\t" } } */
+  /* { dg-final { scan-assembler "csneg\t" } } */
   return llabs (a);
 }
 
 long long
 abs64_in_dreg (long long a)
 {
-  /* { dg-final { scan-assembler "abs\td\[0-9\]+, d\[0-9\]+" } } */
+  /* { dg-final { scan-assembler "csneg\t" } } */
   register long long x asm ("d8") = a;
   register long long y asm ("d9");
   asm volatile ("" : : "w" (x));
@@ -50,4 +49,3 @@ main (void)
   return 0;
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/abs_2.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/abs_2.c
@@ -28,4 +28,3 @@ main (int argc, char **argv)
 
 
 /* { dg-final { scan-assembler-not "sabd" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/acle/crc32b.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/acle/crc32b.c
@@ -12,4 +12,3 @@ test_crc32b (uint32_t arg0, uint8_t arg1)
 }
 
 /* { dg-final { scan-assembler "crc32b\tw..?, w..?, w..?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/acle/crc32cb.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/acle/crc32cb.c
@@ -12,4 +12,3 @@ test_crc32cb (uint32_t arg0, uint8_t arg1)
 }
 
 /* { dg-final { scan-assembler "crc32cb\tw..?, w..?, w..?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/acle/crc32cd.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/acle/crc32cd.c
@@ -12,4 +12,3 @@ test_crc32cd (uint32_t arg0, uint64_t arg1)
 }
 
 /* { dg-final { scan-assembler "crc32cx\tw..?, w..?, x..?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/acle/crc32ch.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/acle/crc32ch.c
@@ -12,4 +12,3 @@ test_crc32ch (uint32_t arg0, uint16_t arg1)
 }
 
 /* { dg-final { scan-assembler "crc32ch\tw..?, w..?, w..?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/acle/crc32cw.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/acle/crc32cw.c
@@ -12,4 +12,3 @@ test_crc32cw (uint32_t arg0, uint32_t arg1)
 }
 
 /* { dg-final { scan-assembler "crc32cw\tw..?, w..?, w..?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/acle/crc32d.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/acle/crc32d.c
@@ -12,4 +12,3 @@ test_crc32d (uint32_t arg0, uint64_t arg1)
 }
 
 /* { dg-final { scan-assembler "crc32x\tw..?, w..?, x..?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/acle/crc32h.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/acle/crc32h.c
@@ -12,4 +12,3 @@ test_crc32h (uint32_t arg0, uint16_t arg1)
 }
 
 /* { dg-final { scan-assembler "crc32h\tw..?, w..?, w..?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/acle/crc32w.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/acle/crc32w.c
@@ -12,4 +12,3 @@ test_crc32w (uint32_t arg0, uint32_t arg1)
 }
 
 /* { dg-final { scan-assembler "crc32w\tw..?, w..?, w..?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/adds1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/adds1.c
@@ -12,7 +12,7 @@ adds_si_test1 (int a, int b, int c)
   if (d == 0)
     return a + c;
   else
-    return b + d + c;
+    return d;
 }
 
 int
@@ -24,7 +24,7 @@ adds_si_test2 (int a, int b, int c)
   if (d == 0)
     return a + c;
   else
-    return b + d + c;
+    return d;
 }
 
 int
@@ -36,7 +36,7 @@ adds_si_test3 (int a, int b, int c)
   if (d == 0)
     return a + c;
   else
-    return b + d + c;
+    return d;
 }
 
 typedef long long s64;
@@ -50,7 +50,7 @@ adds_di_test1 (s64 a, s64 b, s64 c)
   if (d == 0)
     return a + c;
   else
-    return b + d + c;
+    return d;
 }
 
 s64
@@ -62,7 +62,7 @@ adds_di_test2 (s64 a, s64 b, s64 c)
   if (d == 0)
     return a + c;
   else
-    return b + d + c;
+    return d;
 }
 
 s64
@@ -74,7 +74,7 @@ adds_di_test3 (s64 a, s64 b, s64 c)
   if (d == 0)
     return a + c;
   else
-    return b + d + c;
+    return d;
 }
 
 int main ()
@@ -83,67 +83,66 @@ int main ()
   s64 y;
 
   x = adds_si_test1 (29, 4, 5);
-  if (x != 42)
+  if (x != (29 + 4))
     abort ();
 
-  x = adds_si_test1 (5, 2, 20);
-  if (x != 29)
+  x = adds_si_test1 (5, 2, -5);
+  if (x != 7)
     abort ();
 
   x = adds_si_test2 (29, 4, 5);
-  if (x != 293)
+  if (x != (29 + 0xff))
     abort ();
 
-  x = adds_si_test2 (1024, 2, 20);
-  if (x != 1301)
+  x = adds_si_test2 (-255, 2, 20);
+  if (x != -235)
     abort ();
 
   x = adds_si_test3 (35, 4, 5);
-  if (x != 76)
+  if (x != (35 + (4 << 3)))
     abort ();
 
-  x = adds_si_test3 (5, 2, 20);
-  if (x != 43)
+  x = adds_si_test3 (-(2 << 3), 2, 20);
+  if (x != (20 - (2 << 3)))
     abort ();
 
   y = adds_di_test1 (0x130000029ll,
 		     0x320000004ll,
 		     0x505050505ll);
 
-  if (y != 0xc75050536)
+  if (y != (0x130000029ll + 0x320000004ll))
     abort ();
 
   y = adds_di_test1 (0x5000500050005ll,
-		     0x2111211121112ll,
+		     -0x5000500050005ll,
 		     0x0000000002020ll);
-  if (y != 0x9222922294249)
+  if (y != (0x5000500050005ll + 0x0000000002020ll))
     abort ();
 
   y = adds_di_test2 (0x130000029ll,
 		     0x320000004ll,
 		     0x505050505ll);
-  if (y != 0x955050631)
+  if (y != (0x130000029ll + 0xff))
     abort ();
 
-  y = adds_di_test2 (0x130002900ll,
+  y = adds_di_test2 (-0xff,
 		     0x320000004ll,
 		     0x505050505ll);
-  if (y != 0x955052f08)
+  if (y != (0x505050505ll - 0xff))
     abort ();
 
   y = adds_di_test3 (0x130000029ll,
 		     0x064000008ll,
 		     0x505050505ll);
-  if (y != 0x9b9050576)
+  if (y != (0x130000029ll + (0x064000008ll << 3)))
     abort ();
 
   y = adds_di_test3 (0x130002900ll,
-		     0x088000008ll,
+		     -(0x130002900ll >> 3),
 		     0x505050505ll);
-  if (y != 0xafd052e4d)
+  if (y != (0x130002900ll + 0x505050505ll))
     abort ();
 
   return 0;
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/adds2.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/adds2.c
@@ -152,4 +152,3 @@ int main ()
   return 0;
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/adds3.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/adds3.c
@@ -12,7 +12,7 @@ adds_ext (s64 a, int b, int c)
   if (d == 0)
     return a + c;
   else
-    return b + d + c;
+    return d;
 }
 
 int
@@ -23,7 +23,7 @@ adds_shift_ext (s64 a, int b, int c)
   if (d == 0)
     return a + c;
   else
-    return b + d + c;
+    return d;
 }
 
 int main ()
@@ -32,27 +32,27 @@ int main ()
   s64 y;
 
   x = adds_ext (0x13000002ll, 41, 15);
-  if (x != 318767203)
+  if (x != (int)(0x13000002ll + 41))
     abort ();
 
-  x = adds_ext (0x50505050ll, 29, 4);
-  if (x != 1347440782)
+  x = adds_ext (0x50505050ll, -0x50505050ll, 4);
+  if (x != (int)(0x50505050ll + 4))
     abort ();
 
   x = adds_ext (0x12121212121ll, 2, 14);
-  if (x != 555819315)
+  if (x != (int)(0x12121212121ll + 2))
     abort ();
 
   x = adds_shift_ext (0x123456789ll, 4, 12);
-  if (x != 591751097)
+  if (x != (int)(0x123456789ll + (4 << 3)))
     abort ();
 
-  x = adds_shift_ext (0x02020202ll, 9, 8);
-  if (x != 33686107)
+  x = adds_shift_ext (-(0x02020202ll << 3), 0x02020202ll, 8);
+  if (x != (int)(8 - (0x02020202ll << 3)))
     abort ();
 
   x = adds_shift_ext (0x987987987987ll, 23, 41);
-  if (x != -2020050305)
+  if (x != (int)(0x987987987987ll + (23 << 3)))
     abort ();
 
   return 0;
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/advsimd-intrinsics.exp
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/advsimd-intrinsics.exp
@@ -27,39 +27,43 @@ load_lib gcc-dg.exp
 
 # Initialize `dg'.
 load_lib c-torture.exp
-load_lib target-supports.exp
-load_lib torture-options.exp
 
 dg-init
 
-if {[istarget arm*-*-*]
-    && ![check_effective_target_arm_neon_ok]} then {
-  return
+# The default action for a test is 'run'.  Save current default.
+global dg-do-what-default
+set save-dg-do-what-default ${dg-do-what-default}
+
+# For ARM, make sure that we have a target compatible with NEON, and do
+# not attempt to run execution tests if the hardware doesn't support it.
+if {[istarget arm*-*-*]} then {
+    if {![check_effective_target_arm_neon_ok]} then {
+      return
+    }
+    if {![is-effective-target arm_neon_hw]} then {
+        set dg-do-what-default compile
+    } else {
+        set dg-do-what-default run
+    }
+} else {
+    set dg-do-what-default run
 }
 
 torture-init
 set-torture-options $C_TORTURE_OPTIONS {{}} $LTO_TORTURE_OPTIONS
 
-# Make sure Neon flags are provided, if necessary.
-set additional_flags [add_options_for_arm_neon ""]
+# Make sure Neon flags are provided, if necessary.  Use fp16 if we can.
+if {[check_effective_target_arm_neon_fp16_ok]} then {
+  set additional_flags [add_options_for_arm_neon_fp16 ""]
+} else {
+  set additional_flags [add_options_for_arm_neon ""]
+}
 
 # Main loop.
-foreach src [lsort [glob -nocomplain $srcdir/$subdir/*.c]] {
-    # If we're only testing specific files and this isn't one of them, skip it.
-    if ![runtest_file_p $runtests $src] then {
-	continue
-    }
-
-    # runtest_file_p is already run above, and the code below can run
-    # runtest_file_p again, make sure everything for this test is
-    # performed if the above runtest_file_p decided this runtest
-    # instance should execute the test
-    gcc_parallel_test_enable 0
-    c-torture-execute $src $additional_flags
-    gcc-dg-runtest $src "" $additional_flags
-    gcc_parallel_test_enable 1
-}
+gcc-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.c]] \
+	       "" ${additional_flags}
 
 # All done.
+set dg-do-what-default ${save-dg-do-what-default}
 torture-finish
 dg-finish
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/arm-neon-ref.h
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/arm-neon-ref.h
@@ -7,6 +7,7 @@
 #include <inttypes.h>
 
 /* helper type, to help write floating point results in integer form.  */
+typedef uint16_t hfloat16_t;
 typedef uint32_t hfloat32_t;
 typedef uint64_t hfloat64_t;
 
@@ -132,6 +133,9 @@ static ARRAY(result, uint, 32, 2);
 static ARRAY(result, uint, 64, 1);
 static ARRAY(result, poly, 8, 8);
 static ARRAY(result, poly, 16, 4);
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+static ARRAY(result, float, 16, 4);
+#endif
 static ARRAY(result, float, 32, 2);
 static ARRAY(result, int, 8, 16);
 static ARRAY(result, int, 16, 8);
@@ -143,6 +147,9 @@ static ARRAY(result, uint, 32, 4);
 static ARRAY(result, uint, 64, 2);
 static ARRAY(result, poly, 8, 16);
 static ARRAY(result, poly, 16, 8);
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+static ARRAY(result, float, 16, 8);
+#endif
 static ARRAY(result, float, 32, 4);
 #ifdef __aarch64__
 static ARRAY(result, float, 64, 2);
@@ -160,6 +167,7 @@ extern ARRAY(expected, uint, 32, 2);
 extern ARRAY(expected, uint, 64, 1);
 extern ARRAY(expected, poly, 8, 8);
 extern ARRAY(expected, poly, 16, 4);
+extern ARRAY(expected, hfloat, 16, 4);
 extern ARRAY(expected, hfloat, 32, 2);
 extern ARRAY(expected, int, 8, 16);
 extern ARRAY(expected, int, 16, 8);
@@ -171,38 +179,11 @@ extern ARRAY(expected, uint, 32, 4);
 extern ARRAY(expected, uint, 64, 2);
 extern ARRAY(expected, poly, 8, 16);
 extern ARRAY(expected, poly, 16, 8);
+extern ARRAY(expected, hfloat, 16, 8);
 extern ARRAY(expected, hfloat, 32, 4);
 extern ARRAY(expected, hfloat, 64, 2);
 
-/* Check results. Operates on all possible vector types.  */
-#define CHECK_RESULTS(test_name,comment)				\
-  {									\
-    CHECK(test_name, int, 8, 8, PRIx8, expected, comment);		\
-    CHECK(test_name, int, 16, 4, PRIx16, expected, comment);		\
-    CHECK(test_name, int, 32, 2, PRIx32, expected, comment);		\
-    CHECK(test_name, int, 64, 1, PRIx64, expected, comment);		\
-    CHECK(test_name, uint, 8, 8, PRIx8, expected, comment);		\
-    CHECK(test_name, uint, 16, 4, PRIx16, expected, comment);		\
-    CHECK(test_name, uint, 32, 2, PRIx32, expected, comment);		\
-    CHECK(test_name, uint, 64, 1, PRIx64, expected, comment);		\
-    CHECK(test_name, poly, 8, 8, PRIx8, expected, comment);		\
-    CHECK(test_name, poly, 16, 4, PRIx16, expected, comment);		\
-    CHECK_FP(test_name, float, 32, 2, PRIx32, expected, comment);	\
-									\
-    CHECK(test_name, int, 8, 16, PRIx8, expected, comment);		\
-    CHECK(test_name, int, 16, 8, PRIx16, expected, comment);		\
-    CHECK(test_name, int, 32, 4, PRIx32, expected, comment);		\
-    CHECK(test_name, int, 64, 2, PRIx64, expected, comment);		\
-    CHECK(test_name, uint, 8, 16, PRIx8, expected, comment);		\
-    CHECK(test_name, uint, 16, 8, PRIx16, expected, comment);		\
-    CHECK(test_name, uint, 32, 4, PRIx32, expected, comment);		\
-    CHECK(test_name, uint, 64, 2, PRIx64, expected, comment);		\
-    CHECK(test_name, poly, 8, 16, PRIx8, expected, comment);		\
-    CHECK(test_name, poly, 16, 8, PRIx16, expected, comment);		\
-    CHECK_FP(test_name, float, 32, 4, PRIx32, expected, comment);	\
-  }									\
-
-#define CHECK_RESULTS_NAMED(test_name,EXPECTED,comment)			\
+#define CHECK_RESULTS_NAMED_NO_FP16(test_name,EXPECTED,comment)		\
   {									\
     CHECK(test_name, int, 8, 8, PRIx8, EXPECTED, comment);		\
     CHECK(test_name, int, 16, 4, PRIx16, EXPECTED, comment);		\
@@ -229,13 +210,32 @@ extern ARRAY(expected, hfloat, 64, 2);
     CHECK_FP(test_name, float, 32, 4, PRIx32, EXPECTED, comment);	\
   }									\
 
+/* Check results against EXPECTED.  Operates on all possible vector types.  */
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+#define CHECK_RESULTS_NAMED(test_name,EXPECTED,comment)			\
+  {									\
+    CHECK_RESULTS_NAMED_NO_FP16(test_name, EXPECTED, comment)		\
+    CHECK_FP(test_name, float, 16, 4, PRIx16, EXPECTED, comment);	\
+    CHECK_FP(test_name, float, 16, 8, PRIx16, EXPECTED, comment);	\
+  }
+#else
+#define CHECK_RESULTS_NAMED(test_name,EXPECTED,comment)		\
+  CHECK_RESULTS_NAMED_NO_FP16(test_name, EXPECTED, comment)
+#endif
+
+#define CHECK_RESULTS_NO_FP16(test_name,comment)			\
+  CHECK_RESULTS_NAMED_NO_FP16(test_name, expected, comment)
+
+#define CHECK_RESULTS(test_name,comment)		\
+  CHECK_RESULTS_NAMED(test_name, expected, comment)
 
 
 #if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
 
 typedef union {
   struct {
-    int _xxx:25;
+    int _xxx:24;
+    unsigned int FZ:1;
     unsigned int DN:1;
     unsigned int AHP:1;
     unsigned int QC:1;
@@ -258,7 +258,8 @@ typedef union {
     unsigned int QC:1;
     unsigned int AHP:1;
     unsigned int DN:1;
-    int _dnm:25;
+    unsigned int FZ:1;
+    int _dnm:24;
   } b;
   unsigned int word;
 } _ARM_FPSCR;
@@ -378,6 +379,9 @@ static void clean_results (void)
   CLEAN(result, uint, 64, 1);
   CLEAN(result, poly, 8, 8);
   CLEAN(result, poly, 16, 4);
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+  CLEAN(result, float, 16, 4);
+#endif
   CLEAN(result, float, 32, 2);
 
   CLEAN(result, int, 8, 16);
@@ -390,15 +394,23 @@ static void clean_results (void)
   CLEAN(result, uint, 64, 2);
   CLEAN(result, poly, 8, 16);
   CLEAN(result, poly, 16, 8);
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+  CLEAN(result, float, 16, 8);
+#endif
   CLEAN(result, float, 32, 4);
 
 #if defined(__aarch64__)
   /* On AArch64, make sure to return DefaultNaN to have the same
      results as on AArch32.  */
-  _ARM_FPSCR _afpscr_for_dn;
-  asm volatile ("mrs %0,fpcr" : "=r" (_afpscr_for_dn));
-  _afpscr_for_dn.b.DN = 1;
-  asm volatile ("msr fpcr,%0" : : "r" (_afpscr_for_dn));
+  _ARM_FPSCR _afpscr;
+  asm volatile ("mrs %0,fpcr" : "=r" (_afpscr));
+  _afpscr.b.DN = 1;
+
+  /* On AArch64, make sure to flush to zero by default, as on
+     AArch32. */
+  _afpscr.b.FZ = 1;
+
+  asm volatile ("msr fpcr,%0" : : "r" (_afpscr));
 #endif
 }
 
@@ -436,21 +448,40 @@ static void clean_results (void)
   DECL_VARIABLE(VAR, uint, 64, 2)
 
 /* Declare all 64 bits variants.  */
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
 #define DECL_VARIABLE_64BITS_VARIANTS(VAR)	\
   DECL_VARIABLE_64BITS_SIGNED_VARIANTS(VAR);	\
   DECL_VARIABLE_64BITS_UNSIGNED_VARIANTS(VAR);	\
   DECL_VARIABLE(VAR, poly, 8, 8);		\
   DECL_VARIABLE(VAR, poly, 16, 4);		\
+  DECL_VARIABLE(VAR, float, 16, 4);		\
   DECL_VARIABLE(VAR, float, 32, 2)
+#else
+#define DECL_VARIABLE_64BITS_VARIANTS(VAR)	\
+  DECL_VARIABLE_64BITS_SIGNED_VARIANTS(VAR);	\
+  DECL_VARIABLE_64BITS_UNSIGNED_VARIANTS(VAR);	\
+  DECL_VARIABLE(VAR, poly, 8, 8);		\
+  DECL_VARIABLE(VAR, poly, 16, 4);		\
+  DECL_VARIABLE(VAR, float, 32, 2)
+#endif
 
 /* Declare all 128 bits variants.  */
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
 #define DECL_VARIABLE_128BITS_VARIANTS(VAR)	\
   DECL_VARIABLE_128BITS_SIGNED_VARIANTS(VAR);	\
   DECL_VARIABLE_128BITS_UNSIGNED_VARIANTS(VAR);	\
   DECL_VARIABLE(VAR, poly, 8, 16);		\
   DECL_VARIABLE(VAR, poly, 16, 8);		\
+  DECL_VARIABLE(VAR, float, 16, 8);		\
   DECL_VARIABLE(VAR, float, 32, 4)
-
+#else
+#define DECL_VARIABLE_128BITS_VARIANTS(VAR)	\
+  DECL_VARIABLE_128BITS_SIGNED_VARIANTS(VAR);	\
+  DECL_VARIABLE_128BITS_UNSIGNED_VARIANTS(VAR);	\
+  DECL_VARIABLE(VAR, poly, 8, 16);		\
+  DECL_VARIABLE(VAR, poly, 16, 8);		\
+  DECL_VARIABLE(VAR, float, 32, 4)
+#endif
 /* Declare all variants.  */
 #define DECL_VARIABLE_ALL_VARIANTS(VAR)		\
   DECL_VARIABLE_64BITS_VARIANTS(VAR);		\
@@ -469,6 +500,15 @@ static void clean_results (void)
 /* Helpers to initialize vectors.  */
 #define VDUP(VAR, Q, T1, T2, W, N, V)			\
   VECT_VAR(VAR, T1, W, N) = vdup##Q##_n_##T2##W(V)
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+/* Work around that there is no vdup_n_f16 intrinsic.  */
+#define vdup_n_f16(VAL)		\
+  __extension__			\
+    ({				\
+      float16_t f = VAL;	\
+      vld1_dup_f16(&f);		\
+    })
+#endif
 
 #define VSET_LANE(VAR, Q, T1, T2, W, N, L, V)				\
   VECT_VAR(VAR, T1, W, N) = vset##Q##_lane_##T2##W(V,			\
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/binary_op.inc
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/binary_op.inc
@@ -55,7 +55,22 @@ void FNNAME (INSN_NAME) (void)
   /* Apply a binary operator named INSN_NAME.  */
   TEST_MACRO_ALL_VARIANTS_1_5(TEST_BINARY_OP, INSN_NAME);
 
-  CHECK_RESULTS (TEST_MSG, "");
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected, "");
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected, "");
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected, "");
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected, "");
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected, "");
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected, "");
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected, "");
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected, "");
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected, "");
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected, "");
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected, "");
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected, "");
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected, "");
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected, "");
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected, "");
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected, "");
 
 #ifdef EXTRA_TESTS
   EXTRA_TESTS();
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/binary_sat_op.inc
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/binary_sat_op.inc
@@ -76,7 +76,22 @@ void FNNAME (INSN_NAME) (void)
   TEST_BINARY_SAT_OP(INSN_NAME, q, uint, u, 32, 4, expected_cumulative_sat, "");
   TEST_BINARY_SAT_OP(INSN_NAME, q, uint, u, 64, 2, expected_cumulative_sat, "");
 
-  CHECK_RESULTS (TEST_MSG, "");
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected, "");
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected, "");
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected, "");
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected, "");
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected, "");
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected, "");
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected, "");
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected, "");
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected, "");
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected, "");
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected, "");
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected, "");
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected, "");
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected, "");
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected, "");
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected, "");
 
 #ifdef EXTRA_TESTS
   EXTRA_TESTS();
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/compute-ref-data.h
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/compute-ref-data.h
@@ -118,6 +118,10 @@ VECT_VAR_DECL_INIT(buffer, uint, 32, 2);
 PAD(buffer_pad, uint, 32, 2);
 VECT_VAR_DECL_INIT(buffer, uint, 64, 1);
 PAD(buffer_pad, uint, 64, 1);
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+VECT_VAR_DECL_INIT(buffer, float, 16, 4);
+PAD(buffer_pad, float, 16, 4);
+#endif
 VECT_VAR_DECL_INIT(buffer, float, 32, 2);
 PAD(buffer_pad, float, 32, 2);
 VECT_VAR_DECL_INIT(buffer, int, 8, 16);
@@ -140,6 +144,10 @@ VECT_VAR_DECL_INIT(buffer, poly, 8, 16);
 PAD(buffer_pad, poly, 8, 16);
 VECT_VAR_DECL_INIT(buffer, poly, 16, 8);
 PAD(buffer_pad, poly, 16, 8);
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+VECT_VAR_DECL_INIT(buffer, float, 16, 8);
+PAD(buffer_pad, float, 16, 8);
+#endif
 VECT_VAR_DECL_INIT(buffer, float, 32, 4);
 PAD(buffer_pad, float, 32, 4);
 #ifdef __aarch64__
@@ -170,6 +178,10 @@ VECT_VAR_DECL_INIT(buffer_dup, poly, 8, 8);
 VECT_VAR_DECL(buffer_dup_pad, poly, 8, 8);
 VECT_VAR_DECL_INIT(buffer_dup, poly, 16, 4);
 VECT_VAR_DECL(buffer_dup_pad, poly, 16, 4);
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+VECT_VAR_DECL_INIT4(buffer_dup, float, 16, 4);
+VECT_VAR_DECL(buffer_dup_pad, float, 16, 4);
+#endif
 VECT_VAR_DECL_INIT4(buffer_dup, float, 32, 2);
 VECT_VAR_DECL(buffer_dup_pad, float, 32, 2);
 
@@ -193,5 +205,9 @@ VECT_VAR_DECL_INIT(buffer_dup, poly, 8, 16);
 VECT_VAR_DECL(buffer_dup_pad, poly, 8, 16);
 VECT_VAR_DECL_INIT(buffer_dup, poly, 16, 8);
 VECT_VAR_DECL(buffer_dup_pad, poly, 16, 8);
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+VECT_VAR_DECL_INIT(buffer_dup, float, 16, 8);
+VECT_VAR_DECL(buffer_dup_pad, float, 16, 8);
+#endif
 VECT_VAR_DECL_INIT(buffer_dup, float, 32, 4);
 VECT_VAR_DECL(buffer_dup_pad, float, 32, 4);
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/unary_op.inc
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/unary_op.inc
@@ -57,7 +57,12 @@ void FNNAME (INSN_NAME) (void)
   TEST_UNARY_OP(INSN_NAME, q, int, s, 16, 8);
   TEST_UNARY_OP(INSN_NAME, q, int, s, 32, 4);
 
-  CHECK_RESULTS (TEST_MSG, "");
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected, "");
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected, "");
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected, "");
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected, "");
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected, "");
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected, "");
 
 #ifdef EXTRA_TESTS
   EXTRA_TESTS();
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vXXXl.inc
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vXXXl.inc
@@ -60,7 +60,12 @@ void FNNAME (INSN_NAME) (void)
   TEST_VADDL(INSN_NAME, uint, u, 16, 32, 4);
   TEST_VADDL(INSN_NAME, uint, u, 32, 64, 2);
 
-  CHECK_RESULTS (TEST_MSG, "");
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected, "");
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected, "");
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected, "");
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected, "");
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected, "");
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected, "");
 }
 
 int main (void)
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vXXXw.inc
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vXXXw.inc
@@ -60,7 +60,12 @@ void FNNAME (INSN_NAME) (void)
   TEST_VADDW(INSN_NAME, uint, u, 16, 32, 4);
   TEST_VADDW(INSN_NAME, uint, u, 32, 64, 2);
 
-  CHECK_RESULTS (TEST_MSG, "");
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected, "");
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected, "");
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected, "");
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected, "");
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected, "");
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected, "");
 }
 
 int main (void)
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vaba.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vaba.c
@@ -7,16 +7,10 @@ VECT_VAR_DECL(expected,int,8,8) [] = { 0xf6, 0xf7, 0xf8, 0xf9,
 				       0xfa, 0xfb, 0xfc, 0xfd };
 VECT_VAR_DECL(expected,int,16,4) [] = { 0x16, 0x17, 0x18, 0x19 };
 VECT_VAR_DECL(expected,int,32,2) [] = { 0x20, 0x21 };
-VECT_VAR_DECL(expected,int,64,1) [] = { 0x3333333333333333 };
 VECT_VAR_DECL(expected,uint,8,8) [] = { 0x53, 0x54, 0x55, 0x56,
 					0x57, 0x58, 0x59, 0x5a };
 VECT_VAR_DECL(expected,uint,16,4) [] = { 0x907, 0x908, 0x909, 0x90a };
 VECT_VAR_DECL(expected,uint,32,2) [] = { 0xffffffe7, 0xffffffe8 };
-VECT_VAR_DECL(expected,uint,64,1) [] = { 0x3333333333333333 };
-VECT_VAR_DECL(expected,poly,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0x33333333, 0x33333333 };
 VECT_VAR_DECL(expected,int,8,16) [] = { 0x5e, 0x5f, 0x60, 0x61,
 					0x62, 0x63, 0x64, 0x65,
 					0x66, 0x67, 0x68, 0x69,
@@ -24,8 +18,6 @@ VECT_VAR_DECL(expected,int,8,16) [] = { 0x5e, 0x5f, 0x60, 0x61,
 VECT_VAR_DECL(expected,int,16,8) [] = { 0xb9c, 0xb9d, 0xb9e, 0xb9f,
 					0xba0, 0xba1, 0xba2, 0xba3 };
 VECT_VAR_DECL(expected,int,32,4) [] = { 0x26e0, 0x26e1, 0x26e2, 0x26e3 };
-VECT_VAR_DECL(expected,int,64,2) [] = { 0x3333333333333333,
-					0x3333333333333333 };
 VECT_VAR_DECL(expected,uint,8,16) [] = { 0xf8, 0xf9, 0xfa, 0xfb,
 					 0xfc, 0xfd, 0xfe, 0xff,
 					 0x0, 0x1, 0x2, 0x3,
@@ -33,16 +25,6 @@ VECT_VAR_DECL(expected,uint,8,16) [] = { 0xf8, 0xf9, 0xfa, 0xfb,
 VECT_VAR_DECL(expected,uint,16,8) [] = { 0xfff9, 0xfffa, 0xfffb, 0xfffc,
 					 0xfffd, 0xfffe, 0xffff, 0x0 };
 VECT_VAR_DECL(expected,uint,32,4) [] = { 0xc, 0xd, 0xe, 0xf };
-VECT_VAR_DECL(expected,uint,64,2) [] = { 0x3333333333333333,
-					 0x3333333333333333 };
-VECT_VAR_DECL(expected,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0x33333333, 0x33333333,
-					   0x33333333, 0x33333333 };
 
 #define TEST_MSG "VABA/VABAQ"
 void exec_vaba (void)
@@ -132,7 +114,18 @@ void exec_vaba (void)
   TEST_VABA(q, uint, u, 16, 8);
   TEST_VABA(q, uint, u, 32, 4);
 
-  CHECK_RESULTS (TEST_MSG, "");
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected, "");
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected, "");
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected, "");
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected, "");
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected, "");
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected, "");
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected, "");
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected, "");
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected, "");
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected, "");
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected, "");
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected, "");
 }
 
 int main (void)
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vabal.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vabal.c
@@ -3,45 +3,15 @@
 #include "compute-ref-data.h"
 
 /* Expected results.  */
-VECT_VAR_DECL(expected,int,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-				       0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,int,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,int,32,2) [] = { 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,int,64,1) [] = { 0x3333333333333333 };
-VECT_VAR_DECL(expected,uint,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,uint,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,uint,32,2) [] = { 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,uint,64,1) [] = { 0x3333333333333333 };
-VECT_VAR_DECL(expected,poly,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,int,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
 VECT_VAR_DECL(expected,int,16,8) [] = { 0xfff6, 0xfff7, 0xfff8, 0xfff9,
 					0xfffa, 0xfffb, 0xfffc, 0xfffd };
 VECT_VAR_DECL(expected,int,32,4) [] = { 0x16, 0x17, 0x18, 0x19 };
 VECT_VAR_DECL(expected,int,64,2) [] = { 0x20, 0x21 };
-VECT_VAR_DECL(expected,uint,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
 VECT_VAR_DECL(expected,uint,16,8) [] = { 0x53, 0x54, 0x55, 0x56,
 					 0x57, 0x58, 0x59, 0x5a };
 VECT_VAR_DECL(expected,uint,32,4) [] = { 0x907, 0x908, 0x909, 0x90a };
 VECT_VAR_DECL(expected,uint,64,2) [] = { 0xffffffe7,
 					 0xffffffe8 };
-VECT_VAR_DECL(expected,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0x33333333, 0x33333333,
-					   0x33333333, 0x33333333 };
 
 /* Expected results for cases with input values chosen to test
    possible intermediate overflow.  */
@@ -121,7 +91,12 @@ void exec_vabal (void)
   TEST_VABAL(uint, u, 16, 32, 4);
   TEST_VABAL(uint, u, 32, 64, 2);
 
-  CHECK_RESULTS (TEST_MSG, "");
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected, "");
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected, "");
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected, "");
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected, "");
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected, "");
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected, "");
 
   /* Use values that could lead to overflow intermediate
    * calculations.  */
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vabd.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vabd.c
@@ -8,15 +8,10 @@ VECT_VAR_DECL(expected,int,8,8) [] = { 0x11, 0x10, 0xf, 0xe,
 				       0xd, 0xc, 0xb, 0xa };
 VECT_VAR_DECL(expected,int,16,4) [] = { 0x3, 0x2, 0x1, 0x0 };
 VECT_VAR_DECL(expected,int,32,2) [] = { 0x18, 0x17 };
-VECT_VAR_DECL(expected,int,64,1) [] = { 0x3333333333333333 };
 VECT_VAR_DECL(expected,uint,8,8) [] = { 0xef, 0xf0, 0xf1, 0xf2,
 					0xf3, 0xf4, 0xf5, 0xf6 };
 VECT_VAR_DECL(expected,uint,16,4) [] = { 0xffe3, 0xffe4, 0xffe5, 0xffe6 };
 VECT_VAR_DECL(expected,uint,32,2) [] = { 0xffffffe8, 0xffffffe9 };
-VECT_VAR_DECL(expected,uint,64,1) [] = { 0x3333333333333333 };
-VECT_VAR_DECL(expected,poly,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
 VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0x41c26666, 0x41ba6666 };
 VECT_VAR_DECL(expected,int,8,16) [] = { 0x1a, 0x19, 0x18, 0x17,
 					0x16, 0x15, 0x14, 0x13,
@@ -25,8 +20,6 @@ VECT_VAR_DECL(expected,int,8,16) [] = { 0x1a, 0x19, 0x18, 0x17,
 VECT_VAR_DECL(expected,int,16,8) [] = { 0x4, 0x3, 0x2, 0x1,
 					0x0, 0x1, 0x2, 0x3 };
 VECT_VAR_DECL(expected,int,32,4) [] = { 0x30, 0x2f, 0x2e, 0x2d };
-VECT_VAR_DECL(expected,int,64,2) [] = { 0x3333333333333333,
-					0x3333333333333333 };
 VECT_VAR_DECL(expected,uint,8,16) [] = { 0xe6, 0xe7, 0xe8, 0xe9,
 					 0xea, 0xeb, 0xec, 0xed,
 					 0xee, 0xef, 0xf0, 0xf1,
@@ -35,14 +28,6 @@ VECT_VAR_DECL(expected,uint,16,8) [] = { 0xffe4, 0xffe5, 0xffe6, 0xffe7,
 					 0xffe8, 0xffe9, 0xffea, 0xffeb };
 VECT_VAR_DECL(expected,uint,32,4) [] = { 0xffffffd0, 0xffffffd1,
 					 0xffffffd2, 0xffffffd3 };
-VECT_VAR_DECL(expected,uint,64,2) [] = { 0x3333333333333333,
-					 0x3333333333333333 };
-VECT_VAR_DECL(expected,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					 0x3333, 0x3333, 0x3333, 0x3333 };
 VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0x42407ae1, 0x423c7ae1,
 					   0x42387ae1, 0x42347ae1 };
 
@@ -130,7 +115,20 @@ void exec_vabd (void)
   TEST_VABD(q, uint, u, 32, 4);
   TEST_VABD(q, float, f, 32, 4);
 
-  CHECK_RESULTS (TEST_MSG, "");
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected, "");
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected, "");
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected, "");
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected, "");
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected, "");
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected, "");
+  CHECK_FP(TEST_MSG, float, 32, 2, PRIx32, expected, "");
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected, "");
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected, "");
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected, "");
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected, "");
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected, "");
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected, "");
+  CHECK_FP(TEST_MSG, float, 32, 4, PRIx32, expected, "");
 
 
   /* Extra FP tests with special values (-0.0, ....) */
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vabdl.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vabdl.c
@@ -3,45 +3,15 @@
 #include "compute-ref-data.h"
 
 /* Expected results.  */
-VECT_VAR_DECL(expected,int,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-				       0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,int,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,int,32,2) [] = { 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,int,64,1) [] = { 0x3333333333333333 };
-VECT_VAR_DECL(expected,uint,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,uint,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,uint,32,2) [] = { 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,uint,64,1) [] = { 0x3333333333333333 };
-VECT_VAR_DECL(expected,poly,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,int,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
 VECT_VAR_DECL(expected,int,16,8) [] = { 0x11, 0x10, 0xf, 0xe,
 					0xd, 0xc, 0xb, 0xa };
 VECT_VAR_DECL(expected,int,32,4) [] = { 0x3, 0x2, 0x1, 0x0 };
 VECT_VAR_DECL(expected,int,64,2) [] = { 0x18, 0x17 };
-VECT_VAR_DECL(expected,uint,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
 VECT_VAR_DECL(expected,uint,16,8) [] = { 0xef, 0xf0, 0xf1, 0xf2,
 					 0xf3, 0xf4, 0xf5, 0xf6 };
 VECT_VAR_DECL(expected,uint,32,4) [] = { 0xffe3, 0xffe4, 0xffe5, 0xffe6 };
 VECT_VAR_DECL(expected,uint,64,2) [] = { 0xffffffe8,
 					 0xffffffe9 };
-VECT_VAR_DECL(expected,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0x33333333, 0x33333333,
-					   0x33333333, 0x33333333 };
 
 #define TEST_MSG "VABDL"
 void exec_vabdl (void)
@@ -99,7 +69,12 @@ void exec_vabdl (void)
   TEST_VABDL(uint, u, 16, 32, 4);
   TEST_VABDL(uint, u, 32, 64, 2);
 
-  CHECK_RESULTS (TEST_MSG, "");
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected, "");
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected, "");
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected, "");
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected, "");
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected, "");
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected, "");
 }
 
 int main (void)
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vabs.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vabs.c
@@ -12,41 +12,11 @@ VECT_VAR_DECL(expected,int,8,8) [] = { 0x10, 0xf, 0xe, 0xd,
 				       0xc, 0xb, 0xa, 0x9 };
 VECT_VAR_DECL(expected,int,16,4) [] = { 0x10, 0xf, 0xe, 0xd };
 VECT_VAR_DECL(expected,int,32,2) [] = { 0x10, 0xf };
-VECT_VAR_DECL(expected,int,64,1) [] = { 0x3333333333333333 };
-VECT_VAR_DECL(expected,uint,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,uint,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,uint,32,2) [] = { 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,uint,64,1) [] = { 0x3333333333333333 };
-VECT_VAR_DECL(expected,poly,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0x33333333, 0x33333333 };
 VECT_VAR_DECL(expected,int,8,16) [] = { 0x10, 0xf, 0xe, 0xd, 0xc, 0xb, 0xa, 0x9,
 					0x8, 0x7, 0x6, 0x5, 0x4, 0x3, 0x2, 0x1 };
 VECT_VAR_DECL(expected,int,16,8) [] = { 0x10, 0xf, 0xe, 0xd,
 					0xc, 0xb, 0xa, 0x9 };
 VECT_VAR_DECL(expected,int,32,4) [] = { 0x10, 0xf, 0xe, 0xd };
-VECT_VAR_DECL(expected,int,64,2) [] = { 0x3333333333333333,
-					0x3333333333333333 };
-VECT_VAR_DECL(expected,uint,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,uint,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,uint,32,4) [] = { 0x33333333, 0x33333333,
-					 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,uint,64,2) [] = { 0x3333333333333333,
-					 0x3333333333333333 };
-VECT_VAR_DECL(expected,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0x33333333, 0x33333333,
-					  0x33333333, 0x33333333 };
 
 /* Expected results for float32 variants. Needs to be separated since
    the generic test function does not test floating-point
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vadd.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vadd.c
@@ -18,10 +18,6 @@ VECT_VAR_DECL(expected,uint,8,8) [] = { 0x4, 0x5, 0x6, 0x7,
 VECT_VAR_DECL(expected,uint,16,4) [] = { 0xe, 0xf, 0x10, 0x11 };
 VECT_VAR_DECL(expected,uint,32,2) [] = { 0x18, 0x19 };
 VECT_VAR_DECL(expected,uint,64,1) [] = { 0xfffffffffffffff2 };
-VECT_VAR_DECL(expected,poly,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0x33333333, 0x33333333 };
 VECT_VAR_DECL(expected,int,8,16) [] = { 0xe6, 0xe7, 0xe8, 0xe9,
 					0xea, 0xeb, 0xec, 0xed,
 					0xee, 0xef, 0xf0, 0xf1,
@@ -40,14 +36,6 @@ VECT_VAR_DECL(expected,uint,16,8) [] = { 0xfff3, 0xfff4, 0xfff5, 0xfff6,
 VECT_VAR_DECL(expected,uint,32,4) [] = { 0x27, 0x28, 0x29, 0x2a };
 VECT_VAR_DECL(expected,uint,64,2) [] = { 0xfffffffffffffff3,
 					 0xfffffffffffffff4 };
-VECT_VAR_DECL(expected,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0x33333333, 0x33333333,
-					   0x33333333, 0x33333333 };
 
 /* Expected results for float32 variants. Needs to be separated since
    the generic test function does not test floating-point
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vaddl.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vaddl.c
@@ -6,46 +6,16 @@
 #define TEST_MSG "VADDL"
 
 /* Expected results.  */
-VECT_VAR_DECL(expected,int,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-				       0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,int,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,int,32,2) [] = { 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,int,64,1) [] = { 0x3333333333333333 };
-VECT_VAR_DECL(expected,uint,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,uint,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,uint,32,2) [] = { 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,uint,64,1) [] = { 0x3333333333333333 };
-VECT_VAR_DECL(expected,poly,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,int,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
 VECT_VAR_DECL(expected,int,16,8) [] = {  0xffe3, 0xffe4, 0xffe5, 0xffe6,
 					 0xffe7, 0xffe8, 0xffe9, 0xffea };
 VECT_VAR_DECL(expected,int,32,4) [] = { 0xffffffe2, 0xffffffe3,
 					0xffffffe4, 0xffffffe5 };
 VECT_VAR_DECL(expected,int,64,2) [] = { 0xffffffffffffffe0,
 					0xffffffffffffffe1 };
-VECT_VAR_DECL(expected,uint,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
 VECT_VAR_DECL(expected,uint,16,8) [] = { 0x1e3, 0x1e4, 0x1e5, 0x1e6,
 					 0x1e7, 0x1e8, 0x1e9, 0x1ea };
 VECT_VAR_DECL(expected,uint,32,4) [] = { 0x1ffe1, 0x1ffe2,
 					 0x1ffe3, 0x1ffe4 };
 VECT_VAR_DECL(expected,uint,64,2) [] = { 0x1ffffffe0, 0x1ffffffe1 };
-VECT_VAR_DECL(expected,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0x33333333, 0x33333333,
-					   0x33333333, 0x33333333 };
 
 #include "vXXXl.inc"
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vaddw.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vaddw.c
@@ -6,46 +6,16 @@
 #define TEST_MSG "VADDW"
 
 /* Expected results.  */
-VECT_VAR_DECL(expected,int,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-				       0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,int,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,int,32,2) [] = { 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,int,64,1) [] = { 0x3333333333333333 };
-VECT_VAR_DECL(expected,uint,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,uint,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,uint,32,2) [] = { 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,uint,64,1) [] = { 0x3333333333333333 };
-VECT_VAR_DECL(expected,poly,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,int,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
 VECT_VAR_DECL(expected,int,16,8) [] = {  0xffe3, 0xffe4, 0xffe5, 0xffe6,
 					 0xffe7, 0xffe8, 0xffe9, 0xffea };
 VECT_VAR_DECL(expected,int,32,4) [] = { 0xffffffe2, 0xffffffe3,
 					0xffffffe4, 0xffffffe5 };
 VECT_VAR_DECL(expected,int,64,2) [] = { 0xffffffffffffffe0,
 					0xffffffffffffffe1 };
-VECT_VAR_DECL(expected,uint,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
 VECT_VAR_DECL(expected,uint,16,8) [] = { 0xe3, 0xe4, 0xe5, 0xe6,
 					 0xe7, 0xe8, 0xe9, 0xea };
 VECT_VAR_DECL(expected,uint,32,4) [] = { 0xffe1, 0xffe2,
 					 0xffe3, 0xffe4 };
 VECT_VAR_DECL(expected,uint,64,2) [] = { 0xffffffe0, 0xffffffe1 };
-VECT_VAR_DECL(expected,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0x33333333, 0x33333333,
-					   0x33333333, 0x33333333 };
 
 #include "vXXXw.inc"
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vand.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vand.c
@@ -14,10 +14,6 @@ VECT_VAR_DECL(expected,uint,8,8) [] = { 0x10, 0x10, 0x10, 0x10,
 VECT_VAR_DECL(expected,uint,16,4) [] = { 0x10, 0x10, 0x12, 0x12 };
 VECT_VAR_DECL(expected,uint,32,2) [] = { 0x20, 0x20 };
 VECT_VAR_DECL(expected,uint,64,1) [] = { 0x0 };
-VECT_VAR_DECL(expected,poly,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0x33333333, 0x33333333 };
 VECT_VAR_DECL(expected,int,8,16) [] = { 0xf0, 0xf0, 0xf2, 0xf2,
 					0xf4, 0xf4, 0xf6, 0xf6,
 					0xf0, 0xf0, 0xf2, 0xf2,
@@ -35,11 +31,3 @@ VECT_VAR_DECL(expected,uint,16,8) [] = { 0x0, 0x1, 0x2, 0x3,
 					 0x0, 0x1, 0x2, 0x3 };
 VECT_VAR_DECL(expected,uint,32,4) [] = { 0x30, 0x31, 0x32, 0x33 };
 VECT_VAR_DECL(expected,uint,64,2) [] = { 0x0, 0x1 };
-VECT_VAR_DECL(expected,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0x33333333, 0x33333333,
-					   0x33333333, 0x33333333 };
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vbic.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vbic.c
@@ -14,10 +14,6 @@ VECT_VAR_DECL(expected,uint,8,8) [] = { 0xe0, 0xe1, 0xe2, 0xe3,
 VECT_VAR_DECL(expected,uint,16,4) [] = { 0xffe0, 0xffe1, 0xffe0, 0xffe1 };
 VECT_VAR_DECL(expected,uint,32,2) [] = { 0xffffffd0, 0xffffffd1 };
 VECT_VAR_DECL(expected,uint,64,1) [] = { 0xfffffffffffffff0 };
-VECT_VAR_DECL(expected,poly,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0x33333333, 0x33333333 };
 VECT_VAR_DECL(expected,int,8,16) [] = { 0x0, 0x1, 0x0, 0x1,
 					0x0, 0x1, 0x0, 0x1,
 					0x8, 0x9, 0x8, 0x9,
@@ -36,11 +32,3 @@ VECT_VAR_DECL(expected,uint,32,4) [] = { 0xffffffc0, 0xffffffc0,
 					 0xffffffc0, 0xffffffc0 };
 VECT_VAR_DECL(expected,uint,64,2) [] = { 0xfffffffffffffff0,
 					 0xfffffffffffffff0 };
-VECT_VAR_DECL(expected,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0x33333333, 0x33333333,
-					   0x33333333, 0x33333333 };
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vbsl.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vbsl.c
@@ -114,7 +114,7 @@ void exec_vbsl (void)
   TEST_VBSL(uint, , float, f, 32, 2);
   TEST_VBSL(uint, q, float, f, 32, 4);
 
-  CHECK_RESULTS (TEST_MSG, "");
+  CHECK_RESULTS_NO_FP16 (TEST_MSG, "");
 }
 
 int main (void)
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vcage.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vcage.c
@@ -4,48 +4,9 @@
 #include "cmp_fp_op.inc"
 
 /* Expected results.  */
-VECT_VAR_DECL(expected,int,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-				       0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,int,16,4) [] = { 0x333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,int,32,2) [] = { 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,int,64,1) [] = { 0x3333333333333333 };
-VECT_VAR_DECL(expected,uint,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,uint,16,4) [] = { 0x333, 0x3333, 0x3333, 0x3333 };
 VECT_VAR_DECL(expected,uint,32,2) [] = { 0xffffffff, 0x0 };
-VECT_VAR_DECL(expected,uint,64,1) [] = { 0x3333333333333333 };
-VECT_VAR_DECL(expected,poly,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,int,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,int,16,8) [] = { 0x333, 0x3333, 0x3333, 0x3333,
-					0x333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,int,32,4) [] = { 0x33333333, 0x33333333,
-					0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,int,64,2) [] = { 0x3333333333333333,
-					0x3333333333333333 };
-VECT_VAR_DECL(expected,uint,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,uint,16,8) [] = { 0x333, 0x3333, 0x3333, 0x3333,
-					 0x333, 0x3333, 0x3333, 0x3333 };
 VECT_VAR_DECL(expected,uint,32,4) [] = { 0xffffffff, 0xffffffff,
 					 0xffffffff, 0x0 };
-VECT_VAR_DECL(expected,uint,64,2) [] = { 0x3333333333333333,
-					 0x3333333333333333 };
-VECT_VAR_DECL(expected,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0x33333333, 0x33333333,
-					   0x33333333, 0x33333333 };
 
 VECT_VAR_DECL(expected2,uint,32,2) [] = { 0xffffffff, 0xffffffff };
 VECT_VAR_DECL(expected2,uint,32,4) [] = { 0xffffffff, 0xffffffff,
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vcagt.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vcagt.c
@@ -4,47 +4,9 @@
 #include "cmp_fp_op.inc"
 
 /* Expected results.  */
-VECT_VAR_DECL(expected,int,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-				       0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,int,16,4) [] = { 0x333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,int,32,2) [] = { 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,int,64,1) [] = { 0x3333333333333333 };
-VECT_VAR_DECL(expected,uint,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,uint,16,4) [] = { 0x333, 0x3333, 0x3333, 0x3333 };
 VECT_VAR_DECL(expected,uint,32,2) [] = { 0x0, 0x0 };
-VECT_VAR_DECL(expected,uint,64,1) [] = { 0x3333333333333333 };
-VECT_VAR_DECL(expected,poly,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,int,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,int,16,8) [] = { 0x333, 0x3333, 0x3333, 0x3333,
-					0x333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,int,32,4) [] = { 0xffffffff, 0xffffffff, 0x0, 0x0 };
-VECT_VAR_DECL(expected,int,64,2) [] = { 0x3333333333333333,
-					0x3333333333333333 };
-VECT_VAR_DECL(expected,uint,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,uint,16,8) [] = { 0x333, 0x3333, 0x3333, 0x3333,
-					 0x333, 0x3333, 0x3333, 0x3333 };
 VECT_VAR_DECL(expected,uint,32,4) [] = { 0xffffffff, 0xffffffff,
 					 0x0, 0x0 };
-VECT_VAR_DECL(expected,uint,64,2) [] = { 0x3333333333333333,
-					 0x3333333333333333 };
-VECT_VAR_DECL(expected,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0x33333333, 0x33333333,
-					   0x33333333, 0x33333333 };
 
 VECT_VAR_DECL(expected2,uint,32,2) [] = { 0xffffffff, 0xffffffff };
 VECT_VAR_DECL(expected2,uint,32,4) [] = { 0xffffffff, 0xffffffff,
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vcale.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vcale.c
@@ -4,46 +4,8 @@
 #include "cmp_fp_op.inc"
 
 /* Expected results.  */
-VECT_VAR_DECL(expected,int,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-				       0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,int,16,4) [] = { 0x333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,int,32,2) [] = { 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,int,64,1) [] = { 0x3333333333333333 };
-VECT_VAR_DECL(expected,uint,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,uint,16,4) [] = { 0x333, 0x3333, 0x3333, 0x3333 };
 VECT_VAR_DECL(expected,uint,32,2) [] = { 0xffffffff, 0xffffffff };
-VECT_VAR_DECL(expected,uint,64,1) [] = { 0x3333333333333333 };
-VECT_VAR_DECL(expected,poly,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,int,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,int,16,8) [] = { 0x333, 0x3333, 0x3333, 0x3333,
-					0x333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,int,32,4) [] = { 0xffffffff, 0xffffffff, 0x0, 0x0 };
-VECT_VAR_DECL(expected,int,64,2) [] = { 0x3333333333333333,
-					0x3333333333333333 };
-VECT_VAR_DECL(expected,uint,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,uint,16,8) [] = { 0x333, 0x3333, 0x3333, 0x3333,
-					 0x333, 0x3333, 0x3333, 0x3333 };
 VECT_VAR_DECL(expected,uint,32,4) [] = { 0x0, 0x0, 0xffffffff, 0xffffffff };
-VECT_VAR_DECL(expected,uint,64,2) [] = { 0x3333333333333333,
-					 0x3333333333333333 };
-VECT_VAR_DECL(expected,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0x33333333, 0x33333333,
-					   0x33333333, 0x33333333 };
 
 VECT_VAR_DECL(expected2,uint,32,2) [] = { 0x0, 0x0 };
 VECT_VAR_DECL(expected2,uint,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vcalt.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vcalt.c
@@ -4,46 +4,8 @@
 #include "cmp_fp_op.inc"
 
 /* Expected results.  */
-VECT_VAR_DECL(expected,int,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-				       0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,int,16,4) [] = { 0x333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,int,32,2) [] = { 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,int,64,1) [] = { 0x3333333333333333 };
-VECT_VAR_DECL(expected,uint,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,uint,16,4) [] = { 0x333, 0x3333, 0x3333, 0x3333 };
 VECT_VAR_DECL(expected,uint,32,2) [] = { 0x0, 0xffffffff };
-VECT_VAR_DECL(expected,uint,64,1) [] = { 0x3333333333333333 };
-VECT_VAR_DECL(expected,poly,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,int,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,int,16,8) [] = { 0x333, 0x3333, 0x3333, 0x3333,
-					0x333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,int,32,4) [] = { 0xffffffff, 0xffffffff, 0x0, 0x0 };
-VECT_VAR_DECL(expected,int,64,2) [] = { 0x3333333333333333,
-					0x3333333333333333 };
-VECT_VAR_DECL(expected,uint,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,uint,16,8) [] = { 0x333, 0x3333, 0x3333, 0x3333,
-					 0x333, 0x3333, 0x3333, 0x3333 };
 VECT_VAR_DECL(expected,uint,32,4) [] = { 0x0, 0x0, 0x0, 0xffffffff };
-VECT_VAR_DECL(expected,uint,64,2) [] = { 0x3333333333333333,
-					 0x3333333333333333 };
-VECT_VAR_DECL(expected,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0x33333333, 0x33333333,
-					   0x33333333, 0x33333333 };
 
 VECT_VAR_DECL(expected2,uint,32,2) [] = { 0x0, 0x0 };
 VECT_VAR_DECL(expected2,uint,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vceq.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vceq.c
@@ -8,29 +8,9 @@ void exec_vceq_p8(void);
 #include "cmp_op.inc"
 
 /* Expected results.  */
-VECT_VAR_DECL(expected,int,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-				       0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,int,16,4) [] = { 0x333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,int,32,2) [] = { 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,int,64,1) [] = { 0x3333333333333333 };
 VECT_VAR_DECL(expected,uint,8,8) [] = { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0x0 };
 VECT_VAR_DECL(expected,uint,16,4) [] = { 0x0, 0x0, 0xffff, 0x0 };
 VECT_VAR_DECL(expected,uint,32,2) [] = { 0xffffffff, 0x0 };
-VECT_VAR_DECL(expected,uint,64,1) [] = { 0x3333333333333333 };
-VECT_VAR_DECL(expected,poly,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,int,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,int,16,8) [] = { 0x333, 0x3333, 0x3333, 0x3333,
-					0x333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,int,32,4) [] = { 0x33333333, 0x33333333,
-					0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,int,64,2) [] = { 0x3333333333333333,
-					0x3333333333333333 };
 VECT_VAR_DECL(expected,uint,8,16) [] = { 0x0, 0x0, 0x0, 0x0,
 					 0x0, 0x0, 0x0, 0x0,
 					 0x0, 0x0, 0x0, 0x0,
@@ -38,16 +18,6 @@ VECT_VAR_DECL(expected,uint,8,16) [] = { 0x0, 0x0, 0x0, 0x0,
 VECT_VAR_DECL(expected,uint,16,8) [] = { 0x0, 0x0, 0x0, 0x0,
 					 0x0, 0x0, 0xffff, 0x0 };
 VECT_VAR_DECL(expected,uint,32,4) [] = { 0x0, 0x0, 0xffffffff, 0x0 };
-VECT_VAR_DECL(expected,uint,64,2) [] = { 0x3333333333333333,
-					 0x3333333333333333 };
-VECT_VAR_DECL(expected,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0x33333333, 0x33333333,
-					   0x33333333, 0x33333333 };
 
 VECT_VAR_DECL(expected_uint,uint,8,8) [] = { 0x0, 0x0, 0x0, 0xff,
 					     0x0, 0x0, 0x0, 0x0 };
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vcge.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vcge.c
@@ -4,29 +4,9 @@
 #include "cmp_op.inc"
 
 /* Expected results.  */
-VECT_VAR_DECL(expected,int,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-				       0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,int,16,4) [] = { 0x333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,int,32,2) [] = { 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,int,64,1) [] = { 0x3333333333333333 };
 VECT_VAR_DECL(expected,uint,8,8) [] = { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff };
 VECT_VAR_DECL(expected,uint,16,4) [] = { 0x0, 0x0, 0xffff, 0xffff };
 VECT_VAR_DECL(expected,uint,32,2) [] = { 0xffffffff, 0xffffffff };
-VECT_VAR_DECL(expected,uint,64,1) [] = { 0x3333333333333333 };
-VECT_VAR_DECL(expected,poly,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,int,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,int,16,8) [] = { 0x333, 0x3333, 0x3333, 0x3333,
-					0x333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,int,32,4) [] = { 0x33333333, 0x33333333,
-					0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,int,64,2) [] = { 0x3333333333333333,
-					0x3333333333333333 };
 VECT_VAR_DECL(expected,uint,8,16) [] = { 0x0, 0x0, 0x0, 0x0,
 					 0x0, 0x0, 0x0, 0x0,
 					 0x0, 0x0, 0x0, 0x0,
@@ -34,16 +14,6 @@ VECT_VAR_DECL(expected,uint,8,16) [] = { 0x0, 0x0, 0x0, 0x0,
 VECT_VAR_DECL(expected,uint,16,8) [] = { 0x0, 0x0, 0x0, 0x0,
 					 0x0, 0x0, 0xffff, 0xffff };
 VECT_VAR_DECL(expected,uint,32,4) [] = { 0x0, 0x0, 0xffffffff, 0xffffffff };
-VECT_VAR_DECL(expected,uint,64,2) [] = { 0x3333333333333333,
-					 0x3333333333333333 };
-VECT_VAR_DECL(expected,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0x33333333, 0x33333333,
-					   0x33333333, 0x33333333 };
 
 VECT_VAR_DECL(expected_uint,uint,8,8) [] = { 0x0, 0x0, 0x0, 0xff,
 					     0xff, 0xff, 0xff, 0xff };
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vcgt.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vcgt.c
@@ -4,29 +4,9 @@
 #include "cmp_op.inc"
 
 /* Expected results.  */
-VECT_VAR_DECL(expected,int,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-				       0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,int,16,4) [] = { 0x333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,int,32,2) [] = { 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,int,64,1) [] = { 0x3333333333333333 };
 VECT_VAR_DECL(expected,uint,8,8) [] = { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff };
 VECT_VAR_DECL(expected,uint,16,4) [] = { 0x0, 0x0, 0x0, 0xffff };
 VECT_VAR_DECL(expected,uint,32,2) [] = { 0x0, 0xffffffff };
-VECT_VAR_DECL(expected,uint,64,1) [] = { 0x3333333333333333 };
-VECT_VAR_DECL(expected,poly,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,int,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,int,16,8) [] = { 0x333, 0x3333, 0x3333, 0x3333,
-					0x333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,int,32,4) [] = { 0x33333333, 0x33333333,
-					0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,int,64,2) [] = { 0x3333333333333333,
-					0x3333333333333333 };
 VECT_VAR_DECL(expected,uint,8,16) [] = { 0x0, 0x0, 0x0, 0x0,
 					 0x0, 0x0, 0x0, 0x0,
 					 0x0, 0x0, 0x0, 0x0,
@@ -34,16 +14,6 @@ VECT_VAR_DECL(expected,uint,8,16) [] = { 0x0, 0x0, 0x0, 0x0,
 VECT_VAR_DECL(expected,uint,16,8) [] = { 0x0, 0x0, 0x0, 0x0,
 					 0x0, 0x0, 0x0, 0xffff };
 VECT_VAR_DECL(expected,uint,32,4) [] = { 0x0, 0x0, 0x0, 0xffffffff };
-VECT_VAR_DECL(expected,uint,64,2) [] = { 0x3333333333333333,
-					 0x3333333333333333 };
-VECT_VAR_DECL(expected,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0x33333333, 0x33333333,
-					   0x33333333, 0x33333333 };
 
 VECT_VAR_DECL(expected_uint,uint,8,8) [] = { 0x0, 0x0, 0x0, 0x0,
 					     0xff, 0xff, 0xff, 0xff };
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vcle.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vcle.c
@@ -4,30 +4,10 @@
 #include "cmp_op.inc"
 
 /* Expected results.  */
-VECT_VAR_DECL(expected,int,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-				       0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,int,16,4) [] = { 0x333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,int,32,2) [] = { 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,int,64,1) [] = { 0x3333333333333333 };
 VECT_VAR_DECL(expected,uint,8,8) [] = { 0xff, 0xff, 0xff, 0xff,
 					0xff, 0xff, 0xff, 0x0 };
 VECT_VAR_DECL(expected,uint,16,4) [] = { 0xffff, 0xffff, 0xffff, 0x0 };
 VECT_VAR_DECL(expected,uint,32,2) [] = { 0xffffffff, 0x0 };
-VECT_VAR_DECL(expected,uint,64,1) [] = { 0x3333333333333333 };
-VECT_VAR_DECL(expected,poly,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,int,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,int,16,8) [] = { 0x333, 0x3333, 0x3333, 0x3333,
-					0x333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,int,32,4) [] = { 0x33333333, 0x33333333,
-					0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,int,64,2) [] = { 0x3333333333333333,
-					0x3333333333333333 };
 VECT_VAR_DECL(expected,uint,8,16) [] = { 0xff, 0xff, 0xff, 0xff,
 					 0xff, 0xff, 0xff, 0xff,
 					 0xff, 0xff, 0xff, 0xff,
@@ -36,16 +16,6 @@ VECT_VAR_DECL(expected,uint,16,8) [] = { 0xffff, 0xffff, 0xffff, 0xffff,
 					 0xffff, 0xffff, 0xffff, 0x0 };
 VECT_VAR_DECL(expected,uint,32,4) [] = { 0xffffffff, 0xffffffff,
 					 0xffffffff, 0x0 };
-VECT_VAR_DECL(expected,uint,64,2) [] = { 0x3333333333333333,
-					 0x3333333333333333 };
-VECT_VAR_DECL(expected,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0x33333333, 0x33333333,
-					   0x33333333, 0x33333333 };
 
 VECT_VAR_DECL(expected_uint,uint,8,8) [] = { 0xff, 0xff, 0xff, 0xff,
 					     0x0, 0x0, 0x0, 0x0 };
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vcls.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vcls.c
@@ -6,16 +6,6 @@
 VECT_VAR_DECL(expected,int,8,8) [] = { 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6 };
 VECT_VAR_DECL(expected,int,16,4) [] = { 0x2, 0x2, 0x2, 0x2 };
 VECT_VAR_DECL(expected,int,32,2) [] = { 0x19, 0x19 };
-VECT_VAR_DECL(expected,int,64,1) [] = { 0x3333333333333333 };
-VECT_VAR_DECL(expected,uint,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,uint,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,uint,32,2) [] = { 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,uint,64,1) [] = { 0x3333333333333333 };
-VECT_VAR_DECL(expected,poly,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0x33333333, 0x33333333 };
 VECT_VAR_DECL(expected,int,8,16) [] = { 0x7, 0x7, 0x7, 0x7,
 					0x7, 0x7, 0x7, 0x7,
 					0x7, 0x7, 0x7, 0x7,
@@ -23,45 +13,12 @@ VECT_VAR_DECL(expected,int,8,16) [] = { 0x7, 0x7, 0x7, 0x7,
 VECT_VAR_DECL(expected,int,16,8) [] = { 0x2, 0x2, 0x2, 0x2,
 					0x2, 0x2, 0x2, 0x2 };
 VECT_VAR_DECL(expected,int,32,4) [] = { 0x14, 0x14, 0x14, 0x14 };
-VECT_VAR_DECL(expected,int,64,2) [] = { 0x3333333333333333,
-					0x3333333333333333 };
-VECT_VAR_DECL(expected,uint,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,uint,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,uint,32,4) [] = { 0x33333333, 0x33333333,
-					 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,uint,64,2) [] = { 0x3333333333333333,
-					 0x3333333333333333 };
-VECT_VAR_DECL(expected,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0x33333333, 0x33333333,
-					   0x33333333, 0x33333333 };
 
 /* Expected results with negative input.  */
 VECT_VAR_DECL(expected_with_negative,int,8,8) [] = { 0x7, 0x7, 0x7, 0x7,
 						     0x7, 0x7, 0x7, 0x7 };
 VECT_VAR_DECL(expected_with_negative,int,16,4) [] = { 0x1, 0x1, 0x1, 0x1 };
 VECT_VAR_DECL(expected_with_negative,int,32,2) [] = { 0x1, 0x1 };
-VECT_VAR_DECL(expected_with_negative,int,64,1) [] = { 0x3333333333333333 };
-VECT_VAR_DECL(expected_with_negative,uint,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-						      0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected_with_negative,uint,16,4) [] = { 0x3333, 0x3333,
-						       0x3333, 0x3333 };
-VECT_VAR_DECL(expected_with_negative,uint,32,2) [] = { 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected_with_negative,uint,64,1) [] = { 0x3333333333333333 };
-VECT_VAR_DECL(expected_with_negative,poly,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-						      0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected_with_negative,poly,16,4) [] = { 0x3333, 0x3333,
-						       0x3333, 0x3333 };
-VECT_VAR_DECL(expected_with_negative,hfloat,32,2) [] = { 0x33333333,
-							 0x33333333 };
 VECT_VAR_DECL(expected_with_negative,int,8,16) [] = { 0x0, 0x0, 0x0, 0x0,
 						      0x0, 0x0, 0x0, 0x0,
 						      0x0, 0x0, 0x0, 0x0,
@@ -69,32 +26,6 @@ VECT_VAR_DECL(expected_with_negative,int,8,16) [] = { 0x0, 0x0, 0x0, 0x0,
 VECT_VAR_DECL(expected_with_negative,int,16,8) [] = { 0x2, 0x2, 0x2, 0x2,
 						      0x2, 0x2, 0x2, 0x2 };
 VECT_VAR_DECL(expected_with_negative,int,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
-VECT_VAR_DECL(expected_with_negative,int,64,2) [] = { 0x3333333333333333,
-						      0x3333333333333333 };
-VECT_VAR_DECL(expected_with_negative,uint,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-						       0x33, 0x33, 0x33, 0x33,
-						       0x33, 0x33, 0x33, 0x33,
-						       0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected_with_negative,uint,16,8) [] = { 0x3333, 0x3333,
-						       0x3333, 0x3333,
-						       0x3333, 0x3333,
-						       0x3333, 0x3333 };
-VECT_VAR_DECL(expected_with_negative,uint,32,4) [] = { 0x33333333, 0x33333333,
-						       0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected_with_negative,uint,64,2) [] = { 0x3333333333333333,
-						       0x3333333333333333 };
-VECT_VAR_DECL(expected_with_negative,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-						       0x33, 0x33, 0x33, 0x33,
-						       0x33, 0x33, 0x33, 0x33,
-						       0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected_with_negative,poly,16,8) [] = { 0x3333, 0x3333,
-						       0x3333, 0x3333,
-						       0x3333, 0x3333,
-						       0x3333, 0x3333 };
-VECT_VAR_DECL(expected_with_negative,hfloat,32,4) [] = { 0x33333333,
-							 0x33333333,
-							 0x33333333,
-							 0x33333333 };
 
 #define INSN_NAME vcls
 #define TEST_MSG "VCLS/VCLSQ"
@@ -146,7 +77,13 @@ FNNAME (INSN_NAME)
   TEST_UNARY_OP(INSN_NAME, q, int, s, 16, 8);
   TEST_UNARY_OP(INSN_NAME, q, int, s, 32, 4);
 
-  CHECK_RESULTS (TEST_MSG, " (positive input)");
+#define MSG_POSITIVE " (positive input)"
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected, MSG_POSITIVE);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected, MSG_POSITIVE);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected, MSG_POSITIVE);
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected, MSG_POSITIVE);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected, MSG_POSITIVE);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected, MSG_POSITIVE);
 
   /* Fill input vector with arbitrary values (negative).  */
   VDUP(vector, , int, s, 8, 8, 0xFF);
@@ -164,7 +101,13 @@ FNNAME (INSN_NAME)
   TEST_UNARY_OP(INSN_NAME, q, int, s, 16, 8);
   TEST_UNARY_OP(INSN_NAME, q, int, s, 32, 4);
 
-  CHECK_RESULTS_NAMED (TEST_MSG, expected_with_negative, " (negative input)");
+#define MSG_NEGATIVE " (negative input)"
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_with_negative, MSG_NEGATIVE);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_with_negative, MSG_NEGATIVE);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_with_negative, MSG_NEGATIVE);
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected_with_negative, MSG_NEGATIVE);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_with_negative, MSG_NEGATIVE);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_with_negative, MSG_NEGATIVE);
 }
 
 int main (void)
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vclt.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vclt.c
@@ -4,30 +4,10 @@
 #include "cmp_op.inc"
 
 /* Expected results.  */
-VECT_VAR_DECL(expected,int,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-				       0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,int,16,4) [] = { 0x333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,int,32,2) [] = { 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,int,64,1) [] = { 0x3333333333333333 };
 VECT_VAR_DECL(expected,uint,8,8) [] = { 0xff, 0xff, 0xff, 0xff,
 					0xff, 0xff, 0x0, 0x0 };
 VECT_VAR_DECL(expected,uint,16,4) [] = { 0xffff, 0xffff, 0x0, 0x0 };
 VECT_VAR_DECL(expected,uint,32,2) [] = { 0x0, 0x0 };
-VECT_VAR_DECL(expected,uint,64,1) [] = { 0x3333333333333333 };
-VECT_VAR_DECL(expected,poly,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,int,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,int,16,8) [] = { 0x333, 0x3333, 0x3333, 0x3333,
-					0x333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,int,32,4) [] = { 0x33333333, 0x33333333,
-					0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,int,64,2) [] = { 0x3333333333333333,
-					0x3333333333333333 };
 VECT_VAR_DECL(expected,uint,8,16) [] = { 0xff, 0xff, 0xff, 0xff,
 					 0xff, 0xff, 0xff, 0xff,
 					 0xff, 0xff, 0xff, 0xff,
@@ -35,16 +15,6 @@ VECT_VAR_DECL(expected,uint,8,16) [] = { 0xff, 0xff, 0xff, 0xff,
 VECT_VAR_DECL(expected,uint,16,8) [] = { 0xffff, 0xffff, 0xffff, 0xffff,
 					 0xffff, 0xffff, 0x0, 0x0 };
 VECT_VAR_DECL(expected,uint,32,4) [] = { 0xffffffff, 0xffffffff, 0x0, 0x0 };
-VECT_VAR_DECL(expected,uint,64,2) [] = { 0x3333333333333333,
-					 0x3333333333333333 };
-VECT_VAR_DECL(expected,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0x33333333, 0x33333333,
-					   0x33333333, 0x33333333 };
 
 VECT_VAR_DECL(expected_uint,uint,8,8) [] = { 0xff, 0xff, 0xff, 0x0,
 					     0x0, 0x0, 0x0, 0x0 };
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vclz.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vclz.c
@@ -6,36 +6,18 @@
 VECT_VAR_DECL(expected,int,8,8) [] = { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 };
 VECT_VAR_DECL(expected,int,16,4) [] = { 0x3, 0x3, 0x3, 0x3 };
 VECT_VAR_DECL(expected,int,32,2) [] = { 0x11, 0x11 };
-VECT_VAR_DECL(expected,int,64,1) [] = { 0x3333333333333333 };
 VECT_VAR_DECL(expected,uint,8,8) [] = { 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2 };
 VECT_VAR_DECL(expected,uint,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
 VECT_VAR_DECL(expected,uint,32,2) [] = { 0x5, 0x5 };
-VECT_VAR_DECL(expected,uint,64,1) [] = { 0x3333333333333333 };
-VECT_VAR_DECL(expected,poly,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0x33333333, 0x33333333 };
 VECT_VAR_DECL(expected,int,8,16) [] = { 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
 					0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2 };
 VECT_VAR_DECL(expected,int,16,8) [] = { 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3 };
 VECT_VAR_DECL(expected,int,32,4) [] = { 0x3, 0x3, 0x3, 0x3 };
-VECT_VAR_DECL(expected,int,64,2) [] = { 0x3333333333333333,
-					0x3333333333333333 };
 VECT_VAR_DECL(expected,uint,8,16) [] = { 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3,
 					 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3 };
 VECT_VAR_DECL(expected,uint,16,8) [] = { 0xd, 0xd, 0xd, 0xd,
 					 0xd, 0xd, 0xd, 0xd };
 VECT_VAR_DECL(expected,uint,32,4) [] = { 0x1f, 0x1f, 0x1f, 0x1f };
-VECT_VAR_DECL(expected,uint,64,2) [] = { 0x3333333333333333,
-					 0x3333333333333333 };
-VECT_VAR_DECL(expected,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0x33333333, 0x33333333,
-					   0x33333333, 0x33333333 };
 
 
 /* Expected results with input=0.  */
@@ -43,16 +25,10 @@ VECT_VAR_DECL(expected_with_0,int,8,8) [] = { 0x8, 0x8, 0x8, 0x8,
 					      0x8, 0x8, 0x8, 0x8 };
 VECT_VAR_DECL(expected_with_0,int,16,4) [] = { 0x10, 0x10, 0x10, 0x10 };
 VECT_VAR_DECL(expected_with_0,int,32,2) [] = { 0x20, 0x20 };
-VECT_VAR_DECL(expected_with_0,int,64,1) [] = { 0x3333333333333333 };
 VECT_VAR_DECL(expected_with_0,uint,8,8) [] = { 0x8, 0x8, 0x8, 0x8,
 					       0x8, 0x8, 0x8, 0x8 };
 VECT_VAR_DECL(expected_with_0,uint,16,4) [] = { 0x10, 0x10, 0x10, 0x10 };
 VECT_VAR_DECL(expected_with_0,uint,32,2) [] = { 0x20, 0x20 };
-VECT_VAR_DECL(expected_with_0,uint,64,1) [] = { 0x3333333333333333 };
-VECT_VAR_DECL(expected_with_0,poly,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-					       0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected_with_0,poly,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected_with_0,hfloat,32,2) [] = { 0x33333333, 0x33333333 };
 VECT_VAR_DECL(expected_with_0,int,8,16) [] = { 0x8, 0x8, 0x8, 0x8,
 					       0x8, 0x8, 0x8, 0x8,
 					       0x8, 0x8, 0x8, 0x8,
@@ -60,8 +36,6 @@ VECT_VAR_DECL(expected_with_0,int,8,16) [] = { 0x8, 0x8, 0x8, 0x8,
 VECT_VAR_DECL(expected_with_0,int,16,8) [] = { 0x10, 0x10, 0x10, 0x10,
 					       0x10, 0x10, 0x10, 0x10 };
 VECT_VAR_DECL(expected_with_0,int,32,4) [] = { 0x20, 0x20, 0x20, 0x20 };
-VECT_VAR_DECL(expected_with_0,int,64,2) [] = { 0x3333333333333333,
-					       0x3333333333333333 };
 VECT_VAR_DECL(expected_with_0,uint,8,16) [] = { 0x8, 0x8, 0x8, 0x8,
 						0x8, 0x8, 0x8, 0x8,
 						0x8, 0x8, 0x8, 0x8,
@@ -69,16 +43,6 @@ VECT_VAR_DECL(expected_with_0,uint,8,16) [] = { 0x8, 0x8, 0x8, 0x8,
 VECT_VAR_DECL(expected_with_0,uint,16,8) [] = { 0x10, 0x10, 0x10, 0x10,
 						0x10, 0x10, 0x10, 0x10 };
 VECT_VAR_DECL(expected_with_0,uint,32,4) [] = { 0x20, 0x20, 0x20, 0x20 };
-VECT_VAR_DECL(expected_with_0,uint,64,2) [] = { 0x3333333333333333,
-						0x3333333333333333 };
-VECT_VAR_DECL(expected_with_0,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected_with_0,poly,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-						0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected_with_0,hfloat,32,4) [] = { 0x33333333, 0x33333333,
-						  0x33333333, 0x33333333 };
 
 #define INSN_NAME vclz
 #define TEST_MSG "VCLZ/VCLZQ"
@@ -154,7 +118,18 @@ FNNAME (INSN_NAME)
   TEST_UNARY_OP(INSN_NAME, q, uint, u, 16, 8);
   TEST_UNARY_OP(INSN_NAME, q, uint, u, 32, 4);
 
-  CHECK_RESULTS (TEST_MSG, "");
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected, "");
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected, "");
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected, "");
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected, "");
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected, "");
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected, "");
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected, "");
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected, "");
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected, "");
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected, "");
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected, "");
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected, "");
 
   /* Test with zero as input.  */
   VDUP(vector, , int, s, 8, 8, 0);
@@ -184,7 +159,19 @@ FNNAME (INSN_NAME)
   TEST_UNARY_OP(INSN_NAME, q, uint, u, 16, 8);
   TEST_UNARY_OP(INSN_NAME, q, uint, u, 32, 4);
 
-  CHECK_RESULTS_NAMED (TEST_MSG, expected_with_0, " (input=0)");
+#define MSG_ZERO " (input=0)"
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_with_0, MSG_ZERO);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_with_0, MSG_ZERO);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_with_0, MSG_ZERO);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_with_0, MSG_ZERO);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_with_0, MSG_ZERO);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_with_0, MSG_ZERO);
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected_with_0, MSG_ZERO);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_with_0, MSG_ZERO);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_with_0, MSG_ZERO);
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected_with_0, MSG_ZERO);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_with_0, MSG_ZERO);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_with_0, MSG_ZERO);
 }
 
 int main (void)
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vcnt.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vcnt.c
@@ -4,37 +4,14 @@
 
 /* Expected results.  */
 VECT_VAR_DECL(expected,int,8,8) [] = { 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8 };
-VECT_VAR_DECL(expected,int,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,int,32,2) [] = { 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,int,64,1) [] = { 0x3333333333333333 };
 VECT_VAR_DECL(expected,uint,8,8) [] = { 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4 };
-VECT_VAR_DECL(expected,uint,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,uint,32,2) [] = { 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,uint,64,1) [] = { 0x3333333333333333 };
 VECT_VAR_DECL(expected,poly,8,8) [] = { 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4 };
-VECT_VAR_DECL(expected,poly,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0x33333333, 0x33333333 };
 VECT_VAR_DECL(expected,int,8,16) [] = { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 					0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 };
-VECT_VAR_DECL(expected,int,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,int,32,4) [] = { 0x33333333, 0x33333333,
-					0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,int,64,2) [] = { 0x3333333333333333, 0x3333333333333333 };
 VECT_VAR_DECL(expected,uint,8,16) [] = { 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
 					 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6 };
-VECT_VAR_DECL(expected,uint,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,uint,32,4) [] = { 0x33333333, 0x33333333,
-					 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,uint,64,2) [] = { 0x3333333333333333,
-					 0x3333333333333333 };
 VECT_VAR_DECL(expected,poly,8,16) [] = { 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
 					 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6 };
-VECT_VAR_DECL(expected,poly,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0x33333333, 0x33333333,
-					   0x33333333, 0x33333333 };
 
 #define INSN_NAME vcnt
 #define TEST_MSG "VCNT/VCNTQ"
@@ -86,7 +63,12 @@ FNNAME (INSN_NAME)
   TEST_UNARY_OP(INSN_NAME, q, uint, u, 8, 16);
   TEST_UNARY_OP(INSN_NAME, q, poly, p, 8, 16);
 
-  CHECK_RESULTS (TEST_MSG, "");
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected, "");
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected, "");
+  CHECK(TEST_MSG, poly, 8, 8, PRIx8, expected, "");
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected, "");
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected, "");
+  CHECK(TEST_MSG, poly, 8, 16, PRIx8, expected, "");
 }
 
 int main (void)
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vcombine.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vcombine.c
@@ -3,20 +3,6 @@
 #include "compute-ref-data.h"
 
 /* Expected results.  */
-VECT_VAR_DECL(expected,int,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-				       0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,int,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,int,32,2) [] = { 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,int,64,1) [] = { 0x3333333333333333 };
-VECT_VAR_DECL(expected,uint,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,uint,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,uint,32,2) [] = { 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,uint,64,1) [] = { 0x3333333333333333 };
-VECT_VAR_DECL(expected,poly,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0x33333333, 0x33333333 };
 VECT_VAR_DECL(expected,int,8,16) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
 					0xf4, 0xf5, 0xf6, 0xf7,
 					0x11, 0x11, 0x11, 0x11,
@@ -41,6 +27,8 @@ VECT_VAR_DECL(expected,poly,16,8) [] = { 0xfff0, 0xfff1, 0xfff2, 0xfff3,
 					 0x66, 0x66, 0x66, 0x66 };
 VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0xc1800000, 0xc1700000,
 					   0x40533333, 0x40533333 };
+VECT_VAR_DECL(expected,hfloat,16,8) [] = { 0xcc00, 0xcb80, 0xcb00, 0xca80,
+					   0x4080, 0x4080, 0x4080, 0x4080 };
 
 #define TEST_MSG "VCOMBINE"
 void exec_vcombine (void)
@@ -58,6 +46,9 @@ void exec_vcombine (void)
 
   /* Initialize input "vector64_a" from "buffer".  */
   TEST_MACRO_64BITS_VARIANTS_2_5(VLOAD, vector64_a, buffer);
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+  VLOAD(vector64_a, buffer, , float, f, 16, 4);
+#endif
   VLOAD(vector64_a, buffer, , float, f, 32, 2);
 
   /* Choose init value arbitrarily.  */
@@ -71,6 +62,9 @@ void exec_vcombine (void)
   VDUP(vector64_b, , uint, u, 64, 1, 0x88);
   VDUP(vector64_b, , poly, p, 8, 8, 0x55);
   VDUP(vector64_b, , poly, p, 16, 4, 0x66);
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+  VDUP(vector64_b, , float, f, 16, 4, 2.25);
+#endif
   VDUP(vector64_b, , float, f, 32, 2, 3.3f);
 
   clean_results ();
@@ -86,9 +80,25 @@ void exec_vcombine (void)
   TEST_VCOMBINE(uint, u, 64, 1, 2);
   TEST_VCOMBINE(poly, p, 8, 8, 16);
   TEST_VCOMBINE(poly, p, 16, 4, 8);
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+  TEST_VCOMBINE(float, f, 16, 4, 8);
+#endif
   TEST_VCOMBINE(float, f, 32, 2, 4);
 
-  CHECK_RESULTS (TEST_MSG, "");
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected, "");
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected, "");
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected, "");
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected, "");
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected, "");
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected, "");
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected, "");
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected, "");
+  CHECK(TEST_MSG, poly, 8, 16, PRIx8, expected, "");
+  CHECK(TEST_MSG, poly, 16, 8, PRIx16, expected, "");
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+  CHECK_FP(TEST_MSG, float, 16, 8, PRIx16, expected, "");
+#endif
+  CHECK_FP(TEST_MSG, float, 32, 4, PRIx32, expected, "");
 }
 
 int main (void)
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vcreate.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vcreate.c
@@ -16,35 +16,8 @@ VECT_VAR_DECL(expected,uint,64,1) [] = { 0x123456789abcdef0 };
 VECT_VAR_DECL(expected,poly,8,8) [] = { 0xf0, 0xde, 0xbc, 0x9a,
 					0x78, 0x56, 0x34, 0x12 };
 VECT_VAR_DECL(expected,poly,16,4) [] = { 0xdef0, 0x9abc, 0x5678, 0x1234 };
+VECT_VAR_DECL(expected,hfloat,16,4) [] = { 0xdef0, 0x9abc, 0x5678, 0x1234 };
 VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0x9abcdef0, 0x12345678 };
-VECT_VAR_DECL(expected,int,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,int,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,int,32,4) [] = { 0x33333333, 0x33333333,
-					0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,int,64,2) [] = { 0x3333333333333333,
-					0x3333333333333333 };
-VECT_VAR_DECL(expected,uint,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,uint,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,uint,32,4) [] = { 0x33333333, 0x33333333,
-					 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,uint,64,2) [] = { 0x3333333333333333,
-					 0x3333333333333333 };
-VECT_VAR_DECL(expected,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0x33333333, 0x33333333,
-					   0x33333333, 0x33333333 };
 
 #define INSN_NAME vcreate
 #define TEST_MSG "VCREATE"
@@ -66,6 +39,9 @@ FNNAME (INSN_NAME)
   DECL_VAL(val, int, 16, 4);
   DECL_VAL(val, int, 32, 2);
   DECL_VAL(val, int, 64, 1);
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+  DECL_VAL(val, float, 16, 4);
+#endif
   DECL_VAL(val, float, 32, 2);
   DECL_VAL(val, uint, 8, 8);
   DECL_VAL(val, uint, 16, 4);
@@ -78,6 +54,9 @@ FNNAME (INSN_NAME)
   DECL_VARIABLE(vector_res, int, 16, 4);
   DECL_VARIABLE(vector_res, int, 32, 2);
   DECL_VARIABLE(vector_res, int, 64, 1);
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+  DECL_VARIABLE(vector_res, float, 16, 4);
+#endif
   DECL_VARIABLE(vector_res, float, 32, 2);
   DECL_VARIABLE(vector_res, uint, 8, 8);
   DECL_VARIABLE(vector_res, uint, 16, 4);
@@ -93,6 +72,9 @@ FNNAME (INSN_NAME)
   VECT_VAR(val, int, 16, 4) = 0x123456789abcdef0LL;
   VECT_VAR(val, int, 32, 2) = 0x123456789abcdef0LL;
   VECT_VAR(val, int, 64, 1) = 0x123456789abcdef0LL;
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+  VECT_VAR(val, float, 16, 4) = 0x123456789abcdef0LL;
+#endif
   VECT_VAR(val, float, 32, 2) = 0x123456789abcdef0LL;
   VECT_VAR(val, uint, 8, 8) = 0x123456789abcdef0ULL;
   VECT_VAR(val, uint, 16, 4) = 0x123456789abcdef0ULL;
@@ -104,6 +86,9 @@ FNNAME (INSN_NAME)
   TEST_VCREATE(int, s, 8, 8);
   TEST_VCREATE(int, s, 16, 4);
   TEST_VCREATE(int, s, 32, 2);
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+  TEST_VCREATE(float, f, 16, 4);
+#endif
   TEST_VCREATE(float, f, 32, 2);
   TEST_VCREATE(int, s, 64, 1);
   TEST_VCREATE(uint, u, 8, 8);
@@ -113,7 +98,20 @@ FNNAME (INSN_NAME)
   TEST_VCREATE(poly, p, 8, 8);
   TEST_VCREATE(poly, p, 16, 4);
 
-  CHECK_RESULTS (TEST_MSG, "");
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected, "");
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected, "");
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected, "");
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected, "");
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected, "");
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected, "");
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected, "");
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected, "");
+  CHECK(TEST_MSG, poly, 8, 8, PRIx8, expected, "");
+  CHECK(TEST_MSG, poly, 16, 4, PRIx16, expected, "");
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+  CHECK_FP(TEST_MSG, float, 16, 4, PRIx16, expected, "");
+#endif
+  CHECK_FP(TEST_MSG, float, 32, 2, PRIx32, expected, "");
 }
 
 int main (void)
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vcvt_f16.c
@@ -0,0 +1,100 @@
+/* { dg-require-effective-target arm_neon_fp16_hw { target { arm*-*-* } } } */
+#include <arm_neon.h>
+#include "arm-neon-ref.h"
+#include "compute-ref-data.h"
+#include <math.h>
+
+/* Expected results for vcvt.  */
+VECT_VAR_DECL (expected,hfloat,32,4) [] = { 0x41800000, 0x41700000,
+					    0x41600000, 0x41500000 };
+VECT_VAR_DECL (expected,hfloat,16,4) [] = { 0x3e00, 0x4100, 0x4300, 0x4480 };
+
+/* Expected results for vcvt_high_f32_f16.  */
+VECT_VAR_DECL (expected_high,hfloat,32,4) [] = { 0xc1400000, 0xc1300000,
+						 0xc1200000, 0xc1100000 };
+/* Expected results for vcvt_high_f16_f32.  */
+VECT_VAR_DECL (expected_high,hfloat,16,8) [] = { 0x4000, 0x4000, 0x4000, 0x4000,
+						 0xcc00, 0xcb80, 0xcb00, 0xca80 };
+
+void
+exec_vcvt (void)
+{
+  clean_results ();
+
+#define TEST_MSG "vcvt_f32_f16"
+  {
+    VECT_VAR_DECL (buffer_src, float, 16, 4) [] = { 16.0, 15.0, 14.0, 13.0 };
+
+    DECL_VARIABLE (vector_src, float, 16, 4);
+
+    VLOAD (vector_src, buffer_src, , float, f, 16, 4);
+    DECL_VARIABLE (vector_res, float, 32, 4) =
+	vcvt_f32_f16 (VECT_VAR (vector_src, float, 16, 4));
+    vst1q_f32 (VECT_VAR (result, float, 32, 4),
+	       VECT_VAR (vector_res, float, 32, 4));
+
+    CHECK_FP (TEST_MSG, float, 32, 4, PRIx32, expected, "");
+  }
+#undef TEST_MSG
+
+  clean_results ();
+
+#define TEST_MSG "vcvt_f16_f32"
+  {
+    VECT_VAR_DECL (buffer_src, float, 32, 4) [] = { 1.5, 2.5, 3.5, 4.5 };
+    DECL_VARIABLE (vector_src, float, 32, 4);
+
+    VLOAD (vector_src, buffer_src, q, float, f, 32, 4);
+    DECL_VARIABLE (vector_res, float, 16, 4) =
+      vcvt_f16_f32 (VECT_VAR (vector_src, float, 32, 4));
+    vst1_f16 (VECT_VAR (result, float, 16, 4),
+	      VECT_VAR (vector_res, float, 16 ,4));
+
+    CHECK_FP (TEST_MSG, float, 16, 4, PRIx16, expected, "");
+  }
+#undef TEST_MSG
+
+  /* We run more tests for AArch64 as the relevant intrinsics
+     do not exist on AArch32.  */
+#if defined (__aarch64__)
+  clean_results ();
+
+#define TEST_MSG "vcvt_high_f32_f16"
+  {
+    DECL_VARIABLE (vector_src, float, 16, 8);
+    VLOAD (vector_src, buffer, q, float, f, 16, 8);
+    DECL_VARIABLE (vector_res, float, 32, 4);
+    VECT_VAR (vector_res, float, 32, 4) =
+      vcvt_high_f32_f16 (VECT_VAR (vector_src, float, 16, 8));
+    vst1q_f32 (VECT_VAR (result, float, 32, 4),
+	       VECT_VAR (vector_res, float, 32, 4));
+    CHECK_FP (TEST_MSG, float, 32, 4, PRIx32, expected_high, "");
+  }
+#undef TEST_MSG
+  clean_results ();
+
+#define TEST_MSG "vcvt_high_f16_f32"
+  {
+    DECL_VARIABLE (vector_low, float, 16, 4);
+    VDUP (vector_low, , float, f, 16, 4, 2.0);
+
+    DECL_VARIABLE (vector_src, float, 32, 4);
+    VLOAD (vector_src, buffer, q, float, f, 32, 4);
+
+    DECL_VARIABLE (vector_res, float, 16, 8) =
+      vcvt_high_f16_f32 (VECT_VAR (vector_low, float, 16, 4),
+			 VECT_VAR (vector_src, float, 32, 4));
+    vst1q_f16 (VECT_VAR (result, float, 16, 8),
+	       VECT_VAR (vector_res, float, 16, 8));
+
+    CHECK_FP (TEST_MSG, float, 16, 8, PRIx16, expected_high, "");
+  }
+#endif
+}
+
+int
+main (void)
+{
+  exec_vcvt ();
+  return 0;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vcvt_high_1.c
@@ -0,0 +1,98 @@
+/* { dg-skip-if "" { arm*-*-* } } */
+
+#include "arm_neon.h"
+
+void abort (void);
+
+void
+foo (void)
+{
+  /* Test vcvt_high_f32_f64.  */
+  float32x2_t arg1;
+  float64x2_t arg2;
+  float32x4_t result;
+  arg1 = vcreate_f32 (UINT64_C (0x3f0db5793f6e1892));
+  arg2 = vcombine_f64 (vcreate_f64 (UINT64_C (0x3fe8e49d23fb575d)),
+		       vcreate_f64 (UINT64_C (0x3fd921291b3df73e)));
+  //  Expect: "result" = 3ec909483f4724e93f0db5793f6e1892
+  result = vcvt_high_f32_f64 (arg1, arg2);
+  float32_t got;
+  float32_t exp;
+
+  /* Lane 0.  */
+  got = vgetq_lane_f32 (result, 0);
+  exp = ((float32_t) 0.9300624132156372);
+  if (((((exp / got) < ((float32_t) 0.999))
+	 || ((exp / got) > ((float32_t) 1.001)))
+     && (((exp - got) < ((float32_t) -1.0e-4))
+	 || ((exp - got) > ((float32_t) 1.0e-4)))))
+    abort ();
+
+  /* Lane 1.  */
+  got = vgetq_lane_f32 (result, 1);
+  exp = ((float32_t) 0.5535503029823303);
+  if (((((exp / got) < ((float32_t) 0.999))
+	  || ((exp / got) > ((float32_t) 1.001)))
+     && (((exp - got) < ((float32_t) -1.0e-4))
+	   || ((exp - got) > ((float32_t) 1.0e-4)))))
+    abort ();
+
+  /* Lane 2.  */
+  got = vgetq_lane_f32 (result, 2);
+  exp = ((float32_t) 0.7779069617051665);
+  if (((((exp / got) < ((float32_t) 0.999))
+	  || ((exp / got) > ((float32_t) 1.001)))
+      && (((exp - got) < ((float32_t) -1.0e-4))
+	  || ((exp - got) > ((float32_t) 1.0e-4)))))
+    abort ();
+
+  /* Lane 3.  */
+  got = vgetq_lane_f32 (result, 3);
+  exp = ((float32_t) 0.3926489606891329);
+  if (((((exp / got) < ((float32_t) 0.999))
+	  || ((exp / got) > ((float32_t) 1.001)))
+      && (((exp - got) < ((float32_t) -1.0e-4))
+	  || ((exp - got) > ((float32_t) 1.0e-4)))))
+    abort ();
+}
+
+void
+bar (void)
+{
+  /* Test vcvt_high_f64_f32.  */
+  float32x4_t arg1;
+  float64x2_t result;
+  arg1 = vcombine_f32 (vcreate_f32 (UINT64_C (0x3f7c5cf13f261f74)),
+		       vcreate_f32 (UINT64_C (0x3e3a7bc03f6ccc1d)));
+  //  Expect: "result" = 3fc74f78000000003fed9983a0000000
+  result = vcvt_high_f64_f32 (arg1);
+
+  float64_t got;
+  float64_t exp;
+
+  /* Lane 0.  */
+  got = vgetq_lane_f64 (result, 0);
+  exp = 0.9249895215034485;
+  if (((((exp / got) < 0.999)
+	 || ((exp / got) > 1.001))
+     && (((exp - got) < -1.0e-4)
+	 || ((exp - got) > 1.0e-4))))
+    abort ();
+
+  /* Lane 1.  */
+  got = vgetq_lane_f64 (result, 1);
+  exp = 0.1821126937866211;
+  if (((((exp / got) < 0.999)
+	  || ((exp / got) > 1.001))
+      && (((exp - got) < -1.0e-4)
+	  || ((exp - got) > 1.0e-4))))
+    abort ();
+}
+
+int
+main (int argc, char **argv)
+{
+  foo ();
+  bar ();
+  return 0;
+}
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vdup-vmov.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vdup-vmov.c
@@ -187,13 +187,13 @@ void exec_vdup_vmov (void)
 
     switch (i) {
     case 0:
-      CHECK_RESULTS_NAMED (TEST_MSG, expected0, "");
+      CHECK_RESULTS_NAMED_NO_FP16 (TEST_MSG, expected0, "");
       break;
     case 1:
-      CHECK_RESULTS_NAMED (TEST_MSG, expected1, "");
+      CHECK_RESULTS_NAMED_NO_FP16 (TEST_MSG, expected1, "");
       break;
     case 2:
-      CHECK_RESULTS_NAMED (TEST_MSG, expected2, "");
+      CHECK_RESULTS_NAMED_NO_FP16 (TEST_MSG, expected2, "");
       break;
     default:
       abort();
@@ -232,13 +232,13 @@ void exec_vdup_vmov (void)
 
     switch (i) {
     case 0:
-      CHECK_RESULTS_NAMED (TEST_MSG, expected0, "");
+      CHECK_RESULTS_NAMED_NO_FP16 (TEST_MSG, expected0, "");
       break;
     case 1:
-      CHECK_RESULTS_NAMED (TEST_MSG, expected1, "");
+      CHECK_RESULTS_NAMED_NO_FP16 (TEST_MSG, expected1, "");
       break;
     case 2:
-      CHECK_RESULTS_NAMED (TEST_MSG, expected2, "");
+      CHECK_RESULTS_NAMED_NO_FP16 (TEST_MSG, expected2, "");
       break;
     default:
       abort();
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vdup_lane.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vdup_lane.c
@@ -90,7 +90,7 @@ void exec_vdup_lane (void)
   TEST_VDUP_LANE(q, poly, p, 16, 8, 4, 1);
   TEST_VDUP_LANE(q, float, f, 32, 4, 2, 1);
 
-  CHECK_RESULTS (TEST_MSG, "");
+  CHECK_RESULTS_NO_FP16 (TEST_MSG, "");
 }
 
 int main (void)
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/veor.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/veor.c
@@ -14,10 +14,6 @@ VECT_VAR_DECL(expected,uint,8,8) [] = { 0xe4, 0xe5, 0xe6, 0xe7,
 VECT_VAR_DECL(expected,uint,16,4) [] = { 0xffee, 0xffef, 0xffec, 0xffed };
 VECT_VAR_DECL(expected,uint,32,2) [] = { 0xffffffd8, 0xffffffd9 };
 VECT_VAR_DECL(expected,uint,64,1) [] = { 0xfffffffffffffff2 };
-VECT_VAR_DECL(expected,poly,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0x33333333, 0x33333333 };
 VECT_VAR_DECL(expected,int,8,16) [] = { 0x6, 0x7, 0x4, 0x5,
 					0x2, 0x3, 0x0, 0x1,
 					0xe, 0xf, 0xc, 0xd,
@@ -37,11 +33,3 @@ VECT_VAR_DECL(expected,uint,32,4) [] = { 0xffffffc7, 0xffffffc6,
 					 0xffffffc5, 0xffffffc4 };
 VECT_VAR_DECL(expected,uint,64,2) [] = { 0xfffffffffffffff3,
 					 0xfffffffffffffff2 };
-VECT_VAR_DECL(expected,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0x33333333, 0x33333333,
-					   0x33333333, 0x33333333 };
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vext.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vext.c
@@ -113,7 +113,7 @@ void exec_vext (void)
   TEST_VEXT(q, poly, p, 16, 8, 6);
   TEST_VEXT(q, float, f, 32, 4, 3);
 
-  CHECK_RESULTS (TEST_MSG, "");
+  CHECK_RESULTS_NO_FP16 (TEST_MSG, "");
 }
 
 int main (void)
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vget_high.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vget_high.c
@@ -16,35 +16,8 @@ VECT_VAR_DECL(expected,uint,64,1) [] = { 0xfffffffffffffff1 };
 VECT_VAR_DECL(expected,poly,8,8) [] = { 0xf8, 0xf9, 0xfa, 0xfb,
 					0xfc, 0xfd, 0xfe, 0xff };
 VECT_VAR_DECL(expected,poly,16,4) [] = { 0xfff4, 0xfff5, 0xfff6, 0xfff7 };
+VECT_VAR_DECL(expected,hfloat,16,4) [] = { 0xca00, 0xc980, 0xc900, 0xc880 };
 VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0xc1600000, 0xc1500000 };
-VECT_VAR_DECL(expected,int,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,int,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,int,32,4) [] = { 0x33333333, 0x33333333,
-					0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,int,64,2) [] = { 0x3333333333333333,
-					0x3333333333333333 };
-VECT_VAR_DECL(expected,uint,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,uint,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,uint,32,4) [] = { 0x33333333, 0x33333333,
-					 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,uint,64,2) [] = { 0x3333333333333333,
-					 0x3333333333333333 };
-VECT_VAR_DECL(expected,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0x33333333, 0x33333333,
-					   0x33333333, 0x33333333 };
 
 #define TEST_MSG "VGET_HIGH"
 void exec_vget_high (void)
@@ -59,6 +32,9 @@ void exec_vget_high (void)
   DECL_VARIABLE_128BITS_VARIANTS(vector128);
 
   TEST_MACRO_128BITS_VARIANTS_2_5(VLOAD, vector128, buffer);
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+  VLOAD(vector128, buffer, q, float, f, 16, 8);
+#endif
   VLOAD(vector128, buffer, q, float, f, 32, 4);
 
   clean_results ();
@@ -74,9 +50,22 @@ void exec_vget_high (void)
   TEST_VGET_HIGH(uint, u, 64, 1, 2);
   TEST_VGET_HIGH(poly, p, 8, 8, 16);
   TEST_VGET_HIGH(poly, p, 16, 4, 8);
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+  TEST_VGET_HIGH(float, f, 16, 4, 8);
+#endif
   TEST_VGET_HIGH(float, f, 32, 2, 4);
 
-  CHECK_RESULTS (TEST_MSG, "");
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected, "");
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected, "");
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected, "");
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected, "");
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected, "");
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected, "");
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected, "");
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected, "");
+  CHECK(TEST_MSG, poly, 8, 8, PRIx8, expected, "");
+  CHECK(TEST_MSG, poly, 16, 4, PRIx16, expected, "");
+  CHECK_FP(TEST_MSG, float, 32, 2, PRIx32, expected, "");
 }
 
 int main (void)
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vget_lane.c
@@ -0,0 +1,125 @@
+#include <arm_neon.h>
+#include "arm-neon-ref.h"
+#include "compute-ref-data.h"
+
+/* Expected results.  */
+int8_t     expected_s8   = 0xf7;
+int16_t    expected_s16  = 0xfff3;
+int32_t    expected_s32  = 0xfffffff1;
+int64_t    expected_s64  = 0xfffffffffffffff0;
+uint8_t    expected_u8   = 0xf6;
+uint16_t   expected_u16  = 0xfff2;
+uint32_t   expected_u32  = 0xfffffff1;
+uint64_t   expected_u64  = 0xfffffffffffffff0;
+poly8_t    expected_p8   = 0xf6;
+poly16_t   expected_p16  = 0xfff2;
+hfloat32_t expected_f32  = 0xc1700000;
+
+int8_t     expectedq_s8  = 0xff;
+int16_t    expectedq_s16 = 0xfff5;
+int32_t    expectedq_s32 = 0xfffffff3;
+int64_t    expectedq_s64 = 0xfffffffffffffff1;
+uint8_t    expectedq_u8  = 0xfe;
+uint16_t   expectedq_u16 = 0xfff6;
+uint32_t   expectedq_u32 = 0xfffffff2;
+uint64_t   expectedq_u64 = 0xfffffffffffffff1;
+poly8_t    expectedq_p8  = 0xfe;
+poly16_t   expectedq_p16 = 0xfff6;
+hfloat32_t expectedq_f32 = 0xc1500000;
+
+int error_found = 0;
+
+#define TEST_MSG "VGET_LANE"
+void exec_vget_lane (void)
+{
+  /* vec=vget_lane(vec, lane), then store the result.  */
+#define TEST_VGET_LANE(Q, T1, T2, W, N, L)				   \
+  VAR(var, T1, W) = vget##Q##_lane_##T2##W(VECT_VAR(vector, T1, W, N), L); \
+  if (VAR(var, T1, W) != expected##Q##_##T2##W) {			   \
+    fprintf(stderr,							   \
+	    "ERROR in %s (%s line %d in result '%s') at type %s "	   \
+	    "got 0x%" PRIx##W " != 0x%" PRIx##W "\n",			   \
+	    TEST_MSG, __FILE__, __LINE__,				   \
+	    STR(expected##Q##_##T2##W),					   \
+	    STR(VECT_NAME(T1, W, N)),					   \
+	    VAR(var, T1, W),						   \
+	    expected##Q##_##T2##W);					   \
+    error_found = 1;							   \
+  }
+
+  /* Special variant for floating-point.  */
+  union {
+    uint32_t var_int32;
+    float32_t var_float32;
+  } var_int32_float32;
+
+#define TEST_VGET_LANE_FP(Q, T1, T2, W, N, L)				   \
+  VAR(var, T1, W) = vget##Q##_lane_##T2##W(VECT_VAR(vector, T1, W, N), L); \
+  var_int##W##_float##W.var_float##W = VAR(var, T1, W);			   \
+  if (var_int##W##_float##W.var_int##W != expected##Q##_##T2##W) {	   \
+    fprintf(stderr,							   \
+	    "ERROR in %s (%s line %d in result '%s') at type %s "	   \
+	    "got 0x%" PRIx##W " != 0x%" PRIx##W "\n",			   \
+	    TEST_MSG, __FILE__, __LINE__,				   \
+	    STR(expected##Q##_##T2##W),					   \
+	    STR(VECT_NAME(T1, W, N)),					   \
+	    var_int##W##_float##W.var_int##W,				   \
+	    expected##Q##_##T2##W);					   \
+    error_found = 1;							   \
+  }
+
+  DECL_VARIABLE_ALL_VARIANTS(vector);
+
+  /* Scalar variables.  */
+  VAR_DECL(var, int, 8);
+  VAR_DECL(var, int, 16);
+  VAR_DECL(var, int, 32);
+  VAR_DECL(var, int, 64);
+  VAR_DECL(var, uint, 8);
+  VAR_DECL(var, uint, 16);
+  VAR_DECL(var, uint, 32);
+  VAR_DECL(var, uint, 64);
+  VAR_DECL(var, poly, 8);
+  VAR_DECL(var, poly, 16);
+  VAR_DECL(var, float, 32);
+
+  /* Initialize input values.  */
+  TEST_MACRO_ALL_VARIANTS_2_5(VLOAD, vector, buffer);
+  VLOAD(vector, buffer, , float, f, 32, 2);
+  VLOAD(vector, buffer, q, float, f, 32, 4);
+
+  /* Choose lane arbitrarily.  */
+  TEST_VGET_LANE(, int, s, 8, 8, 7);
+  TEST_VGET_LANE(, int, s, 16, 4, 3);
+  TEST_VGET_LANE(, int, s, 32, 2, 1);
+  TEST_VGET_LANE(, int, s, 64, 1, 0);
+  TEST_VGET_LANE(, uint, u, 8, 8, 6);
+  TEST_VGET_LANE(, uint, u, 16, 4, 2);
+  TEST_VGET_LANE(, uint, u, 32, 2, 1);
+  TEST_VGET_LANE(, uint, u, 64, 1, 0);
+  TEST_VGET_LANE(, poly, p, 8, 8, 6);
+  TEST_VGET_LANE(, poly, p, 16, 4, 2);
+  TEST_VGET_LANE_FP(, float, f, 32, 2, 1);
+
+  TEST_VGET_LANE(q, int, s, 8, 16, 15);
+  TEST_VGET_LANE(q, int, s, 16, 8, 5);
+  TEST_VGET_LANE(q, int, s, 32, 4, 3);
+  TEST_VGET_LANE(q, int, s, 64, 2, 1);
+  TEST_VGET_LANE(q, uint, u, 8, 16, 14);
+  TEST_VGET_LANE(q, uint, u, 16, 8, 6);
+  TEST_VGET_LANE(q, uint, u, 32, 4, 2);
+  TEST_VGET_LANE(q, uint, u, 64, 2, 1);
+  TEST_VGET_LANE(q, poly, p, 8, 16, 14);
+  TEST_VGET_LANE(q, poly, p, 16, 8, 6);
+  TEST_VGET_LANE_FP(q, float, f, 32, 4, 3);
+}
+
+int main (void)
+{
+  exec_vget_lane ();
+
+  if (error_found)
+    abort();
+
+  return 0;
+}
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vget_low.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vget_low.c
@@ -16,35 +16,8 @@ VECT_VAR_DECL(expected,uint,64,1) [] = { 0xfffffffffffffff0 };
 VECT_VAR_DECL(expected,poly,8,8) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
 					0xf4, 0xf5, 0xf6, 0xf7 };
 VECT_VAR_DECL(expected,poly,16,4) [] = { 0xfff0, 0xfff1, 0xfff2, 0xfff3 };
+VECT_VAR_DECL(expected,hfloat,16,4) [] = { 0xcc00, 0xcb80, 0xcb00, 0xca80 };
 VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0xc1800000, 0xc1700000 };
-VECT_VAR_DECL(expected,int,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,int,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,int,32,4) [] = { 0x33333333, 0x33333333,
-					0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,int,64,2) [] = { 0x3333333333333333,
-					0x3333333333333333 };
-VECT_VAR_DECL(expected,uint,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,uint,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,uint,32,4) [] = { 0x33333333, 0x33333333,
-					 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,uint,64,2) [] = { 0x3333333333333333,
-					 0x3333333333333333 };
-VECT_VAR_DECL(expected,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0x33333333, 0x33333333,
-					   0x33333333, 0x33333333 };
 
 #define TEST_MSG "VGET_LOW"
 void exec_vget_low (void)
@@ -59,6 +32,9 @@ void exec_vget_low (void)
   DECL_VARIABLE_128BITS_VARIANTS(vector128);
 
   TEST_MACRO_128BITS_VARIANTS_2_5(VLOAD, vector128, buffer);
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+  VLOAD(vector128, buffer, q, float, f, 16, 8);
+#endif
   VLOAD(vector128, buffer, q, float, f, 32, 4);
 
   clean_results ();
@@ -74,9 +50,25 @@ void exec_vget_low (void)
   TEST_VGET_LOW(uint, u, 64, 1, 2);
   TEST_VGET_LOW(poly, p, 8, 8, 16);
   TEST_VGET_LOW(poly, p, 16, 4, 8);
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+  TEST_VGET_LOW(float, f, 16, 4, 8);
+#endif
   TEST_VGET_LOW(float, f, 32, 2, 4);
 
-  CHECK_RESULTS (TEST_MSG, "");
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected, "");
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected, "");
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected, "");
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected, "");
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected, "");
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected, "");
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected, "");
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected, "");
+  CHECK(TEST_MSG, poly, 8, 8, PRIx8, expected, "");
+  CHECK(TEST_MSG, poly, 16, 4, PRIx16, expected, "");
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+  CHECK_FP(TEST_MSG, float, 16, 4, PRIx16, expected, "");
+#endif
+  CHECK_FP(TEST_MSG, float, 32, 2, PRIx32, expected, "");
 }
 
 int main (void)
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld1.c
@@ -16,6 +16,7 @@ VECT_VAR_DECL(expected,uint,64,1) [] = { 0xfffffffffffffff0 };
 VECT_VAR_DECL(expected,poly,8,8) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
 					0xf4, 0xf5, 0xf6, 0xf7 };
 VECT_VAR_DECL(expected,poly,16,4) [] = { 0xfff0, 0xfff1, 0xfff2, 0xfff3 };
+VECT_VAR_DECL(expected,hfloat,16,4) [] = { 0xcc00, 0xcb80, 0xcb00, 0xca80 };
 VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0xc1800000, 0xc1700000 };
 VECT_VAR_DECL(expected,int,8,16) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
 					0xf4, 0xf5, 0xf6, 0xf7,
@@ -44,6 +45,8 @@ VECT_VAR_DECL(expected,poly,8,16) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
 					 0xfc, 0xfd, 0xfe, 0xff };
 VECT_VAR_DECL(expected,poly,16,8) [] = { 0xfff0, 0xfff1, 0xfff2, 0xfff3,
 					 0xfff4, 0xfff5, 0xfff6, 0xfff7 };
+VECT_VAR_DECL(expected,hfloat,16,8) [] = { 0xcc00, 0xcb80, 0xcb00, 0xca80,
+					   0xca00, 0xc980, 0xc900, 0xc880 };
 VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0xc1800000, 0xc1700000,
 					   0xc1600000, 0xc1500000 };
 
@@ -62,6 +65,10 @@ void exec_vld1 (void)
 
   TEST_MACRO_ALL_VARIANTS_2_5(TEST_VLD1, vector, buffer);
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+  TEST_VLD1(vector, buffer, , float, f, 16, 4);
+  TEST_VLD1(vector, buffer, q, float, f, 16, 8);
+#endif
   TEST_VLD1(vector, buffer, , float, f, 32, 2);
   TEST_VLD1(vector, buffer, q, float, f, 32, 4);
 
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld1_dup.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld1_dup.c
@@ -17,6 +17,7 @@ VECT_VAR_DECL(expected0,uint,64,1) [] = { 0xfffffffffffffff0 };
 VECT_VAR_DECL(expected0,poly,8,8) [] = { 0xf0, 0xf0, 0xf0, 0xf0,
 					 0xf0, 0xf0, 0xf0, 0xf0 };
 VECT_VAR_DECL(expected0,poly,16,4) [] = { 0xfff0, 0xfff0, 0xfff0, 0xfff0 };
+VECT_VAR_DECL(expected0,hfloat,16,4) [] = { 0xcc00, 0xcc00, 0xcc00, 0xcc00 };
 VECT_VAR_DECL(expected0,hfloat,32,2) [] = { 0xc1800000, 0xc1800000 };
 VECT_VAR_DECL(expected0,int,8,16) [] = { 0xf0, 0xf0, 0xf0, 0xf0,
 					 0xf0, 0xf0, 0xf0, 0xf0,
@@ -44,6 +45,8 @@ VECT_VAR_DECL(expected0,poly,8,16) [] = { 0xf0, 0xf0, 0xf0, 0xf0,
 					  0xf0, 0xf0, 0xf0, 0xf0 };
 VECT_VAR_DECL(expected0,poly,16,8) [] = { 0xfff0, 0xfff0, 0xfff0, 0xfff0,
 					  0xfff0, 0xfff0, 0xfff0, 0xfff0 };
+VECT_VAR_DECL(expected0,hfloat,16,8) [] = { 0xcc00, 0xcc00, 0xcc00, 0xcc00,
+					    0xcc00, 0xcc00, 0xcc00, 0xcc00 };
 VECT_VAR_DECL(expected0,hfloat,32,4) [] = { 0xc1800000, 0xc1800000,
 					    0xc1800000, 0xc1800000 };
 
@@ -61,6 +64,7 @@ VECT_VAR_DECL(expected1,uint,64,1) [] = { 0xfffffffffffffff1 };
 VECT_VAR_DECL(expected1,poly,8,8) [] = { 0xf1, 0xf1, 0xf1, 0xf1,
 					 0xf1, 0xf1, 0xf1, 0xf1 };
 VECT_VAR_DECL(expected1,poly,16,4) [] = { 0xfff1, 0xfff1, 0xfff1, 0xfff1 };
+VECT_VAR_DECL(expected1,hfloat,16,4) [] = { 0xcb80, 0xcb80, 0xcb80, 0xcb80 };
 VECT_VAR_DECL(expected1,hfloat,32,2) [] = { 0xc1700000, 0xc1700000 };
 VECT_VAR_DECL(expected1,int,8,16) [] = { 0xf1, 0xf1, 0xf1, 0xf1,
 					 0xf1, 0xf1, 0xf1, 0xf1,
@@ -88,6 +92,8 @@ VECT_VAR_DECL(expected1,poly,8,16) [] = { 0xf1, 0xf1, 0xf1, 0xf1,
 					  0xf1, 0xf1, 0xf1, 0xf1 };
 VECT_VAR_DECL(expected1,poly,16,8) [] = { 0xfff1, 0xfff1, 0xfff1, 0xfff1,
 					  0xfff1, 0xfff1, 0xfff1, 0xfff1 };
+VECT_VAR_DECL(expected1,hfloat,16,8) [] = { 0xcb80, 0xcb80, 0xcb80, 0xcb80,
+					    0xcb80, 0xcb80, 0xcb80, 0xcb80 };
 VECT_VAR_DECL(expected1,hfloat,32,4) [] = { 0xc1700000, 0xc1700000,
 					    0xc1700000, 0xc1700000 };
 
@@ -105,6 +111,7 @@ VECT_VAR_DECL(expected2,uint,64,1) [] = { 0xfffffffffffffff2 };
 VECT_VAR_DECL(expected2,poly,8,8) [] = { 0xf2, 0xf2, 0xf2, 0xf2,
 					 0xf2, 0xf2, 0xf2, 0xf2 };
 VECT_VAR_DECL(expected2,poly,16,4) [] = { 0xfff2, 0xfff2, 0xfff2, 0xfff2 };
+VECT_VAR_DECL(expected2,hfloat,16,4) [] = { 0xcb00, 0xcb00, 0xcb00, 0xcb00 };
 VECT_VAR_DECL(expected2,hfloat,32,2) [] = { 0xc1600000, 0xc1600000 };
 VECT_VAR_DECL(expected2,int,8,16) [] = { 0xf2, 0xf2, 0xf2, 0xf2,
 					 0xf2, 0xf2, 0xf2, 0xf2,
@@ -132,6 +139,8 @@ VECT_VAR_DECL(expected2,poly,8,16) [] = { 0xf2, 0xf2, 0xf2, 0xf2,
 					  0xf2, 0xf2, 0xf2, 0xf2 };
 VECT_VAR_DECL(expected2,poly,16,8) [] = { 0xfff2, 0xfff2, 0xfff2, 0xfff2,
 					  0xfff2, 0xfff2, 0xfff2, 0xfff2 };
+VECT_VAR_DECL(expected2,hfloat,16,8) [] = { 0xcb00, 0xcb00, 0xcb00, 0xcb00,
+					    0xcb00, 0xcb00, 0xcb00, 0xcb00 };
 VECT_VAR_DECL(expected2,hfloat,32,4) [] = { 0xc1600000, 0xc1600000,
 					    0xc1600000, 0xc1600000 };
 
@@ -154,6 +163,10 @@ void exec_vld1_dup (void)
 
     TEST_MACRO_ALL_VARIANTS_2_5(TEST_VLD1_DUP, vector, buffer_dup);
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+    TEST_VLD1_DUP(vector, buffer_dup, , float, f, 16, 4);
+    TEST_VLD1_DUP(vector, buffer_dup, q, float, f, 16, 8);
+#endif
     TEST_VLD1_DUP(vector, buffer_dup, , float, f, 32, 2);
     TEST_VLD1_DUP(vector, buffer_dup, q, float, f, 32, 4);
 
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld1_lane.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld1_lane.c
@@ -16,6 +16,7 @@ VECT_VAR_DECL(expected,uint,64,1) [] = { 0xfffffffffffffff0 };
 VECT_VAR_DECL(expected,poly,8,8) [] = { 0xaa, 0xaa, 0xaa, 0xaa,
 					0xaa, 0xaa, 0xaa, 0xf0 };
 VECT_VAR_DECL(expected,poly,16,4) [] = { 0xaaaa, 0xaaaa, 0xaaaa, 0xfff0 };
+VECT_VAR_DECL(expected,hfloat,16,4) [] = { 0xaaaa, 0xaaaa, 0xcc00, 0xaaaa };
 VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0xaaaaaaaa, 0xc1800000 };
 VECT_VAR_DECL(expected,int,8,16) [] = { 0xaa, 0xaa, 0xaa, 0xaa,
 					0xaa, 0xaa, 0xaa, 0xaa,
@@ -43,6 +44,8 @@ VECT_VAR_DECL(expected,poly,8,16) [] = { 0xaa, 0xaa, 0xaa, 0xaa,
 					 0xf0, 0xaa, 0xaa, 0xaa };
 VECT_VAR_DECL(expected,poly,16,8) [] = { 0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa,
 					 0xaaaa, 0xaaaa, 0xfff0, 0xaaaa };
+VECT_VAR_DECL(expected,hfloat,16,8) [] = { 0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa,
+					   0xaaaa, 0xcc00, 0xaaaa, 0xaaaa };
 VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0xaaaaaaaa, 0xaaaaaaaa,
 					   0xc1800000, 0xaaaaaaaa };
 
@@ -72,6 +75,9 @@ void exec_vld1_lane (void)
   ARRAY(buffer_src, uint, 64, 1);
   ARRAY(buffer_src, poly, 8, 8);
   ARRAY(buffer_src, poly, 16, 4);
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+  ARRAY(buffer_src, float, 16, 4);
+#endif
   ARRAY(buffer_src, float, 32, 2);
 
   ARRAY(buffer_src, int, 8, 16);
@@ -84,6 +90,9 @@ void exec_vld1_lane (void)
   ARRAY(buffer_src, uint, 64, 2);
   ARRAY(buffer_src, poly, 8, 16);
   ARRAY(buffer_src, poly, 16, 8);
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+  ARRAY(buffer_src, float, 16, 8);
+#endif
   ARRAY(buffer_src, float, 32, 4);
 
   clean_results ();
@@ -99,6 +108,9 @@ void exec_vld1_lane (void)
   TEST_VLD1_LANE(, uint, u, 64, 1, 0);
   TEST_VLD1_LANE(, poly, p, 8, 8, 7);
   TEST_VLD1_LANE(, poly, p, 16, 4, 3);
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+  TEST_VLD1_LANE(, float, f, 16, 4, 2);
+#endif
   TEST_VLD1_LANE(, float, f, 32, 2, 1);
 
   TEST_VLD1_LANE(q, int, s, 8, 16, 15);
@@ -111,6 +123,9 @@ void exec_vld1_lane (void)
   TEST_VLD1_LANE(q, uint, u, 64, 2, 0);
   TEST_VLD1_LANE(q, poly, p, 8, 16, 12);
   TEST_VLD1_LANE(q, poly, p, 16, 8, 6);
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+  TEST_VLD1_LANE(q, float, f, 16, 8, 5);
+#endif
   TEST_VLD1_LANE(q, float, f, 32, 4, 2);
 
   CHECK_RESULTS (TEST_MSG, "");
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld2_lane_f16_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+float16x4x2_t
+f_vld2_lane_f16 (float16_t * p, float16x4x2_t v)
+{
+  float16x4x2_t res;
+  /* { dg-error "lane 4 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  res = vld2_lane_f16 (p, v, 4);
+  /* { dg-error "lane -1 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  res = vld2_lane_f16 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld2_lane_f32_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+float32x2x2_t
+f_vld2_lane_f32 (float32_t * p, float32x2x2_t v)
+{
+  float32x2x2_t res;
+  /* { dg-error "lane 2 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  res = vld2_lane_f32 (p, v, 2);
+  /* { dg-error "lane -1 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  res = vld2_lane_f32 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld2_lane_f64_indices_1.c
@@ -0,0 +1,17 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+/* { dg-skip-if "" { arm*-*-* } } */
+
+float64x1x2_t
+f_vld2_lane_f64 (float64_t * p, float64x1x2_t v)
+{
+  float64x1x2_t res;
+  /* { dg-error "lane 1 out of range 0 - 0" "" { xfail arm*-*-* } 0 } */
+  res = vld2_lane_f64 (p, v, 1);
+  /* { dg-error "lane -1 out of range 0 - 0" "" { xfail arm*-*-* } 0 } */
+  res = vld2_lane_f64 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld2_lane_p8_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+poly8x8x2_t
+f_vld2_lane_p8 (poly8_t * p, poly8x8x2_t v)
+{
+  poly8x8x2_t res;
+  /* { dg-error "lane 8 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  res = vld2_lane_p8 (p, v, 8);
+  /* { dg-error "lane -1 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  res = vld2_lane_p8 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld2_lane_s16_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+int16x4x2_t
+f_vld2_lane_s16 (int16_t * p, int16x4x2_t v)
+{
+  int16x4x2_t res;
+  /* { dg-error "lane 4 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  res = vld2_lane_s16 (p, v, 4);
+  /* { dg-error "lane -1 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  res = vld2_lane_s16 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld2_lane_s32_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+int32x2x2_t
+f_vld2_lane_s32 (int32_t * p, int32x2x2_t v)
+{
+  int32x2x2_t res;
+  /* { dg-error "lane 2 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  res = vld2_lane_s32 (p, v, 2);
+  /* { dg-error "lane -1 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  res = vld2_lane_s32 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld2_lane_s64_indices_1.c
@@ -0,0 +1,17 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+/* { dg-skip-if "" { arm*-*-* } } */
+
+int64x1x2_t
+f_vld2_lane_s64 (int64_t * p, int64x1x2_t v)
+{
+  int64x1x2_t res;
+  /* { dg-error "lane 1 out of range 0 - 0" "" { xfail arm*-*-* } 0 } */
+  res = vld2_lane_s64 (p, v, 1);
+  /* { dg-error "lane -1 out of range 0 - 0" "" { xfail arm*-*-* } 0 } */
+  res = vld2_lane_s64 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld2_lane_s8_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+int8x8x2_t
+f_vld2_lane_s8 (int8_t * p, int8x8x2_t v)
+{
+  int8x8x2_t res;
+  /* { dg-error "lane 8 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  res = vld2_lane_s8 (p, v, 8);
+  /* { dg-error "lane -1 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  res = vld2_lane_s8 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld2_lane_u16_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+uint16x4x2_t
+f_vld2_lane_u16 (uint16_t * p, uint16x4x2_t v)
+{
+  uint16x4x2_t res;
+  /* { dg-error "lane 4 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  res = vld2_lane_u16 (p, v, 4);
+  /* { dg-error "lane -1 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  res = vld2_lane_u16 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld2_lane_u32_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+uint32x2x2_t
+f_vld2_lane_u32 (uint32_t * p, uint32x2x2_t v)
+{
+  uint32x2x2_t res;
+  /* { dg-error "lane 2 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  res = vld2_lane_u32 (p, v, 2);
+  /* { dg-error "lane -1 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  res = vld2_lane_u32 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld2_lane_u64_indices_1.c
@@ -0,0 +1,17 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+/* { dg-skip-if "" { arm*-*-* } } */
+
+uint64x1x2_t
+f_vld2_lane_u64 (uint64_t * p, uint64x1x2_t v)
+{
+  uint64x1x2_t res;
+  /* { dg-error "lane 1 out of range 0 - 0" "" { xfail arm*-*-* } 0 } */
+  res = vld2_lane_u64 (p, v, 1);
+  /* { dg-error "lane -1 out of range 0 - 0" "" { xfail arm*-*-* } 0 } */
+  res = vld2_lane_u64 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld2_lane_u8_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+uint8x8x2_t
+f_vld2_lane_u8 (uint8_t * p, uint8x8x2_t v)
+{
+  uint8x8x2_t res;
+  /* { dg-error "lane 8 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  res = vld2_lane_u8 (p, v, 8);
+  /* { dg-error "lane -1 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  res = vld2_lane_u8 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld2q_lane_f16_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+float16x8x2_t
+f_vld2q_lane_f16 (float16_t * p, float16x8x2_t v)
+{
+  float16x8x2_t res;
+  /* { dg-error "lane 8 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  res = vld2q_lane_f16 (p, v, 8);
+  /* { dg-error "lane -1 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  res = vld2q_lane_f16 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld2q_lane_f32_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+float32x4x2_t
+f_vld2q_lane_f32 (float32_t * p, float32x4x2_t v)
+{
+  float32x4x2_t res;
+  /* { dg-error "lane 4 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  res = vld2q_lane_f32 (p, v, 4);
+  /* { dg-error "lane -1 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  res = vld2q_lane_f32 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld2q_lane_f64_indices_1.c
@@ -0,0 +1,17 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+/* { dg-skip-if "" { arm*-*-* } } */
+
+float64x2x2_t
+f_vld2q_lane_f64 (float64_t * p, float64x2x2_t v)
+{
+  float64x2x2_t res;
+  /* { dg-error "lane 2 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  res = vld2q_lane_f64 (p, v, 2);
+  /* { dg-error "lane -1 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  res = vld2q_lane_f64 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld2q_lane_p8_indices_1.c
@@ -0,0 +1,17 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+/* { dg-skip-if "" { arm*-*-* } } */
+
+poly8x16x2_t
+f_vld2q_lane_p8 (poly8_t * p, poly8x16x2_t v)
+{
+  poly8x16x2_t res;
+  /* { dg-error "lane 16 out of range 0 - 15" "" { xfail arm*-*-* } 0 } */
+  res = vld2q_lane_p8 (p, v, 16);
+  /* { dg-error "lane -1 out of range 0 - 15" "" { xfail arm*-*-* } 0 } */
+  res = vld2q_lane_p8 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld2q_lane_s16_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+int16x8x2_t
+f_vld2q_lane_s16 (int16_t * p, int16x8x2_t v)
+{
+  int16x8x2_t res;
+  /* { dg-error "lane 8 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  res = vld2q_lane_s16 (p, v, 8);
+  /* { dg-error "lane -1 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  res = vld2q_lane_s16 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld2q_lane_s32_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+int32x4x2_t
+f_vld2q_lane_s32 (int32_t * p, int32x4x2_t v)
+{
+  int32x4x2_t res;
+  /* { dg-error "lane 4 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  res = vld2q_lane_s32 (p, v, 4);
+  /* { dg-error "lane -1 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  res = vld2q_lane_s32 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld2q_lane_s64_indices_1.c
@@ -0,0 +1,17 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+/* { dg-skip-if "" { arm*-*-* } } */
+
+int64x2x2_t
+f_vld2q_lane_s64 (int64_t * p, int64x2x2_t v)
+{
+  int64x2x2_t res;
+  /* { dg-error "lane 2 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  res = vld2q_lane_s64 (p, v, 2);
+  /* { dg-error "lane -1 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  res = vld2q_lane_s64 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld2q_lane_s8_indices_1.c
@@ -0,0 +1,17 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+/* { dg-skip-if "" { arm*-*-* } } */
+
+int8x16x2_t
+f_vld2q_lane_s8 (int8_t * p, int8x16x2_t v)
+{
+  int8x16x2_t res;
+  /* { dg-error "lane 16 out of range 0 - 15" "" { xfail arm*-*-* } 0 } */
+  res = vld2q_lane_s8 (p, v, 16);
+  /* { dg-error "lane -1 out of range 0 - 15" "" { xfail arm*-*-* } 0 } */
+  res = vld2q_lane_s8 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld2q_lane_u16_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+uint16x8x2_t
+f_vld2q_lane_u16 (uint16_t * p, uint16x8x2_t v)
+{
+  uint16x8x2_t res;
+  /* { dg-error "lane 8 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  res = vld2q_lane_u16 (p, v, 8);
+  /* { dg-error "lane -1 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  res = vld2q_lane_u16 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld2q_lane_u32_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+uint32x4x2_t
+f_vld2q_lane_u32 (uint32_t * p, uint32x4x2_t v)
+{
+  uint32x4x2_t res;
+  /* { dg-error "lane 4 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  res = vld2q_lane_u32 (p, v, 4);
+  /* { dg-error "lane -1 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  res = vld2q_lane_u32 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld2q_lane_u64_indices_1.c
@@ -0,0 +1,17 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+/* { dg-skip-if "" { arm*-*-* } } */
+
+uint64x2x2_t
+f_vld2q_lane_u64 (uint64_t * p, uint64x2x2_t v)
+{
+  uint64x2x2_t res;
+  /* { dg-error "lane 2 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  res = vld2q_lane_u64 (p, v, 2);
+  /* { dg-error "lane -1 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  res = vld2q_lane_u64 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld2q_lane_u8_indices_1.c
@@ -0,0 +1,17 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+/* { dg-skip-if "" { arm*-*-* } } */
+
+uint8x16x2_t
+f_vld2q_lane_u8 (uint8_t * p, uint8x16x2_t v)
+{
+  uint8x16x2_t res;
+  /* { dg-error "lane 16 out of range 0 - 15" "" { xfail arm*-*-* } 0 } */
+  res = vld2q_lane_u8 (p, v, 16);
+  /* { dg-error "lane -1 out of range 0 - 15" "" { xfail arm*-*-* } 0 } */
+  res = vld2q_lane_u8 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld3_lane_f16_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+float16x4x3_t
+f_vld3_lane_f16 (float16_t * p, float16x4x3_t v)
+{
+  float16x4x3_t res;
+  /* { dg-error "lane 4 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  res = vld3_lane_f16 (p, v, 4);
+  /* { dg-error "lane -1 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  res = vld3_lane_f16 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld3_lane_f32_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+float32x2x3_t
+f_vld3_lane_f32 (float32_t * p, float32x2x3_t v)
+{
+  float32x2x3_t res;
+  /* { dg-error "lane 2 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  res = vld3_lane_f32 (p, v, 2);
+  /* { dg-error "lane -1 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  res = vld3_lane_f32 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld3_lane_f64_indices_1.c
@@ -0,0 +1,17 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+/* { dg-skip-if "" { arm*-*-* } } */
+
+float64x1x3_t
+f_vld3_lane_f64 (float64_t * p, float64x1x3_t v)
+{
+  float64x1x3_t res;
+  /* { dg-error "lane 1 out of range 0 - 0" "" { xfail arm*-*-* } 0 } */
+  res = vld3_lane_f64 (p, v, 1);
+  /* { dg-error "lane -1 out of range 0 - 0" "" { xfail arm*-*-* } 0 } */
+  res = vld3_lane_f64 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld3_lane_p8_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+poly8x8x3_t
+f_vld3_lane_p8 (poly8_t * p, poly8x8x3_t v)
+{
+  poly8x8x3_t res;
+  /* { dg-error "lane 8 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  res = vld3_lane_p8 (p, v, 8);
+  /* { dg-error "lane -1 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  res = vld3_lane_p8 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld3_lane_s16_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+int16x4x3_t
+f_vld3_lane_s16 (int16_t * p, int16x4x3_t v)
+{
+  int16x4x3_t res;
+  /* { dg-error "lane 4 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  res = vld3_lane_s16 (p, v, 4);
+  /* { dg-error "lane -1 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  res = vld3_lane_s16 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld3_lane_s32_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+int32x2x3_t
+f_vld3_lane_s32 (int32_t * p, int32x2x3_t v)
+{
+  int32x2x3_t res;
+  /* { dg-error "lane 2 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  res = vld3_lane_s32 (p, v, 2);
+  /* { dg-error "lane -1 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  res = vld3_lane_s32 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld3_lane_s64_indices_1.c
@@ -0,0 +1,17 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+/* { dg-skip-if "" { arm*-*-* } } */
+
+int64x1x3_t
+f_vld3_lane_s64 (int64_t * p, int64x1x3_t v)
+{
+  int64x1x3_t res;
+  /* { dg-error "lane 1 out of range 0 - 0" "" { xfail arm*-*-* } 0 } */
+  res = vld3_lane_s64 (p, v, 1);
+  /* { dg-error "lane -1 out of range 0 - 0" "" { xfail arm*-*-* } 0 } */
+  res = vld3_lane_s64 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld3_lane_s8_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+int8x8x3_t
+f_vld3_lane_s8 (int8_t * p, int8x8x3_t v)
+{
+  int8x8x3_t res;
+  /* { dg-error "lane 8 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  res = vld3_lane_s8 (p, v, 8);
+  /* { dg-error "lane -1 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  res = vld3_lane_s8 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld3_lane_u16_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+uint16x4x3_t
+f_vld3_lane_u16 (uint16_t * p, uint16x4x3_t v)
+{
+  uint16x4x3_t res;
+  /* { dg-error "lane 4 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  res = vld3_lane_u16 (p, v, 4);
+  /* { dg-error "lane -1 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  res = vld3_lane_u16 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld3_lane_u32_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+uint32x2x3_t
+f_vld3_lane_u32 (uint32_t * p, uint32x2x3_t v)
+{
+  uint32x2x3_t res;
+  /* { dg-error "lane 2 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  res = vld3_lane_u32 (p, v, 2);
+  /* { dg-error "lane -1 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  res = vld3_lane_u32 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld3_lane_u64_indices_1.c
@@ -0,0 +1,17 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+/* { dg-skip-if "" { arm*-*-* } } */
+
+uint64x1x3_t
+f_vld3_lane_u64 (uint64_t * p, uint64x1x3_t v)
+{
+  uint64x1x3_t res;
+  /* { dg-error "lane 1 out of range 0 - 0" "" { xfail arm*-*-* } 0 } */
+  res = vld3_lane_u64 (p, v, 1);
+  /* { dg-error "lane -1 out of range 0 - 0" "" { xfail arm*-*-* } 0 } */
+  res = vld3_lane_u64 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld3_lane_u8_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+uint8x8x3_t
+f_vld3_lane_u8 (uint8_t * p, uint8x8x3_t v)
+{
+  uint8x8x3_t res;
+  /* { dg-error "lane 8 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  res = vld3_lane_u8 (p, v, 8);
+  /* { dg-error "lane -1 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  res = vld3_lane_u8 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld3q_lane_f16_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+float16x8x3_t
+f_vld3q_lane_f16 (float16_t * p, float16x8x3_t v)
+{
+  float16x8x3_t res;
+  /* { dg-error "lane 8 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  res = vld3q_lane_f16 (p, v, 8);
+  /* { dg-error "lane -1 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  res = vld3q_lane_f16 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld3q_lane_f32_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+float32x4x3_t
+f_vld3q_lane_f32 (float32_t * p, float32x4x3_t v)
+{
+  float32x4x3_t res;
+  /* { dg-error "lane 4 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  res = vld3q_lane_f32 (p, v, 4);
+  /* { dg-error "lane -1 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  res = vld3q_lane_f32 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld3q_lane_f64_indices_1.c
@@ -0,0 +1,17 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+/* { dg-skip-if "" { arm*-*-* } } */
+
+float64x2x3_t
+f_vld3q_lane_f64 (float64_t * p, float64x2x3_t v)
+{
+  float64x2x3_t res;
+  /* { dg-error "lane 2 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  res = vld3q_lane_f64 (p, v, 2);
+  /* { dg-error "lane -1 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  res = vld3q_lane_f64 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld3q_lane_p8_indices_1.c
@@ -0,0 +1,17 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+/* { dg-skip-if "" { arm*-*-* } } */
+
+poly8x16x3_t
+f_vld3q_lane_p8 (poly8_t * p, poly8x16x3_t v)
+{
+  poly8x16x3_t res;
+  /* { dg-error "lane 16 out of range 0 - 15" "" { xfail arm*-*-* } 0 } */
+  res = vld3q_lane_p8 (p, v, 16);
+  /* { dg-error "lane -1 out of range 0 - 15" "" { xfail arm*-*-* } 0 } */
+  res = vld3q_lane_p8 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld3q_lane_s16_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+int16x8x3_t
+f_vld3q_lane_s16 (int16_t * p, int16x8x3_t v)
+{
+  int16x8x3_t res;
+  /* { dg-error "lane 8 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  res = vld3q_lane_s16 (p, v, 8);
+  /* { dg-error "lane -1 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  res = vld3q_lane_s16 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld3q_lane_s32_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+int32x4x3_t
+f_vld3q_lane_s32 (int32_t * p, int32x4x3_t v)
+{
+  int32x4x3_t res;
+  /* { dg-error "lane 4 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  res = vld3q_lane_s32 (p, v, 4);
+  /* { dg-error "lane -1 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  res = vld3q_lane_s32 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld3q_lane_s64_indices_1.c
@@ -0,0 +1,17 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+/* { dg-skip-if "" { arm*-*-* } } */
+
+int64x2x3_t
+f_vld3q_lane_s64 (int64_t * p, int64x2x3_t v)
+{
+  int64x2x3_t res;
+  /* { dg-error "lane 2 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  res = vld3q_lane_s64 (p, v, 2);
+  /* { dg-error "lane -1 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  res = vld3q_lane_s64 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld3q_lane_s8_indices_1.c
@@ -0,0 +1,17 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+/* { dg-skip-if "" { arm*-*-* } } */
+
+int8x16x3_t
+f_vld3q_lane_s8 (int8_t * p, int8x16x3_t v)
+{
+  int8x16x3_t res;
+  /* { dg-error "lane 16 out of range 0 - 15" "" { xfail arm*-*-* } 0 } */
+  res = vld3q_lane_s8 (p, v, 16);
+  /* { dg-error "lane -1 out of range 0 - 15" "" { xfail arm*-*-* } 0 } */
+  res = vld3q_lane_s8 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld3q_lane_u16_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+uint16x8x3_t
+f_vld3q_lane_u16 (uint16_t * p, uint16x8x3_t v)
+{
+  uint16x8x3_t res;
+  /* { dg-error "lane 8 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  res = vld3q_lane_u16 (p, v, 8);
+  /* { dg-error "lane -1 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  res = vld3q_lane_u16 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld3q_lane_u32_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+uint32x4x3_t
+f_vld3q_lane_u32 (uint32_t * p, uint32x4x3_t v)
+{
+  uint32x4x3_t res;
+  /* { dg-error "lane 4 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  res = vld3q_lane_u32 (p, v, 4);
+  /* { dg-error "lane -1 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  res = vld3q_lane_u32 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld3q_lane_u64_indices_1.c
@@ -0,0 +1,17 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+/* { dg-skip-if "" { arm*-*-* } } */
+
+uint64x2x3_t
+f_vld3q_lane_u64 (uint64_t * p, uint64x2x3_t v)
+{
+  uint64x2x3_t res;
+  /* { dg-error "lane 2 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  res = vld3q_lane_u64 (p, v, 2);
+  /* { dg-error "lane -1 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  res = vld3q_lane_u64 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld3q_lane_u8_indices_1.c
@@ -0,0 +1,17 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+/* { dg-skip-if "" { arm*-*-* } } */
+
+uint8x16x3_t
+f_vld3q_lane_u8 (uint8_t * p, uint8x16x3_t v)
+{
+  uint8x16x3_t res;
+  /* { dg-error "lane 16 out of range 0 - 15" "" { xfail arm*-*-* } 0 } */
+  res = vld3q_lane_u8 (p, v, 16);
+  /* { dg-error "lane -1 out of range 0 - 15" "" { xfail arm*-*-* } 0 } */
+  res = vld3q_lane_u8 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld4_lane_f16_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+float16x4x4_t
+f_vld4_lane_f16 (float16_t * p, float16x4x4_t v)
+{
+  float16x4x4_t res;
+  /* { dg-error "lane 4 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  res = vld4_lane_f16 (p, v, 4);
+  /* { dg-error "lane -1 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  res = vld4_lane_f16 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld4_lane_f32_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+float32x2x4_t
+f_vld4_lane_f32 (float32_t * p, float32x2x4_t v)
+{
+  float32x2x4_t res;
+  /* { dg-error "lane 2 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  res = vld4_lane_f32 (p, v, 2);
+  /* { dg-error "lane -1 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  res = vld4_lane_f32 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld4_lane_f64_indices_1.c
@@ -0,0 +1,17 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+/* { dg-skip-if "" { arm*-*-* } } */
+
+float64x1x4_t
+f_vld4_lane_f64 (float64_t * p, float64x1x4_t v)
+{
+  float64x1x4_t res;
+  /* { dg-error "lane 1 out of range 0 - 0" "" { xfail arm*-*-* } 0 } */
+  res = vld4_lane_f64 (p, v, 1);
+  /* { dg-error "lane -1 out of range 0 - 0" "" { xfail arm*-*-* } 0 } */
+  res = vld4_lane_f64 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld4_lane_p8_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+poly8x8x4_t
+f_vld4_lane_p8 (poly8_t * p, poly8x8x4_t v)
+{
+  poly8x8x4_t res;
+  /* { dg-error "lane 8 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  res = vld4_lane_p8 (p, v, 8);
+  /* { dg-error "lane -1 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  res = vld4_lane_p8 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld4_lane_s16_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+int16x4x4_t
+f_vld4_lane_s16 (int16_t * p, int16x4x4_t v)
+{
+  int16x4x4_t res;
+  /* { dg-error "lane 4 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  res = vld4_lane_s16 (p, v, 4);
+  /* { dg-error "lane -1 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  res = vld4_lane_s16 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld4_lane_s32_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+int32x2x4_t
+f_vld4_lane_s32 (int32_t * p, int32x2x4_t v)
+{
+  int32x2x4_t res;
+  /* { dg-error "lane 2 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  res = vld4_lane_s32 (p, v, 2);
+  /* { dg-error "lane -1 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  res = vld4_lane_s32 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld4_lane_s64_indices_1.c
@@ -0,0 +1,17 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+/* { dg-skip-if "" { arm*-*-* } } */
+
+int64x1x4_t
+f_vld4_lane_s64 (int64_t * p, int64x1x4_t v)
+{
+  int64x1x4_t res;
+  /* { dg-error "lane 1 out of range 0 - 0" "" { xfail arm*-*-* } 0 } */
+  res = vld4_lane_s64 (p, v, 1);
+  /* { dg-error "lane -1 out of range 0 - 0" "" { xfail arm*-*-* } 0 } */
+  res = vld4_lane_s64 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld4_lane_s8_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+int8x8x4_t
+f_vld4_lane_s8 (int8_t * p, int8x8x4_t v)
+{
+  int8x8x4_t res;
+  /* { dg-error "lane 8 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  res = vld4_lane_s8 (p, v, 8);
+  /* { dg-error "lane -1 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  res = vld4_lane_s8 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld4_lane_u16_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+uint16x4x4_t
+f_vld4_lane_u16 (uint16_t * p, uint16x4x4_t v)
+{
+  uint16x4x4_t res;
+  /* { dg-error "lane 4 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  res = vld4_lane_u16 (p, v, 4);
+  /* { dg-error "lane -1 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  res = vld4_lane_u16 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld4_lane_u32_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+uint32x2x4_t
+f_vld4_lane_u32 (uint32_t * p, uint32x2x4_t v)
+{
+  uint32x2x4_t res;
+  /* { dg-error "lane 2 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  res = vld4_lane_u32 (p, v, 2);
+  /* { dg-error "lane -1 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  res = vld4_lane_u32 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld4_lane_u64_indices_1.c
@@ -0,0 +1,17 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+/* { dg-skip-if "" { arm*-*-* } } */
+
+uint64x1x4_t
+f_vld4_lane_u64 (uint64_t * p, uint64x1x4_t v)
+{
+  uint64x1x4_t res;
+  /* { dg-error "lane 1 out of range 0 - 0" "" { xfail arm*-*-* } 0 } */
+  res = vld4_lane_u64 (p, v, 1);
+  /* { dg-error "lane -1 out of range 0 - 0" "" { xfail arm*-*-* } 0 } */
+  res = vld4_lane_u64 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld4_lane_u8_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+uint8x8x4_t
+f_vld4_lane_u8 (uint8_t * p, uint8x8x4_t v)
+{
+  uint8x8x4_t res;
+  /* { dg-error "lane 8 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  res = vld4_lane_u8 (p, v, 8);
+  /* { dg-error "lane -1 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  res = vld4_lane_u8 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld4q_lane_f16_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+float16x8x4_t
+f_vld4q_lane_f16 (float16_t * p, float16x8x4_t v)
+{
+  float16x8x4_t res;
+  /* { dg-error "lane 8 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  res = vld4q_lane_f16 (p, v, 8);
+  /* { dg-error "lane -1 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  res = vld4q_lane_f16 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld4q_lane_f32_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+float32x4x4_t
+f_vld4q_lane_f32 (float32_t * p, float32x4x4_t v)
+{
+  float32x4x4_t res;
+  /* { dg-error "lane 4 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  res = vld4q_lane_f32 (p, v, 4);
+  /* { dg-error "lane -1 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  res = vld4q_lane_f32 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld4q_lane_f64_indices_1.c
@@ -0,0 +1,17 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+/* { dg-skip-if "" { arm*-*-* } } */
+
+float64x2x4_t
+f_vld4q_lane_f64 (float64_t * p, float64x2x4_t v)
+{
+  float64x2x4_t res;
+  /* { dg-error "lane 2 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  res = vld4q_lane_f64 (p, v, 2);
+  /* { dg-error "lane -1 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  res = vld4q_lane_f64 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld4q_lane_p8_indices_1.c
@@ -0,0 +1,17 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+/* { dg-skip-if "" { arm*-*-* } } */
+
+poly8x16x4_t
+f_vld4q_lane_p8 (poly8_t * p, poly8x16x4_t v)
+{
+  poly8x16x4_t res;
+  /* { dg-error "lane 16 out of range 0 - 15" "" { xfail arm*-*-* } 0 } */
+  res = vld4q_lane_p8 (p, v, 16);
+  /* { dg-error "lane -1 out of range 0 - 15" "" { xfail arm*-*-* } 0 } */
+  res = vld4q_lane_p8 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld4q_lane_s16_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+int16x8x4_t
+f_vld4q_lane_s16 (int16_t * p, int16x8x4_t v)
+{
+  int16x8x4_t res;
+  /* { dg-error "lane 8 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  res = vld4q_lane_s16 (p, v, 8);
+  /* { dg-error "lane -1 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  res = vld4q_lane_s16 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld4q_lane_s32_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+int32x4x4_t
+f_vld4q_lane_s32 (int32_t * p, int32x4x4_t v)
+{
+  int32x4x4_t res;
+  /* { dg-error "lane 4 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  res = vld4q_lane_s32 (p, v, 4);
+  /* { dg-error "lane -1 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  res = vld4q_lane_s32 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld4q_lane_s64_indices_1.c
@@ -0,0 +1,17 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+/* { dg-skip-if "" { arm*-*-* } } */
+
+int64x2x4_t
+f_vld4q_lane_s64 (int64_t * p, int64x2x4_t v)
+{
+  int64x2x4_t res;
+  /* { dg-error "lane 2 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  res = vld4q_lane_s64 (p, v, 2);
+  /* { dg-error "lane -1 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  res = vld4q_lane_s64 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld4q_lane_s8_indices_1.c
@@ -0,0 +1,17 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+/* { dg-skip-if "" { arm*-*-* } } */
+
+int8x16x4_t
+f_vld4q_lane_s8 (int8_t * p, int8x16x4_t v)
+{
+  int8x16x4_t res;
+  /* { dg-error "lane 16 out of range 0 - 15" "" { xfail arm*-*-* } 0 } */
+  res = vld4q_lane_s8 (p, v, 16);
+  /* { dg-error "lane -1 out of range 0 - 15" "" { xfail arm*-*-* } 0 } */
+  res = vld4q_lane_s8 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld4q_lane_u16_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+uint16x8x4_t
+f_vld4q_lane_u16 (uint16_t * p, uint16x8x4_t v)
+{
+  uint16x8x4_t res;
+  /* { dg-error "lane 8 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  res = vld4q_lane_u16 (p, v, 8);
+  /* { dg-error "lane -1 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  res = vld4q_lane_u16 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld4q_lane_u32_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+uint32x4x4_t
+f_vld4q_lane_u32 (uint32_t * p, uint32x4x4_t v)
+{
+  uint32x4x4_t res;
+  /* { dg-error "lane 4 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  res = vld4q_lane_u32 (p, v, 4);
+  /* { dg-error "lane -1 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  res = vld4q_lane_u32 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld4q_lane_u64_indices_1.c
@@ -0,0 +1,17 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+/* { dg-skip-if "" { arm*-*-* } } */
+
+uint64x2x4_t
+f_vld4q_lane_u64 (uint64_t * p, uint64x2x4_t v)
+{
+  uint64x2x4_t res;
+  /* { dg-error "lane 2 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  res = vld4q_lane_u64 (p, v, 2);
+  /* { dg-error "lane -1 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  res = vld4q_lane_u64 (p, v, -1);
+  return res;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld4q_lane_u8_indices_1.c
@@ -0,0 +1,17 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+/* { dg-skip-if "" { arm*-*-* } } */
+
+uint8x16x4_t
+f_vld4q_lane_u8 (uint8_t * p, uint8x16x4_t v)
+{
+  uint8x16x4_t res;
+  /* { dg-error "lane 16 out of range 0 - 15" "" { xfail arm*-*-* } 0 } */
+  res = vld4q_lane_u8 (p, v, 16);
+  /* { dg-error "lane -1 out of range 0 - 15" "" { xfail arm*-*-* } 0 } */
+  res = vld4q_lane_u8 (p, v, -1);
+  return res;
+}
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vldX.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vldX.c
@@ -18,6 +18,7 @@ VECT_VAR_DECL(expected_vld2_0,uint,64,1) [] = { 0xfffffffffffffff0 };
 VECT_VAR_DECL(expected_vld2_0,poly,8,8) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
 					       0xf4, 0xf5, 0xf6, 0xf7 };
 VECT_VAR_DECL(expected_vld2_0,poly,16,4) [] = { 0xfff0, 0xfff1, 0xfff2, 0xfff3 };
+VECT_VAR_DECL(expected_vld2_0,hfloat,16,4) [] = { 0xcc00, 0xcb80, 0xcb00, 0xca80 };
 VECT_VAR_DECL(expected_vld2_0,hfloat,32,2) [] = { 0xc1800000, 0xc1700000 };
 VECT_VAR_DECL(expected_vld2_0,int,8,16) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
 					       0xf4, 0xf5, 0xf6, 0xf7,
@@ -27,8 +28,6 @@ VECT_VAR_DECL(expected_vld2_0,int,16,8) [] = { 0xfff0, 0xfff1, 0xfff2, 0xfff3,
 					       0xfff4, 0xfff5, 0xfff6, 0xfff7 };
 VECT_VAR_DECL(expected_vld2_0,int,32,4) [] = { 0xfffffff0, 0xfffffff1,
 					       0xfffffff2, 0xfffffff3 };
-VECT_VAR_DECL(expected_vld2_0,int,64,2) [] = { 0x3333333333333333,
-					       0x3333333333333333 };
 VECT_VAR_DECL(expected_vld2_0,uint,8,16) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
 						0xf4, 0xf5, 0xf6, 0xf7,
 						0xf8, 0xf9, 0xfa, 0xfb,
@@ -37,14 +36,14 @@ VECT_VAR_DECL(expected_vld2_0,uint,16,8) [] = { 0xfff0, 0xfff1, 0xfff2, 0xfff3,
 						0xfff4, 0xfff5, 0xfff6, 0xfff7 };
 VECT_VAR_DECL(expected_vld2_0,uint,32,4) [] = { 0xfffffff0, 0xfffffff1,
 						0xfffffff2, 0xfffffff3 };
-VECT_VAR_DECL(expected_vld2_0,uint,64,2) [] = { 0x3333333333333333,
-						0x3333333333333333 };
 VECT_VAR_DECL(expected_vld2_0,poly,8,16) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
 						0xf4, 0xf5, 0xf6, 0xf7,
 						0xf8, 0xf9, 0xfa, 0xfb,
 						0xfc, 0xfd, 0xfe, 0xff };
 VECT_VAR_DECL(expected_vld2_0,poly,16,8) [] = { 0xfff0, 0xfff1, 0xfff2, 0xfff3,
 						0xfff4, 0xfff5, 0xfff6, 0xfff7 };
+VECT_VAR_DECL(expected_vld2_0,hfloat,16,8) [] = { 0xcc00, 0xcb80, 0xcb00, 0xca80,
+						  0xca00, 0xc980, 0xc900, 0xc880 };
 VECT_VAR_DECL(expected_vld2_0,hfloat,32,4) [] = { 0xc1800000, 0xc1700000,
 						  0xc1600000, 0xc1500000 };
 
@@ -62,6 +61,7 @@ VECT_VAR_DECL(expected_vld2_1,uint,64,1) [] = { 0xfffffffffffffff1 };
 VECT_VAR_DECL(expected_vld2_1,poly,8,8) [] = { 0xf8, 0xf9, 0xfa, 0xfb,
 					       0xfc, 0xfd, 0xfe, 0xff };
 VECT_VAR_DECL(expected_vld2_1,poly,16,4) [] = { 0xfff4, 0xfff5, 0xfff6, 0xfff7 };
+VECT_VAR_DECL(expected_vld2_1,hfloat,16,4) [] = { 0xca00, 0xc980, 0xc900, 0xc880 };
 VECT_VAR_DECL(expected_vld2_1,hfloat,32,2) [] = { 0xc1600000, 0xc1500000 };
 VECT_VAR_DECL(expected_vld2_1,int,8,16) [] = { 0x0, 0x1, 0x2, 0x3,
 					       0x4, 0x5, 0x6, 0x7,
@@ -71,8 +71,6 @@ VECT_VAR_DECL(expected_vld2_1,int,16,8) [] = { 0xfff8, 0xfff9, 0xfffa, 0xfffb,
 					       0xfffc, 0xfffd, 0xfffe, 0xffff };
 VECT_VAR_DECL(expected_vld2_1,int,32,4) [] = { 0xfffffff4, 0xfffffff5,
 					       0xfffffff6, 0xfffffff7 };
-VECT_VAR_DECL(expected_vld2_1,int,64,2) [] = { 0x3333333333333333,
-					       0x3333333333333333 };
 VECT_VAR_DECL(expected_vld2_1,uint,8,16) [] = { 0x0, 0x1, 0x2, 0x3,
 						0x4, 0x5, 0x6, 0x7,
 						0x8, 0x9, 0xa, 0xb,
@@ -81,14 +79,14 @@ VECT_VAR_DECL(expected_vld2_1,uint,16,8) [] = { 0xfff8, 0xfff9, 0xfffa, 0xfffb,
 						0xfffc, 0xfffd, 0xfffe, 0xffff };
 VECT_VAR_DECL(expected_vld2_1,uint,32,4) [] = { 0xfffffff4, 0xfffffff5,
 						0xfffffff6, 0xfffffff7 };
-VECT_VAR_DECL(expected_vld2_1,uint,64,2) [] = { 0x3333333333333333,
-						0x3333333333333333 };
 VECT_VAR_DECL(expected_vld2_1,poly,8,16) [] = { 0x0, 0x1, 0x2, 0x3,
 						0x4, 0x5, 0x6, 0x7,
 						0x8, 0x9, 0xa, 0xb,
 						0xc, 0xd, 0xe, 0xf };
 VECT_VAR_DECL(expected_vld2_1,poly,16,8) [] = { 0xfff8, 0xfff9, 0xfffa, 0xfffb,
 						0xfffc, 0xfffd, 0xfffe, 0xffff };
+VECT_VAR_DECL(expected_vld2_1,hfloat,16,8) [] = { 0xc800, 0xc700, 0xc600, 0xc500,
+						  0xc400, 0xc200, 0xc000, 0xbc00 };
 VECT_VAR_DECL(expected_vld2_1,hfloat,32,4) [] = { 0xc1400000, 0xc1300000,
 						  0xc1200000, 0xc1100000 };
 
@@ -106,6 +104,7 @@ VECT_VAR_DECL(expected_vld3_0,uint,64,1) [] = { 0xfffffffffffffff0 };
 VECT_VAR_DECL(expected_vld3_0,poly,8,8) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
 					       0xf4, 0xf5, 0xf6, 0xf7 };
 VECT_VAR_DECL(expected_vld3_0,poly,16,4) [] = { 0xfff0, 0xfff1, 0xfff2, 0xfff3 };
+VECT_VAR_DECL(expected_vld3_0,hfloat,16,4) [] = { 0xcc00, 0xcb80, 0xcb00, 0xca80 };
 VECT_VAR_DECL(expected_vld3_0,hfloat,32,2) [] = { 0xc1800000, 0xc1700000 };
 VECT_VAR_DECL(expected_vld3_0,int,8,16) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
 					       0xf4, 0xf5, 0xf6, 0xf7,
@@ -115,8 +114,6 @@ VECT_VAR_DECL(expected_vld3_0,int,16,8) [] = { 0xfff0, 0xfff1, 0xfff2, 0xfff3,
 					       0xfff4, 0xfff5, 0xfff6, 0xfff7 };
 VECT_VAR_DECL(expected_vld3_0,int,32,4) [] = { 0xfffffff0, 0xfffffff1,
 					       0xfffffff2, 0xfffffff3 };
-VECT_VAR_DECL(expected_vld3_0,int,64,2) [] = { 0x3333333333333333,
-					       0x3333333333333333 };
 VECT_VAR_DECL(expected_vld3_0,uint,8,16) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
 						0xf4, 0xf5, 0xf6, 0xf7,
 						0xf8, 0xf9, 0xfa, 0xfb,
@@ -125,14 +122,14 @@ VECT_VAR_DECL(expected_vld3_0,uint,16,8) [] = { 0xfff0, 0xfff1, 0xfff2, 0xfff3,
 						0xfff4, 0xfff5, 0xfff6, 0xfff7 };
 VECT_VAR_DECL(expected_vld3_0,uint,32,4) [] = { 0xfffffff0, 0xfffffff1,
 						0xfffffff2, 0xfffffff3 };
-VECT_VAR_DECL(expected_vld3_0,uint,64,2) [] = { 0x3333333333333333,
-						0x3333333333333333 };
 VECT_VAR_DECL(expected_vld3_0,poly,8,16) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
 						0xf4, 0xf5, 0xf6, 0xf7,
 						0xf8, 0xf9, 0xfa, 0xfb,
 						0xfc, 0xfd, 0xfe, 0xff };
 VECT_VAR_DECL(expected_vld3_0,poly,16,8) [] = { 0xfff0, 0xfff1, 0xfff2, 0xfff3,
 						0xfff4, 0xfff5, 0xfff6, 0xfff7 };
+VECT_VAR_DECL(expected_vld3_0,hfloat,16,8) [] = { 0xcc00, 0xcb80, 0xcb00, 0xca80,
+						  0xca00, 0xc980, 0xc900, 0xc880 };
 VECT_VAR_DECL(expected_vld3_0,hfloat,32,4) [] = { 0xc1800000, 0xc1700000,
 						  0xc1600000, 0xc1500000 };
 
@@ -150,6 +147,7 @@ VECT_VAR_DECL(expected_vld3_1,uint,64,1) [] = { 0xfffffffffffffff1 };
 VECT_VAR_DECL(expected_vld3_1,poly,8,8) [] = { 0xf8, 0xf9, 0xfa, 0xfb,
 					       0xfc, 0xfd, 0xfe, 0xff };
 VECT_VAR_DECL(expected_vld3_1,poly,16,4) [] = { 0xfff4, 0xfff5, 0xfff6, 0xfff7 };
+VECT_VAR_DECL(expected_vld3_1,hfloat,16,4) [] = { 0xca00, 0xc980, 0xc900, 0xc880 };
 VECT_VAR_DECL(expected_vld3_1,hfloat,32,2) [] = { 0xc1600000, 0xc1500000 };
 VECT_VAR_DECL(expected_vld3_1,int,8,16) [] = { 0x0, 0x1, 0x2, 0x3,
 					       0x4, 0x5, 0x6, 0x7,
@@ -159,8 +157,6 @@ VECT_VAR_DECL(expected_vld3_1,int,16,8) [] = { 0xfff8, 0xfff9, 0xfffa, 0xfffb,
 					       0xfffc, 0xfffd, 0xfffe, 0xffff };
 VECT_VAR_DECL(expected_vld3_1,int,32,4) [] = { 0xfffffff4, 0xfffffff5,
 					       0xfffffff6, 0xfffffff7 };
-VECT_VAR_DECL(expected_vld3_1,int,64,2) [] = { 0x3333333333333333,
-					       0x3333333333333333 };
 VECT_VAR_DECL(expected_vld3_1,uint,8,16) [] = { 0x0, 0x1, 0x2, 0x3,
 						0x4, 0x5, 0x6, 0x7,
 						0x8, 0x9, 0xa, 0xb,
@@ -169,14 +165,14 @@ VECT_VAR_DECL(expected_vld3_1,uint,16,8) [] = { 0xfff8, 0xfff9, 0xfffa, 0xfffb,
 						0xfffc, 0xfffd, 0xfffe, 0xffff };
 VECT_VAR_DECL(expected_vld3_1,uint,32,4) [] = { 0xfffffff4, 0xfffffff5,
 						0xfffffff6, 0xfffffff7 };
-VECT_VAR_DECL(expected_vld3_1,uint,64,2) [] = { 0x3333333333333333,
-						0x3333333333333333 };
 VECT_VAR_DECL(expected_vld3_1,poly,8,16) [] = { 0x0, 0x1, 0x2, 0x3,
 						0x4, 0x5, 0x6, 0x7,
 						0x8, 0x9, 0xa, 0xb,
 						0xc, 0xd, 0xe, 0xf };
 VECT_VAR_DECL(expected_vld3_1,poly,16,8) [] = { 0xfff8, 0xfff9, 0xfffa, 0xfffb,
 						0xfffc, 0xfffd, 0xfffe, 0xffff };
+VECT_VAR_DECL(expected_vld3_1,hfloat,16,8) [] = { 0xc800, 0xc700, 0xc600, 0xc500,
+						  0xc400, 0xc200, 0xc000, 0xbc00 };
 VECT_VAR_DECL(expected_vld3_1,hfloat,32,4) [] = { 0xc1400000, 0xc1300000,
 						  0xc1200000, 0xc1100000 };
 
@@ -197,6 +193,7 @@ VECT_VAR_DECL(expected_vld3_2,poly,8,8) [] = { 0x0, 0x1, 0x2, 0x3,
 					       0x4, 0x5, 0x6, 0x7 };
 VECT_VAR_DECL(expected_vld3_2,poly,16,4) [] = { 0xfff8, 0xfff9,
 						0xfffa, 0xfffb };
+VECT_VAR_DECL(expected_vld3_2,hfloat,16,4) [] = { 0xc800, 0xc700, 0xc600, 0xc500 };
 VECT_VAR_DECL(expected_vld3_2,hfloat,32,2) [] = { 0xc1400000, 0xc1300000 };
 VECT_VAR_DECL(expected_vld3_2,int,8,16) [] = { 0x10, 0x11, 0x12, 0x13,
 					       0x14, 0x15, 0x16, 0x17,
@@ -206,8 +203,6 @@ VECT_VAR_DECL(expected_vld3_2,int,16,8) [] = { 0x0, 0x1, 0x2, 0x3,
 					       0x4, 0x5, 0x6, 0x7 };
 VECT_VAR_DECL(expected_vld3_2,int,32,4) [] = { 0xfffffff8, 0xfffffff9,
 					       0xfffffffa, 0xfffffffb };
-VECT_VAR_DECL(expected_vld3_2,int,64,2) [] = { 0x3333333333333333,
-					       0x3333333333333333 };
 VECT_VAR_DECL(expected_vld3_2,uint,8,16) [] = { 0x10, 0x11, 0x12, 0x13,
 						0x14, 0x15, 0x16, 0x17,
 						0x18, 0x19, 0x1a, 0x1b,
@@ -216,14 +211,14 @@ VECT_VAR_DECL(expected_vld3_2,uint,16,8) [] = { 0x0, 0x1, 0x2, 0x3,
 						0x4, 0x5, 0x6, 0x7 };
 VECT_VAR_DECL(expected_vld3_2,uint,32,4) [] = { 0xfffffff8, 0xfffffff9,
 						0xfffffffa, 0xfffffffb };
-VECT_VAR_DECL(expected_vld3_2,uint,64,2) [] = { 0x3333333333333333,
-						0x3333333333333333 };
 VECT_VAR_DECL(expected_vld3_2,poly,8,16) [] = { 0x10, 0x11, 0x12, 0x13,
 						0x14, 0x15, 0x16, 0x17,
 						0x18, 0x19, 0x1a, 0x1b,
 						0x1c, 0x1d, 0x1e, 0x1f };
 VECT_VAR_DECL(expected_vld3_2,poly,16,8) [] = { 0x0, 0x1, 0x2, 0x3,
 						0x4, 0x5, 0x6, 0x7 };
+VECT_VAR_DECL(expected_vld3_2,hfloat,16,8) [] = { 0x0000, 0x3c00, 0x4000, 0x4200,
+						  0x4400, 0x4500, 0x4600, 0x4700 };
 VECT_VAR_DECL(expected_vld3_2,hfloat,32,4) [] = { 0xc1000000, 0xc0e00000,
 						  0xc0c00000, 0xc0a00000 };
 
@@ -243,6 +238,7 @@ VECT_VAR_DECL(expected_vld4_0,uint,64,1) [] = { 0xfffffffffffffff0 };
 VECT_VAR_DECL(expected_vld4_0,poly,8,8) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
 					       0xf4, 0xf5, 0xf6, 0xf7 };
 VECT_VAR_DECL(expected_vld4_0,poly,16,4) [] = { 0xfff0, 0xfff1, 0xfff2, 0xfff3 };
+VECT_VAR_DECL(expected_vld4_0,hfloat,16,4) [] = { 0xcc00, 0xcb80, 0xcb00, 0xca80 };
 VECT_VAR_DECL(expected_vld4_0,hfloat,32,2) [] = { 0xc1800000, 0xc1700000 };
 VECT_VAR_DECL(expected_vld4_0,int,8,16) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
 					       0xf4, 0xf5, 0xf6, 0xf7,
@@ -252,8 +248,6 @@ VECT_VAR_DECL(expected_vld4_0,int,16,8) [] = { 0xfff0, 0xfff1, 0xfff2, 0xfff3,
 					       0xfff4, 0xfff5, 0xfff6, 0xfff7 };
 VECT_VAR_DECL(expected_vld4_0,int,32,4) [] = { 0xfffffff0, 0xfffffff1,
 					       0xfffffff2, 0xfffffff3 };
-VECT_VAR_DECL(expected_vld4_0,int,64,2) [] = { 0x3333333333333333,
-					       0x3333333333333333 };
 VECT_VAR_DECL(expected_vld4_0,uint,8,16) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
 						0xf4, 0xf5, 0xf6, 0xf7,
 						0xf8, 0xf9, 0xfa, 0xfb,
@@ -262,14 +256,14 @@ VECT_VAR_DECL(expected_vld4_0,uint,16,8) [] = { 0xfff0, 0xfff1, 0xfff2, 0xfff3,
 						0xfff4, 0xfff5, 0xfff6, 0xfff7 };
 VECT_VAR_DECL(expected_vld4_0,uint,32,4) [] = { 0xfffffff0, 0xfffffff1,
 						0xfffffff2, 0xfffffff3 };
-VECT_VAR_DECL(expected_vld4_0,uint,64,2) [] = { 0x3333333333333333,
-						0x3333333333333333 };
 VECT_VAR_DECL(expected_vld4_0,poly,8,16) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
 						0xf4, 0xf5, 0xf6, 0xf7,
 						0xf8, 0xf9, 0xfa, 0xfb,
 						0xfc, 0xfd, 0xfe, 0xff };
 VECT_VAR_DECL(expected_vld4_0,poly,16,8) [] = { 0xfff0, 0xfff1, 0xfff2, 0xfff3,
 						0xfff4, 0xfff5, 0xfff6, 0xfff7 };
+VECT_VAR_DECL(expected_vld4_0,hfloat,16,8) [] = { 0xcc00, 0xcb80, 0xcb00, 0xca80,
+						  0xca00, 0xc980, 0xc900, 0xc880 };
 VECT_VAR_DECL(expected_vld4_0,hfloat,32,4) [] = { 0xc1800000, 0xc1700000,
 						  0xc1600000, 0xc1500000 };
 
@@ -287,6 +281,7 @@ VECT_VAR_DECL(expected_vld4_1,uint,64,1) [] = { 0xfffffffffffffff1 };
 VECT_VAR_DECL(expected_vld4_1,poly,8,8) [] = { 0xf8, 0xf9, 0xfa, 0xfb,
 					       0xfc, 0xfd, 0xfe, 0xff };
 VECT_VAR_DECL(expected_vld4_1,poly,16,4) [] = { 0xfff4, 0xfff5, 0xfff6, 0xfff7 };
+VECT_VAR_DECL(expected_vld4_1,hfloat,16,4) [] = { 0xca00, 0xc980, 0xc900, 0xc880 };
 VECT_VAR_DECL(expected_vld4_1,hfloat,32,2) [] = { 0xc1600000, 0xc1500000 };
 VECT_VAR_DECL(expected_vld4_1,int,8,16) [] = { 0x0, 0x1, 0x2, 0x3,
 					       0x4, 0x5, 0x6, 0x7,
@@ -296,8 +291,6 @@ VECT_VAR_DECL(expected_vld4_1,int,16,8) [] = { 0xfff8, 0xfff9, 0xfffa, 0xfffb,
 					       0xfffc, 0xfffd, 0xfffe, 0xffff };
 VECT_VAR_DECL(expected_vld4_1,int,32,4) [] = { 0xfffffff4, 0xfffffff5,
 					       0xfffffff6, 0xfffffff7 };
-VECT_VAR_DECL(expected_vld4_1,int,64,2) [] = { 0x3333333333333333,
-					       0x3333333333333333 };
 VECT_VAR_DECL(expected_vld4_1,uint,8,16) [] = { 0x0, 0x1, 0x2, 0x3,
 						0x4, 0x5, 0x6, 0x7,
 						0x8, 0x9, 0xa, 0xb,
@@ -306,14 +299,14 @@ VECT_VAR_DECL(expected_vld4_1,uint,16,8) [] = { 0xfff8, 0xfff9, 0xfffa, 0xfffb,
 						0xfffc, 0xfffd, 0xfffe, 0xffff };
 VECT_VAR_DECL(expected_vld4_1,uint,32,4) [] = { 0xfffffff4, 0xfffffff5,
 						0xfffffff6, 0xfffffff7 };
-VECT_VAR_DECL(expected_vld4_1,uint,64,2) [] = { 0x3333333333333333,
-						0x3333333333333333 };
 VECT_VAR_DECL(expected_vld4_1,poly,8,16) [] = { 0x0, 0x1, 0x2, 0x3,
 						0x4, 0x5, 0x6, 0x7,
 						0x8, 0x9, 0xa, 0xb,
 						0xc, 0xd, 0xe, 0xf };
 VECT_VAR_DECL(expected_vld4_1,poly,16,8) [] = { 0xfff8, 0xfff9, 0xfffa, 0xfffb,
 						0xfffc, 0xfffd, 0xfffe, 0xffff };
+VECT_VAR_DECL(expected_vld4_1,hfloat,16,8) [] = { 0xc800, 0xc700, 0xc600, 0xc500,
+						  0xc400, 0xc200, 0xc000, 0xbc00 };
 VECT_VAR_DECL(expected_vld4_1,hfloat,32,4) [] = { 0xc1400000, 0xc1300000,
 						  0xc1200000, 0xc1100000 };
 
@@ -331,6 +324,7 @@ VECT_VAR_DECL(expected_vld4_2,uint,64,1) [] = { 0xfffffffffffffff2 };
 VECT_VAR_DECL(expected_vld4_2,poly,8,8) [] = { 0x0, 0x1, 0x2, 0x3,
 					       0x4, 0x5, 0x6, 0x7 };
 VECT_VAR_DECL(expected_vld4_2,poly,16,4) [] = { 0xfff8, 0xfff9, 0xfffa, 0xfffb };
+VECT_VAR_DECL(expected_vld4_2,hfloat,16,4) [] = { 0xc800, 0xc700, 0xc600, 0xc500 };
 VECT_VAR_DECL(expected_vld4_2,hfloat,32,2) [] = { 0xc1400000, 0xc1300000 };
 VECT_VAR_DECL(expected_vld4_2,int,8,16) [] = { 0x10, 0x11, 0x12, 0x13,
 					       0x14, 0x15, 0x16, 0x17,
@@ -340,8 +334,6 @@ VECT_VAR_DECL(expected_vld4_2,int,16,8) [] = { 0x0, 0x1, 0x2, 0x3,
 					       0x4, 0x5, 0x6, 0x7 };
 VECT_VAR_DECL(expected_vld4_2,int,32,4) [] = { 0xfffffff8, 0xfffffff9,
 					       0xfffffffa, 0xfffffffb };
-VECT_VAR_DECL(expected_vld4_2,int,64,2) [] = { 0x3333333333333333,
-					       0x3333333333333333 };
 VECT_VAR_DECL(expected_vld4_2,uint,8,16) [] = { 0x10, 0x11, 0x12, 0x13,
 						0x14, 0x15, 0x16, 0x17,
 						0x18, 0x19, 0x1a, 0x1b,
@@ -350,14 +342,14 @@ VECT_VAR_DECL(expected_vld4_2,uint,16,8) [] = { 0x0, 0x1, 0x2, 0x3,
 						0x4, 0x5, 0x6, 0x7 };
 VECT_VAR_DECL(expected_vld4_2,uint,32,4) [] = { 0xfffffff8, 0xfffffff9,
 						0xfffffffa, 0xfffffffb };
-VECT_VAR_DECL(expected_vld4_2,uint,64,2) [] = { 0x3333333333333333,
-						0x3333333333333333 };
 VECT_VAR_DECL(expected_vld4_2,poly,8,16) [] = { 0x10, 0x11, 0x12, 0x13,
 						0x14, 0x15, 0x16, 0x17,
 						0x18, 0x19, 0x1a, 0x1b,
 						0x1c, 0x1d, 0x1e, 0x1f };
 VECT_VAR_DECL(expected_vld4_2,poly,16,8) [] = { 0x0, 0x1, 0x2, 0x3,
 						0x4, 0x5, 0x6, 0x7 };
+VECT_VAR_DECL(expected_vld4_2,hfloat,16,8) [] = { 0x0000, 0x3c00, 0x4000, 0x4200,
+						  0x4400, 0x4500, 0x4600, 0x4700 };
 VECT_VAR_DECL(expected_vld4_2,hfloat,32,4) [] = { 0xc1000000, 0xc0e00000,
 						  0xc0c00000, 0xc0a00000 };
 
@@ -375,6 +367,7 @@ VECT_VAR_DECL(expected_vld4_3,uint,64,1) [] = { 0xfffffffffffffff3 };
 VECT_VAR_DECL(expected_vld4_3,poly,8,8) [] = { 0x8, 0x9, 0xa, 0xb,
 					       0xc, 0xd, 0xe, 0xf };
 VECT_VAR_DECL(expected_vld4_3,poly,16,4) [] = { 0xfffc, 0xfffd, 0xfffe, 0xffff };
+VECT_VAR_DECL(expected_vld4_3,hfloat,16,4) [] = { 0xc400, 0xc200, 0xc000, 0xbc00 };
 VECT_VAR_DECL(expected_vld4_3,hfloat,32,2) [] = { 0xc1200000, 0xc1100000 };
 VECT_VAR_DECL(expected_vld4_3,int,8,16) [] = { 0x20, 0x21, 0x22, 0x23,
 					       0x24, 0x25, 0x26, 0x27,
@@ -384,8 +377,6 @@ VECT_VAR_DECL(expected_vld4_3,int,16,8) [] = { 0x8, 0x9, 0xa, 0xb,
 					       0xc, 0xd, 0xe, 0xf };
 VECT_VAR_DECL(expected_vld4_3,int,32,4) [] = { 0xfffffffc, 0xfffffffd,
 					       0xfffffffe, 0xffffffff };
-VECT_VAR_DECL(expected_vld4_3,int,64,2) [] = { 0x3333333333333333,
-					       0x3333333333333333 };
 VECT_VAR_DECL(expected_vld4_3,uint,8,16) [] = { 0x20, 0x21, 0x22, 0x23,
 						0x24, 0x25, 0x26, 0x27,
 						0x28, 0x29, 0x2a, 0x2b,
@@ -394,14 +385,14 @@ VECT_VAR_DECL(expected_vld4_3,uint,16,8) [] = { 0x8, 0x9, 0xa, 0xb,
 						0xc, 0xd, 0xe, 0xf };
 VECT_VAR_DECL(expected_vld4_3,uint,32,4) [] = { 0xfffffffc, 0xfffffffd,
 						0xfffffffe, 0xffffffff };
-VECT_VAR_DECL(expected_vld4_3,uint,64,2) [] = { 0x3333333333333333,
-						0x3333333333333333 };
 VECT_VAR_DECL(expected_vld4_3,poly,8,16) [] = { 0x20, 0x21, 0x22, 0x23,
 						0x24, 0x25, 0x26, 0x27,
 						0x28, 0x29, 0x2a, 0x2b,
 						0x2c, 0x2d, 0x2e, 0x2f };
 VECT_VAR_DECL(expected_vld4_3,poly,16,8) [] = { 0x8, 0x9, 0xa, 0xb,
 						0xc, 0xd, 0xe, 0xf };
+VECT_VAR_DECL(expected_vld4_3,hfloat,16,8) [] = { 0x4800, 0x4880, 0x4900, 0x4980,
+						  0x4a00, 0x4a80, 0x4b00, 0x4b80 };
 VECT_VAR_DECL(expected_vld4_3,hfloat,32,4) [] = { 0xc0800000, 0xc0400000,
 						  0xc0000000, 0xbf800000 };
 
@@ -434,7 +425,7 @@ void exec_vldX (void)
 	 sizeof(VECT_VAR(result, T1, W, N)));
 
   /* We need all variants in 64 bits, but there is no 64x2 variant.  */
-#define DECL_ALL_VLDX(X)			\
+#define DECL_ALL_VLDX_NO_FP16(X)		\
   DECL_VLDX(int, 8, 8, X);			\
   DECL_VLDX(int, 16, 4, X);			\
   DECL_VLDX(int, 32, 2, X);			\
@@ -456,7 +447,16 @@ void exec_vldX (void)
   DECL_VLDX(poly, 16, 8, X);			\
   DECL_VLDX(float, 32, 4, X)
 
-#define TEST_ALL_VLDX(X)			\
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+#define DECL_ALL_VLDX(X)	\
+  DECL_ALL_VLDX_NO_FP16(X);	\
+  DECL_VLDX(float, 16, 4, X);	\
+  DECL_VLDX(float, 16, 8, X)
+#else
+#define DECL_ALL_VLDX(X) DECL_ALL_VLDX_NO_FP16(X)
+#endif
+
+#define TEST_ALL_VLDX_NO_FP16(X)		\
   TEST_VLDX(, int, s, 8, 8, X);			\
   TEST_VLDX(, int, s, 16, 4, X);		\
   TEST_VLDX(, int, s, 32, 2, X);		\
@@ -478,7 +478,16 @@ void exec_vldX (void)
   TEST_VLDX(q, poly, p, 16, 8, X);		\
   TEST_VLDX(q, float, f, 32, 4, X)
 
-#define TEST_ALL_EXTRA_CHUNKS(X, Y)		\
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+#define TEST_ALL_VLDX(X)		\
+  TEST_ALL_VLDX_NO_FP16(X);		\
+  TEST_VLDX(, float, f, 16, 4, X);	\
+  TEST_VLDX(q, float, f, 16, 8, X)
+#else
+#define TEST_ALL_VLDX(X) TEST_ALL_VLDX_NO_FP16(X)
+#endif
+
+#define TEST_ALL_EXTRA_CHUNKS_NO_FP16(X, Y)	\
   TEST_EXTRA_CHUNK(int, 8, 8, X, Y);		\
   TEST_EXTRA_CHUNK(int, 16, 4, X, Y);		\
   TEST_EXTRA_CHUNK(int, 32, 2, X, Y);		\
@@ -500,6 +509,51 @@ void exec_vldX (void)
   TEST_EXTRA_CHUNK(poly, 16, 8, X, Y);		\
   TEST_EXTRA_CHUNK(float, 32, 4, X, Y)
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+#define TEST_ALL_EXTRA_CHUNKS(X, Y)		\
+  TEST_ALL_EXTRA_CHUNKS_NO_FP16(X, Y)		\
+  TEST_EXTRA_CHUNK(float, 16, 4, X, Y);		\
+  TEST_EXTRA_CHUNK(float, 16, 8, X, Y);
+#else
+#define TEST_ALL_EXTRA_CHUNKS(X, Y) TEST_ALL_EXTRA_CHUNKS_NO_FP16(X, Y)
+#endif
+
+  /* vldX supports all vector types except [u]int64x2.  */
+#define CHECK_RESULTS_VLDX_NO_FP16(test_name,EXPECTED,comment)		\
+    CHECK(test_name, int, 8, 8, PRIx8, EXPECTED, comment);		\
+    CHECK(test_name, int, 16, 4, PRIx16, EXPECTED, comment);		\
+    CHECK(test_name, int, 32, 2, PRIx32, EXPECTED, comment);		\
+    CHECK(test_name, int, 64, 1, PRIx64, EXPECTED, comment);		\
+    CHECK(test_name, uint, 8, 8, PRIx8, EXPECTED, comment);		\
+    CHECK(test_name, uint, 16, 4, PRIx16, EXPECTED, comment);		\
+    CHECK(test_name, uint, 32, 2, PRIx32, EXPECTED, comment);		\
+    CHECK(test_name, uint, 64, 1, PRIx64, EXPECTED, comment);		\
+    CHECK(test_name, poly, 8, 8, PRIx8, EXPECTED, comment);		\
+    CHECK(test_name, poly, 16, 4, PRIx16, EXPECTED, comment);		\
+    CHECK_FP(test_name, float, 32, 2, PRIx32, EXPECTED, comment);	\
+									\
+    CHECK(test_name, int, 8, 16, PRIx8, EXPECTED, comment);		\
+    CHECK(test_name, int, 16, 8, PRIx16, EXPECTED, comment);		\
+    CHECK(test_name, int, 32, 4, PRIx32, EXPECTED, comment);		\
+    CHECK(test_name, uint, 8, 16, PRIx8, EXPECTED, comment);		\
+    CHECK(test_name, uint, 16, 8, PRIx16, EXPECTED, comment);		\
+    CHECK(test_name, uint, 32, 4, PRIx32, EXPECTED, comment);		\
+    CHECK(test_name, poly, 8, 16, PRIx8, EXPECTED, comment);		\
+    CHECK(test_name, poly, 16, 8, PRIx16, EXPECTED, comment);		\
+    CHECK_FP(test_name, float, 32, 4, PRIx32, EXPECTED, comment)
+
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+#define CHECK_RESULTS_VLDX(test_name,EXPECTED,comment)			\
+  {									\
+    CHECK_RESULTS_VLDX_NO_FP16(test_name, EXPECTED, comment);		\
+    CHECK_FP(test_name, float, 16, 4, PRIx16, EXPECTED, comment);	\
+    CHECK_FP(test_name, float, 16, 8, PRIx16, EXPECTED, comment);	\
+  }
+#else
+#define CHECK_RESULTS_VLDX(test_name, EXPECTED, comment)		\
+  { CHECK_RESULTS_VLDX_NO_FP16(test_name, EXPECTED, comment); }
+#endif
+
   DECL_ALL_VLDX(2);
   DECL_ALL_VLDX(3);
   DECL_ALL_VLDX(4);
@@ -526,6 +580,10 @@ void exec_vldX (void)
   PAD(buffer_vld2_pad, poly, 8, 8);
   VECT_ARRAY_INIT2(buffer_vld2, poly, 16, 4);
   PAD(buffer_vld2_pad, poly, 16, 4);
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+  VECT_ARRAY_INIT2(buffer_vld2, float, 16, 4);
+  PAD(buffer_vld2_pad, float, 16, 4);
+#endif
   VECT_ARRAY_INIT2(buffer_vld2, float, 32, 2);
   PAD(buffer_vld2_pad, float, 32, 2);
 
@@ -549,6 +607,10 @@ void exec_vldX (void)
   PAD(buffer_vld2_pad, poly, 8, 16);
   VECT_ARRAY_INIT2(buffer_vld2, poly, 16, 8);
   PAD(buffer_vld2_pad, poly, 16, 8);
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+  VECT_ARRAY_INIT2(buffer_vld2, float, 16, 8);
+  PAD(buffer_vld2_pad, float, 16, 8);
+#endif
   VECT_ARRAY_INIT2(buffer_vld2, float, 32, 4);
   PAD(buffer_vld2_pad, float, 32, 4);
 
@@ -573,6 +635,10 @@ void exec_vldX (void)
   PAD(buffer_vld3_pad, poly, 8, 8);
   VECT_ARRAY_INIT3(buffer_vld3, poly, 16, 4);
   PAD(buffer_vld3_pad, poly, 16, 4);
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+  VECT_ARRAY_INIT3(buffer_vld3, float, 16, 4);
+  PAD(buffer_vld3_pad, float, 16, 4);
+#endif
   VECT_ARRAY_INIT3(buffer_vld3, float, 32, 2);
   PAD(buffer_vld3_pad, float, 32, 2);
 
@@ -596,6 +662,10 @@ void exec_vldX (void)
   PAD(buffer_vld3_pad, poly, 8, 16);
   VECT_ARRAY_INIT3(buffer_vld3, poly, 16, 8);
   PAD(buffer_vld3_pad, poly, 16, 8);
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+  VECT_ARRAY_INIT3(buffer_vld3, float, 16, 8);
+  PAD(buffer_vld3_pad, float, 16, 8);
+#endif
   VECT_ARRAY_INIT3(buffer_vld3, float, 32, 4);
   PAD(buffer_vld3_pad, float, 32, 4);
 
@@ -620,6 +690,10 @@ void exec_vldX (void)
   PAD(buffer_vld4_pad, poly, 8, 8);
   VECT_ARRAY_INIT4(buffer_vld4, poly, 16, 4);
   PAD(buffer_vld4_pad, poly, 16, 4);
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+  VECT_ARRAY_INIT4(buffer_vld4, float, 16, 4);
+  PAD(buffer_vld4_pad, float, 16, 4);
+#endif
   VECT_ARRAY_INIT4(buffer_vld4, float, 32, 2);
   PAD(buffer_vld4_pad, float, 32, 2);
 
@@ -643,6 +717,10 @@ void exec_vldX (void)
   PAD(buffer_vld4_pad, poly, 8, 16);
   VECT_ARRAY_INIT4(buffer_vld4, poly, 16, 8);
   PAD(buffer_vld4_pad, poly, 16, 8);
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+  VECT_ARRAY_INIT4(buffer_vld4, float, 16, 8);
+  PAD(buffer_vld4_pad, float, 16, 8);
+#endif
   VECT_ARRAY_INIT4(buffer_vld4, float, 32, 4);
   PAD(buffer_vld4_pad, float, 32, 4);
 
@@ -650,39 +728,39 @@ void exec_vldX (void)
   clean_results ();
 #define TEST_MSG "VLD2/VLD2Q"
   TEST_ALL_VLDX(2);
-  CHECK_RESULTS_NAMED (TEST_MSG, expected_vld2_0, "chunk 0");
+  CHECK_RESULTS_VLDX (TEST_MSG, expected_vld2_0, "chunk 0");
 
   TEST_ALL_EXTRA_CHUNKS(2, 1);
-  CHECK_RESULTS_NAMED (TEST_MSG, expected_vld2_1, "chunk 1");
+  CHECK_RESULTS_VLDX (TEST_MSG, expected_vld2_1, "chunk 1");
 
   /* Check vld3/vld3q.  */
   clean_results ();
 #undef TEST_MSG
 #define TEST_MSG "VLD3/VLD3Q"
   TEST_ALL_VLDX(3);
-  CHECK_RESULTS_NAMED (TEST_MSG, expected_vld3_0, "chunk 0");
+  CHECK_RESULTS_VLDX (TEST_MSG, expected_vld3_0, "chunk 0");
 
   TEST_ALL_EXTRA_CHUNKS(3, 1);
-  CHECK_RESULTS_NAMED (TEST_MSG, expected_vld3_1, "chunk 1");
+  CHECK_RESULTS_VLDX (TEST_MSG, expected_vld3_1, "chunk 1");
 
   TEST_ALL_EXTRA_CHUNKS(3, 2);
-  CHECK_RESULTS_NAMED (TEST_MSG, expected_vld3_2, "chunk 2");
+  CHECK_RESULTS_VLDX (TEST_MSG, expected_vld3_2, "chunk 2");
 
   /* Check vld4/vld4q.  */
   clean_results ();
 #undef TEST_MSG
 #define TEST_MSG "VLD4/VLD4Q"
   TEST_ALL_VLDX(4);
-  CHECK_RESULTS_NAMED (TEST_MSG, expected_vld4_0, "chunk 0");
+  CHECK_RESULTS_VLDX (TEST_MSG, expected_vld4_0, "chunk 0");
 
   TEST_ALL_EXTRA_CHUNKS(4, 1);
-  CHECK_RESULTS_NAMED (TEST_MSG, expected_vld4_1, "chunk 1");
+  CHECK_RESULTS_VLDX (TEST_MSG, expected_vld4_1, "chunk 1");
 
   TEST_ALL_EXTRA_CHUNKS(4, 2);
-  CHECK_RESULTS_NAMED (TEST_MSG, expected_vld4_2, "chunk 2");
+  CHECK_RESULTS_VLDX (TEST_MSG, expected_vld4_2, "chunk 2");
 
   TEST_ALL_EXTRA_CHUNKS(4, 3);
-  CHECK_RESULTS_NAMED (TEST_MSG, expected_vld4_3, "chunk 3");
+  CHECK_RESULTS_VLDX (TEST_MSG, expected_vld4_3, "chunk 3");
 }
 
 int main (void)
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vldX_dup.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vldX_dup.c
@@ -18,35 +18,8 @@ VECT_VAR_DECL(expected_vld2_0,uint,64,1) [] = { 0xfffffffffffffff0 };
 VECT_VAR_DECL(expected_vld2_0,poly,8,8) [] = { 0xf0, 0xf1, 0xf0, 0xf1,
 					0xf0, 0xf1, 0xf0, 0xf1 };
 VECT_VAR_DECL(expected_vld2_0,poly,16,4) [] = { 0xfff0, 0xfff1, 0xfff0, 0xfff1 };
+VECT_VAR_DECL(expected_vld2_0,hfloat,16,4) [] = {0xcc00, 0xcb80, 0xcc00, 0xcb80 };
 VECT_VAR_DECL(expected_vld2_0,hfloat,32,2) [] = { 0xc1800000, 0xc1700000 };
-VECT_VAR_DECL(expected_vld2_0,int,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected_vld2_0,int,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected_vld2_0,int,32,4) [] = { 0x33333333, 0x33333333,
-					0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected_vld2_0,int,64,2) [] = { 0x3333333333333333,
-					0x3333333333333333 };
-VECT_VAR_DECL(expected_vld2_0,uint,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected_vld2_0,uint,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected_vld2_0,uint,32,4) [] = { 0x33333333, 0x33333333,
-					 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected_vld2_0,uint,64,2) [] = { 0x3333333333333333,
-					 0x3333333333333333 };
-VECT_VAR_DECL(expected_vld2_0,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected_vld2_0,poly,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected_vld2_0,hfloat,32,4) [] = { 0x33333333, 0x33333333,
-					   0x33333333, 0x33333333 };
 
 /* vld2_dup/chunk 1.  */
 VECT_VAR_DECL(expected_vld2_1,int,8,8) [] = { 0xf0, 0xf1, 0xf0, 0xf1,
@@ -63,35 +36,8 @@ VECT_VAR_DECL(expected_vld2_1,poly,8,8) [] = { 0xf0, 0xf1, 0xf0, 0xf1,
 					       0xf0, 0xf1, 0xf0, 0xf1 };
 VECT_VAR_DECL(expected_vld2_1,poly,16,4) [] = { 0xfff0, 0xfff1,
 						0xfff0, 0xfff1 };
+VECT_VAR_DECL(expected_vld2_1,hfloat,16,4) [] = { 0xcc00, 0xcb80, 0xcc00, 0xcb80 };
 VECT_VAR_DECL(expected_vld2_1,hfloat,32,2) [] = { 0xc1800000, 0xc1700000 };
-VECT_VAR_DECL(expected_vld2_1,int,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					       0x33, 0x33, 0x33, 0x33,
-					       0x33, 0x33, 0x33, 0x33,
-					       0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected_vld2_1,int,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					       0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected_vld2_1,int,32,4) [] = { 0x33333333, 0x33333333,
-					       0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected_vld2_1,int,64,2) [] = { 0x3333333333333333,
-					       0x3333333333333333 };
-VECT_VAR_DECL(expected_vld2_1,uint,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected_vld2_1,uint,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-						0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected_vld2_1,uint,32,4) [] = { 0x33333333, 0x33333333,
-						0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected_vld2_1,uint,64,2) [] = { 0x3333333333333333,
-						0x3333333333333333 };
-VECT_VAR_DECL(expected_vld2_1,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected_vld2_1,poly,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-						0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected_vld2_1,hfloat,32,4) [] = { 0x33333333, 0x33333333,
-						  0x33333333, 0x33333333 };
 
 /* vld3_dup/chunk 0.  */
 VECT_VAR_DECL(expected_vld3_0,int,8,8) [] = { 0xf0, 0xf1, 0xf2, 0xf0,
@@ -110,35 +56,8 @@ VECT_VAR_DECL(expected_vld3_0,poly,8,8) [] = { 0xf0, 0xf1, 0xf2, 0xf0,
 					       0xf1, 0xf2, 0xf0, 0xf1 };
 VECT_VAR_DECL(expected_vld3_0,poly,16,4) [] = { 0xfff0, 0xfff1,
 						0xfff2, 0xfff0 };
+VECT_VAR_DECL(expected_vld3_0,hfloat,16,4) [] = { 0xcc00, 0xcb80, 0xcb00, 0xcc00 };
 VECT_VAR_DECL(expected_vld3_0,hfloat,32,2) [] = { 0xc1800000, 0xc1700000 };
-VECT_VAR_DECL(expected_vld3_0,int,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					       0x33, 0x33, 0x33, 0x33,
-					       0x33, 0x33, 0x33, 0x33,
-					       0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected_vld3_0,int,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					       0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected_vld3_0,int,32,4) [] = { 0x33333333, 0x33333333,
-					       0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected_vld3_0,int,64,2) [] = { 0x3333333333333333,
-					       0x3333333333333333 };
-VECT_VAR_DECL(expected_vld3_0,uint,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected_vld3_0,uint,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-						0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected_vld3_0,uint,32,4) [] = { 0x33333333, 0x33333333,
-						0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected_vld3_0,uint,64,2) [] = { 0x3333333333333333,
-						0x3333333333333333 };
-VECT_VAR_DECL(expected_vld3_0,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected_vld3_0,poly,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-						0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected_vld3_0,hfloat,32,4) [] = { 0x33333333, 0x33333333,
-						  0x33333333, 0x33333333 };
 
 /* vld3_dup/chunk 1.  */
 VECT_VAR_DECL(expected_vld3_1,int,8,8) [] = { 0xf2, 0xf0, 0xf1, 0xf2,
@@ -157,35 +76,8 @@ VECT_VAR_DECL(expected_vld3_1,poly,8,8) [] = { 0xf2, 0xf0, 0xf1, 0xf2,
 					       0xf0, 0xf1, 0xf2, 0xf0 };
 VECT_VAR_DECL(expected_vld3_1,poly,16,4) [] = { 0xfff1, 0xfff2,
 						0xfff0, 0xfff1 };
+VECT_VAR_DECL(expected_vld3_1,hfloat,16,4) [] = { 0xcb80, 0xcb00, 0xcc00, 0xcb80 };
 VECT_VAR_DECL(expected_vld3_1,hfloat,32,2) [] = { 0xc1600000, 0xc1800000 };
-VECT_VAR_DECL(expected_vld3_1,int,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					       0x33, 0x33, 0x33, 0x33,
-					       0x33, 0x33, 0x33, 0x33,
-					       0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected_vld3_1,int,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					       0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected_vld3_1,int,32,4) [] = { 0x33333333, 0x33333333,
-					       0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected_vld3_1,int,64,2) [] = { 0x3333333333333333,
-					       0x3333333333333333 };
-VECT_VAR_DECL(expected_vld3_1,uint,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected_vld3_1,uint,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-						0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected_vld3_1,uint,32,4) [] = { 0x33333333, 0x33333333,
-						0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected_vld3_1,uint,64,2) [] = { 0x3333333333333333,
-						0x3333333333333333 };
-VECT_VAR_DECL(expected_vld3_1,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected_vld3_1,poly,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-						0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected_vld3_1,hfloat,32,4) [] = { 0x33333333, 0x33333333,
-						  0x33333333, 0x33333333 };
 
 /* vld3_dup/chunk 2.  */
 VECT_VAR_DECL(expected_vld3_2,int,8,8) [] = { 0xf1, 0xf2, 0xf0, 0xf1,
@@ -204,35 +96,8 @@ VECT_VAR_DECL(expected_vld3_2,poly,8,8) [] = { 0xf1, 0xf2, 0xf0, 0xf1,
 					       0xf2, 0xf0, 0xf1, 0xf2 };
 VECT_VAR_DECL(expected_vld3_2,poly,16,4) [] = { 0xfff2, 0xfff0,
 						0xfff1, 0xfff2 };
+VECT_VAR_DECL(expected_vld3_2,hfloat,16,4) [] = { 0xcb00, 0xcc00, 0xcb80, 0xcb00 };
 VECT_VAR_DECL(expected_vld3_2,hfloat,32,2) [] = { 0xc1700000, 0xc1600000 };
-VECT_VAR_DECL(expected_vld3_2,int,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					       0x33, 0x33, 0x33, 0x33,
-					       0x33, 0x33, 0x33, 0x33,
-					       0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected_vld3_2,int,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					       0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected_vld3_2,int,32,4) [] = { 0x33333333, 0x33333333,
-					       0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected_vld3_2,int,64,2) [] = { 0x3333333333333333,
-					       0x3333333333333333 };
-VECT_VAR_DECL(expected_vld3_2,uint,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected_vld3_2,uint,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-						0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected_vld3_2,uint,32,4) [] = { 0x33333333, 0x33333333,
-						0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected_vld3_2,uint,64,2) [] = { 0x3333333333333333,
-						0x3333333333333333 };
-VECT_VAR_DECL(expected_vld3_2,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected_vld3_2,poly,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-						0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected_vld3_2,hfloat,32,4) [] = { 0x33333333, 0x33333333,
-						  0x33333333, 0x33333333 };
 
 /* vld4_dup/chunk 0.  */
 VECT_VAR_DECL(expected_vld4_0,int,8,8) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
@@ -249,35 +114,8 @@ VECT_VAR_DECL(expected_vld4_0,uint,64,1) [] = { 0xfffffffffffffff0 };
 VECT_VAR_DECL(expected_vld4_0,poly,8,8) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
 					       0xf0, 0xf1, 0xf2, 0xf3 };
 VECT_VAR_DECL(expected_vld4_0,poly,16,4) [] = { 0xfff0, 0xfff1, 0xfff2, 0xfff3 };
+VECT_VAR_DECL(expected_vld4_0,hfloat,16,4) [] = { 0xcc00, 0xcb80, 0xcb00, 0xca80 };
 VECT_VAR_DECL(expected_vld4_0,hfloat,32,2) [] = { 0xc1800000, 0xc1700000 };
-VECT_VAR_DECL(expected_vld4_0,int,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					       0x33, 0x33, 0x33, 0x33,
-					       0x33, 0x33, 0x33, 0x33,
-					       0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected_vld4_0,int,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					       0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected_vld4_0,int,32,4) [] = { 0x33333333, 0x33333333,
-					       0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected_vld4_0,int,64,2) [] = { 0x3333333333333333,
-					       0x3333333333333333 };
-VECT_VAR_DECL(expected_vld4_0,uint,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected_vld4_0,uint,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-						0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected_vld4_0,uint,32,4) [] = { 0x33333333, 0x33333333,
-						0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected_vld4_0,uint,64,2) [] = { 0x3333333333333333,
-						0x3333333333333333 };
-VECT_VAR_DECL(expected_vld4_0,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected_vld4_0,poly,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-						0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected_vld4_0,hfloat,32,4) [] = { 0x33333333, 0x33333333,
-						  0x33333333, 0x33333333 };
 
 /* vld4_dup/chunk 1.  */
 VECT_VAR_DECL(expected_vld4_1,int,8,8) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
@@ -293,35 +131,8 @@ VECT_VAR_DECL(expected_vld4_1,uint,64,1) [] = { 0xfffffffffffffff1 };
 VECT_VAR_DECL(expected_vld4_1,poly,8,8) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
 					       0xf0, 0xf1, 0xf2, 0xf3 };
 VECT_VAR_DECL(expected_vld4_1,poly,16,4) [] = { 0xfff0, 0xfff1, 0xfff2, 0xfff3 };
+VECT_VAR_DECL(expected_vld4_1,hfloat,16,4) [] = { 0xcc00, 0xcb80, 0xcb00, 0xca80 };
 VECT_VAR_DECL(expected_vld4_1,hfloat,32,2) [] = { 0xc1600000, 0xc1500000 };
-VECT_VAR_DECL(expected_vld4_1,int,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					       0x33, 0x33, 0x33, 0x33,
-					       0x33, 0x33, 0x33, 0x33,
-					       0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected_vld4_1,int,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					       0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected_vld4_1,int,32,4) [] = { 0x33333333, 0x33333333,
-					       0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected_vld4_1,int,64,2) [] = { 0x3333333333333333,
-					       0x3333333333333333 };
-VECT_VAR_DECL(expected_vld4_1,uint,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected_vld4_1,uint,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-						0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected_vld4_1,uint,32,4) [] = { 0x33333333, 0x33333333,
-						0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected_vld4_1,uint,64,2) [] = { 0x3333333333333333,
-						0x3333333333333333 };
-VECT_VAR_DECL(expected_vld4_1,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected_vld4_1,poly,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-						0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected_vld4_1,hfloat,32,4) [] = { 0x33333333, 0x33333333,
-						  0x33333333, 0x33333333 };
 
 /* vld4_dup/chunk 2.  */
 VECT_VAR_DECL(expected_vld4_2,int,8,8) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
@@ -337,35 +148,8 @@ VECT_VAR_DECL(expected_vld4_2,uint,64,1) [] = { 0xfffffffffffffff2 };
 VECT_VAR_DECL(expected_vld4_2,poly,8,8) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
 					       0xf0, 0xf1, 0xf2, 0xf3 };
 VECT_VAR_DECL(expected_vld4_2,poly,16,4) [] = { 0xfff0, 0xfff1, 0xfff2, 0xfff3 };
+VECT_VAR_DECL(expected_vld4_2,hfloat,16,4) [] = { 0xcc00, 0xcb80, 0xcb00, 0xca80 };
 VECT_VAR_DECL(expected_vld4_2,hfloat,32,2) [] = { 0xc1800000, 0xc1700000 };
-VECT_VAR_DECL(expected_vld4_2,int,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					       0x33, 0x33, 0x33, 0x33,
-					       0x33, 0x33, 0x33, 0x33,
-					       0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected_vld4_2,int,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					       0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected_vld4_2,int,32,4) [] = { 0x33333333, 0x33333333,
-					       0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected_vld4_2,int,64,2) [] = { 0x3333333333333333,
-					       0x3333333333333333 };
-VECT_VAR_DECL(expected_vld4_2,uint,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected_vld4_2,uint,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-						0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected_vld4_2,uint,32,4) [] = { 0x33333333, 0x33333333,
-						0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected_vld4_2,uint,64,2) [] = { 0x3333333333333333,
-						0x3333333333333333 };
-VECT_VAR_DECL(expected_vld4_2,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected_vld4_2,poly,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-						0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected_vld4_2,hfloat,32,4) [] = { 0x33333333, 0x33333333,
-						  0x33333333, 0x33333333 };
 
 /* vld4_dup/chunk3.  */
 VECT_VAR_DECL(expected_vld4_3,int,8,8) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
@@ -381,34 +165,8 @@ VECT_VAR_DECL(expected_vld4_3,uint,64,1) [] = { 0xfffffffffffffff3 };
 VECT_VAR_DECL(expected_vld4_3,poly,8,8) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
 					       0xf0, 0xf1, 0xf2, 0xf3 };
 VECT_VAR_DECL(expected_vld4_3,poly,16,4) [] = { 0xfff0, 0xfff1, 0xfff2, 0xfff3 };
+VECT_VAR_DECL(expected_vld4_3,hfloat,16,4) [] = { 0xcc00, 0xcb80, 0xcb00, 0xca80 };
 VECT_VAR_DECL(expected_vld4_3,hfloat,32,2) [] = { 0xc1600000, 0xc1500000 };
-VECT_VAR_DECL(expected_vld4_3,int,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					       0x33, 0x33, 0x33, 0x33,
-					       0x33, 0x33, 0x33, 0x33,
-					       0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected_vld4_3,int,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					       0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected_vld4_3,int,32,4) [] = { 0x33333333, 0x33333333,
-					       0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected_vld4_3,int,64,2) [] = { 0x3333333333333333, 0x3333333333333333 };
-VECT_VAR_DECL(expected_vld4_3,uint,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected_vld4_3,uint,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-						0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected_vld4_3,uint,32,4) [] = { 0x33333333, 0x33333333,
-						0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected_vld4_3,uint,64,2) [] = { 0x3333333333333333,
-						0x3333333333333333 };
-VECT_VAR_DECL(expected_vld4_3,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected_vld4_3,poly,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-						0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected_vld4_3,hfloat,32,4) [] = { 0x33333333, 0x33333333,
-						  0x33333333, 0x33333333 };
 
 void exec_vldX_dup (void)
 {
@@ -439,7 +197,7 @@ void exec_vldX_dup (void)
 	 &(VECT_VAR(result_bis_##X, T1, W, N)[Y*N]),	\
 	 sizeof(VECT_VAR(result, T1, W, N)));
 
-#define DECL_ALL_VLDX_DUP(X)			\
+#define DECL_ALL_VLDX_DUP_NO_FP16(X)		\
   DECL_VLDX_DUP(int, 8, 8, X);			\
   DECL_VLDX_DUP(int, 16, 4, X);			\
   DECL_VLDX_DUP(int, 32, 2, X);			\
@@ -452,7 +210,15 @@ void exec_vldX_dup (void)
   DECL_VLDX_DUP(poly, 16, 4, X);		\
   DECL_VLDX_DUP(float, 32, 2, X)
 
-#define TEST_ALL_VLDX_DUP(X)			\
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+#define DECL_ALL_VLDX_DUP(X)		\
+  DECL_ALL_VLDX_DUP_NO_FP16(X);		\
+  DECL_VLDX_DUP(float, 16, 4, X)
+#else
+#define DECL_ALL_VLDX_DUP(X) DECL_ALL_VLDX_DUP_NO_FP16(X)
+#endif
+
+#define TEST_ALL_VLDX_DUP_NO_FP16(X)		\
   TEST_VLDX_DUP(, int, s, 8, 8, X);		\
   TEST_VLDX_DUP(, int, s, 16, 4, X);		\
   TEST_VLDX_DUP(, int, s, 32, 2, X);		\
@@ -465,7 +231,15 @@ void exec_vldX_dup (void)
   TEST_VLDX_DUP(, poly, p, 16, 4, X);		\
   TEST_VLDX_DUP(, float, f, 32, 2, X)
 
-#define TEST_ALL_EXTRA_CHUNKS(X, Y)		\
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+#define TEST_ALL_VLDX_DUP(X)		\
+  TEST_ALL_VLDX_DUP_NO_FP16(X);		\
+  TEST_VLDX_DUP(, float, f, 16, 4, X)
+#else
+#define TEST_ALL_VLDX_DUP(X) TEST_ALL_VLDX_DUP_NO_FP16(X)
+#endif
+
+#define TEST_ALL_EXTRA_CHUNKS_NO_FP16(X, Y)	\
   TEST_EXTRA_CHUNK(int, 8, 8, X, Y);		\
   TEST_EXTRA_CHUNK(int, 16, 4, X, Y);		\
   TEST_EXTRA_CHUNK(int, 32, 2, X, Y);		\
@@ -478,6 +252,40 @@ void exec_vldX_dup (void)
   TEST_EXTRA_CHUNK(poly, 16, 4, X, Y);		\
   TEST_EXTRA_CHUNK(float, 32, 2, X, Y)
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+#define TEST_ALL_EXTRA_CHUNKS(X, Y)	\
+  TEST_ALL_EXTRA_CHUNKS_NO_FP16(X, Y);	\
+  TEST_EXTRA_CHUNK(float, 16, 4, X, Y)
+#else
+#define TEST_ALL_EXTRA_CHUNKS(X, Y) TEST_ALL_EXTRA_CHUNKS_NO_FP16(X, Y)
+#endif
+
+  /* vldX_dup supports only 64-bit inputs.  */
+#define CHECK_RESULTS_VLDX_DUP_NO_FP16(test_name,EXPECTED,comment)	\
+    CHECK(test_name, int, 8, 8, PRIx8, EXPECTED, comment);		\
+    CHECK(test_name, int, 16, 4, PRIx16, EXPECTED, comment);		\
+    CHECK(test_name, int, 32, 2, PRIx32, EXPECTED, comment);		\
+    CHECK(test_name, int, 64, 1, PRIx64, EXPECTED, comment);		\
+    CHECK(test_name, uint, 8, 8, PRIx8, EXPECTED, comment);		\
+    CHECK(test_name, uint, 16, 4, PRIx16, EXPECTED, comment);		\
+    CHECK(test_name, uint, 32, 2, PRIx32, EXPECTED, comment);		\
+    CHECK(test_name, uint, 64, 1, PRIx64, EXPECTED, comment);		\
+    CHECK(test_name, poly, 8, 8, PRIx8, EXPECTED, comment);		\
+    CHECK(test_name, poly, 16, 4, PRIx16, EXPECTED, comment);		\
+    CHECK_FP(test_name, float, 32, 2, PRIx32, EXPECTED, comment)
+
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+#define CHECK_RESULTS_VLDX_DUP(test_name,EXPECTED,comment)		\
+  {									\
+    CHECK_RESULTS_VLDX_DUP_NO_FP16(test_name,EXPECTED,comment);		\
+    CHECK_FP(test_name, float, 16, 4, PRIx16, EXPECTED, comment);	\
+  }
+#else
+#define CHECK_RESULTS_VLDX_DUP(test_name,EXPECTED,comment)		\
+  {									\
+    CHECK_RESULTS_VLDX_DUP_NO_FP16(test_name,EXPECTED,comment);		\
+  }
+#endif
 
   DECL_ALL_VLDX_DUP(2);
   DECL_ALL_VLDX_DUP(3);
@@ -505,6 +313,10 @@ void exec_vldX_dup (void)
   PAD(buffer_vld2_pad, poly, 8, 8);
   VECT_ARRAY_INIT2(buffer_vld2, poly, 16, 4);
   PAD(buffer_vld2_pad, poly, 16, 4);
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+  VECT_ARRAY_INIT2(buffer_vld2, float, 16, 4);
+  PAD(buffer_vld2_pad, float, 16, 4);
+#endif
   VECT_ARRAY_INIT2(buffer_vld2, float, 32, 2);
   PAD(buffer_vld2_pad, float, 32, 2);
 
@@ -528,6 +340,10 @@ void exec_vldX_dup (void)
   PAD(buffer_vld2_pad, poly, 8, 16);
   VECT_ARRAY_INIT2(buffer_vld2, poly, 16, 8);
   PAD(buffer_vld2_pad, poly, 16, 8);
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+  VECT_ARRAY_INIT2(buffer_vld2, float, 16, 8);
+  PAD(buffer_vld2_pad, float, 16, 8);
+#endif
   VECT_ARRAY_INIT2(buffer_vld2, float, 32, 4);
   PAD(buffer_vld2_pad, float, 32, 4);
 
@@ -552,6 +368,10 @@ void exec_vldX_dup (void)
   PAD(buffer_vld3_pad, poly, 8, 8);
   VECT_ARRAY_INIT3(buffer_vld3, poly, 16, 4);
   PAD(buffer_vld3_pad, poly, 16, 4);
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+  VECT_ARRAY_INIT3(buffer_vld3, float, 16, 4);
+  PAD(buffer_vld3_pad, float, 16, 4);
+#endif
   VECT_ARRAY_INIT3(buffer_vld3, float, 32, 2);
   PAD(buffer_vld3_pad, float, 32, 2);
 
@@ -575,6 +395,10 @@ void exec_vldX_dup (void)
   PAD(buffer_vld3_pad, poly, 8, 16);
   VECT_ARRAY_INIT3(buffer_vld3, poly, 16, 8);
   PAD(buffer_vld3_pad, poly, 16, 8);
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+  VECT_ARRAY_INIT3(buffer_vld3, float, 16, 8);
+  PAD(buffer_vld3_pad, float, 16, 8);
+#endif
   VECT_ARRAY_INIT3(buffer_vld3, float, 32, 4);
   PAD(buffer_vld3_pad, float, 32, 4);
 
@@ -599,6 +423,10 @@ void exec_vldX_dup (void)
   PAD(buffer_vld4_pad, poly, 8, 8);
   VECT_ARRAY_INIT4(buffer_vld4, poly, 16, 4);
   PAD(buffer_vld4_pad, poly, 16, 4);
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+  VECT_ARRAY_INIT4(buffer_vld4, float, 16, 4);
+  PAD(buffer_vld4_pad, float, 16, 4);
+#endif
   VECT_ARRAY_INIT4(buffer_vld4, float, 32, 2);
   PAD(buffer_vld4_pad, float, 32, 2);
 
@@ -622,6 +450,10 @@ void exec_vldX_dup (void)
   PAD(buffer_vld4_pad, poly, 8, 16);
   VECT_ARRAY_INIT4(buffer_vld4, poly, 16, 8);
   PAD(buffer_vld4_pad, poly, 16, 8);
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+  VECT_ARRAY_INIT4(buffer_vld4, float, 16, 8);
+  PAD(buffer_vld4_pad, float, 16, 8);
+#endif
   VECT_ARRAY_INIT4(buffer_vld4, float, 32, 4);
   PAD(buffer_vld4_pad, float, 32, 4);
 
@@ -629,39 +461,39 @@ void exec_vldX_dup (void)
   clean_results ();
 #define TEST_MSG "VLD2_DUP/VLD2Q_DUP"
   TEST_ALL_VLDX_DUP(2);
-  CHECK_RESULTS_NAMED (TEST_MSG, expected_vld2_0, "chunk 0");
+  CHECK_RESULTS_VLDX_DUP (TEST_MSG, expected_vld2_0, "chunk 0");
 
   TEST_ALL_EXTRA_CHUNKS(2, 1);
-  CHECK_RESULTS_NAMED (TEST_MSG, expected_vld2_1, "chunk 1");
+  CHECK_RESULTS_VLDX_DUP (TEST_MSG, expected_vld2_1, "chunk 1");
 
   /* Check vld3_dup/vld3q_dup.  */
   clean_results ();
 #undef TEST_MSG
 #define TEST_MSG "VLD3_DUP/VLD3Q_DUP"
   TEST_ALL_VLDX_DUP(3);
-  CHECK_RESULTS_NAMED (TEST_MSG, expected_vld3_0, "chunk 0");
+  CHECK_RESULTS_VLDX_DUP (TEST_MSG, expected_vld3_0, "chunk 0");
 
   TEST_ALL_EXTRA_CHUNKS(3, 1);
-  CHECK_RESULTS_NAMED (TEST_MSG, expected_vld3_1, "chunk 1");
+  CHECK_RESULTS_VLDX_DUP (TEST_MSG, expected_vld3_1, "chunk 1");
 
   TEST_ALL_EXTRA_CHUNKS(3, 2);
-  CHECK_RESULTS_NAMED (TEST_MSG, expected_vld3_2, "chunk 2");
+  CHECK_RESULTS_VLDX_DUP (TEST_MSG, expected_vld3_2, "chunk 2");
 
   /* Check vld4_dup/vld4q_dup */
   clean_results ();
 #undef TEST_MSG
 #define TEST_MSG "VLD4_DUP/VLD4Q_DUP"
   TEST_ALL_VLDX_DUP(4);
-  CHECK_RESULTS_NAMED (TEST_MSG, expected_vld4_0, "chunk 0");
+  CHECK_RESULTS_VLDX_DUP (TEST_MSG, expected_vld4_0, "chunk 0");
 
   TEST_ALL_EXTRA_CHUNKS(4, 1);
-  CHECK_RESULTS_NAMED (TEST_MSG, expected_vld4_1, "chunk 1");
+  CHECK_RESULTS_VLDX_DUP (TEST_MSG, expected_vld4_1, "chunk 1");
 
   TEST_ALL_EXTRA_CHUNKS(4, 2);
-  CHECK_RESULTS_NAMED (TEST_MSG, expected_vld4_2, "chunk 2");
+  CHECK_RESULTS_VLDX_DUP (TEST_MSG, expected_vld4_2, "chunk 2");
 
   TEST_ALL_EXTRA_CHUNKS(4, 3);
-  CHECK_RESULTS_NAMED (TEST_MSG, expected_vld4_3, "chunk 3");
+  CHECK_RESULTS_VLDX_DUP (TEST_MSG, expected_vld4_3, "chunk 3");
 }
 
 int main (void)
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vldX_lane.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vldX_lane.c
@@ -9,44 +9,29 @@ VECT_VAR_DECL(expected_vld2_0,int,8,8) [] = { 0xaa, 0xaa, 0xaa, 0xaa,
 					      0xaa, 0xaa, 0xaa, 0xaa };
 VECT_VAR_DECL(expected_vld2_0,int,16,4) [] = { 0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa };
 VECT_VAR_DECL(expected_vld2_0,int,32,2) [] = { 0xfffffff0, 0xfffffff1 };
-VECT_VAR_DECL(expected_vld2_0,int,64,1) [] = { 0x3333333333333333 };
 VECT_VAR_DECL(expected_vld2_0,uint,8,8) [] = { 0xaa, 0xaa, 0xaa, 0xaa,
 					       0xaa, 0xaa, 0xaa, 0xaa };
 VECT_VAR_DECL(expected_vld2_0,uint,16,4) [] = { 0xaaaa, 0xaaaa,
 						0xaaaa, 0xaaaa };
 VECT_VAR_DECL(expected_vld2_0,uint,32,2) [] = { 0xaaaaaaaa, 0xaaaaaaaa };
-VECT_VAR_DECL(expected_vld2_0,uint,64,1) [] = { 0x3333333333333333 };
 VECT_VAR_DECL(expected_vld2_0,poly,8,8) [] = { 0xaa, 0xaa, 0xaa, 0xaa,
 					       0xaa, 0xaa, 0xaa, 0xaa };
 VECT_VAR_DECL(expected_vld2_0,poly,16,4) [] = { 0xaaaa, 0xaaaa,
 						0xaaaa, 0xaaaa };
+VECT_VAR_DECL(expected_vld2_0,hfloat,16,4) [] = { 0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa };
 VECT_VAR_DECL(expected_vld2_0,hfloat,32,2) [] = { 0xc1800000, 0xc1700000 };
-VECT_VAR_DECL(expected_vld2_0,int,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					       0x33, 0x33, 0x33, 0x33,
-					       0x33, 0x33, 0x33, 0x33,
-					       0x33, 0x33, 0x33, 0x33 };
 VECT_VAR_DECL(expected_vld2_0,int,16,8) [] = { 0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa,
 					       0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa };
 VECT_VAR_DECL(expected_vld2_0,int,32,4) [] = { 0xaaaaaaaa, 0xaaaaaaaa,
 					       0xaaaaaaaa, 0xaaaaaaaa };
-VECT_VAR_DECL(expected_vld2_0,int,64,2) [] = { 0x3333333333333333,
-					       0x3333333333333333 };
-VECT_VAR_DECL(expected_vld2_0,uint,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33 };
 VECT_VAR_DECL(expected_vld2_0,uint,16,8) [] = { 0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa,
 						0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa };
 VECT_VAR_DECL(expected_vld2_0,uint,32,4) [] = { 0xfffffff0, 0xfffffff1,
 						0xaaaaaaaa, 0xaaaaaaaa };
-VECT_VAR_DECL(expected_vld2_0,uint,64,2) [] = { 0x3333333333333333,
-						0x3333333333333333 };
-VECT_VAR_DECL(expected_vld2_0,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33 };
 VECT_VAR_DECL(expected_vld2_0,poly,16,8) [] = { 0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa,
 						0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa };
+VECT_VAR_DECL(expected_vld2_0,hfloat,16,8) [] = { 0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa,
+						  0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa } ;
 VECT_VAR_DECL(expected_vld2_0,hfloat,32,4) [] = { 0xaaaaaaaa, 0xaaaaaaaa,
 						  0xaaaaaaaa, 0xaaaaaaaa };
 
@@ -55,42 +40,27 @@ VECT_VAR_DECL(expected_vld2_1,int,8,8) [] = { 0xaa, 0xaa, 0xaa, 0xaa,
 					      0xaa, 0xaa, 0xf0, 0xf1 };
 VECT_VAR_DECL(expected_vld2_1,int,16,4) [] = { 0xfff0, 0xfff1, 0xaaaa, 0xaaaa };
 VECT_VAR_DECL(expected_vld2_1,int,32,2) [] = { 0xaaaaaaaa, 0xaaaaaaaa };
-VECT_VAR_DECL(expected_vld2_1,int,64,1) [] = { 0x3333333333333333 };
 VECT_VAR_DECL(expected_vld2_1,uint,8,8) [] = { 0xf0, 0xf1, 0xaa, 0xaa,
 					       0xaa, 0xaa, 0xaa, 0xaa };
 VECT_VAR_DECL(expected_vld2_1,uint,16,4) [] = { 0xaaaa, 0xaaaa, 0xfff0, 0xfff1 };
 VECT_VAR_DECL(expected_vld2_1,uint,32,2) [] = { 0xfffffff0, 0xfffffff1 };
-VECT_VAR_DECL(expected_vld2_1,uint,64,1) [] = { 0x3333333333333333 };
 VECT_VAR_DECL(expected_vld2_1,poly,8,8) [] = { 0xf0, 0xf1, 0xaa, 0xaa,
 					       0xaa, 0xaa, 0xaa, 0xaa };
 VECT_VAR_DECL(expected_vld2_1,poly,16,4) [] = { 0xaaaa, 0xaaaa, 0xfff0, 0xfff1 };
+VECT_VAR_DECL(expected_vld2_1,hfloat,16,4) [] = { 0xcc00, 0xcb80, 0xaaaa, 0xaaaa };
 VECT_VAR_DECL(expected_vld2_1,hfloat,32,2) [] = { 0xaaaaaaaa, 0xaaaaaaaa };
-VECT_VAR_DECL(expected_vld2_1,int,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					       0x33, 0x33, 0x33, 0x33,
-					       0x33, 0x33, 0x33, 0x33,
-					       0x33, 0x33, 0x33, 0x33 };
 VECT_VAR_DECL(expected_vld2_1,int,16,8) [] = { 0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa,
 					       0xfff0, 0xfff1, 0xaaaa, 0xaaaa };
 VECT_VAR_DECL(expected_vld2_1,int,32,4) [] = { 0xfffffff0, 0xfffffff1,
 					       0xaaaaaaaa, 0xaaaaaaaa };
-VECT_VAR_DECL(expected_vld2_1,int,64,2) [] = { 0x3333333333333333,
-					       0x3333333333333333 };
-VECT_VAR_DECL(expected_vld2_1,uint,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33 };
 VECT_VAR_DECL(expected_vld2_1,uint,16,8) [] = { 0xaaaa, 0xaaaa, 0xfff0, 0xfff1,
 						0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa };
 VECT_VAR_DECL(expected_vld2_1,uint,32,4) [] = { 0xaaaaaaaa, 0xaaaaaaaa,
 						0xaaaaaaaa, 0xaaaaaaaa };
-VECT_VAR_DECL(expected_vld2_1,uint,64,2) [] = { 0x3333333333333333,
-						0x3333333333333333 };
-VECT_VAR_DECL(expected_vld2_1,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33 };
 VECT_VAR_DECL(expected_vld2_1,poly,16,8) [] = { 0xaaaa, 0xaaaa, 0xfff0, 0xfff1,
 						0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa };
+VECT_VAR_DECL(expected_vld2_1,hfloat,16,8) [] = { 0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa,
+						  0xcc00, 0xcb80, 0xaaaa, 0xaaaa };
 VECT_VAR_DECL(expected_vld2_1,hfloat,32,4) [] = { 0xc1800000, 0xc1700000,
 						  0xaaaaaaaa, 0xaaaaaaaa };
 
@@ -99,42 +69,27 @@ VECT_VAR_DECL(expected_vld3_0,int,8,8) [] = { 0xaa, 0xaa, 0xaa, 0xaa,
 					      0xaa, 0xaa, 0xaa, 0xaa };
 VECT_VAR_DECL(expected_vld3_0,int,16,4) [] = { 0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa };
 VECT_VAR_DECL(expected_vld3_0,int,32,2) [] = { 0xfffffff0, 0xfffffff1 };
-VECT_VAR_DECL(expected_vld3_0,int,64,1) [] = { 0x3333333333333333 };
 VECT_VAR_DECL(expected_vld3_0,uint,8,8) [] = { 0xaa, 0xaa, 0xaa, 0xaa,
 					       0xaa, 0xaa, 0xaa, 0xaa };
 VECT_VAR_DECL(expected_vld3_0,uint,16,4) [] = { 0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa };
 VECT_VAR_DECL(expected_vld3_0,uint,32,2) [] = { 0xaaaaaaaa, 0xaaaaaaaa };
-VECT_VAR_DECL(expected_vld3_0,uint,64,1) [] = { 0x3333333333333333 };
 VECT_VAR_DECL(expected_vld3_0,poly,8,8) [] = { 0xaa, 0xaa, 0xaa, 0xaa,
 					       0xaa, 0xaa, 0xaa, 0xaa };
 VECT_VAR_DECL(expected_vld3_0,poly,16,4) [] = { 0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa };
+VECT_VAR_DECL(expected_vld3_0,hfloat,16,4) [] = { 0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa };
 VECT_VAR_DECL(expected_vld3_0,hfloat,32,2) [] = { 0xc1800000, 0xc1700000 };
-VECT_VAR_DECL(expected_vld3_0,int,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					       0x33, 0x33, 0x33, 0x33,
-					       0x33, 0x33, 0x33, 0x33,
-					       0x33, 0x33, 0x33, 0x33 };
 VECT_VAR_DECL(expected_vld3_0,int,16,8) [] = { 0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa,
 					       0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa };
 VECT_VAR_DECL(expected_vld3_0,int,32,4) [] = { 0xaaaaaaaa, 0xaaaaaaaa,
 					       0xaaaaaaaa, 0xaaaaaaaa };
-VECT_VAR_DECL(expected_vld3_0,int,64,2) [] = { 0x3333333333333333,
-					       0x3333333333333333 };
-VECT_VAR_DECL(expected_vld3_0,uint,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33 };
 VECT_VAR_DECL(expected_vld3_0,uint,16,8) [] = { 0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa,
 						0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa };
 VECT_VAR_DECL(expected_vld3_0,uint,32,4) [] = { 0xfffffff0, 0xfffffff1,
 						0xfffffff2, 0xaaaaaaaa };
-VECT_VAR_DECL(expected_vld3_0,uint,64,2) [] = { 0x3333333333333333,
-						0x3333333333333333 };
-VECT_VAR_DECL(expected_vld3_0,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33 };
 VECT_VAR_DECL(expected_vld3_0,poly,16,8) [] = { 0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa,
 						0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa };
+VECT_VAR_DECL(expected_vld3_0,hfloat,16,8) [] = { 0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa,
+						  0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa };
 VECT_VAR_DECL(expected_vld3_0,hfloat,32,4) [] = { 0xaaaaaaaa, 0xaaaaaaaa,
 						  0xaaaaaaaa, 0xaaaaaaaa };
 
@@ -143,42 +98,27 @@ VECT_VAR_DECL(expected_vld3_1,int,8,8) [] = { 0xaa, 0xaa, 0xaa, 0xaa,
 					      0xaa, 0xaa, 0xaa, 0xaa };
 VECT_VAR_DECL(expected_vld3_1,int,16,4) [] = { 0xaaaa, 0xaaaa, 0xfff0, 0xfff1 };
 VECT_VAR_DECL(expected_vld3_1,int,32,2) [] = { 0xfffffff2, 0xaaaaaaaa };
-VECT_VAR_DECL(expected_vld3_1,int,64,1) [] = { 0x3333333333333333 };
 VECT_VAR_DECL(expected_vld3_1,uint,8,8) [] = { 0xaa, 0xaa, 0xaa, 0xaa,
 					       0xf0, 0xf1, 0xf2, 0xaa };
 VECT_VAR_DECL(expected_vld3_1,uint,16,4) [] = { 0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa };
 VECT_VAR_DECL(expected_vld3_1,uint,32,2) [] = { 0xaaaaaaaa, 0xfffffff0 };
-VECT_VAR_DECL(expected_vld3_1,uint,64,1) [] = { 0x3333333333333333 };
 VECT_VAR_DECL(expected_vld3_1,poly,8,8) [] = { 0xaa, 0xaa, 0xaa, 0xaa,
 					       0xf0, 0xf1, 0xf2, 0xaa };
 VECT_VAR_DECL(expected_vld3_1,poly,16,4) [] = { 0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa };
+VECT_VAR_DECL(expected_vld3_1,hfloat,16,4) [] = { 0xaaaa, 0xaaaa, 0xcc00, 0xcb80 };
 VECT_VAR_DECL(expected_vld3_1,hfloat,32,2) [] = { 0xc1600000, 0xaaaaaaaa };
-VECT_VAR_DECL(expected_vld3_1,int,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					       0x33, 0x33, 0x33, 0x33,
-					       0x33, 0x33, 0x33, 0x33,
-					       0x33, 0x33, 0x33, 0x33 };
 VECT_VAR_DECL(expected_vld3_1,int,16,8) [] = { 0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa,
 					       0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa };
 VECT_VAR_DECL(expected_vld3_1,int,32,4) [] = { 0xaaaaaaaa, 0xaaaaaaaa,
 					       0xfffffff0, 0xfffffff1 };
-VECT_VAR_DECL(expected_vld3_1,int,64,2) [] = { 0x3333333333333333,
-					       0x3333333333333333 };
-VECT_VAR_DECL(expected_vld3_1,uint,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33 };
 VECT_VAR_DECL(expected_vld3_1,uint,16,8) [] = { 0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa,
 						0xaaaa, 0xaaaa, 0xaaaa, 0xfff0 };
 VECT_VAR_DECL(expected_vld3_1,uint,32,4) [] = { 0xaaaaaaaa, 0xaaaaaaaa,
 						0xaaaaaaaa, 0xaaaaaaaa };
-VECT_VAR_DECL(expected_vld3_1,uint,64,2) [] = { 0x3333333333333333,
-						0x3333333333333333 };
-VECT_VAR_DECL(expected_vld3_1,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33 };
 VECT_VAR_DECL(expected_vld3_1,poly,16,8) [] = { 0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa,
 						0xaaaa, 0xaaaa, 0xaaaa, 0xfff0 };
+VECT_VAR_DECL(expected_vld3_1,hfloat,16,8) [] = { 0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa,
+						  0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa };
 VECT_VAR_DECL(expected_vld3_1,hfloat,32,4) [] = { 0xaaaaaaaa, 0xaaaaaaaa,
 						  0xc1800000, 0xc1700000 };
 
@@ -187,42 +127,27 @@ VECT_VAR_DECL(expected_vld3_2,int,8,8) [] = { 0xaa, 0xaa, 0xaa, 0xaa,
 					      0xaa, 0xf0, 0xf1, 0xf2 };
 VECT_VAR_DECL(expected_vld3_2,int,16,4) [] = { 0xfff2, 0xaaaa, 0xaaaa, 0xaaaa };
 VECT_VAR_DECL(expected_vld3_2,int,32,2) [] = { 0xaaaaaaaa, 0xaaaaaaaa };
-VECT_VAR_DECL(expected_vld3_2,int,64,1) [] = { 0x3333333333333333 };
 VECT_VAR_DECL(expected_vld3_2,uint,8,8) [] = { 0xaa, 0xaa, 0xaa, 0xaa,
 					       0xaa, 0xaa, 0xaa, 0xaa };
 VECT_VAR_DECL(expected_vld3_2,uint,16,4) [] = { 0xaaaa, 0xfff0, 0xfff1, 0xfff2 };
 VECT_VAR_DECL(expected_vld3_2,uint,32,2) [] = { 0xfffffff1, 0xfffffff2 };
-VECT_VAR_DECL(expected_vld3_2,uint,64,1) [] = { 0x3333333333333333 };
 VECT_VAR_DECL(expected_vld3_2,poly,8,8) [] = { 0xaa, 0xaa, 0xaa, 0xaa,
 					       0xaa, 0xaa, 0xaa, 0xaa };
 VECT_VAR_DECL(expected_vld3_2,poly,16,4) [] = { 0xaaaa, 0xfff0, 0xfff1, 0xfff2 };
+VECT_VAR_DECL(expected_vld3_2,hfloat,16,4) [] = { 0xcb00, 0xaaaa, 0xaaaa, 0xaaaa };
 VECT_VAR_DECL(expected_vld3_2,hfloat,32,2) [] = { 0xaaaaaaaa, 0xaaaaaaaa };
-VECT_VAR_DECL(expected_vld3_2,int,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					       0x33, 0x33, 0x33, 0x33,
-					       0x33, 0x33, 0x33, 0x33,
-					       0x33, 0x33, 0x33, 0x33 };
 VECT_VAR_DECL(expected_vld3_2,int,16,8) [] = { 0xaaaa, 0xaaaa, 0xfff0, 0xfff1,
 					       0xfff2, 0xaaaa, 0xaaaa, 0xaaaa };
 VECT_VAR_DECL(expected_vld3_2,int,32,4) [] = { 0xfffffff2, 0xaaaaaaaa,
 					       0xaaaaaaaa, 0xaaaaaaaa };
-VECT_VAR_DECL(expected_vld3_2,int,64,2) [] = { 0x3333333333333333,
-					       0x3333333333333333 };
-VECT_VAR_DECL(expected_vld3_2,uint,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33 };
 VECT_VAR_DECL(expected_vld3_2,uint,16,8) [] = { 0xfff1, 0xfff2, 0xaaaa, 0xaaaa,
 						0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa };
 VECT_VAR_DECL(expected_vld3_2,uint,32,4) [] = { 0xaaaaaaaa, 0xaaaaaaaa,
 						0xaaaaaaaa, 0xaaaaaaaa };
-VECT_VAR_DECL(expected_vld3_2,uint,64,2) [] = { 0x3333333333333333,
-						0x3333333333333333 };
-VECT_VAR_DECL(expected_vld3_2,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33 };
 VECT_VAR_DECL(expected_vld3_2,poly,16,8) [] = { 0xfff1, 0xfff2, 0xaaaa, 0xaaaa,
 						0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa };
+VECT_VAR_DECL(expected_vld3_2,hfloat,16,8) [] = { 0xaaaa, 0xaaaa, 0xcc00, 0xcb80,
+						  0xcb00, 0xaaaa, 0xaaaa, 0xaaaa };
 VECT_VAR_DECL(expected_vld3_2,hfloat,32,4) [] = { 0xc1600000, 0xaaaaaaaa,
 						  0xaaaaaaaa, 0xaaaaaaaa };
 
@@ -231,42 +156,27 @@ VECT_VAR_DECL(expected_vld4_0,int,8,8) [] = { 0xaa, 0xaa, 0xaa, 0xaa,
 					      0xaa, 0xaa, 0xaa, 0xaa };
 VECT_VAR_DECL(expected_vld4_0,int,16,4) [] = { 0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa };
 VECT_VAR_DECL(expected_vld4_0,int,32,2) [] = { 0xfffffff0, 0xfffffff1 };
-VECT_VAR_DECL(expected_vld4_0,int,64,1) [] = { 0x3333333333333333 };
 VECT_VAR_DECL(expected_vld4_0,uint,8,8) [] = { 0xaa, 0xaa, 0xaa, 0xaa,
 					       0xaa, 0xaa, 0xaa, 0xaa };
 VECT_VAR_DECL(expected_vld4_0,uint,16,4) [] = { 0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa };
 VECT_VAR_DECL(expected_vld4_0,uint,32,2) [] = { 0xaaaaaaaa, 0xaaaaaaaa };
-VECT_VAR_DECL(expected_vld4_0,uint,64,1) [] = { 0x3333333333333333 };
 VECT_VAR_DECL(expected_vld4_0,poly,8,8) [] = { 0xaa, 0xaa, 0xaa, 0xaa,
 					       0xaa, 0xaa, 0xaa, 0xaa };
 VECT_VAR_DECL(expected_vld4_0,poly,16,4) [] = { 0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa };
+VECT_VAR_DECL(expected_vld4_0,hfloat,16,4) [] = { 0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa };
 VECT_VAR_DECL(expected_vld4_0,hfloat,32,2) [] = { 0xc1800000, 0xc1700000 };
-VECT_VAR_DECL(expected_vld4_0,int,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					       0x33, 0x33, 0x33, 0x33,
-					       0x33, 0x33, 0x33, 0x33,
-					       0x33, 0x33, 0x33, 0x33 };
 VECT_VAR_DECL(expected_vld4_0,int,16,8) [] = { 0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa,
 					       0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa };
 VECT_VAR_DECL(expected_vld4_0,int,32,4) [] = { 0xaaaaaaaa, 0xaaaaaaaa,
 					       0xaaaaaaaa, 0xaaaaaaaa };
-VECT_VAR_DECL(expected_vld4_0,int,64,2) [] = { 0x3333333333333333,
-					       0x3333333333333333 };
-VECT_VAR_DECL(expected_vld4_0,uint,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33 };
 VECT_VAR_DECL(expected_vld4_0,uint,16,8) [] = { 0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa,
 						0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa };
 VECT_VAR_DECL(expected_vld4_0,uint,32,4) [] = { 0xfffffff0, 0xfffffff1,
 						0xfffffff2, 0xfffffff3 };
-VECT_VAR_DECL(expected_vld4_0,uint,64,2) [] = { 0x3333333333333333,
-						0x3333333333333333 };
-VECT_VAR_DECL(expected_vld4_0,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33 };
 VECT_VAR_DECL(expected_vld4_0,poly,16,8) [] = { 0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa,
 						0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa };
+VECT_VAR_DECL(expected_vld4_0,hfloat,16,8) [] = { 0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa,
+						  0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa };
 VECT_VAR_DECL(expected_vld4_0,hfloat,32,4) [] = { 0xaaaaaaaa, 0xaaaaaaaa,
 						  0xaaaaaaaa, 0xaaaaaaaa };
 
@@ -275,42 +185,27 @@ VECT_VAR_DECL(expected_vld4_1,int,8,8) [] = { 0xaa, 0xaa, 0xaa, 0xaa,
 					      0xaa, 0xaa, 0xaa, 0xaa };
 VECT_VAR_DECL(expected_vld4_1,int,16,4) [] = { 0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa };
 VECT_VAR_DECL(expected_vld4_1,int,32,2) [] = { 0xfffffff2, 0xfffffff3 };
-VECT_VAR_DECL(expected_vld4_1,int,64,1) [] = { 0x3333333333333333 };
 VECT_VAR_DECL(expected_vld4_1,uint,8,8) [] = { 0xaa, 0xaa, 0xaa, 0xaa,
 					       0xaa, 0xaa, 0xaa, 0xaa };
 VECT_VAR_DECL(expected_vld4_1,uint,16,4) [] = { 0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa };
 VECT_VAR_DECL(expected_vld4_1,uint,32,2) [] = { 0xaaaaaaaa, 0xaaaaaaaa };
-VECT_VAR_DECL(expected_vld4_1,uint,64,1) [] = { 0x3333333333333333 };
 VECT_VAR_DECL(expected_vld4_1,poly,8,8) [] = { 0xaa, 0xaa, 0xaa, 0xaa,
 					       0xaa, 0xaa, 0xaa, 0xaa };
 VECT_VAR_DECL(expected_vld4_1,poly,16,4) [] = { 0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa };
+VECT_VAR_DECL(expected_vld4_1,hfloat,16,4) [] = { 0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa };
 VECT_VAR_DECL(expected_vld4_1,hfloat,32,2) [] = { 0xc1600000, 0xc1500000 };
-VECT_VAR_DECL(expected_vld4_1,int,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					       0x33, 0x33, 0x33, 0x33,
-					       0x33, 0x33, 0x33, 0x33,
-					       0x33, 0x33, 0x33, 0x33 };
 VECT_VAR_DECL(expected_vld4_1,int,16,8) [] = { 0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa,
 					       0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa };
 VECT_VAR_DECL(expected_vld4_1,int,32,4) [] = { 0xaaaaaaaa, 0xaaaaaaaa,
 					       0xaaaaaaaa, 0xaaaaaaaa };
-VECT_VAR_DECL(expected_vld4_1,int,64,2) [] = { 0x3333333333333333,
-					       0x3333333333333333 };
-VECT_VAR_DECL(expected_vld4_1,uint,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33 };
 VECT_VAR_DECL(expected_vld4_1,uint,16,8) [] = { 0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa,
 						0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa };
 VECT_VAR_DECL(expected_vld4_1,uint,32,4) [] = { 0xaaaaaaaa, 0xaaaaaaaa,
 						0xaaaaaaaa, 0xaaaaaaaa };
-VECT_VAR_DECL(expected_vld4_1,uint,64,2) [] = { 0x3333333333333333,
-						0x3333333333333333 };
-VECT_VAR_DECL(expected_vld4_1,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33 };
 VECT_VAR_DECL(expected_vld4_1,poly,16,8) [] = { 0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa,
 						0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa };
+VECT_VAR_DECL(expected_vld4_1,hfloat,16,8) [] = { 0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa,
+						  0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa };
 VECT_VAR_DECL(expected_vld4_1,hfloat,32,4) [] = { 0xaaaaaaaa, 0xaaaaaaaa,
 						  0xaaaaaaaa, 0xaaaaaaaa };
 
@@ -319,42 +214,27 @@ VECT_VAR_DECL(expected_vld4_2,int,8,8) [] = { 0xaa, 0xaa, 0xaa, 0xaa,
 					      0xaa, 0xaa, 0xaa, 0xaa };
 VECT_VAR_DECL(expected_vld4_2,int,16,4) [] = { 0xfff0, 0xfff1, 0xfff2, 0xfff3 };
 VECT_VAR_DECL(expected_vld4_2,int,32,2) [] = { 0xaaaaaaaa, 0xaaaaaaaa };
-VECT_VAR_DECL(expected_vld4_2,int,64,1) [] = { 0x3333333333333333 };
 VECT_VAR_DECL(expected_vld4_2,uint,8,8) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
 					       0xaa, 0xaa, 0xaa, 0xaa };
 VECT_VAR_DECL(expected_vld4_2,uint,16,4) [] = { 0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa };
 VECT_VAR_DECL(expected_vld4_2,uint,32,2) [] = { 0xfffffff0, 0xfffffff1 };
-VECT_VAR_DECL(expected_vld4_2,uint,64,1) [] = { 0x3333333333333333 };
 VECT_VAR_DECL(expected_vld4_2,poly,8,8) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
 					       0xaa, 0xaa, 0xaa, 0xaa };
 VECT_VAR_DECL(expected_vld4_2,poly,16,4) [] = { 0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa };
+VECT_VAR_DECL(expected_vld4_2,hfloat,16,4) [] = { 0xcc00, 0xcb80, 0xcb00, 0xca80 };
 VECT_VAR_DECL(expected_vld4_2,hfloat,32,2) [] = { 0xaaaaaaaa, 0xaaaaaaaa };
-VECT_VAR_DECL(expected_vld4_2,int,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					       0x33, 0x33, 0x33, 0x33,
-					       0x33, 0x33, 0x33, 0x33,
-					       0x33, 0x33, 0x33, 0x33 };
 VECT_VAR_DECL(expected_vld4_2,int,16,8) [] = { 0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa,
 					       0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa };
 VECT_VAR_DECL(expected_vld4_2,int,32,4) [] = { 0xfffffff0, 0xfffffff1,
 					       0xfffffff2, 0xfffffff3 };
-VECT_VAR_DECL(expected_vld4_2,int,64,2) [] = { 0x3333333333333333,
-					       0x3333333333333333 };
-VECT_VAR_DECL(expected_vld4_2,uint,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33 };
 VECT_VAR_DECL(expected_vld4_2,uint,16,8) [] = { 0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa,
 						0xfff0, 0xfff1, 0xfff2, 0xfff3 };
 VECT_VAR_DECL(expected_vld4_2,uint,32,4) [] = { 0xaaaaaaaa, 0xaaaaaaaa,
 						0xaaaaaaaa, 0xaaaaaaaa };
-VECT_VAR_DECL(expected_vld4_2,uint,64,2) [] = { 0x3333333333333333,
-						0x3333333333333333 };
-VECT_VAR_DECL(expected_vld4_2,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33 };
 VECT_VAR_DECL(expected_vld4_2,poly,16,8) [] = { 0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa,
 						0xfff0, 0xfff1, 0xfff2, 0xfff3 };
+VECT_VAR_DECL(expected_vld4_2,hfloat,16,8) [] = { 0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa,
+						  0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa };
 VECT_VAR_DECL(expected_vld4_2,hfloat,32,4) [] = { 0xc1800000, 0xc1700000,
 						  0xc1600000, 0xc1500000 };
 
@@ -363,42 +243,27 @@ VECT_VAR_DECL(expected_vld4_3,int,8,8) [] = { 0xaa, 0xaa, 0xaa, 0xaa,
 					      0xf0, 0xf1, 0xf2, 0xf3 };
 VECT_VAR_DECL(expected_vld4_3,int,16,4) [] = { 0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa };
 VECT_VAR_DECL(expected_vld4_3,int,32,2) [] = { 0xaaaaaaaa, 0xaaaaaaaa };
-VECT_VAR_DECL(expected_vld4_3,int,64,1) [] = { 0x3333333333333333 };
 VECT_VAR_DECL(expected_vld4_3,uint,8,8) [] = { 0xaa, 0xaa, 0xaa, 0xaa,
 					       0xaa, 0xaa, 0xaa, 0xaa };
 VECT_VAR_DECL(expected_vld4_3,uint,16,4) [] = { 0xfff0, 0xfff1, 0xfff2, 0xfff3 };
 VECT_VAR_DECL(expected_vld4_3,uint,32,2) [] = { 0xfffffff2, 0xfffffff3 };
-VECT_VAR_DECL(expected_vld4_3,uint,64,1) [] = { 0x3333333333333333 };
 VECT_VAR_DECL(expected_vld4_3,poly,8,8) [] = { 0xaa, 0xaa, 0xaa, 0xaa,
 					       0xaa, 0xaa, 0xaa, 0xaa };
 VECT_VAR_DECL(expected_vld4_3,poly,16,4) [] = { 0xfff0, 0xfff1, 0xfff2, 0xfff3 };
+VECT_VAR_DECL(expected_vld4_3,hfloat,16,4) [] = { 0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa };
 VECT_VAR_DECL(expected_vld4_3,hfloat,32,2) [] = { 0xaaaaaaaa, 0xaaaaaaaa };
-VECT_VAR_DECL(expected_vld4_3,int,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					       0x33, 0x33, 0x33, 0x33,
-					       0x33, 0x33, 0x33, 0x33,
-					       0x33, 0x33, 0x33, 0x33 };
 VECT_VAR_DECL(expected_vld4_3,int,16,8) [] = { 0xfff0, 0xfff1, 0xfff2, 0xfff3,
 					       0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa };
 VECT_VAR_DECL(expected_vld4_3,int,32,4) [] = { 0xaaaaaaaa, 0xaaaaaaaa,
 					       0xaaaaaaaa, 0xaaaaaaaa };
-VECT_VAR_DECL(expected_vld4_3,int,64,2) [] = { 0x3333333333333333,
-					       0x3333333333333333 };
-VECT_VAR_DECL(expected_vld4_3,uint,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33 };
 VECT_VAR_DECL(expected_vld4_3,uint,16,8) [] = { 0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa,
 						0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa };
 VECT_VAR_DECL(expected_vld4_3,uint,32,4) [] = { 0xaaaaaaaa, 0xaaaaaaaa,
 						0xaaaaaaaa, 0xaaaaaaaa };
-VECT_VAR_DECL(expected_vld4_3,uint,64,2) [] = { 0x3333333333333333,
-						0x3333333333333333 };
-VECT_VAR_DECL(expected_vld4_3,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33,
-						0x33, 0x33, 0x33, 0x33 };
 VECT_VAR_DECL(expected_vld4_3,poly,16,8) [] = { 0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa,
 						0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa };
+VECT_VAR_DECL(expected_vld4_3,hfloat,16,8) [] = { 0xcc00, 0xcb80, 0xcb00, 0xca80,
+						  0xaaaa, 0xaaaa, 0xaaaa, 0xaaaa };
 VECT_VAR_DECL(expected_vld4_3,hfloat,32,4) [] = { 0xaaaaaaaa, 0xaaaaaaaa,
 						  0xaaaaaaaa, 0xaaaaaaaa };
 
@@ -414,6 +279,9 @@ VECT_VAR_DECL_INIT(buffer_vld2_lane, uint, 32, 2);
 VECT_VAR_DECL_INIT(buffer_vld2_lane, uint, 64, 2);
 VECT_VAR_DECL_INIT(buffer_vld2_lane, poly, 8, 2);
 VECT_VAR_DECL_INIT(buffer_vld2_lane, poly, 16, 2);
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+VECT_VAR_DECL_INIT(buffer_vld2_lane, float, 16, 2);
+#endif
 VECT_VAR_DECL_INIT(buffer_vld2_lane, float, 32, 2);
 
 /* Input buffers for vld3_lane */
@@ -427,6 +295,9 @@ VECT_VAR_DECL_INIT(buffer_vld3_lane, uint, 32, 3);
 VECT_VAR_DECL_INIT(buffer_vld3_lane, uint, 64, 3);
 VECT_VAR_DECL_INIT(buffer_vld3_lane, poly, 8, 3);
 VECT_VAR_DECL_INIT(buffer_vld3_lane, poly, 16, 3);
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+VECT_VAR_DECL_INIT(buffer_vld3_lane, float, 16, 3);
+#endif
 VECT_VAR_DECL_INIT(buffer_vld3_lane, float, 32, 3);
 
 /* Input buffers for vld4_lane */
@@ -440,6 +311,9 @@ VECT_VAR_DECL_INIT(buffer_vld4_lane, uint, 32, 4);
 VECT_VAR_DECL_INIT(buffer_vld4_lane, uint, 64, 4);
 VECT_VAR_DECL_INIT(buffer_vld4_lane, poly, 8, 4);
 VECT_VAR_DECL_INIT(buffer_vld4_lane, poly, 16, 4);
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+VECT_VAR_DECL_INIT(buffer_vld4_lane, float, 16, 4);
+#endif
 VECT_VAR_DECL_INIT(buffer_vld4_lane, float, 32, 4);
 
 void exec_vldX_lane (void)
@@ -483,7 +357,7 @@ void exec_vldX_lane (void)
 	 sizeof(VECT_VAR(result, T1, W, N)));
 
   /* We need all variants in 64 bits, but there is no 64x2 variant.  */
-#define DECL_ALL_VLDX_LANE(X)			\
+#define DECL_ALL_VLDX_LANE_NO_FP16(X)		\
   DECL_VLDX_LANE(int, 8, 8, X);			\
   DECL_VLDX_LANE(int, 16, 4, X);		\
   DECL_VLDX_LANE(int, 32, 2, X);		\
@@ -500,6 +374,15 @@ void exec_vldX_lane (void)
   DECL_VLDX_LANE(float, 32, 2, X);		\
   DECL_VLDX_LANE(float, 32, 4, X)
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+#define DECL_ALL_VLDX_LANE(X)		\
+  DECL_ALL_VLDX_LANE_NO_FP16(X);	\
+  DECL_VLDX_LANE(float, 16, 4, X);	\
+  DECL_VLDX_LANE(float, 16, 8, X)
+#else
+#define DECL_ALL_VLDX_LANE(X) DECL_ALL_VLDX_LANE_NO_FP16(X)
+#endif
+
   /* Add some padding to try to catch out of bound accesses.  */
 #define ARRAY1(V, T, W, N) VECT_VAR_DECL(V,T,W,N)[1]={42}
 #define DUMMY_ARRAY(V, T, W, N, L) \
@@ -508,7 +391,7 @@ void exec_vldX_lane (void)
 
   /* Use the same lanes regardless of the size of the array (X), for
      simplicity.  */
-#define TEST_ALL_VLDX_LANE(X)			\
+#define TEST_ALL_VLDX_LANE_NO_FP16(X)		\
   TEST_VLDX_LANE(, int, s, 8, 8, X, 7);		\
   TEST_VLDX_LANE(, int, s, 16, 4, X, 2);	\
   TEST_VLDX_LANE(, int, s, 32, 2, X, 0);	\
@@ -525,7 +408,16 @@ void exec_vldX_lane (void)
   TEST_VLDX_LANE(, float, f, 32, 2, X, 0);	\
   TEST_VLDX_LANE(q, float, f, 32, 4, X, 2)
 
-#define TEST_ALL_EXTRA_CHUNKS(X, Y)		\
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+#define TEST_ALL_VLDX_LANE(X)			\
+  TEST_ALL_VLDX_LANE_NO_FP16(X);		\
+  TEST_VLDX_LANE(, float, f, 16, 4, X, 2);	\
+  TEST_VLDX_LANE(q, float, f, 16, 8, X, 6)
+#else
+#define TEST_ALL_VLDX_LANE(X) TEST_ALL_VLDX_LANE_NO_FP16(X)
+#endif
+
+#define TEST_ALL_EXTRA_CHUNKS_NO_FP16(X,Y)	\
   TEST_EXTRA_CHUNK(int, 8, 8, X, Y);		\
   TEST_EXTRA_CHUNK(int, 16, 4, X, Y);		\
   TEST_EXTRA_CHUNK(int, 32, 2, X, Y);		\
@@ -542,6 +434,47 @@ void exec_vldX_lane (void)
   TEST_EXTRA_CHUNK(float, 32, 2, X, Y);		\
   TEST_EXTRA_CHUNK(float, 32, 4, X, Y)
 
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+#define TEST_ALL_EXTRA_CHUNKS(X,Y)		\
+  TEST_ALL_EXTRA_CHUNKS_NO_FP16(X, Y);		\
+  TEST_EXTRA_CHUNK(float, 16, 4, X, Y);		\
+  TEST_EXTRA_CHUNK(float, 16, 8, X, Y)
+#else
+#define TEST_ALL_EXTRA_CHUNKS(X,Y) TEST_ALL_EXTRA_CHUNKS_NO_FP16(X, Y)
+#endif
+
+  /* vldX_lane supports only a subset of all variants.  */
+#define CHECK_RESULTS_VLDX_LANE_NO_FP16(test_name,EXPECTED,comment)	\
+    CHECK(test_name, int, 8, 8, PRIx8, EXPECTED, comment);		\
+    CHECK(test_name, int, 16, 4, PRIx16, EXPECTED, comment);		\
+    CHECK(test_name, int, 32, 2, PRIx32, EXPECTED, comment);		\
+    CHECK(test_name, uint, 8, 8, PRIx8, EXPECTED, comment);		\
+    CHECK(test_name, uint, 16, 4, PRIx16, EXPECTED, comment);		\
+    CHECK(test_name, uint, 32, 2, PRIx32, EXPECTED, comment);		\
+    CHECK(test_name, poly, 8, 8, PRIx8, EXPECTED, comment);		\
+    CHECK(test_name, poly, 16, 4, PRIx16, EXPECTED, comment);		\
+    CHECK_FP(test_name, float, 32, 2, PRIx32, EXPECTED, comment);	\
+    CHECK(test_name, int, 16, 8, PRIx16, EXPECTED, comment);		\
+    CHECK(test_name, int, 32, 4, PRIx32, EXPECTED, comment);		\
+    CHECK(test_name, uint, 16, 8, PRIx16, EXPECTED, comment);		\
+    CHECK(test_name, uint, 32, 4, PRIx32, EXPECTED, comment);		\
+    CHECK(test_name, poly, 16, 8, PRIx16, EXPECTED, comment);		\
+    CHECK_FP(test_name, float, 32, 4, PRIx32, EXPECTED, comment)
+
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+#define CHECK_RESULTS_VLDX_LANE(test_name,EXPECTED,comment)		\
+  {									\
+    CHECK_RESULTS_VLDX_LANE_NO_FP16(test_name,EXPECTED,comment);	\
+    CHECK_FP(test_name, float, 16, 4, PRIx16, EXPECTED, comment);	\
+    CHECK_FP(test_name, float, 16, 8, PRIx16, EXPECTED, comment);	\
+  }
+#else
+#define CHECK_RESULTS_VLDX_LANE(test_name,EXPECTED,comment)		\
+  {									\
+    CHECK_RESULTS_VLDX_LANE_NO_FP16(test_name,EXPECTED,comment);	\
+  }
+#endif
+
   /* Declare the temporary buffers / variables.  */
   DECL_ALL_VLDX_LANE(2);
   DECL_ALL_VLDX_LANE(3);
@@ -561,6 +494,10 @@ void exec_vldX_lane (void)
   DUMMY_ARRAY(buffer_src, uint, 16, 8, 4);
   DUMMY_ARRAY(buffer_src, uint, 32, 4, 4);
   DUMMY_ARRAY(buffer_src, poly, 16, 8, 4);
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+  DUMMY_ARRAY(buffer_src, float, 16, 4, 4);
+  DUMMY_ARRAY(buffer_src, float, 16, 8, 4);
+#endif
   DUMMY_ARRAY(buffer_src, float, 32, 2, 4);
   DUMMY_ARRAY(buffer_src, float, 32, 4, 4);
 
@@ -568,39 +505,39 @@ void exec_vldX_lane (void)
   clean_results ();
 #define TEST_MSG "VLD2_LANE/VLD2Q_LANE"
   TEST_ALL_VLDX_LANE(2);
-  CHECK_RESULTS_NAMED (TEST_MSG, expected_vld2_0, " chunk 0");
+  CHECK_RESULTS_VLDX_LANE (TEST_MSG, expected_vld2_0, " chunk 0");
 
   TEST_ALL_EXTRA_CHUNKS(2, 1);
-  CHECK_RESULTS_NAMED (TEST_MSG, expected_vld2_1, " chunk 1");
+  CHECK_RESULTS_VLDX_LANE (TEST_MSG, expected_vld2_1, " chunk 1");
 
   /* Check vld3_lane/vld3q_lane.  */
   clean_results ();
 #undef TEST_MSG
 #define TEST_MSG "VLD3_LANE/VLD3Q_LANE"
   TEST_ALL_VLDX_LANE(3);
-  CHECK_RESULTS_NAMED (TEST_MSG, expected_vld3_0, " chunk 0");
+  CHECK_RESULTS_VLDX_LANE (TEST_MSG, expected_vld3_0, " chunk 0");
 
   TEST_ALL_EXTRA_CHUNKS(3, 1);
-  CHECK_RESULTS_NAMED (TEST_MSG, expected_vld3_1, " chunk 1");
+  CHECK_RESULTS_VLDX_LANE (TEST_MSG, expected_vld3_1, " chunk 1");
 
   TEST_ALL_EXTRA_CHUNKS(3, 2);
-  CHECK_RESULTS_NAMED (TEST_MSG, expected_vld3_2, " chunk 2");
+  CHECK_RESULTS_VLDX_LANE (TEST_MSG, expected_vld3_2, " chunk 2");
 
   /* Check vld4_lane/vld4q_lane.  */
   clean_results ();
 #undef TEST_MSG
 #define TEST_MSG "VLD4_LANE/VLD4Q_LANE"
   TEST_ALL_VLDX_LANE(4);
-  CHECK_RESULTS_NAMED (TEST_MSG, expected_vld4_0, " chunk 0");
+  CHECK_RESULTS_VLDX_LANE (TEST_MSG, expected_vld4_0, " chunk 0");
 
   TEST_ALL_EXTRA_CHUNKS(4, 1);
-  CHECK_RESULTS_NAMED (TEST_MSG, expected_vld4_1, " chunk 1");
+  CHECK_RESULTS_VLDX_LANE (TEST_MSG, expected_vld4_1, " chunk 1");
   TEST_ALL_EXTRA_CHUNKS(4, 2);
 
-  CHECK_RESULTS_NAMED (TEST_MSG, expected_vld4_2, " chunk 2");
+  CHECK_RESULTS_VLDX_LANE (TEST_MSG, expected_vld4_2, " chunk 2");
 
   TEST_ALL_EXTRA_CHUNKS(4, 3);
-  CHECK_RESULTS_NAMED (TEST_MSG, expected_vld4_3, " chunk 3");
+  CHECK_RESULTS_VLDX_LANE (TEST_MSG, expected_vld4_3, " chunk 3");
 }
 
 int main (void)
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vmul.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vmul.c
@@ -7,15 +7,12 @@ VECT_VAR_DECL(expected,int,8,8) [] = { 0xf0, 0x1, 0x12, 0x23,
 				       0x34, 0x45, 0x56, 0x67 };
 VECT_VAR_DECL(expected,int,16,4) [] = { 0xfde0, 0xfe02, 0xfe24, 0xfe46 };
 VECT_VAR_DECL(expected,int,32,2) [] = { 0xfffffcd0, 0xfffffd03 };
-VECT_VAR_DECL(expected,int,64,1) [] = { 0x3333333333333333 };
 VECT_VAR_DECL(expected,uint,8,8) [] = { 0xc0, 0x4, 0x48, 0x8c,
 					0xd0, 0x14, 0x58, 0x9c };
 VECT_VAR_DECL(expected,uint,16,4) [] = { 0xfab0, 0xfb05, 0xfb5a, 0xfbaf };
 VECT_VAR_DECL(expected,uint,32,2) [] = { 0xfffff9a0, 0xfffffa06 };
-VECT_VAR_DECL(expected,uint,64,1) [] = { 0x3333333333333333 };
 VECT_VAR_DECL(expected,poly,8,8) [] = { 0xc0, 0x84, 0x48, 0xc,
 					0xd0, 0x94, 0x58, 0x1c };
-VECT_VAR_DECL(expected,poly,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
 VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0xc4053333, 0xc3f9c000 };
 VECT_VAR_DECL(expected,int,8,16) [] = { 0x90, 0x7, 0x7e, 0xf5,
 					0x6c, 0xe3, 0x5a, 0xd1,
@@ -25,8 +22,6 @@ VECT_VAR_DECL(expected,int,16,8) [] = { 0xf780, 0xf808, 0xf890, 0xf918,
 					0xf9a0, 0xfa28, 0xfab0, 0xfb38 };
 VECT_VAR_DECL(expected,int,32,4) [] = { 0xfffff670, 0xfffff709,
 					0xfffff7a2, 0xfffff83b };
-VECT_VAR_DECL(expected,int,64,2) [] = { 0x3333333333333333,
-					0x3333333333333333 };
 VECT_VAR_DECL(expected,uint,8,16) [] = { 0x60, 0xa, 0xb4, 0x5e,
 					 0x8, 0xb2, 0x5c, 0x6,
 					 0xb0, 0x5a, 0x4, 0xae,
@@ -35,14 +30,10 @@ VECT_VAR_DECL(expected,uint,16,8) [] = { 0xf450, 0xf50b, 0xf5c6, 0xf681,
 					 0xf73c, 0xf7f7, 0xf8b2, 0xf96d };
 VECT_VAR_DECL(expected,uint,32,4) [] = { 0xfffff340, 0xfffff40c,
 					 0xfffff4d8, 0xfffff5a4 };
-VECT_VAR_DECL(expected,uint,64,2) [] = { 0x3333333333333333,
-					 0x3333333333333333 };
 VECT_VAR_DECL(expected,poly,8,16) [] = { 0x60, 0xca, 0x34, 0x9e,
 					 0xc8, 0x62, 0x9c, 0x36,
 					 0x30, 0x9a, 0x64, 0xce,
 					 0x98, 0x32, 0xcc, 0x66 };
-VECT_VAR_DECL(expected,poly,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					 0x3333, 0x3333, 0x3333, 0x3333 };
 VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0xc4c73333, 0xc4bac000,
 					   0xc4ae4ccd, 0xc4a1d999 };
 
@@ -145,7 +136,22 @@ void FNNAME (INSN_NAME) (void)
   TEST_VMUL(INSN_NAME, q, poly, p, 8, 16);
   TEST_VMUL(INSN_NAME, q, float, f, 32, 4);
 
-  CHECK_RESULTS (TEST_MSG, "");
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected, "");
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected, "");
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected, "");
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected, "");
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected, "");
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected, "");
+  CHECK(TEST_MSG, poly, 8, 8, PRIx8, expected, "");
+  CHECK_FP(TEST_MSG, float, 32, 2, PRIx32, expected, "");
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected, "");
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected, "");
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected, "");
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected, "");
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected, "");
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected, "");
+  CHECK(TEST_MSG, poly, 8, 16, PRIx8, expected, "");
+  CHECK_FP(TEST_MSG, float, 32, 4, PRIx32, expected, "");
 }
 
 int main (void)
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vneg.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vneg.c
@@ -12,41 +12,11 @@ VECT_VAR_DECL(expected,int,8,8) [] = { 0x10, 0xf, 0xe, 0xd,
 				       0xc, 0xb, 0xa, 0x9 };
 VECT_VAR_DECL(expected,int,16,4) [] = { 0x10, 0xf, 0xe, 0xd };
 VECT_VAR_DECL(expected,int,32,2) [] = { 0x10, 0xf };
-VECT_VAR_DECL(expected,int,64,1) [] = { 0x3333333333333333 };
-VECT_VAR_DECL(expected,uint,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,uint,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,uint,32,2) [] = { 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,uint,64,1) [] = { 0x3333333333333333 };
-VECT_VAR_DECL(expected,poly,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0x33333333, 0x33333333 };
 VECT_VAR_DECL(expected,int,8,16) [] = { 0x10, 0xf, 0xe, 0xd, 0xc, 0xb, 0xa, 0x9,
 					0x8, 0x7, 0x6, 0x5, 0x4, 0x3, 0x2, 0x1 };
 VECT_VAR_DECL(expected,int,16,8) [] = { 0x10, 0xf, 0xe, 0xd,
 					0xc, 0xb, 0xa, 0x9 };
 VECT_VAR_DECL(expected,int,32,4) [] = { 0x10, 0xf, 0xe, 0xd };
-VECT_VAR_DECL(expected,int,64,2) [] = { 0x3333333333333333,
-					0x3333333333333333 };
-VECT_VAR_DECL(expected,uint,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,uint,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,uint,32,4) [] = { 0x33333333, 0x33333333,
-					 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,uint,64,2) [] = { 0x3333333333333333,
-					 0x3333333333333333 };
-VECT_VAR_DECL(expected,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0x33333333, 0x33333333,
-					   0x33333333, 0x33333333 };
 
 /* Expected results for float32 variants. Needs to be separated since
    the generic test function does not test floating-point
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vorn.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vorn.c
@@ -14,10 +14,6 @@ VECT_VAR_DECL(expected,uint,8,8) [] = { 0xfb, 0xfb, 0xfb, 0xfb,
 VECT_VAR_DECL(expected,uint,16,4) [] = { 0xfff1, 0xfff1, 0xfff3, 0xfff3 };
 VECT_VAR_DECL(expected,uint,32,2) [] = { 0xfffffff7, 0xfffffff7 };
 VECT_VAR_DECL(expected,uint,64,1) [] = { 0xfffffffffffffffd };
-VECT_VAR_DECL(expected,poly,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0x33333333, 0x33333333 };
 VECT_VAR_DECL(expected,int,8,16) [] = { 0xf9, 0xf9, 0xfb, 0xfb,
 					0xfd, 0xfd, 0xff, 0xff,
 					0xf9, 0xf9, 0xfb, 0xfb,
@@ -38,11 +34,3 @@ VECT_VAR_DECL(expected,uint,32,4) [] = { 0xfffffff8, 0xfffffff9,
 					 0xfffffffa, 0xfffffffb };
 VECT_VAR_DECL(expected,uint,64,2) [] = { 0xfffffffffffffffc,
 					 0xfffffffffffffffd };
-VECT_VAR_DECL(expected,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0x33333333, 0x33333333,
-					   0x33333333, 0x33333333 };
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vorr.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vorr.c
@@ -14,10 +14,6 @@ VECT_VAR_DECL(expected,uint,8,8) [] = { 0xf4, 0xf5, 0xf6, 0xf7,
 VECT_VAR_DECL(expected,uint,16,4) [] = { 0xfffe, 0xffff, 0xfffe, 0xffff };
 VECT_VAR_DECL(expected,uint,32,2) [] = { 0xfffffff8, 0xfffffff9 };
 VECT_VAR_DECL(expected,uint,64,1) [] = { 0xfffffffffffffff2 };
-VECT_VAR_DECL(expected,poly,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0x33333333, 0x33333333 };
 VECT_VAR_DECL(expected,int,8,16) [] = { 0xf6, 0xf7, 0xf6, 0xf7,
 					0xf6, 0xf7, 0xf6, 0xf7,
 					0xfe, 0xff, 0xfe, 0xff,
@@ -38,11 +34,3 @@ VECT_VAR_DECL(expected,uint,32,4) [] = { 0xfffffff7, 0xfffffff7,
 					 0xfffffff7, 0xfffffff7 };
 VECT_VAR_DECL(expected,uint,64,2) [] = { 0xfffffffffffffff3,
 					 0xfffffffffffffff3 };
-VECT_VAR_DECL(expected,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0x33333333, 0x33333333,
-					   0x33333333, 0x33333333 };
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vqabs.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vqabs.c
@@ -11,16 +11,6 @@ void vqabs_extra(void);
 VECT_VAR_DECL(expected,int,8,8) [] = { 0x10, 0xf, 0xe, 0xd, 0xc, 0xb, 0xa, 0x9 };
 VECT_VAR_DECL(expected,int,16,4) [] = { 0x10, 0xf, 0xe, 0xd };
 VECT_VAR_DECL(expected,int,32,2) [] = { 0x10, 0xf };
-VECT_VAR_DECL(expected,int,64,1) [] = { 0x3333333333333333 };
-VECT_VAR_DECL(expected,uint,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,uint,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,uint,32,2) [] = { 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,uint,64,1) [] = { 0x3333333333333333 };
-VECT_VAR_DECL(expected,poly,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0x33333333, 0x33333333 };
 VECT_VAR_DECL(expected,int,8,16) [] = { 0x10, 0xf, 0xe, 0xd,
 					0xc, 0xb, 0xa, 0x9,
 					0x8, 0x7, 0x6, 0x5,
@@ -28,25 +18,6 @@ VECT_VAR_DECL(expected,int,8,16) [] = { 0x10, 0xf, 0xe, 0xd,
 VECT_VAR_DECL(expected,int,16,8) [] = { 0x10, 0xf, 0xe, 0xd,
 					0xc, 0xb, 0xa, 0x9 };
 VECT_VAR_DECL(expected,int,32,4) [] = { 0x10, 0xf, 0xe, 0xd };
-VECT_VAR_DECL(expected,int,64,2) [] = { 0x3333333333333333, 0x3333333333333333 };
-VECT_VAR_DECL(expected,uint,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,uint,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,uint,32,4) [] = { 0x33333333, 0x33333333,
-					 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,uint,64,2) [] = { 0x3333333333333333,
-					 0x3333333333333333 };
-VECT_VAR_DECL(expected,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0x33333333, 0x33333333,
-					   0x33333333, 0x33333333 };
 
 /* Expected values of cumulative_saturation flag.  */
 int VECT_VAR(expected_cumulative_sat,int,8,8) = 0;
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vqadd.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vqadd.c
@@ -39,10 +39,6 @@ VECT_VAR_DECL(expected,uint,8,8) [] = { 0xff, 0xff, 0xff, 0xff,
 VECT_VAR_DECL(expected,uint,16,4) [] = { 0xffff, 0xffff, 0xffff, 0xffff };
 VECT_VAR_DECL(expected,uint,32,2) [] = { 0xffffffff, 0xffffffff };
 VECT_VAR_DECL(expected,uint,64,1) [] = { 0xffffffffffffffff };
-VECT_VAR_DECL(expected,poly,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0x33333333, 0x33333333 };
 VECT_VAR_DECL(expected,int,8,16) [] = { 0x1, 0x2, 0x3, 0x4,
 					0x5, 0x6, 0x7, 0x8,
 					0x9, 0xa, 0xb, 0xc,
@@ -61,14 +57,6 @@ VECT_VAR_DECL(expected,uint,32,4) [] = { 0xffffffff, 0xffffffff,
 					 0xffffffff, 0xffffffff };
 VECT_VAR_DECL(expected,uint,64,2) [] = { 0xffffffffffffffff,
 					 0xffffffffffffffff };
-VECT_VAR_DECL(expected,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0x33333333, 0x33333333,
-					   0x33333333, 0x33333333 };
 
 
 /* 64-bits types, with 0 as second input.  */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vqmovn.c
@@ -0,0 +1,134 @@
+#include <arm_neon.h>
+#include "arm-neon-ref.h"
+#include "compute-ref-data.h"
+
+/* Expected values of cumulative_saturation flag.  */
+int VECT_VAR(expected_cumulative_sat,int,8,8) = 0;
+int VECT_VAR(expected_cumulative_sat,int,16,4) = 0;
+int VECT_VAR(expected_cumulative_sat,int,32,2) = 0;
+int VECT_VAR(expected_cumulative_sat,uint,8,8) = 0;
+int VECT_VAR(expected_cumulative_sat,uint,16,4) = 0;
+int VECT_VAR(expected_cumulative_sat,uint,32,2) = 0;
+
+/* Expected results.  */
+VECT_VAR_DECL(expected,int,8,8) [] = { 0x12, 0x12, 0x12, 0x12,
+				       0x12, 0x12, 0x12, 0x12 };
+VECT_VAR_DECL(expected,int,16,4) [] = { 0x1278, 0x1278, 0x1278, 0x1278 };
+VECT_VAR_DECL(expected,int,32,2) [] = { 0x12345678, 0x12345678 };
+VECT_VAR_DECL(expected,uint,8,8) [] = { 0x82, 0x82, 0x82, 0x82,
+					0x82, 0x82, 0x82, 0x82 };
+VECT_VAR_DECL(expected,uint,16,4) [] = { 0x8765, 0x8765, 0x8765, 0x8765 };
+VECT_VAR_DECL(expected,uint,32,2) [] = { 0x87654321, 0x87654321 };
+
+/* Expected values of cumulative_saturation flag when saturation occurs.  */
+int VECT_VAR(expected_cumulative_sat1,int,8,8) = 1;
+int VECT_VAR(expected_cumulative_sat1,int,16,4) = 1;
+int VECT_VAR(expected_cumulative_sat1,int,32,2) = 1;
+int VECT_VAR(expected_cumulative_sat1,uint,8,8) = 1;
+int VECT_VAR(expected_cumulative_sat1,uint,16,4) = 1;
+int VECT_VAR(expected_cumulative_sat1,uint,32,2) = 1;
+
+/* Expected results when saturation occurs.  */
+VECT_VAR_DECL(expected1,int,8,8) [] = { 0x7f, 0x7f, 0x7f, 0x7f,
+					0x7f, 0x7f, 0x7f, 0x7f };
+VECT_VAR_DECL(expected1,int,16,4) [] = { 0x7fff, 0x7fff, 0x7fff, 0x7fff };
+VECT_VAR_DECL(expected1,int,32,2) [] = { 0x7fffffff, 0x7fffffff };
+VECT_VAR_DECL(expected1,uint,8,8) [] = { 0xff, 0xff, 0xff, 0xff,
+					 0xff, 0xff, 0xff, 0xff };
+VECT_VAR_DECL(expected1,uint,16,4) [] = { 0xffff, 0xffff, 0xffff, 0xffff };
+VECT_VAR_DECL(expected1,uint,32,2) [] = { 0xffffffff, 0xffffffff };
+
+#define INSN_NAME vqmovn
+#define TEST_MSG "VQMOVN"
+
+#define FNNAME1(NAME) void exec_ ## NAME (void)
+#define FNNAME(NAME) FNNAME1(NAME)
+
+FNNAME (INSN_NAME)
+{
+  /* Basic test: y=OP(x), then store the result.  */
+#define TEST_UNARY_OP1(INSN, T1, T2, W, W2, N, EXPECTED_CUMULATIVE_SAT, CMT) \
+  Set_Neon_Cumulative_Sat(0, VECT_VAR(vector_res, T1, W, N));		\
+  VECT_VAR(vector_res, T1, W, N) =					\
+    INSN##_##T2##W2(VECT_VAR(vector, T1, W2, N));			\
+  vst1##_##T2##W(VECT_VAR(result, T1, W, N),				\
+		 VECT_VAR(vector_res, T1, W, N));			\
+  CHECK_CUMULATIVE_SAT(TEST_MSG, T1, W, N, EXPECTED_CUMULATIVE_SAT, CMT)
+
+#define TEST_UNARY_OP(INSN, T1, T2, W, W2, N, EXPECTED_CUMULATIVE_SAT, CMT) \
+  TEST_UNARY_OP1(INSN, T1, T2, W, W2, N, EXPECTED_CUMULATIVE_SAT, CMT)
+
+  /* No need for 64 bits variants.  */
+  DECL_VARIABLE(vector, int, 16, 8);
+  DECL_VARIABLE(vector, int, 32, 4);
+  DECL_VARIABLE(vector, int, 64, 2);
+  DECL_VARIABLE(vector, uint, 16, 8);
+  DECL_VARIABLE(vector, uint, 32, 4);
+  DECL_VARIABLE(vector, uint, 64, 2);
+
+  DECL_VARIABLE(vector_res, int, 8, 8);
+  DECL_VARIABLE(vector_res, int, 16, 4);
+  DECL_VARIABLE(vector_res, int, 32, 2);
+  DECL_VARIABLE(vector_res, uint, 8, 8);
+  DECL_VARIABLE(vector_res, uint, 16, 4);
+  DECL_VARIABLE(vector_res, uint, 32, 2);
+
+  clean_results ();
+
+  /* Fill input vector with arbitrary values.  */
+  VDUP(vector, q, int, s, 16, 8, 0x12);
+  VDUP(vector, q, int, s, 32, 4, 0x1278);
+  VDUP(vector, q, int, s, 64, 2, 0x12345678);
+  VDUP(vector, q, uint, u, 16, 8, 0x82);
+  VDUP(vector, q, uint, u, 32, 4, 0x8765);
+  VDUP(vector, q, uint, u, 64, 2, 0x87654321);
+
+  /* Apply a unary operator named INSN_NAME.  */
+#define CMT ""
+  TEST_UNARY_OP(INSN_NAME, int, s, 8, 16, 8, expected_cumulative_sat, CMT);
+  TEST_UNARY_OP(INSN_NAME, int, s, 16, 32, 4, expected_cumulative_sat, CMT);
+  TEST_UNARY_OP(INSN_NAME, int, s, 32, 64, 2, expected_cumulative_sat, CMT);
+  TEST_UNARY_OP(INSN_NAME, uint, u, 8, 16, 8, expected_cumulative_sat, CMT);
+  TEST_UNARY_OP(INSN_NAME, uint, u, 16, 32, 4, expected_cumulative_sat, CMT);
+  TEST_UNARY_OP(INSN_NAME, uint, u, 32, 64, 2, expected_cumulative_sat, CMT);
+
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected, CMT);
+
+
+  /* Fill input vector with arbitrary values which cause cumulative
+     saturation.  */
+  VDUP(vector, q, int, s, 16, 8, 0x1234);
+  VDUP(vector, q, int, s, 32, 4, 0x12345678);
+  VDUP(vector, q, int, s, 64, 2, 0x1234567890ABLL);
+  VDUP(vector, q, uint, u, 16, 8, 0x8234);
+  VDUP(vector, q, uint, u, 32, 4, 0x87654321);
+  VDUP(vector, q, uint, u, 64, 2, 0x8765432187654321ULL);
+
+  /* Apply a unary operator named INSN_NAME.  */
+#undef CMT
+#define CMT " (with saturation)"
+  TEST_UNARY_OP(INSN_NAME, int, s, 8, 16, 8, expected_cumulative_sat1, CMT);
+  TEST_UNARY_OP(INSN_NAME, int, s, 16, 32, 4, expected_cumulative_sat1, CMT);
+  TEST_UNARY_OP(INSN_NAME, int, s, 32, 64, 2, expected_cumulative_sat1, CMT);
+  TEST_UNARY_OP(INSN_NAME, uint, u, 8, 16, 8, expected_cumulative_sat1, CMT);
+  TEST_UNARY_OP(INSN_NAME, uint, u, 16, 32, 4, expected_cumulative_sat1, CMT);
+  TEST_UNARY_OP(INSN_NAME, uint, u, 32, 64, 2, expected_cumulative_sat1, CMT);
+
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected1, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected1, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected1, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected1, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected1, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected1, CMT);
+}
+
+int main (void)
+{
+  exec_vqmovn ();
+  return 0;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vqmovun.c
@@ -0,0 +1,93 @@
+#include <arm_neon.h>
+#include "arm-neon-ref.h"
+#include "compute-ref-data.h"
+
+/* Expected values of cumulative_saturation flag.  */
+int VECT_VAR(expected_cumulative_sat,uint,8,8) = 0;
+int VECT_VAR(expected_cumulative_sat,uint,16,4) = 0;
+int VECT_VAR(expected_cumulative_sat,uint,32,2) = 0;
+
+/* Expected results.  */
+VECT_VAR_DECL(expected,uint,8,8) [] = { 0x34, 0x34, 0x34, 0x34,
+					0x34, 0x34, 0x34, 0x34 };
+VECT_VAR_DECL(expected,uint,16,4) [] = { 0x5678, 0x5678, 0x5678, 0x5678 };
+VECT_VAR_DECL(expected,uint,32,2) [] = { 0x12345678, 0x12345678 };
+
+/* Expected values of cumulative_saturation flag with negative input.  */
+int VECT_VAR(expected_cumulative_sat_neg,uint,8,8) = 1;
+int VECT_VAR(expected_cumulative_sat_neg,uint,16,4) = 1;
+int VECT_VAR(expected_cumulative_sat_neg,uint,32,2) = 1;
+
+/* Expected results with negative input.  */
+VECT_VAR_DECL(expected_neg,uint,8,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					    0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_neg,uint,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_neg,uint,32,2) [] = { 0x0, 0x0 };
+
+#define INSN_NAME vqmovun
+#define TEST_MSG "VQMOVUN"
+
+#define FNNAME1(NAME) void exec_ ## NAME (void)
+#define FNNAME(NAME) FNNAME1(NAME)
+
+FNNAME (INSN_NAME)
+{
+  /* Basic test: y=OP(x), then store the result.  */
+#define TEST_UNARY_OP1(INSN, T1, T2, W, W2, N, EXPECTED_CUMULATIVE_SAT, CMT) \
+  Set_Neon_Cumulative_Sat(0, VECT_VAR(vector_res, T1, W, N));		\
+  VECT_VAR(vector_res, T1, W, N) =					\
+    INSN##_s##W2(VECT_VAR(vector, int, W2, N));				\
+  vst1##_##T2##W(VECT_VAR(result, T1, W, N),				\
+		 VECT_VAR(vector_res, T1, W, N));			\
+  CHECK_CUMULATIVE_SAT(TEST_MSG, T1, W, N, EXPECTED_CUMULATIVE_SAT, CMT)
+
+#define TEST_UNARY_OP(INSN, T1, T2, W, W2, N, EXPECTED_CUMULATIVE_SAT, CMT) \
+  TEST_UNARY_OP1(INSN, T1, T2, W, W2, N, EXPECTED_CUMULATIVE_SAT, CMT)
+
+  DECL_VARIABLE(vector, int, 16, 8);
+  DECL_VARIABLE(vector, int, 32, 4);
+  DECL_VARIABLE(vector, int, 64, 2);
+
+  DECL_VARIABLE(vector_res, uint, 8, 8);
+  DECL_VARIABLE(vector_res, uint, 16, 4);
+  DECL_VARIABLE(vector_res, uint, 32, 2);
+
+  clean_results ();
+
+  /* Fill input vector with arbitrary values.  */
+  VDUP(vector, q, int, s, 16, 8, 0x34);
+  VDUP(vector, q, int, s, 32, 4, 0x5678);
+  VDUP(vector, q, int, s, 64, 2, 0x12345678);
+
+  /* Apply a unary operator named INSN_NAME.  */
+#define CMT ""
+  TEST_UNARY_OP(INSN_NAME, uint, u, 8, 16, 8, expected_cumulative_sat, CMT);
+  TEST_UNARY_OP(INSN_NAME, uint, u, 16, 32, 4, expected_cumulative_sat, CMT);
+  TEST_UNARY_OP(INSN_NAME, uint, u, 32, 64, 2, expected_cumulative_sat, CMT);
+
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected, CMT);
+
+  /* Fill input vector with negative values.  */
+  VDUP(vector, q, int, s, 16, 8, 0x8234);
+  VDUP(vector, q, int, s, 32, 4, 0x87654321);
+  VDUP(vector, q, int, s, 64, 2, 0x8765432187654321LL);
+
+  /* Apply a unary operator named INSN_NAME.  */
+#undef CMT
+#define CMT " (negative input)"
+  TEST_UNARY_OP(INSN_NAME, uint, u, 8, 16, 8, expected_cumulative_sat_neg, CMT);
+  TEST_UNARY_OP(INSN_NAME, uint, u, 16, 32, 4, expected_cumulative_sat_neg, CMT);
+  TEST_UNARY_OP(INSN_NAME, uint, u, 32, 64, 2, expected_cumulative_sat_neg, CMT);
+
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_neg, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_neg, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_neg, CMT);
+}
+
+int main (void)
+{
+  exec_vqmovun ();
+  return 0;
+}
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vqneg.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vqneg.c
@@ -11,16 +11,6 @@ void vqneg_extra(void);
 VECT_VAR_DECL(expected,int,8,8) [] = { 0x10, 0xf, 0xe, 0xd, 0xc, 0xb, 0xa, 0x9 };
 VECT_VAR_DECL(expected,int,16,4) [] = { 0x10, 0xf, 0xe, 0xd };
 VECT_VAR_DECL(expected,int,32,2) [] = { 0x10, 0xf };
-VECT_VAR_DECL(expected,int,64,1) [] = { 0x3333333333333333 };
-VECT_VAR_DECL(expected,uint,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,uint,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,uint,32,2) [] = { 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,uint,64,1) [] = { 0x3333333333333333 };
-VECT_VAR_DECL(expected,poly,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0x33333333, 0x33333333 };
 VECT_VAR_DECL(expected,int,8,16) [] = { 0x10, 0xf, 0xe, 0xd,
 					0xc, 0xb, 0xa, 0x9,
 					0x8, 0x7, 0x6, 0x5,
@@ -28,25 +18,6 @@ VECT_VAR_DECL(expected,int,8,16) [] = { 0x10, 0xf, 0xe, 0xd,
 VECT_VAR_DECL(expected,int,16,8) [] = { 0x10, 0xf, 0xe, 0xd,
 					0xc, 0xb, 0xa, 0x9 };
 VECT_VAR_DECL(expected,int,32,4) [] = { 0x10, 0xf, 0xe, 0xd };
-VECT_VAR_DECL(expected,int,64,2) [] = { 0x3333333333333333, 0x3333333333333333 };
-VECT_VAR_DECL(expected,uint,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,uint,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,uint,32,4) [] = { 0x33333333, 0x33333333,
-					 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,uint,64,2) [] = { 0x3333333333333333,
-					 0x3333333333333333 };
-VECT_VAR_DECL(expected,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0x33333333, 0x33333333,
-					   0x33333333, 0x33333333 };
 
 /* Expected values of cumulative_saturation flag.  */
 int VECT_VAR(expected_cumulative_sat,int,8,8) = 0;
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vqrdmulh.c
@@ -0,0 +1,161 @@
+#include <arm_neon.h>
+#include "arm-neon-ref.h"
+#include "compute-ref-data.h"
+
+/* Expected values of cumulative_saturation flag.  */
+int VECT_VAR(expected_cumulative_sat,int,16,4) = 0;
+int VECT_VAR(expected_cumulative_sat,int,32,2) = 0;
+int VECT_VAR(expected_cumulative_sat,int,16,8) = 0;
+int VECT_VAR(expected_cumulative_sat,int,32,4) = 0;
+
+/* Expected results.  */
+VECT_VAR_DECL(expected,int,16,4) [] = { 0xfff5, 0xfff6, 0xfff7, 0xfff7 };
+VECT_VAR_DECL(expected,int,32,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected,int,16,8) [] = { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected,int,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+
+/* Expected values of cumulative_saturation flag when multiplication
+   saturates.  */
+int VECT_VAR(expected_cumulative_sat_mul,int,16,4) = 1;
+int VECT_VAR(expected_cumulative_sat_mul,int,32,2) = 1;
+int VECT_VAR(expected_cumulative_sat_mul,int,16,8) = 1;
+int VECT_VAR(expected_cumulative_sat_mul,int,32,4) = 1;
+
+/* Expected results when multiplication saturates.  */
+VECT_VAR_DECL(expected_mul,int,16,4) [] = { 0x7fff, 0x7fff, 0x7fff, 0x7fff };
+VECT_VAR_DECL(expected_mul,int,32,2) [] = { 0x7fffffff, 0x7fffffff };
+VECT_VAR_DECL(expected_mul,int,16,8) [] = { 0x7fff, 0x7fff, 0x7fff, 0x7fff,
+					    0x7fff, 0x7fff, 0x7fff, 0x7fff };
+VECT_VAR_DECL(expected_mul,int,32,4) [] = { 0x7fffffff, 0x7fffffff,
+					    0x7fffffff, 0x7fffffff };
+
+/* Expected values of cumulative_saturation flag when rounding
+   should not cause saturation.  */
+int VECT_VAR(expected_cumulative_sat_round,int,16,4) = 0;
+int VECT_VAR(expected_cumulative_sat_round,int,32,2) = 0;
+int VECT_VAR(expected_cumulative_sat_round,int,16,8) = 0;
+int VECT_VAR(expected_cumulative_sat_round,int,32,4) = 0;
+
+/* Expected results when rounding should not cause saturation.  */
+VECT_VAR_DECL(expected_round,int,16,4) [] = { 0x7fff, 0x7fff, 0x7fff, 0x7fff };
+VECT_VAR_DECL(expected_round,int,32,2) [] = { 0x7fffffff, 0x7fffffff };
+VECT_VAR_DECL(expected_round,int,16,8) [] = { 0x7fff, 0x7fff, 0x7fff, 0x7fff,
+					      0x7fff, 0x7fff, 0x7fff, 0x7fff };
+VECT_VAR_DECL(expected_round,int,32,4) [] = { 0x7fffffff, 0x7fffffff,
+					      0x7fffffff, 0x7fffffff };
+
+#define INSN vqrdmulh
+#define TEST_MSG "VQRDMULH"
+
+#define FNNAME1(NAME) void exec_ ## NAME (void)
+#define FNNAME(NAME) FNNAME1(NAME)
+
+FNNAME (INSN)
+{
+  /* vector_res = vqrdmulh(vector,vector2), then store the result.  */
+#define TEST_VQRDMULH2(INSN, Q, T1, T2, W, N, EXPECTED_CUMULATIVE_SAT, CMT) \
+  Set_Neon_Cumulative_Sat(0, VECT_VAR(vector_res, T1, W, N));		\
+  VECT_VAR(vector_res, T1, W, N) =					\
+    INSN##Q##_##T2##W(VECT_VAR(vector, T1, W, N),			\
+		      VECT_VAR(vector2, T1, W, N));			\
+  vst1##Q##_##T2##W(VECT_VAR(result, T1, W, N),				\
+		    VECT_VAR(vector_res, T1, W, N));			\
+  CHECK_CUMULATIVE_SAT(TEST_MSG, T1, W, N, EXPECTED_CUMULATIVE_SAT, CMT)
+
+  /* Two auxliary macros are necessary to expand INSN */
+#define TEST_VQRDMULH1(INSN, Q, T1, T2, W, N, EXPECTED_CUMULATIVE_SAT, CMT) \
+  TEST_VQRDMULH2(INSN, Q, T1, T2, W, N, EXPECTED_CUMULATIVE_SAT, CMT)
+
+#define TEST_VQRDMULH(Q, T1, T2, W, N, EXPECTED_CUMULATIVE_SAT, CMT)	\
+  TEST_VQRDMULH1(INSN, Q, T1, T2, W, N, EXPECTED_CUMULATIVE_SAT, CMT)
+
+
+  DECL_VARIABLE(vector, int, 16, 4);
+  DECL_VARIABLE(vector, int, 32, 2);
+  DECL_VARIABLE(vector, int, 16, 8);
+  DECL_VARIABLE(vector, int, 32, 4);
+
+  DECL_VARIABLE(vector_res, int, 16, 4);
+  DECL_VARIABLE(vector_res, int, 32, 2);
+  DECL_VARIABLE(vector_res, int, 16, 8);
+  DECL_VARIABLE(vector_res, int, 32, 4);
+
+  DECL_VARIABLE(vector2, int, 16, 4);
+  DECL_VARIABLE(vector2, int, 32, 2);
+  DECL_VARIABLE(vector2, int, 16, 8);
+  DECL_VARIABLE(vector2, int, 32, 4);
+
+  clean_results ();
+
+  VLOAD(vector, buffer, , int, s, 16, 4);
+  VLOAD(vector, buffer, , int, s, 32, 2);
+  VLOAD(vector, buffer, q, int, s, 16, 8);
+  VLOAD(vector, buffer, q, int, s, 32, 4);
+
+  /* Initialize vector2.  */
+  VDUP(vector2, , int, s, 16, 4, 0x5555);
+  VDUP(vector2, , int, s, 32, 2, 0xBB);
+  VDUP(vector2, q, int, s, 16, 8, 0x33);
+  VDUP(vector2, q, int, s, 32, 4, 0x22);
+
+#define CMT ""
+  TEST_VQRDMULH(, int, s, 16, 4, expected_cumulative_sat, CMT);
+  TEST_VQRDMULH(, int, s, 32, 2, expected_cumulative_sat, CMT);
+  TEST_VQRDMULH(q, int, s, 16, 8, expected_cumulative_sat, CMT);
+  TEST_VQRDMULH(q, int, s, 32, 4, expected_cumulative_sat, CMT);
+
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected, CMT);
+
+  /* Now use input values such that the multiplication causes
+     saturation.  */
+#define TEST_MSG_MUL " (check mul cumulative saturation)"
+  VDUP(vector, , int, s, 16, 4, 0x8000);
+  VDUP(vector, , int, s, 32, 2, 0x80000000);
+  VDUP(vector, q, int, s, 16, 8, 0x8000);
+  VDUP(vector, q, int, s, 32, 4, 0x80000000);
+  VDUP(vector2, , int, s, 16, 4, 0x8000);
+  VDUP(vector2, , int, s, 32, 2, 0x80000000);
+  VDUP(vector2, q, int, s, 16, 8, 0x8000);
+  VDUP(vector2, q, int, s, 32, 4, 0x80000000);
+
+  TEST_VQRDMULH(, int, s, 16, 4, expected_cumulative_sat_mul, TEST_MSG_MUL);
+  TEST_VQRDMULH(, int, s, 32, 2, expected_cumulative_sat_mul, TEST_MSG_MUL);
+  TEST_VQRDMULH(q, int, s, 16, 8, expected_cumulative_sat_mul, TEST_MSG_MUL);
+  TEST_VQRDMULH(q, int, s, 32, 4, expected_cumulative_sat_mul, TEST_MSG_MUL);
+
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_mul, TEST_MSG_MUL);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_mul, TEST_MSG_MUL);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_mul, TEST_MSG_MUL);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_mul, TEST_MSG_MUL);
+
+  /* Use input values where rounding produces a result equal to the
+     saturation value, but does not set the saturation flag.  */
+#define TEST_MSG_ROUND " (check rounding)"
+  VDUP(vector, , int, s, 16, 4, 0x8000);
+  VDUP(vector, , int, s, 32, 2, 0x80000000);
+  VDUP(vector, q, int, s, 16, 8, 0x8000);
+  VDUP(vector, q, int, s, 32, 4, 0x80000000);
+  VDUP(vector2, , int, s, 16, 4, 0x8001);
+  VDUP(vector2, , int, s, 32, 2, 0x80000001);
+  VDUP(vector2, q, int, s, 16, 8, 0x8001);
+  VDUP(vector2, q, int, s, 32, 4, 0x80000001);
+
+  TEST_VQRDMULH(, int, s, 16, 4, expected_cumulative_sat_round, TEST_MSG_ROUND);
+  TEST_VQRDMULH(, int, s, 32, 2, expected_cumulative_sat_round, TEST_MSG_ROUND);
+  TEST_VQRDMULH(q, int, s, 16, 8, expected_cumulative_sat_round, TEST_MSG_ROUND);
+  TEST_VQRDMULH(q, int, s, 32, 4, expected_cumulative_sat_round, TEST_MSG_ROUND);
+
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_round, TEST_MSG_ROUND);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_round, TEST_MSG_ROUND);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_round, TEST_MSG_ROUND);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_round, TEST_MSG_ROUND);
+}
+
+int main (void)
+{
+  exec_vqrdmulh ();
+  return 0;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vqrdmulh_lane.c
@@ -0,0 +1,169 @@
+#include <arm_neon.h>
+#include "arm-neon-ref.h"
+#include "compute-ref-data.h"
+
+/* Expected values of cumulative_saturation flag.  */
+int VECT_VAR(expected_cumulative_sat,int,16,4) = 0;
+int VECT_VAR(expected_cumulative_sat,int,32,2) = 0;
+int VECT_VAR(expected_cumulative_sat,int,16,8) = 0;
+int VECT_VAR(expected_cumulative_sat,int,32,4) = 0;
+
+/* Expected results.  */
+VECT_VAR_DECL(expected,int,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected,int,32,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected,int,16,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected,int,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+
+/* Expected values of cumulative_saturation flag when multiplication
+   saturates.  */
+int VECT_VAR(expected_cumulative_sat_mul,int,16,4) = 1;
+int VECT_VAR(expected_cumulative_sat_mul,int,32,2) = 1;
+int VECT_VAR(expected_cumulative_sat_mul,int,16,8) = 1;
+int VECT_VAR(expected_cumulative_sat_mul,int,32,4) = 1;
+
+/* Expected results when multiplication saturates.  */
+VECT_VAR_DECL(expected_mul,int,16,4) [] = { 0x7fff, 0x7fff, 0x7fff, 0x7fff };
+VECT_VAR_DECL(expected_mul,int,32,2) [] = { 0x7fffffff, 0x7fffffff };
+VECT_VAR_DECL(expected_mul,int,16,8) [] = { 0x7fff, 0x7fff, 0x7fff, 0x7fff,
+					    0x7fff, 0x7fff, 0x7fff, 0x7fff };
+VECT_VAR_DECL(expected_mul,int,32,4) [] = { 0x7fffffff, 0x7fffffff,
+					    0x7fffffff, 0x7fffffff };
+
+/* Expected values of cumulative_saturation flag when rounding
+   should not cause saturation.  */
+int VECT_VAR(expected_cumulative_sat_round,int,16,4) = 0;
+int VECT_VAR(expected_cumulative_sat_round,int,32,2) = 0;
+int VECT_VAR(expected_cumulative_sat_round,int,16,8) = 0;
+int VECT_VAR(expected_cumulative_sat_round,int,32,4) = 0;
+
+/* Expected results when rounding should not cause saturation.  */
+VECT_VAR_DECL(expected_round,int,16,4) [] = { 0x7fff, 0x7fff, 0x7fff, 0x7fff };
+VECT_VAR_DECL(expected_round,int,32,2) [] = { 0x7fffffff, 0x7fffffff };
+VECT_VAR_DECL(expected_round,int,16,8) [] = { 0x7fff, 0x7fff, 0x7fff, 0x7fff,
+					      0x7fff, 0x7fff, 0x7fff, 0x7fff };
+VECT_VAR_DECL(expected_round,int,32,4) [] = { 0x7fffffff, 0x7fffffff,
+					      0x7fffffff, 0x7fffffff };
+
+#define INSN vqrdmulh
+#define TEST_MSG "VQRDMULH_LANE"
+
+#define FNNAME1(NAME) void exec_ ## NAME ## _lane (void)
+#define FNNAME(NAME) FNNAME1(NAME)
+
+FNNAME (INSN)
+{
+  /* vector_res = vqrdmulh_lane(vector,vector2,lane), then store the result.  */
+#define TEST_VQRDMULH_LANE2(INSN, Q, T1, T2, W, N, N2, L, EXPECTED_CUMULATIVE_SAT, CMT) \
+  Set_Neon_Cumulative_Sat(0, VECT_VAR(vector_res, T1, W, N));		\
+  VECT_VAR(vector_res, T1, W, N) =					\
+    INSN##Q##_lane_##T2##W(VECT_VAR(vector, T1, W, N),			\
+			   VECT_VAR(vector2, T1, W, N2),		\
+			   L);						\
+  vst1##Q##_##T2##W(VECT_VAR(result, T1, W, N),				\
+		    VECT_VAR(vector_res, T1, W, N));			\
+  CHECK_CUMULATIVE_SAT(TEST_MSG, T1, W, N, EXPECTED_CUMULATIVE_SAT, CMT)
+
+  /* Two auxliary macros are necessary to expand INSN */
+#define TEST_VQRDMULH_LANE1(INSN, Q, T1, T2, W, N, N2, L, EXPECTED_CUMULATIVE_SAT, CMT) \
+  TEST_VQRDMULH_LANE2(INSN, Q, T1, T2, W, N, N2, L, EXPECTED_CUMULATIVE_SAT, CMT)
+
+#define TEST_VQRDMULH_LANE(Q, T1, T2, W, N, N2, L, EXPECTED_CUMULATIVE_SAT, CMT) \
+  TEST_VQRDMULH_LANE1(INSN, Q, T1, T2, W, N, N2, L, EXPECTED_CUMULATIVE_SAT, CMT)
+
+
+  DECL_VARIABLE(vector, int, 16, 4);
+  DECL_VARIABLE(vector, int, 32, 2);
+  DECL_VARIABLE(vector, int, 16, 8);
+  DECL_VARIABLE(vector, int, 32, 4);
+
+  DECL_VARIABLE(vector_res, int, 16, 4);
+  DECL_VARIABLE(vector_res, int, 32, 2);
+  DECL_VARIABLE(vector_res, int, 16, 8);
+  DECL_VARIABLE(vector_res, int, 32, 4);
+
+  /* vector2: vqrdmulh_lane and vqrdmulhq_lane have a 2nd argument with
+     the same number of elements, so we need only one variable of each
+     type.  */
+  DECL_VARIABLE(vector2, int, 16, 4);
+  DECL_VARIABLE(vector2, int, 32, 2);
+
+  clean_results ();
+
+  VLOAD(vector, buffer, , int, s, 16, 4);
+  VLOAD(vector, buffer, , int, s, 32, 2);
+
+  VLOAD(vector, buffer, q, int, s, 16, 8);
+  VLOAD(vector, buffer, q, int, s, 32, 4);
+
+  /* Initialize vector2.  */
+  VDUP(vector2, , int, s, 16, 4, 0x55);
+  VDUP(vector2, , int, s, 32, 2, 0xBB);
+
+  /* Choose lane arbitrarily.  */
+#define CMT ""
+  TEST_VQRDMULH_LANE(, int, s, 16, 4, 4, 2, expected_cumulative_sat, CMT);
+  TEST_VQRDMULH_LANE(, int, s, 32, 2, 2, 1, expected_cumulative_sat, CMT);
+  TEST_VQRDMULH_LANE(q, int, s, 16, 8, 4, 3, expected_cumulative_sat, CMT);
+  TEST_VQRDMULH_LANE(q, int, s, 32, 4, 2, 0, expected_cumulative_sat, CMT);
+
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected, CMT);
+
+  /* Now use input values such that the multiplication causes
+     saturation.  */
+#define TEST_MSG_MUL " (check mul cumulative saturation)"
+  VDUP(vector, , int, s, 16, 4, 0x8000);
+  VDUP(vector, , int, s, 32, 2, 0x80000000);
+  VDUP(vector, q, int, s, 16, 8, 0x8000);
+  VDUP(vector, q, int, s, 32, 4, 0x80000000);
+  VDUP(vector2, , int, s, 16, 4, 0x8000);
+  VDUP(vector2, , int, s, 32, 2, 0x80000000);
+
+  TEST_VQRDMULH_LANE(, int, s, 16, 4, 4, 2, expected_cumulative_sat_mul,
+		     TEST_MSG_MUL);
+  TEST_VQRDMULH_LANE(, int, s, 32, 2, 2, 1, expected_cumulative_sat_mul,
+		     TEST_MSG_MUL);
+  TEST_VQRDMULH_LANE(q, int, s, 16, 8, 4, 3, expected_cumulative_sat_mul,
+		     TEST_MSG_MUL);
+  TEST_VQRDMULH_LANE(q, int, s, 32, 4, 2, 0, expected_cumulative_sat_mul,
+		     TEST_MSG_MUL);
+
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_mul, TEST_MSG_MUL);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_mul, TEST_MSG_MUL);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_mul, TEST_MSG_MUL);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_mul, TEST_MSG_MUL);
+
+  VDUP(vector, , int, s, 16, 4, 0x8000);
+  VDUP(vector, , int, s, 32, 2, 0x80000000);
+  VDUP(vector, q, int, s, 16, 8, 0x8000);
+  VDUP(vector, q, int, s, 32, 4, 0x80000000);
+  VDUP(vector2, , int, s, 16, 4, 0x8001);
+  VDUP(vector2, , int, s, 32, 2, 0x80000001);
+
+  /* Use input values where rounding produces a result equal to the
+     saturation value, but does not set the saturation flag.  */
+#define TEST_MSG_ROUND " (check rounding)"
+  TEST_VQRDMULH_LANE(, int, s, 16, 4, 4, 2, expected_cumulative_sat_round,
+		     TEST_MSG_ROUND);
+  TEST_VQRDMULH_LANE(, int, s, 32, 2, 2, 1, expected_cumulative_sat_round,
+		     TEST_MSG_ROUND);
+  TEST_VQRDMULH_LANE(q, int, s, 16, 8, 4, 3, expected_cumulative_sat_round,
+		     TEST_MSG_ROUND);
+  TEST_VQRDMULH_LANE(q, int, s, 32, 4, 2, 0, expected_cumulative_sat_round,
+		     TEST_MSG_ROUND);
+
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_round, TEST_MSG_ROUND);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_round, TEST_MSG_ROUND);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_round, TEST_MSG_ROUND);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_round, TEST_MSG_ROUND);
+}
+
+int main (void)
+{
+  exec_vqrdmulh_lane ();
+  return 0;
+}
+
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vqrdmulh_n.c
@@ -0,0 +1,155 @@
+#include <arm_neon.h>
+#include "arm-neon-ref.h"
+#include "compute-ref-data.h"
+
+/* Expected values of cumulative_saturation flag.  */
+int VECT_VAR(expected_cumulative_sat,int,16,4) = 0;
+int VECT_VAR(expected_cumulative_sat,int,32,2) = 0;
+int VECT_VAR(expected_cumulative_sat,int,16,8) = 0;
+int VECT_VAR(expected_cumulative_sat,int,32,4) = 0;
+
+/* Expected results.  */
+VECT_VAR_DECL(expected,int,16,4) [] = { 0xfffc, 0xfffc, 0xfffc, 0xfffd };
+VECT_VAR_DECL(expected,int,32,2) [] = { 0xfffffffe, 0xfffffffe };
+VECT_VAR_DECL(expected,int,16,8) [] = { 0x6, 0x6, 0x6, 0x5,
+					0x5, 0x4, 0x4, 0x4 };
+VECT_VAR_DECL(expected,int,32,4) [] = { 0xfffffffe, 0xfffffffe,
+					0xfffffffe, 0xfffffffe };
+
+/* Expected values of cumulative_saturation flag when multiplication
+   saturates.  */
+int VECT_VAR(expected_cumulative_sat_mul,int,16,4) = 1;
+int VECT_VAR(expected_cumulative_sat_mul,int,32,2) = 1;
+int VECT_VAR(expected_cumulative_sat_mul,int,16,8) = 1;
+int VECT_VAR(expected_cumulative_sat_mul,int,32,4) = 1;
+
+/* Expected results when multiplication saturates.  */
+VECT_VAR_DECL(expected_mul,int,16,4) [] = { 0x7fff, 0x7fff, 0x7fff, 0x7fff };
+VECT_VAR_DECL(expected_mul,int,32,2) [] = { 0x7fffffff, 0x7fffffff };
+VECT_VAR_DECL(expected_mul,int,16,8) [] = { 0x7fff, 0x7fff, 0x7fff, 0x7fff,
+					    0x7fff, 0x7fff, 0x7fff, 0x7fff };
+VECT_VAR_DECL(expected_mul,int,32,4) [] = { 0x7fffffff, 0x7fffffff,
+					    0x7fffffff, 0x7fffffff };
+
+/* Expected values of cumulative_saturation flag when rounding
+   should not cause saturation.  */
+int VECT_VAR(expected_cumulative_sat_round,int,16,4) = 0;
+int VECT_VAR(expected_cumulative_sat_round,int,32,2) = 0;
+int VECT_VAR(expected_cumulative_sat_round,int,16,8) = 0;
+int VECT_VAR(expected_cumulative_sat_round,int,32,4) = 0;
+
+/* Expected results when rounding should not cause saturation.  */
+VECT_VAR_DECL(expected_round,int,16,4) [] = { 0x7fff, 0x7fff, 0x7fff, 0x7fff };
+VECT_VAR_DECL(expected_round,int,32,2) [] = { 0x7fffffff, 0x7fffffff };
+VECT_VAR_DECL(expected_round,int,16,8) [] = { 0x7fff, 0x7fff, 0x7fff, 0x7fff,
+					      0x7fff, 0x7fff, 0x7fff, 0x7fff };
+VECT_VAR_DECL(expected_round,int,32,4) [] = { 0x7fffffff, 0x7fffffff,
+					      0x7fffffff, 0x7fffffff };
+
+#define INSN vqrdmulh
+#define TEST_MSG "VQRDMULH_N"
+
+#define FNNAME1(NAME) void exec_ ## NAME ## _n (void)
+#define FNNAME(NAME) FNNAME1(NAME)
+
+FNNAME (INSN)
+{
+  int i;
+
+  /* vector_res = vqrdmulh_n(vector,val), then store the result.  */
+#define TEST_VQRDMULH_N2(INSN, Q, T1, T2, W, N, L, EXPECTED_CUMULATIVE_SAT, CMT) \
+  Set_Neon_Cumulative_Sat(0, VECT_VAR(vector_res, T1, W, N));		\
+  VECT_VAR(vector_res, T1, W, N) =					\
+    INSN##Q##_n_##T2##W(VECT_VAR(vector, T1, W, N),			\
+			L);						\
+  vst1##Q##_##T2##W(VECT_VAR(result, T1, W, N),				\
+		    VECT_VAR(vector_res, T1, W, N));			\
+  CHECK_CUMULATIVE_SAT(TEST_MSG, T1, W, N, EXPECTED_CUMULATIVE_SAT, CMT)
+
+  /* Two auxliary macros are necessary to expand INSN */
+#define TEST_VQRDMULH_N1(INSN, Q, T1, T2, W, N, L, EXPECTED_CUMULATIVE_SAT, CMT) \
+  TEST_VQRDMULH_N2(INSN, Q, T1, T2, W, N, L, EXPECTED_CUMULATIVE_SAT, CMT)
+
+#define TEST_VQRDMULH_N(Q, T1, T2, W, N, L, EXPECTED_CUMULATIVE_SAT, CMT) \
+  TEST_VQRDMULH_N1(INSN, Q, T1, T2, W, N, L, EXPECTED_CUMULATIVE_SAT, CMT)
+
+
+  DECL_VARIABLE(vector, int, 16, 4);
+  DECL_VARIABLE(vector, int, 32, 2);
+  DECL_VARIABLE(vector, int, 16, 8);
+  DECL_VARIABLE(vector, int, 32, 4);
+
+  DECL_VARIABLE(vector_res, int, 16, 4);
+  DECL_VARIABLE(vector_res, int, 32, 2);
+  DECL_VARIABLE(vector_res, int, 16, 8);
+  DECL_VARIABLE(vector_res, int, 32, 4);
+
+  clean_results ();
+
+  VLOAD(vector, buffer, , int, s, 16, 4);
+  VLOAD(vector, buffer, , int, s, 32, 2);
+  VLOAD(vector, buffer, q, int, s, 16, 8);
+  VLOAD(vector, buffer, q, int, s, 32, 4);
+
+  /* Choose multiplier arbitrarily.  */
+#define CMT ""
+  TEST_VQRDMULH_N(, int, s, 16, 4, 0x2233, expected_cumulative_sat, CMT);
+  TEST_VQRDMULH_N(, int, s, 32, 2, 0x12345678, expected_cumulative_sat, CMT);
+  TEST_VQRDMULH_N(q, int, s, 16, 8, 0xCD12, expected_cumulative_sat, CMT);
+  TEST_VQRDMULH_N(q, int, s, 32, 4, 0xFA23456, expected_cumulative_sat, CMT);
+
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected, CMT);
+
+  /* Now use input values such that the multiplication causes
+     saturation.  */
+#define TEST_MSG_MUL " (check mul cumulative saturation)"
+  VDUP(vector, , int, s, 16, 4, 0x8000);
+  VDUP(vector, , int, s, 32, 2, 0x80000000);
+  VDUP(vector, q, int, s, 16, 8, 0x8000);
+  VDUP(vector, q, int, s, 32, 4, 0x80000000);
+
+  TEST_VQRDMULH_N(, int, s, 16, 4, 0x8000, expected_cumulative_sat_mul,
+		  TEST_MSG_MUL);
+  TEST_VQRDMULH_N(, int, s, 32, 2, 0x80000000, expected_cumulative_sat_mul,
+		  TEST_MSG_MUL);
+  TEST_VQRDMULH_N(q, int, s, 16, 8, 0x8000, expected_cumulative_sat_mul,
+		  TEST_MSG_MUL);
+  TEST_VQRDMULH_N(q, int, s, 32, 4, 0x80000000, expected_cumulative_sat_mul,
+		  TEST_MSG_MUL);
+
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_mul, TEST_MSG_MUL);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_mul, TEST_MSG_MUL);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_mul, TEST_MSG_MUL);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_mul, TEST_MSG_MUL);
+
+  /* Use input values where rounding produces a result equal to the
+     saturation value, but does not set the saturation flag.  */
+#define TEST_MSG_ROUND " (check rounding)"
+  VDUP(vector, , int, s, 16, 4, 0x8000);
+  VDUP(vector, , int, s, 32, 2, 0x80000000);
+  VDUP(vector, q, int, s, 16, 8, 0x8000);
+  VDUP(vector, q, int, s, 32, 4, 0x80000000);
+
+  TEST_VQRDMULH_N(, int, s, 16, 4, 0x8001, expected_cumulative_sat_round,
+		  TEST_MSG_ROUND);
+  TEST_VQRDMULH_N(, int, s, 32, 2, 0x80000001, expected_cumulative_sat_round,
+		  TEST_MSG_ROUND);
+  TEST_VQRDMULH_N(q, int, s, 16, 8, 0x8001, expected_cumulative_sat_round,
+		  TEST_MSG_ROUND);
+  TEST_VQRDMULH_N(q, int, s, 32, 4, 0x80000001, expected_cumulative_sat_round,
+		  TEST_MSG_ROUND);
+
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_round, TEST_MSG_ROUND);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_round, TEST_MSG_ROUND);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_round, TEST_MSG_ROUND);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_round, TEST_MSG_ROUND);
+}
+
+int main (void)
+{
+  exec_vqrdmulh_n ();
+  return 0;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vqrshl.c
@@ -0,0 +1,1090 @@
+#include <arm_neon.h>
+#include "arm-neon-ref.h"
+#include "compute-ref-data.h"
+
+/* Expected values of cumulative_saturation flag with input=0.  */
+int VECT_VAR(expected_cumulative_sat_0,int,8,8) = 0;
+int VECT_VAR(expected_cumulative_sat_0,int,16,4) = 0;
+int VECT_VAR(expected_cumulative_sat_0,int,32,2) = 0;
+int VECT_VAR(expected_cumulative_sat_0,int,64,1) = 0;
+int VECT_VAR(expected_cumulative_sat_0,uint,8,8) = 0;
+int VECT_VAR(expected_cumulative_sat_0,uint,16,4) = 0;
+int VECT_VAR(expected_cumulative_sat_0,uint,32,2) = 0;
+int VECT_VAR(expected_cumulative_sat_0,uint,64,1) = 0;
+int VECT_VAR(expected_cumulative_sat_0,int,8,16) = 0;
+int VECT_VAR(expected_cumulative_sat_0,int,16,8) = 0;
+int VECT_VAR(expected_cumulative_sat_0,int,32,4) = 0;
+int VECT_VAR(expected_cumulative_sat_0,int,64,2) = 0;
+int VECT_VAR(expected_cumulative_sat_0,uint,8,16) = 0;
+int VECT_VAR(expected_cumulative_sat_0,uint,16,8) = 0;
+int VECT_VAR(expected_cumulative_sat_0,uint,32,4) = 0;
+int VECT_VAR(expected_cumulative_sat_0,uint,64,2) = 0;
+
+/* Expected results with input=0.  */
+VECT_VAR_DECL(expected_0,int,8,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0,int,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0,int,32,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_0,int,64,1) [] = { 0x0 };
+VECT_VAR_DECL(expected_0,uint,8,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					  0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0,uint,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0,uint,32,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_0,uint,64,1) [] = { 0x0 };
+VECT_VAR_DECL(expected_0,int,8,16) [] = { 0x0, 0x0, 0x0, 0x0,
+					  0x0, 0x0, 0x0, 0x0,
+					  0x0, 0x0, 0x0, 0x0,
+					  0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0,int,16,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					  0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0,int,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0,int,64,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_0,uint,8,16) [] = { 0x0, 0x0, 0x0, 0x0,
+					   0x0, 0x0, 0x0, 0x0,
+					   0x0, 0x0, 0x0, 0x0,
+					   0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0,uint,16,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					   0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0,uint,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0,uint,64,2) [] = { 0x0, 0x0 };
+
+/* Expected values of cumulative_saturation flag with input=0 and
+   negative shift amount.  */
+int VECT_VAR(expected_cumulative_sat_0_neg,int,8,8) = 0;
+int VECT_VAR(expected_cumulative_sat_0_neg,int,16,4) = 0;
+int VECT_VAR(expected_cumulative_sat_0_neg,int,32,2) = 0;
+int VECT_VAR(expected_cumulative_sat_0_neg,int,64,1) = 0;
+int VECT_VAR(expected_cumulative_sat_0_neg,uint,8,8) = 0;
+int VECT_VAR(expected_cumulative_sat_0_neg,uint,16,4) = 0;
+int VECT_VAR(expected_cumulative_sat_0_neg,uint,32,2) = 0;
+int VECT_VAR(expected_cumulative_sat_0_neg,uint,64,1) = 0;
+int VECT_VAR(expected_cumulative_sat_0_neg,int,8,16) = 0;
+int VECT_VAR(expected_cumulative_sat_0_neg,int,16,8) = 0;
+int VECT_VAR(expected_cumulative_sat_0_neg,int,32,4) = 0;
+int VECT_VAR(expected_cumulative_sat_0_neg,int,64,2) = 0;
+int VECT_VAR(expected_cumulative_sat_0_neg,uint,8,16) = 0;
+int VECT_VAR(expected_cumulative_sat_0_neg,uint,16,8) = 0;
+int VECT_VAR(expected_cumulative_sat_0_neg,uint,32,4) = 0;
+int VECT_VAR(expected_cumulative_sat_0_neg,uint,64,2) = 0;
+
+/* Expected results with input=0 and negative shift amount.  */
+VECT_VAR_DECL(expected_0_neg,int,8,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					     0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0_neg,int,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0_neg,int,32,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_0_neg,int,64,1) [] = { 0x0 };
+VECT_VAR_DECL(expected_0_neg,uint,8,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					      0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0_neg,uint,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0_neg,uint,32,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_0_neg,uint,64,1) [] = { 0x0 };
+VECT_VAR_DECL(expected_0_neg,int,8,16) [] = { 0x0, 0x0, 0x0, 0x0,
+					      0x0, 0x0, 0x0, 0x0,
+					      0x0, 0x0, 0x0, 0x0,
+					      0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0_neg,int,16,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					      0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0_neg,int,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0_neg,int,64,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_0_neg,uint,8,16) [] = { 0x0, 0x0, 0x0, 0x0,
+					       0x0, 0x0, 0x0, 0x0,
+					       0x0, 0x0, 0x0, 0x0,
+					       0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0_neg,uint,16,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					       0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0_neg,uint,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0_neg,uint,64,2) [] = { 0x0, 0x0 };
+
+/* Expected values of cumulative_saturation flag.  */
+int VECT_VAR(expected_cumulative_sat,int,8,8) = 0;
+int VECT_VAR(expected_cumulative_sat,int,16,4) = 0;
+int VECT_VAR(expected_cumulative_sat,int,32,2) = 0;
+int VECT_VAR(expected_cumulative_sat,int,64,1) = 0;
+int VECT_VAR(expected_cumulative_sat,uint,8,8) = 1;
+int VECT_VAR(expected_cumulative_sat,uint,16,4) = 1;
+int VECT_VAR(expected_cumulative_sat,uint,32,2) = 1;
+int VECT_VAR(expected_cumulative_sat,uint,64,1) = 1;
+int VECT_VAR(expected_cumulative_sat,int,8,16) = 1;
+int VECT_VAR(expected_cumulative_sat,int,16,8) = 1;
+int VECT_VAR(expected_cumulative_sat,int,32,4) = 1;
+int VECT_VAR(expected_cumulative_sat,int,64,2) = 1;
+int VECT_VAR(expected_cumulative_sat,uint,8,16) = 1;
+int VECT_VAR(expected_cumulative_sat,uint,16,8) = 1;
+int VECT_VAR(expected_cumulative_sat,uint,32,4) = 1;
+int VECT_VAR(expected_cumulative_sat,uint,64,2) = 1;
+
+/* Expected results.  */
+VECT_VAR_DECL(expected,int,8,8) [] = { 0xe0, 0xe2, 0xe4, 0xe6,
+				       0xe8, 0xea, 0xec, 0xee };
+VECT_VAR_DECL(expected,int,16,4) [] = { 0xff80, 0xff88, 0xff90, 0xff98 };
+VECT_VAR_DECL(expected,int,32,2) [] = { 0xfffff000, 0xfffff100 };
+VECT_VAR_DECL(expected,int,64,1) [] = { 0xffffffffffffff80 };
+VECT_VAR_DECL(expected,uint,8,8) [] = { 0xff, 0xff, 0xff, 0xff,
+					0xff, 0xff, 0xff, 0xff };
+VECT_VAR_DECL(expected,uint,16,4) [] = { 0xffff, 0xffff, 0xffff, 0xffff };
+VECT_VAR_DECL(expected,uint,32,2) [] = { 0xffffffff, 0xffffffff };
+VECT_VAR_DECL(expected,uint,64,1) [] = { 0xffffffffffffffff };
+VECT_VAR_DECL(expected,int,8,16) [] = { 0x80, 0x80, 0x80, 0x80,
+					0x80, 0x80, 0x80, 0x80,
+					0x80, 0x80, 0x80, 0x80,
+					0x80, 0x80, 0x80, 0x80 };
+VECT_VAR_DECL(expected,int,16,8) [] = { 0x8000, 0x8000, 0x8000, 0x8000,
+					0x8000, 0x8000, 0x8000, 0x8000 };
+VECT_VAR_DECL(expected,int,32,4) [] = { 0x80000000, 0x80000000,
+					0x80000000, 0x80000000 };
+VECT_VAR_DECL(expected,int,64,2) [] = { 0x8000000000000000, 0x8000000000000000 };
+VECT_VAR_DECL(expected,uint,8,16) [] = { 0xff, 0xff, 0xff, 0xff,
+					 0xff, 0xff, 0xff, 0xff,
+					 0xff, 0xff, 0xff, 0xff,
+					 0xff, 0xff, 0xff, 0xff };
+VECT_VAR_DECL(expected,uint,16,8) [] = { 0xffff, 0xffff, 0xffff, 0xffff,
+					 0xffff, 0xffff, 0xffff, 0xffff };
+VECT_VAR_DECL(expected,uint,32,4) [] = { 0xffffffff, 0xffffffff,
+					 0xffffffff, 0xffffffff };
+VECT_VAR_DECL(expected,uint,64,2) [] = { 0xffffffffffffffff,
+					 0xffffffffffffffff };
+
+/* Expected values of cumulative_saturation flag with negative shift
+   amount.  */
+int VECT_VAR(expected_cumulative_sat_neg,int,8,8) = 0;
+int VECT_VAR(expected_cumulative_sat_neg,int,16,4) = 0;
+int VECT_VAR(expected_cumulative_sat_neg,int,32,2) = 0;
+int VECT_VAR(expected_cumulative_sat_neg,int,64,1) = 0;
+int VECT_VAR(expected_cumulative_sat_neg,uint,8,8) = 0;
+int VECT_VAR(expected_cumulative_sat_neg,uint,16,4) = 0;
+int VECT_VAR(expected_cumulative_sat_neg,uint,32,2) = 0;
+int VECT_VAR(expected_cumulative_sat_neg,uint,64,1) = 0;
+int VECT_VAR(expected_cumulative_sat_neg,int,8,16) = 0;
+int VECT_VAR(expected_cumulative_sat_neg,int,16,8) = 0;
+int VECT_VAR(expected_cumulative_sat_neg,int,32,4) = 0;
+int VECT_VAR(expected_cumulative_sat_neg,int,64,2) = 0;
+int VECT_VAR(expected_cumulative_sat_neg,uint,8,16) = 0;
+int VECT_VAR(expected_cumulative_sat_neg,uint,16,8) = 0;
+int VECT_VAR(expected_cumulative_sat_neg,uint,32,4) = 0;
+int VECT_VAR(expected_cumulative_sat_neg,uint,64,2) = 0;
+
+/* Expected results with negative shift amount.  */
+VECT_VAR_DECL(expected_neg,int,8,8) [] = { 0xfc, 0xfc, 0xfd, 0xfd,
+					   0xfd, 0xfd, 0xfe, 0xfe };
+VECT_VAR_DECL(expected_neg,int,16,4) [] = { 0xfffc, 0xfffc, 0xfffd, 0xfffd };
+VECT_VAR_DECL(expected_neg,int,32,2) [] = { 0xfffffffe, 0xfffffffe };
+VECT_VAR_DECL(expected_neg,int,64,1) [] = { 0xffffffffffffffff };
+VECT_VAR_DECL(expected_neg,uint,8,8) [] = { 0x3c, 0x3c, 0x3d, 0x3d,
+					    0x3d, 0x3d, 0x3e, 0x3e };
+VECT_VAR_DECL(expected_neg,uint,16,4) [] = { 0x3ffc, 0x3ffc, 0x3ffd, 0x3ffd };
+VECT_VAR_DECL(expected_neg,uint,32,2) [] = { 0x1ffffffe, 0x1ffffffe };
+VECT_VAR_DECL(expected_neg,uint,64,1) [] = { 0xfffffffffffffff };
+VECT_VAR_DECL(expected_neg,int,8,16) [] = { 0x0, 0x0, 0x0, 0x0,
+					    0x0, 0x0, 0x0, 0x0,
+					    0x0, 0x0, 0x0, 0x0,
+					    0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_neg,int,16,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					    0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_neg,int,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_neg,int,64,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_neg,uint,8,16) [] = { 0x2, 0x2, 0x2, 0x2,
+					     0x2, 0x2, 0x2, 0x2,
+					     0x2, 0x2, 0x2, 0x2,
+					     0x2, 0x2, 0x2, 0x2 };
+VECT_VAR_DECL(expected_neg,uint,16,8) [] = { 0x20, 0x20, 0x20, 0x20,
+					     0x20, 0x20, 0x20, 0x20 };
+VECT_VAR_DECL(expected_neg,uint,32,4) [] = { 0x80000, 0x80000,
+					     0x80000, 0x80000 };
+VECT_VAR_DECL(expected_neg,uint,64,2) [] = { 0x100000000000, 0x100000000000 };
+
+/* Expected values of cumulative_saturation flag with input=max and
+   shift by -1.  */
+int VECT_VAR(expected_cumulative_sat_minus1,int,8,8) = 0;
+int VECT_VAR(expected_cumulative_sat_minus1,int,16,4) = 0;
+int VECT_VAR(expected_cumulative_sat_minus1,int,32,2) = 0;
+int VECT_VAR(expected_cumulative_sat_minus1,int,64,1) = 0;
+int VECT_VAR(expected_cumulative_sat_minus1,uint,8,8) = 0;
+int VECT_VAR(expected_cumulative_sat_minus1,uint,16,4) = 0;
+int VECT_VAR(expected_cumulative_sat_minus1,uint,32,2) = 0;
+int VECT_VAR(expected_cumulative_sat_minus1,uint,64,1) = 0;
+int VECT_VAR(expected_cumulative_sat_minus1,int,8,16) = 0;
+int VECT_VAR(expected_cumulative_sat_minus1,int,16,8) = 0;
+int VECT_VAR(expected_cumulative_sat_minus1,int,32,4) = 0;
+int VECT_VAR(expected_cumulative_sat_minus1,int,64,2) = 0;
+int VECT_VAR(expected_cumulative_sat_minus1,uint,8,16) = 0;
+int VECT_VAR(expected_cumulative_sat_minus1,uint,16,8) = 0;
+int VECT_VAR(expected_cumulative_sat_minus1,uint,32,4) = 0;
+int VECT_VAR(expected_cumulative_sat_minus1,uint,64,2) = 0;
+
+/* Expected results with input=max and shift by -1.  */
+VECT_VAR_DECL(expected_minus1,int,8,8) [] = { 0x40, 0x40, 0x40, 0x40,
+					      0x40, 0x40, 0x40, 0x40 };
+VECT_VAR_DECL(expected_minus1,int,16,4) [] = { 0x4000, 0x4000, 0x4000, 0x4000 };
+VECT_VAR_DECL(expected_minus1,int,32,2) [] = { 0x40000000, 0x40000000 };
+VECT_VAR_DECL(expected_minus1,int,64,1) [] = { 0x4000000000000000 };
+VECT_VAR_DECL(expected_minus1,uint,8,8) [] = { 0x80, 0x80, 0x80, 0x80,
+					       0x80, 0x80, 0x80, 0x80 };
+VECT_VAR_DECL(expected_minus1,uint,16,4) [] = { 0x8000, 0x8000, 0x8000, 0x8000 };
+VECT_VAR_DECL(expected_minus1,uint,32,2) [] = { 0x80000000, 0x80000000 };
+VECT_VAR_DECL(expected_minus1,uint,64,1) [] = { 0x8000000000000000 };
+VECT_VAR_DECL(expected_minus1,int,8,16) [] = { 0x40, 0x40, 0x40, 0x40,
+					       0x40, 0x40, 0x40, 0x40,
+					       0x40, 0x40, 0x40, 0x40,
+					       0x40, 0x40, 0x40, 0x40 };
+VECT_VAR_DECL(expected_minus1,int,16,8) [] = { 0x4000, 0x4000, 0x4000, 0x4000,
+					       0x4000, 0x4000, 0x4000, 0x4000 };
+VECT_VAR_DECL(expected_minus1,int,32,4) [] = { 0x40000000, 0x40000000,
+					       0x40000000, 0x40000000 };
+VECT_VAR_DECL(expected_minus1,int,64,2) [] = { 0x4000000000000000,
+					       0x4000000000000000 };
+VECT_VAR_DECL(expected_minus1,uint,8,16) [] = { 0x80, 0x80, 0x80, 0x80,
+						0x80, 0x80, 0x80, 0x80,
+						0x80, 0x80, 0x80, 0x80,
+						0x80, 0x80, 0x80, 0x80 };
+VECT_VAR_DECL(expected_minus1,uint,16,8) [] = { 0x8000, 0x8000, 0x8000, 0x8000,
+						0x8000, 0x8000, 0x8000, 0x8000 };
+VECT_VAR_DECL(expected_minus1,uint,32,4) [] = { 0x80000000, 0x80000000,
+						0x80000000, 0x80000000 };
+VECT_VAR_DECL(expected_minus1,uint,64,2) [] = { 0x8000000000000000,
+						0x8000000000000000 };
+
+/* Expected values of cumulative_saturation flag with input=max and
+   shift by -3.  */
+int VECT_VAR(expected_cumulative_sat_minus3,int,8,8) = 0;
+int VECT_VAR(expected_cumulative_sat_minus3,int,16,4) = 0;
+int VECT_VAR(expected_cumulative_sat_minus3,int,32,2) = 0;
+int VECT_VAR(expected_cumulative_sat_minus3,int,64,1) = 0;
+int VECT_VAR(expected_cumulative_sat_minus3,uint,8,8) = 0;
+int VECT_VAR(expected_cumulative_sat_minus3,uint,16,4) = 0;
+int VECT_VAR(expected_cumulative_sat_minus3,uint,32,2) = 0;
+int VECT_VAR(expected_cumulative_sat_minus3,uint,64,1) = 0;
+int VECT_VAR(expected_cumulative_sat_minus3,int,8,16) = 0;
+int VECT_VAR(expected_cumulative_sat_minus3,int,16,8) = 0;
+int VECT_VAR(expected_cumulative_sat_minus3,int,32,4) = 0;
+int VECT_VAR(expected_cumulative_sat_minus3,int,64,2) = 0;
+int VECT_VAR(expected_cumulative_sat_minus3,uint,8,16) = 0;
+int VECT_VAR(expected_cumulative_sat_minus3,uint,16,8) = 0;
+int VECT_VAR(expected_cumulative_sat_minus3,uint,32,4) = 0;
+int VECT_VAR(expected_cumulative_sat_minus3,uint,64,2) = 0;
+
+/* Expected results with input=max and shift by -3.  */
+VECT_VAR_DECL(expected_minus3,int,8,8) [] = { 0x10, 0x10, 0x10, 0x10,
+					      0x10, 0x10, 0x10, 0x10 };
+VECT_VAR_DECL(expected_minus3,int,16,4) [] = { 0x1000, 0x1000, 0x1000, 0x1000 };
+VECT_VAR_DECL(expected_minus3,int,32,2) [] = { 0x10000000, 0x10000000 };
+VECT_VAR_DECL(expected_minus3,int,64,1) [] = { 0x1000000000000000 };
+VECT_VAR_DECL(expected_minus3,uint,8,8) [] = { 0x20, 0x20, 0x20, 0x20,
+					       0x20, 0x20, 0x20, 0x20 };
+VECT_VAR_DECL(expected_minus3,uint,16,4) [] = { 0x2000, 0x2000, 0x2000, 0x2000 };
+VECT_VAR_DECL(expected_minus3,uint,32,2) [] = { 0x20000000, 0x20000000 };
+VECT_VAR_DECL(expected_minus3,uint,64,1) [] = { 0x2000000000000000 };
+VECT_VAR_DECL(expected_minus3,int,8,16) [] = { 0x10, 0x10, 0x10, 0x10,
+					       0x10, 0x10, 0x10, 0x10,
+					       0x10, 0x10, 0x10, 0x10,
+					       0x10, 0x10, 0x10, 0x10 };
+VECT_VAR_DECL(expected_minus3,int,16,8) [] = { 0x1000, 0x1000, 0x1000, 0x1000,
+					       0x1000, 0x1000, 0x1000, 0x1000 };
+VECT_VAR_DECL(expected_minus3,int,32,4) [] = { 0x10000000, 0x10000000,
+					       0x10000000, 0x10000000 };
+VECT_VAR_DECL(expected_minus3,int,64,2) [] = { 0x1000000000000000,
+					       0x1000000000000000 };
+VECT_VAR_DECL(expected_minus3,uint,8,16) [] = { 0x20, 0x20, 0x20, 0x20,
+						0x20, 0x20, 0x20, 0x20,
+						0x20, 0x20, 0x20, 0x20,
+						0x20, 0x20, 0x20, 0x20 };
+VECT_VAR_DECL(expected_minus3,uint,16,8) [] = { 0x2000, 0x2000, 0x2000, 0x2000,
+						0x2000, 0x2000, 0x2000, 0x2000 };
+VECT_VAR_DECL(expected_minus3,uint,32,4) [] = { 0x20000000, 0x20000000,
+						0x20000000, 0x20000000 };
+VECT_VAR_DECL(expected_minus3,uint,64,2) [] = { 0x2000000000000000,
+						0x2000000000000000 };
+
+/* Expected values of cumulative_saturation flag with input=max and
+   large shift amount.  */
+int VECT_VAR(expected_cumulative_sat_large_sh,int,8,8) = 1;
+int VECT_VAR(expected_cumulative_sat_large_sh,int,16,4) = 1;
+int VECT_VAR(expected_cumulative_sat_large_sh,int,32,2) = 1;
+int VECT_VAR(expected_cumulative_sat_large_sh,int,64,1) = 1;
+int VECT_VAR(expected_cumulative_sat_large_sh,uint,8,8) = 1;
+int VECT_VAR(expected_cumulative_sat_large_sh,uint,16,4) = 1;
+int VECT_VAR(expected_cumulative_sat_large_sh,uint,32,2) = 1;
+int VECT_VAR(expected_cumulative_sat_large_sh,uint,64,1) = 1;
+int VECT_VAR(expected_cumulative_sat_large_sh,int,8,16) = 1;
+int VECT_VAR(expected_cumulative_sat_large_sh,int,16,8) = 1;
+int VECT_VAR(expected_cumulative_sat_large_sh,int,32,4) = 1;
+int VECT_VAR(expected_cumulative_sat_large_sh,int,64,2) = 1;
+int VECT_VAR(expected_cumulative_sat_large_sh,uint,8,16) = 1;
+int VECT_VAR(expected_cumulative_sat_large_sh,uint,16,8) = 1;
+int VECT_VAR(expected_cumulative_sat_large_sh,uint,32,4) = 1;
+int VECT_VAR(expected_cumulative_sat_large_sh,uint,64,2) = 1;
+
+/* Expected results with input=max and large shift amount.  */
+VECT_VAR_DECL(expected_large_sh,int,8,8) [] = { 0x7f, 0x7f, 0x7f, 0x7f,
+						0x7f, 0x7f, 0x7f, 0x7f };
+VECT_VAR_DECL(expected_large_sh,int,16,4) [] = { 0x7fff, 0x7fff,
+						 0x7fff, 0x7fff };
+VECT_VAR_DECL(expected_large_sh,int,32,2) [] = { 0x7fffffff, 0x7fffffff };
+VECT_VAR_DECL(expected_large_sh,int,64,1) [] = { 0x7fffffffffffffff };
+VECT_VAR_DECL(expected_large_sh,uint,8,8) [] = { 0xff, 0xff, 0xff, 0xff,
+						 0xff, 0xff, 0xff, 0xff };
+VECT_VAR_DECL(expected_large_sh,uint,16,4) [] = { 0xffff, 0xffff,
+						  0xffff, 0xffff };
+VECT_VAR_DECL(expected_large_sh,uint,32,2) [] = { 0xffffffff, 0xffffffff };
+VECT_VAR_DECL(expected_large_sh,uint,64,1) [] = { 0xffffffffffffffff };
+VECT_VAR_DECL(expected_large_sh,int,8,16) [] = { 0x7f, 0x7f, 0x7f, 0x7f,
+						 0x7f, 0x7f, 0x7f, 0x7f,
+						 0x7f, 0x7f, 0x7f, 0x7f,
+						 0x7f, 0x7f, 0x7f, 0x7f };
+VECT_VAR_DECL(expected_large_sh,int,16,8) [] = { 0x7fff, 0x7fff,
+						 0x7fff, 0x7fff,
+						 0x7fff, 0x7fff,
+						 0x7fff, 0x7fff };
+VECT_VAR_DECL(expected_large_sh,int,32,4) [] = { 0x7fffffff, 0x7fffffff,
+						 0x7fffffff, 0x7fffffff };
+VECT_VAR_DECL(expected_large_sh,int,64,2) [] = { 0x7fffffffffffffff,
+						 0x7fffffffffffffff };
+VECT_VAR_DECL(expected_large_sh,uint,8,16) [] = { 0xff, 0xff, 0xff, 0xff,
+						  0xff, 0xff, 0xff, 0xff,
+						  0xff, 0xff, 0xff, 0xff,
+						  0xff, 0xff, 0xff, 0xff };
+VECT_VAR_DECL(expected_large_sh,uint,16,8) [] = { 0xffff, 0xffff,
+						  0xffff, 0xffff,
+						  0xffff, 0xffff,
+						  0xffff, 0xffff };
+VECT_VAR_DECL(expected_large_sh,uint,32,4) [] = { 0xffffffff, 0xffffffff,
+						  0xffffffff, 0xffffffff };
+VECT_VAR_DECL(expected_large_sh,uint,64,2) [] = { 0xffffffffffffffff,
+						  0xffffffffffffffff };
+
+/* Expected values of cumulative_saturation flag with negative input and
+   large shift amount.  */
+int VECT_VAR(expected_cumulative_sat_neg_large_sh,int,8,8) = 1;
+int VECT_VAR(expected_cumulative_sat_neg_large_sh,int,16,4) = 1;
+int VECT_VAR(expected_cumulative_sat_neg_large_sh,int,32,2) = 1;
+int VECT_VAR(expected_cumulative_sat_neg_large_sh,int,64,1) = 1;
+int VECT_VAR(expected_cumulative_sat_neg_large_sh,uint,8,8) = 1;
+int VECT_VAR(expected_cumulative_sat_neg_large_sh,uint,16,4) = 1;
+int VECT_VAR(expected_cumulative_sat_neg_large_sh,uint,32,2) = 1;
+int VECT_VAR(expected_cumulative_sat_neg_large_sh,uint,64,1) = 1;
+int VECT_VAR(expected_cumulative_sat_neg_large_sh,int,8,16) = 1;
+int VECT_VAR(expected_cumulative_sat_neg_large_sh,int,16,8) = 1;
+int VECT_VAR(expected_cumulative_sat_neg_large_sh,int,32,4) = 1;
+int VECT_VAR(expected_cumulative_sat_neg_large_sh,int,64,2) = 1;
+int VECT_VAR(expected_cumulative_sat_neg_large_sh,uint,8,16) = 1;
+int VECT_VAR(expected_cumulative_sat_neg_large_sh,uint,16,8) = 1;
+int VECT_VAR(expected_cumulative_sat_neg_large_sh,uint,32,4) = 1;
+int VECT_VAR(expected_cumulative_sat_neg_large_sh,uint,64,2) = 1;
+
+/* Expected results with negative input and large shift amount.  */
+VECT_VAR_DECL(expected_neg_large_sh,int,8,8) [] = { 0x80, 0x80, 0x80, 0x80,
+						    0x80, 0x80, 0x80, 0x80 };
+VECT_VAR_DECL(expected_neg_large_sh,int,16,4) [] = { 0x8000, 0x8000,
+						     0x8000, 0x8000 };
+VECT_VAR_DECL(expected_neg_large_sh,int,32,2) [] = { 0x80000000, 0x80000000 };
+VECT_VAR_DECL(expected_neg_large_sh,int,64,1) [] = { 0x8000000000000000 };
+VECT_VAR_DECL(expected_neg_large_sh,uint,8,8) [] = { 0xff, 0xff, 0xff, 0xff,
+						     0xff, 0xff, 0xff, 0xff };
+VECT_VAR_DECL(expected_neg_large_sh,uint,16,4) [] = { 0xffff, 0xffff,
+						      0xffff, 0xffff };
+VECT_VAR_DECL(expected_neg_large_sh,uint,32,2) [] = { 0xffffffff,
+						      0xffffffff };
+VECT_VAR_DECL(expected_neg_large_sh,uint,64,1) [] = { 0xffffffffffffffff };
+VECT_VAR_DECL(expected_neg_large_sh,int,8,16) [] = { 0x80, 0x80, 0x80, 0x80,
+						     0x80, 0x80, 0x80, 0x80,
+						     0x80, 0x80, 0x80, 0x80,
+						     0x80, 0x80, 0x80, 0x80 };
+VECT_VAR_DECL(expected_neg_large_sh,int,16,8) [] = { 0x8000, 0x8000,
+						     0x8000, 0x8000,
+						     0x8000, 0x8000,
+						     0x8000, 0x8000 };
+VECT_VAR_DECL(expected_neg_large_sh,int,32,4) [] = { 0x80000000, 0x80000000,
+						     0x80000000, 0x80000000 };
+VECT_VAR_DECL(expected_neg_large_sh,int,64,2) [] = { 0x8000000000000000,
+						     0x8000000000000000 };
+VECT_VAR_DECL(expected_neg_large_sh,uint,8,16) [] = { 0xff, 0xff, 0xff, 0xff,
+						      0xff, 0xff, 0xff, 0xff,
+						      0xff, 0xff, 0xff, 0xff,
+						      0xff, 0xff, 0xff, 0xff };
+VECT_VAR_DECL(expected_neg_large_sh,uint,16,8) [] = { 0xffff, 0xffff,
+						      0xffff, 0xffff,
+						      0xffff, 0xffff,
+						      0xffff, 0xffff };
+VECT_VAR_DECL(expected_neg_large_sh,uint,32,4) [] = { 0xffffffff,
+						      0xffffffff,
+						      0xffffffff,
+						      0xffffffff };
+VECT_VAR_DECL(expected_neg_large_sh,uint,64,2) [] = { 0xffffffffffffffff,
+						      0xffffffffffffffff };
+
+/* Expected values of cumulative_saturation flag with max/min input and
+   large negative shift amount.  */
+int VECT_VAR(expected_cumulative_sat_large_neg_sh,int,8,8) = 0;
+int VECT_VAR(expected_cumulative_sat_large_neg_sh,int,16,4) = 0;
+int VECT_VAR(expected_cumulative_sat_large_neg_sh,int,32,2) = 0;
+int VECT_VAR(expected_cumulative_sat_large_neg_sh,int,64,1) = 0;
+int VECT_VAR(expected_cumulative_sat_large_neg_sh,uint,8,8) = 0;
+int VECT_VAR(expected_cumulative_sat_large_neg_sh,uint,16,4) = 0;
+int VECT_VAR(expected_cumulative_sat_large_neg_sh,uint,32,2) = 0;
+int VECT_VAR(expected_cumulative_sat_large_neg_sh,uint,64,1) = 0;
+int VECT_VAR(expected_cumulative_sat_large_neg_sh,int,8,16) = 0;
+int VECT_VAR(expected_cumulative_sat_large_neg_sh,int,16,8) = 0;
+int VECT_VAR(expected_cumulative_sat_large_neg_sh,int,32,4) = 0;
+int VECT_VAR(expected_cumulative_sat_large_neg_sh,int,64,2) = 0;
+int VECT_VAR(expected_cumulative_sat_large_neg_sh,uint,8,16) = 0;
+int VECT_VAR(expected_cumulative_sat_large_neg_sh,uint,16,8) = 0;
+int VECT_VAR(expected_cumulative_sat_large_neg_sh,uint,32,4) = 0;
+int VECT_VAR(expected_cumulative_sat_large_neg_sh,uint,64,2) = 0;
+
+/* Expected results with max/min input and large negative shift amount.  */
+VECT_VAR_DECL(expected_large_neg_sh,int,8,8) [] = { 0x0, 0x0, 0x0, 0x0,
+						    0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_large_neg_sh,int,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_large_neg_sh,int,32,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_large_neg_sh,int,64,1) [] = { 0x0 };
+VECT_VAR_DECL(expected_large_neg_sh,uint,8,8) [] = { 0x0, 0x0, 0x0, 0x0,
+						     0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_large_neg_sh,uint,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_large_neg_sh,uint,32,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_large_neg_sh,uint,64,1) [] = { 0x0 };
+VECT_VAR_DECL(expected_large_neg_sh,int,8,16) [] = { 0x0, 0x0, 0x0, 0x0,
+						     0x0, 0x0, 0x0, 0x0,
+						     0x0, 0x0, 0x0, 0x0,
+						     0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_large_neg_sh,int,16,8) [] = { 0x0, 0x0, 0x0, 0x0,
+						     0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_large_neg_sh,int,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_large_neg_sh,int,64,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_large_neg_sh,uint,8,16) [] = { 0x0, 0x0, 0x0, 0x0,
+						      0x0, 0x0, 0x0, 0x0,
+						      0x0, 0x0, 0x0, 0x0,
+						      0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_large_neg_sh,uint,16,8) [] = { 0x0, 0x0, 0x0, 0x0,
+						      0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_large_neg_sh,uint,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_large_neg_sh,uint,64,2) [] = { 0x0, 0x0 };
+
+/* Expected values of cumulative_saturation flag with input=0 and
+   large negative shift amount.  */
+int VECT_VAR(expected_cumulative_sat_0_large_neg_sh,int,8,8) = 0;
+int VECT_VAR(expected_cumulative_sat_0_large_neg_sh,int,16,4) = 0;
+int VECT_VAR(expected_cumulative_sat_0_large_neg_sh,int,32,2) = 0;
+int VECT_VAR(expected_cumulative_sat_0_large_neg_sh,int,64,1) = 0;
+int VECT_VAR(expected_cumulative_sat_0_large_neg_sh,uint,8,8) = 0;
+int VECT_VAR(expected_cumulative_sat_0_large_neg_sh,uint,16,4) = 0;
+int VECT_VAR(expected_cumulative_sat_0_large_neg_sh,uint,32,2) = 0;
+int VECT_VAR(expected_cumulative_sat_0_large_neg_sh,uint,64,1) = 0;
+int VECT_VAR(expected_cumulative_sat_0_large_neg_sh,int,8,16) = 0;
+int VECT_VAR(expected_cumulative_sat_0_large_neg_sh,int,16,8) = 0;
+int VECT_VAR(expected_cumulative_sat_0_large_neg_sh,int,32,4) = 0;
+int VECT_VAR(expected_cumulative_sat_0_large_neg_sh,int,64,2) = 0;
+int VECT_VAR(expected_cumulative_sat_0_large_neg_sh,uint,8,16) = 0;
+int VECT_VAR(expected_cumulative_sat_0_large_neg_sh,uint,16,8) = 0;
+int VECT_VAR(expected_cumulative_sat_0_large_neg_sh,uint,32,4) = 0;
+int VECT_VAR(expected_cumulative_sat_0_large_neg_sh,uint,64,2) = 0;
+
+/* Expected results with input=0 and large negative shift amount.  */
+VECT_VAR_DECL(expected_0_large_neg_sh,int,8,8) [] = { 0x0, 0x0, 0x0, 0x0,
+						      0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0_large_neg_sh,int,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0_large_neg_sh,int,32,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_0_large_neg_sh,int,64,1) [] = { 0x0 };
+VECT_VAR_DECL(expected_0_large_neg_sh,uint,8,8) [] = { 0x0, 0x0, 0x0, 0x0,
+						       0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0_large_neg_sh,uint,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0_large_neg_sh,uint,32,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_0_large_neg_sh,uint,64,1) [] = { 0x0 };
+VECT_VAR_DECL(expected_0_large_neg_sh,int,8,16) [] = { 0x0, 0x0, 0x0, 0x0,
+						       0x0, 0x0, 0x0, 0x0,
+						       0x0, 0x0, 0x0, 0x0,
+						       0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0_large_neg_sh,int,16,8) [] = { 0x0, 0x0, 0x0, 0x0,
+						       0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0_large_neg_sh,int,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0_large_neg_sh,int,64,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_0_large_neg_sh,uint,8,16) [] = { 0x0, 0x0, 0x0, 0x0,
+							0x0, 0x0, 0x0, 0x0,
+							0x0, 0x0, 0x0, 0x0,
+							0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0_large_neg_sh,uint,16,8) [] = { 0x0, 0x0, 0x0, 0x0,
+							0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0_large_neg_sh,uint,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0_large_neg_sh,uint,64,2) [] = { 0x0, 0x0 };
+
+#define INSN vqrshl
+#define TEST_MSG "VQRSHL/VQRSHLQ"
+
+#define FNNAME1(NAME) void exec_ ## NAME (void)
+#define FNNAME(NAME) FNNAME1(NAME)
+
+FNNAME (INSN)
+{
+  /* Basic test: v3=vqrshl(v1,v2), then store the result.  */
+#define TEST_VQRSHL2(INSN, T3, Q, T1, T2, W, N, EXPECTED_CUMULATIVE_SAT, CMT) \
+  Set_Neon_Cumulative_Sat(0, VECT_VAR(vector_res, T1, W, N));		\
+  VECT_VAR(vector_res, T1, W, N) =					\
+    INSN##Q##_##T2##W(VECT_VAR(vector, T1, W, N),			\
+		      VECT_VAR(vector_shift, T3, W, N));		\
+  vst1##Q##_##T2##W(VECT_VAR(result, T1, W, N),				\
+		    VECT_VAR(vector_res, T1, W, N));			\
+  CHECK_CUMULATIVE_SAT(TEST_MSG, T1, W, N, EXPECTED_CUMULATIVE_SAT, CMT)
+
+  /* Two auxliary macros are necessary to expand INSN */
+#define TEST_VQRSHL1(INSN, T3, Q, T1, T2, W, N, EXPECTED_CUMULATIVE_SAT, CMT) \
+  TEST_VQRSHL2(INSN, T3, Q, T1, T2, W, N, EXPECTED_CUMULATIVE_SAT, CMT)
+
+#define TEST_VQRSHL(T3, Q, T1, T2, W, N, EXPECTED_CUMULATIVE_SAT, CMT)	\
+  TEST_VQRSHL1(INSN, T3, Q, T1, T2, W, N, EXPECTED_CUMULATIVE_SAT, CMT)
+
+  DECL_VARIABLE_ALL_VARIANTS(vector);
+  DECL_VARIABLE_ALL_VARIANTS(vector_res);
+
+  DECL_VARIABLE_SIGNED_VARIANTS(vector_shift);
+
+  clean_results ();
+
+  /* Fill input vector with 0, to check saturation on limits.  */
+  VDUP(vector, , int, s, 8, 8, 0);
+  VDUP(vector, , int, s, 16, 4, 0);
+  VDUP(vector, , int, s, 32, 2, 0);
+  VDUP(vector, , int, s, 64, 1, 0);
+  VDUP(vector, , uint, u, 8, 8, 0);
+  VDUP(vector, , uint, u, 16, 4, 0);
+  VDUP(vector, , uint, u, 32, 2, 0);
+  VDUP(vector, , uint, u, 64, 1, 0);
+  VDUP(vector, q, int, s, 8, 16, 0);
+  VDUP(vector, q, int, s, 16, 8, 0);
+  VDUP(vector, q, int, s, 32, 4, 0);
+  VDUP(vector, q, int, s, 64, 2, 0);
+  VDUP(vector, q, uint, u, 8, 16, 0);
+  VDUP(vector, q, uint, u, 16, 8, 0);
+  VDUP(vector, q, uint, u, 32, 4, 0);
+  VDUP(vector, q, uint, u, 64, 2, 0);
+
+  /* Choose init value arbitrarily, will be used as shift amount */
+  /* Use values equal to or one-less-than the type width to check
+     behaviour on limits.  */
+  VDUP(vector_shift, , int, s, 8, 8, 7);
+  VDUP(vector_shift, , int, s, 16, 4, 15);
+  VDUP(vector_shift, , int, s, 32, 2, 31);
+  VDUP(vector_shift, , int, s, 64, 1, 63);
+  VDUP(vector_shift, q, int, s, 8, 16, 8);
+  VDUP(vector_shift, q, int, s, 16, 8, 16);
+  VDUP(vector_shift, q, int, s, 32, 4, 32);
+  VDUP(vector_shift, q, int, s, 64, 2, 64);
+
+#define CMT " (with input = 0)"
+  TEST_VQRSHL(int, , int, s, 8, 8, expected_cumulative_sat_0, CMT);
+  TEST_VQRSHL(int, , int, s, 16, 4, expected_cumulative_sat_0, CMT);
+  TEST_VQRSHL(int, , int, s, 32, 2, expected_cumulative_sat_0, CMT);
+  TEST_VQRSHL(int, , int, s, 64, 1, expected_cumulative_sat_0, CMT);
+  TEST_VQRSHL(int, , uint, u, 8, 8, expected_cumulative_sat_0, CMT);
+  TEST_VQRSHL(int, , uint, u, 16, 4, expected_cumulative_sat_0, CMT);
+  TEST_VQRSHL(int, , uint, u, 32, 2, expected_cumulative_sat_0, CMT);
+  TEST_VQRSHL(int, , uint, u, 64, 1, expected_cumulative_sat_0, CMT);
+  TEST_VQRSHL(int, q, int, s, 8, 16, expected_cumulative_sat_0, CMT);
+  TEST_VQRSHL(int, q, int, s, 16, 8, expected_cumulative_sat_0, CMT);
+  TEST_VQRSHL(int, q, int, s, 32, 4, expected_cumulative_sat_0, CMT);
+  TEST_VQRSHL(int, q, int, s, 64, 2, expected_cumulative_sat_0, CMT);
+  TEST_VQRSHL(int, q, uint, u, 8, 16, expected_cumulative_sat_0, CMT);
+  TEST_VQRSHL(int, q, uint, u, 16, 8, expected_cumulative_sat_0, CMT);
+  TEST_VQRSHL(int, q, uint, u, 32, 4, expected_cumulative_sat_0, CMT);
+  TEST_VQRSHL(int, q, uint, u, 64, 2, expected_cumulative_sat_0, CMT);
+
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_0, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_0, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_0, CMT);
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected_0, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_0, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_0, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_0, CMT);
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected_0, CMT);
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected_0, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_0, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_0, CMT);
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected_0, CMT);
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected_0, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_0, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_0, CMT);
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected_0, CMT);
+
+
+  /* Use negative shift amounts.  */
+  VDUP(vector_shift, , int, s, 8, 8, -1);
+  VDUP(vector_shift, , int, s, 16, 4, -2);
+  VDUP(vector_shift, , int, s, 32, 2, -3);
+  VDUP(vector_shift, , int, s, 64, 1, -4);
+  VDUP(vector_shift, q, int, s, 8, 16, -7);
+  VDUP(vector_shift, q, int, s, 16, 8, -11);
+  VDUP(vector_shift, q, int, s, 32, 4, -13);
+  VDUP(vector_shift, q, int, s, 64, 2, -20);
+
+#undef CMT
+#define CMT " (input 0 and negative shift amount)"
+  TEST_VQRSHL(int, , int, s, 8, 8, expected_cumulative_sat_0_neg, CMT);
+  TEST_VQRSHL(int, , int, s, 16, 4, expected_cumulative_sat_0_neg, CMT);
+  TEST_VQRSHL(int, , int, s, 32, 2, expected_cumulative_sat_0_neg, CMT);
+  TEST_VQRSHL(int, , int, s, 64, 1, expected_cumulative_sat_0_neg, CMT);
+  TEST_VQRSHL(int, , uint, u, 8, 8, expected_cumulative_sat_0_neg, CMT);
+  TEST_VQRSHL(int, , uint, u, 16, 4, expected_cumulative_sat_0_neg, CMT);
+  TEST_VQRSHL(int, , uint, u, 32, 2, expected_cumulative_sat_0_neg, CMT);
+  TEST_VQRSHL(int, , uint, u, 64, 1, expected_cumulative_sat_0_neg, CMT);
+  TEST_VQRSHL(int, q, int, s, 8, 16, expected_cumulative_sat_0_neg, CMT);
+  TEST_VQRSHL(int, q, int, s, 16, 8, expected_cumulative_sat_0_neg, CMT);
+  TEST_VQRSHL(int, q, int, s, 32, 4, expected_cumulative_sat_0_neg, CMT);
+  TEST_VQRSHL(int, q, int, s, 64, 2, expected_cumulative_sat_0_neg, CMT);
+  TEST_VQRSHL(int, q, uint, u, 8, 16, expected_cumulative_sat_0_neg, CMT);
+  TEST_VQRSHL(int, q, uint, u, 16, 8, expected_cumulative_sat_0_neg, CMT);
+  TEST_VQRSHL(int, q, uint, u, 32, 4, expected_cumulative_sat_0_neg, CMT);
+  TEST_VQRSHL(int, q, uint, u, 64, 2, expected_cumulative_sat_0_neg, CMT);
+
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_0_neg, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_0_neg, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_0_neg, CMT);
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected_0_neg, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_0_neg, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_0_neg, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_0_neg, CMT);
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected_0_neg, CMT);
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected_0_neg, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_0_neg, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_0_neg, CMT);
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected_0_neg, CMT);
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected_0_neg, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_0_neg, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_0_neg, CMT);
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected_0_neg, CMT);
+
+
+  /* Test again, with predefined input values.  */
+  TEST_MACRO_ALL_VARIANTS_2_5(VLOAD, vector, buffer);
+
+  /* Choose init value arbitrarily, will be used as shift amount.  */
+  VDUP(vector_shift, , int, s, 8, 8, 1);
+  VDUP(vector_shift, , int, s, 16, 4, 3);
+  VDUP(vector_shift, , int, s, 32, 2, 8);
+  VDUP(vector_shift, , int, s, 64, 1, 3);
+  VDUP(vector_shift, q, int, s, 8, 16, 10);
+  VDUP(vector_shift, q, int, s, 16, 8, 12);
+  VDUP(vector_shift, q, int, s, 32, 4, 31);
+  VDUP(vector_shift, q, int, s, 64, 2, 63);
+
+#undef CMT
+#define CMT ""
+  TEST_VQRSHL(int, , int, s, 8, 8, expected_cumulative_sat, CMT);
+  TEST_VQRSHL(int, , int, s, 16, 4, expected_cumulative_sat, CMT);
+  TEST_VQRSHL(int, , int, s, 32, 2, expected_cumulative_sat, CMT);
+  TEST_VQRSHL(int, , int, s, 64, 1, expected_cumulative_sat, CMT);
+  TEST_VQRSHL(int, , uint, u, 8, 8, expected_cumulative_sat, CMT);
+  TEST_VQRSHL(int, , uint, u, 16, 4, expected_cumulative_sat, CMT);
+  TEST_VQRSHL(int, , uint, u, 32, 2, expected_cumulative_sat, CMT);
+  TEST_VQRSHL(int, , uint, u, 64, 1, expected_cumulative_sat, CMT);
+  TEST_VQRSHL(int, q, int, s, 8, 16, expected_cumulative_sat, CMT);
+  TEST_VQRSHL(int, q, int, s, 16, 8, expected_cumulative_sat, CMT);
+  TEST_VQRSHL(int, q, int, s, 32, 4, expected_cumulative_sat, CMT);
+  TEST_VQRSHL(int, q, int, s, 64, 2, expected_cumulative_sat, CMT);
+  TEST_VQRSHL(int, q, uint, u, 8, 16, expected_cumulative_sat, CMT);
+  TEST_VQRSHL(int, q, uint, u, 16, 8, expected_cumulative_sat, CMT);
+  TEST_VQRSHL(int, q, uint, u, 32, 4, expected_cumulative_sat, CMT);
+  TEST_VQRSHL(int, q, uint, u, 64, 2, expected_cumulative_sat, CMT);
+
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected, CMT);
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected, CMT);
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected, CMT);
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected, CMT);
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected, CMT);
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected, CMT);
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected, CMT);
+
+
+  /* Use negative shift amounts.  */
+  VDUP(vector_shift, , int, s, 8, 8, -2);
+  VDUP(vector_shift, , int, s, 16, 4, -2);
+  VDUP(vector_shift, , int, s, 32, 2, -3);
+  VDUP(vector_shift, , int, s, 64, 1, -4);
+  VDUP(vector_shift, q, int, s, 8, 16, -7);
+  VDUP(vector_shift, q, int, s, 16, 8, -11);
+  VDUP(vector_shift, q, int, s, 32, 4, -13);
+  VDUP(vector_shift, q, int, s, 64, 2, -20);
+
+#undef CMT
+#define CMT " (negative shift amount)"
+  TEST_VQRSHL(int, , int, s, 8, 8, expected_cumulative_sat_neg, CMT);
+  TEST_VQRSHL(int, , int, s, 16, 4, expected_cumulative_sat_neg, CMT);
+  TEST_VQRSHL(int, , int, s, 32, 2, expected_cumulative_sat_neg, CMT);
+  TEST_VQRSHL(int, , int, s, 64, 1, expected_cumulative_sat_neg, CMT);
+  TEST_VQRSHL(int, , uint, u, 8, 8, expected_cumulative_sat_neg, CMT);
+  TEST_VQRSHL(int, , uint, u, 16, 4, expected_cumulative_sat_neg, CMT);
+  TEST_VQRSHL(int, , uint, u, 32, 2, expected_cumulative_sat_neg, CMT);
+  TEST_VQRSHL(int, , uint, u, 64, 1, expected_cumulative_sat_neg, CMT);
+  TEST_VQRSHL(int, q, int, s, 8, 16, expected_cumulative_sat_neg, CMT);
+  TEST_VQRSHL(int, q, int, s, 16, 8, expected_cumulative_sat_neg, CMT);
+  TEST_VQRSHL(int, q, int, s, 32, 4, expected_cumulative_sat_neg, CMT);
+  TEST_VQRSHL(int, q, int, s, 64, 2, expected_cumulative_sat_neg, CMT);
+  TEST_VQRSHL(int, q, uint, u, 8, 16, expected_cumulative_sat_neg, CMT);
+  TEST_VQRSHL(int, q, uint, u, 16, 8, expected_cumulative_sat_neg, CMT);
+  TEST_VQRSHL(int, q, uint, u, 32, 4, expected_cumulative_sat_neg, CMT);
+  TEST_VQRSHL(int, q, uint, u, 64, 2, expected_cumulative_sat_neg, CMT);
+
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_neg, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_neg, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_neg, CMT);
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected_neg, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_neg, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_neg, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_neg, CMT);
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected_neg, CMT);
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected_neg, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_neg, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_neg, CMT);
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected_neg, CMT);
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected_neg, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_neg, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_neg, CMT);
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected_neg, CMT);
+
+
+  /* Fill input vector with max value, to check saturation on
+     limits.  */
+  VDUP(vector, , int, s, 8, 8, 0x7F);
+  VDUP(vector, , int, s, 16, 4, 0x7FFF);
+  VDUP(vector, , int, s, 32, 2, 0x7FFFFFFF);
+  VDUP(vector, , int, s, 64, 1, 0x7FFFFFFFFFFFFFFFLL);
+  VDUP(vector, , uint, u, 8, 8, 0xFF);
+  VDUP(vector, , uint, u, 16, 4, 0xFFFF);
+  VDUP(vector, , uint, u, 32, 2, 0xFFFFFFFF);
+  VDUP(vector, , uint, u, 64, 1, 0xFFFFFFFFFFFFFFFFULL);
+  VDUP(vector, q, int, s, 8, 16, 0x7F);
+  VDUP(vector, q, int, s, 16, 8, 0x7FFF);
+  VDUP(vector, q, int, s, 32, 4, 0x7FFFFFFF);
+  VDUP(vector, q, int, s, 64, 2, 0x7FFFFFFFFFFFFFFFLL);
+  VDUP(vector, q, uint, u, 8, 16, 0xFF);
+  VDUP(vector, q, uint, u, 16, 8, 0xFFFF);
+  VDUP(vector, q, uint, u, 32, 4, 0xFFFFFFFF);
+  VDUP(vector, q, uint, u, 64, 2, 0xFFFFFFFFFFFFFFFFULL);
+
+  /* Use -1 shift amount to check cumulative saturation with
+     round_const.  */
+  VDUP(vector_shift, , int, s, 8, 8, -1);
+  VDUP(vector_shift, , int, s, 16, 4, -1);
+  VDUP(vector_shift, , int, s, 32, 2, -1);
+  VDUP(vector_shift, , int, s, 64, 1, -1);
+  VDUP(vector_shift, q, int, s, 8, 16, -1);
+  VDUP(vector_shift, q, int, s, 16, 8, -1);
+  VDUP(vector_shift, q, int, s, 32, 4, -1);
+  VDUP(vector_shift, q, int, s, 64, 2, -1);
+
+#undef CMT
+#define CMT " (checking cumulative saturation: shift by -1)"
+  TEST_VQRSHL(int, , int, s, 8, 8, expected_cumulative_sat_minus1, CMT);
+  TEST_VQRSHL(int, , int, s, 16, 4, expected_cumulative_sat_minus1, CMT);
+  TEST_VQRSHL(int, , int, s, 32, 2, expected_cumulative_sat_minus1, CMT);
+  TEST_VQRSHL(int, , int, s, 64, 1, expected_cumulative_sat_minus1, CMT);
+  TEST_VQRSHL(int, , uint, u, 8, 8, expected_cumulative_sat_minus1, CMT);
+  TEST_VQRSHL(int, , uint, u, 16, 4, expected_cumulative_sat_minus1, CMT);
+  TEST_VQRSHL(int, , uint, u, 32, 2, expected_cumulative_sat_minus1, CMT);
+  TEST_VQRSHL(int, , uint, u, 64, 1, expected_cumulative_sat_minus1, CMT);
+  TEST_VQRSHL(int, q, int, s, 8, 16, expected_cumulative_sat_minus1, CMT);
+  TEST_VQRSHL(int, q, int, s, 16, 8, expected_cumulative_sat_minus1, CMT);
+  TEST_VQRSHL(int, q, int, s, 32, 4, expected_cumulative_sat_minus1, CMT);
+  TEST_VQRSHL(int, q, int, s, 64, 2, expected_cumulative_sat_minus1, CMT);
+  TEST_VQRSHL(int, q, uint, u, 8, 16, expected_cumulative_sat_minus1, CMT);
+  TEST_VQRSHL(int, q, uint, u, 16, 8, expected_cumulative_sat_minus1, CMT);
+  TEST_VQRSHL(int, q, uint, u, 32, 4, expected_cumulative_sat_minus1, CMT);
+  TEST_VQRSHL(int, q, uint, u, 64, 2, expected_cumulative_sat_minus1, CMT);
+
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_minus1, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_minus1, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_minus1, CMT);
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected_minus1, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_minus1, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_minus1, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_minus1, CMT);
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected_minus1, CMT);
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected_minus1, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_minus1, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_minus1, CMT);
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected_minus1, CMT);
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected_minus1, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_minus1, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_minus1, CMT);
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected_minus1, CMT);
+
+
+  /* Use -3 shift amount to check cumulative saturation with
+     round_const. */
+  VDUP(vector_shift, , int, s, 8, 8, -3);
+  VDUP(vector_shift, , int, s, 16, 4, -3);
+  VDUP(vector_shift, , int, s, 32, 2, -3);
+  VDUP(vector_shift, , int, s, 64, 1, -3);
+  VDUP(vector_shift, q, int, s, 8, 16, -3);
+  VDUP(vector_shift, q, int, s, 16, 8, -3);
+  VDUP(vector_shift, q, int, s, 32, 4, -3);
+  VDUP(vector_shift, q, int, s, 64, 2, -3);
+
+#undef CMT
+#define CMT " (checking cumulative saturation: shift by -3)"
+  TEST_VQRSHL(int, , int, s, 8, 8, expected_cumulative_sat_minus3, CMT);
+  TEST_VQRSHL(int, , int, s, 16, 4, expected_cumulative_sat_minus3, CMT);
+  TEST_VQRSHL(int, , int, s, 32, 2, expected_cumulative_sat_minus3, CMT);
+  TEST_VQRSHL(int, , int, s, 64, 1, expected_cumulative_sat_minus3, CMT);
+  TEST_VQRSHL(int, , uint, u, 8, 8, expected_cumulative_sat_minus3, CMT);
+  TEST_VQRSHL(int, , uint, u, 16, 4, expected_cumulative_sat_minus3, CMT);
+  TEST_VQRSHL(int, , uint, u, 32, 2, expected_cumulative_sat_minus3, CMT);
+  TEST_VQRSHL(int, , uint, u, 64, 1, expected_cumulative_sat_minus3, CMT);
+  TEST_VQRSHL(int, q, int, s, 8, 16, expected_cumulative_sat_minus3, CMT);
+  TEST_VQRSHL(int, q, int, s, 16, 8, expected_cumulative_sat_minus3, CMT);
+  TEST_VQRSHL(int, q, int, s, 32, 4, expected_cumulative_sat_minus3, CMT);
+  TEST_VQRSHL(int, q, int, s, 64, 2, expected_cumulative_sat_minus3, CMT);
+  TEST_VQRSHL(int, q, uint, u, 8, 16, expected_cumulative_sat_minus3, CMT);
+  TEST_VQRSHL(int, q, uint, u, 16, 8, expected_cumulative_sat_minus3, CMT);
+  TEST_VQRSHL(int, q, uint, u, 32, 4, expected_cumulative_sat_minus3, CMT);
+  TEST_VQRSHL(int, q, uint, u, 64, 2, expected_cumulative_sat_minus3, CMT);
+
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_minus3, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_minus3, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_minus3, CMT);
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected_minus3, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_minus3, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_minus3, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_minus3, CMT);
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected_minus3, CMT);
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected_minus3, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_minus3, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_minus3, CMT);
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected_minus3, CMT);
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected_minus3, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_minus3, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_minus3, CMT);
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected_minus3, CMT);
+
+
+  /* Use large shift amount.  */
+  VDUP(vector_shift, , int, s, 8, 8, 10);
+  VDUP(vector_shift, , int, s, 16, 4, 20);
+  VDUP(vector_shift, , int, s, 32, 2, 40);
+  VDUP(vector_shift, , int, s, 64, 1, 70);
+  VDUP(vector_shift, q, int, s, 8, 16, 10);
+  VDUP(vector_shift, q, int, s, 16, 8, 20);
+  VDUP(vector_shift, q, int, s, 32, 4, 40);
+  VDUP(vector_shift, q, int, s, 64, 2, 70);
+
+#undef CMT
+#define CMT " (checking cumulative saturation: large shift amount)"
+  TEST_VQRSHL(int, , int, s, 8, 8, expected_cumulative_sat_large_sh, CMT);
+  TEST_VQRSHL(int, , int, s, 16, 4, expected_cumulative_sat_large_sh, CMT);
+  TEST_VQRSHL(int, , int, s, 32, 2, expected_cumulative_sat_large_sh, CMT);
+  TEST_VQRSHL(int, , int, s, 64, 1, expected_cumulative_sat_large_sh, CMT);
+  TEST_VQRSHL(int, , uint, u, 8, 8, expected_cumulative_sat_large_sh, CMT);
+  TEST_VQRSHL(int, , uint, u, 16, 4, expected_cumulative_sat_large_sh, CMT);
+  TEST_VQRSHL(int, , uint, u, 32, 2, expected_cumulative_sat_large_sh, CMT);
+  TEST_VQRSHL(int, , uint, u, 64, 1, expected_cumulative_sat_large_sh, CMT);
+  TEST_VQRSHL(int, q, int, s, 8, 16, expected_cumulative_sat_large_sh, CMT);
+  TEST_VQRSHL(int, q, int, s, 16, 8, expected_cumulative_sat_large_sh, CMT);
+  TEST_VQRSHL(int, q, int, s, 32, 4, expected_cumulative_sat_large_sh, CMT);
+  TEST_VQRSHL(int, q, int, s, 64, 2, expected_cumulative_sat_large_sh, CMT);
+  TEST_VQRSHL(int, q, uint, u, 8, 16, expected_cumulative_sat_large_sh, CMT);
+  TEST_VQRSHL(int, q, uint, u, 16, 8, expected_cumulative_sat_large_sh, CMT);
+  TEST_VQRSHL(int, q, uint, u, 32, 4, expected_cumulative_sat_large_sh, CMT);
+  TEST_VQRSHL(int, q, uint, u, 64, 2, expected_cumulative_sat_large_sh, CMT);
+
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_large_sh, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_large_sh, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_large_sh, CMT);
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected_large_sh, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_large_sh, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_large_sh, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_large_sh, CMT);
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected_large_sh, CMT);
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected_large_sh, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_large_sh, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_large_sh, CMT);
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected_large_sh, CMT);
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected_large_sh, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_large_sh, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_large_sh, CMT);
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected_large_sh, CMT);
+
+
+  /* Fill input vector with negative values, to check saturation on
+     limits.  */
+  VDUP(vector, , int, s, 8, 8, 0x80);
+  VDUP(vector, , int, s, 16, 4, 0x8000);
+  VDUP(vector, , int, s, 32, 2, 0x80000000);
+  VDUP(vector, , int, s, 64, 1, 0x8000000000000000LL);
+  VDUP(vector, q, int, s, 8, 16, 0x80);
+  VDUP(vector, q, int, s, 16, 8, 0x8000);
+  VDUP(vector, q, int, s, 32, 4, 0x80000000);
+  VDUP(vector, q, int, s, 64, 2, 0x8000000000000000LL);
+
+  /* Use large shift amount.  */
+  VDUP(vector_shift, , int, s, 8, 8, 10);
+  VDUP(vector_shift, , int, s, 16, 4, 20);
+  VDUP(vector_shift, , int, s, 32, 2, 40);
+  VDUP(vector_shift, , int, s, 64, 1, 70);
+  VDUP(vector_shift, q, int, s, 8, 16, 10);
+  VDUP(vector_shift, q, int, s, 16, 8, 20);
+  VDUP(vector_shift, q, int, s, 32, 4, 40);
+  VDUP(vector_shift, q, int, s, 64, 2, 70);
+
+#undef CMT
+#define CMT " (checking cumulative saturation: large shift amount with negative input)"
+  TEST_VQRSHL(int, , int, s, 8, 8, expected_cumulative_sat_neg_large_sh, CMT);
+  TEST_VQRSHL(int, , int, s, 16, 4, expected_cumulative_sat_neg_large_sh, CMT);
+  TEST_VQRSHL(int, , int, s, 32, 2, expected_cumulative_sat_neg_large_sh, CMT);
+  TEST_VQRSHL(int, , int, s, 64, 1, expected_cumulative_sat_neg_large_sh, CMT);
+  TEST_VQRSHL(int, , uint, u, 8, 8, expected_cumulative_sat_neg_large_sh, CMT);
+  TEST_VQRSHL(int, , uint, u, 16, 4, expected_cumulative_sat_neg_large_sh, CMT);
+  TEST_VQRSHL(int, , uint, u, 32, 2, expected_cumulative_sat_neg_large_sh, CMT);
+  TEST_VQRSHL(int, , uint, u, 64, 1, expected_cumulative_sat_neg_large_sh, CMT);
+  TEST_VQRSHL(int, q, int, s, 8, 16, expected_cumulative_sat_neg_large_sh, CMT);
+  TEST_VQRSHL(int, q, int, s, 16, 8, expected_cumulative_sat_neg_large_sh, CMT);
+  TEST_VQRSHL(int, q, int, s, 32, 4, expected_cumulative_sat_neg_large_sh, CMT);
+  TEST_VQRSHL(int, q, int, s, 64, 2, expected_cumulative_sat_neg_large_sh, CMT);
+  TEST_VQRSHL(int, q, uint, u, 8, 16, expected_cumulative_sat_neg_large_sh, CMT);
+  TEST_VQRSHL(int, q, uint, u, 16, 8, expected_cumulative_sat_neg_large_sh, CMT);
+  TEST_VQRSHL(int, q, uint, u, 32, 4, expected_cumulative_sat_neg_large_sh, CMT);
+  TEST_VQRSHL(int, q, uint, u, 64, 2, expected_cumulative_sat_neg_large_sh, CMT);
+
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_neg_large_sh, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_neg_large_sh, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_neg_large_sh, CMT);
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected_neg_large_sh, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_neg_large_sh, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_neg_large_sh, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_neg_large_sh, CMT);
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected_neg_large_sh, CMT);
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected_neg_large_sh, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_neg_large_sh, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_neg_large_sh, CMT);
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected_neg_large_sh, CMT);
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected_neg_large_sh, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_neg_large_sh, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_neg_large_sh, CMT);
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected_neg_large_sh, CMT);
+
+
+  /* Fill input vector with negative and positive values, to check
+   * saturation on limits */
+  VDUP(vector, , int, s, 8, 8, 0x7F);
+  VDUP(vector, , int, s, 16, 4, 0x7FFF);
+  VDUP(vector, , int, s, 32, 2, 0x7FFFFFFF);
+  VDUP(vector, , int, s, 64, 1, 0x7FFFFFFFFFFFFFFFLL);
+  VDUP(vector, q, int, s, 8, 16, 0x80);
+  VDUP(vector, q, int, s, 16, 8, 0x8000);
+  VDUP(vector, q, int, s, 32, 4, 0x80000000);
+  VDUP(vector, q, int, s, 64, 2, 0x8000000000000000LL);
+
+  /* Use large negative shift amount  */
+  VDUP(vector_shift, , int, s, 8, 8, -10);
+  VDUP(vector_shift, , int, s, 16, 4, -20);
+  VDUP(vector_shift, , int, s, 32, 2, -40);
+  VDUP(vector_shift, , int, s, 64, 1, -70);
+  VDUP(vector_shift, q, int, s, 8, 16, -10);
+  VDUP(vector_shift, q, int, s, 16, 8, -20);
+  VDUP(vector_shift, q, int, s, 32, 4, -40);
+  VDUP(vector_shift, q, int, s, 64, 2, -70);
+
+#undef CMT
+#define CMT " (checking cumulative saturation: large negative shift amount)"
+  TEST_VQRSHL(int, , int, s, 8, 8, expected_cumulative_sat_large_neg_sh, CMT);
+  TEST_VQRSHL(int, , int, s, 16, 4, expected_cumulative_sat_large_neg_sh, CMT);
+  TEST_VQRSHL(int, , int, s, 32, 2, expected_cumulative_sat_large_neg_sh, CMT);
+  TEST_VQRSHL(int, , int, s, 64, 1, expected_cumulative_sat_large_neg_sh, CMT);
+  TEST_VQRSHL(int, , uint, u, 8, 8, expected_cumulative_sat_large_neg_sh, CMT);
+  TEST_VQRSHL(int, , uint, u, 16, 4, expected_cumulative_sat_large_neg_sh, CMT);
+  TEST_VQRSHL(int, , uint, u, 32, 2, expected_cumulative_sat_large_neg_sh, CMT);
+  TEST_VQRSHL(int, , uint, u, 64, 1, expected_cumulative_sat_large_neg_sh, CMT);
+  TEST_VQRSHL(int, q, int, s, 8, 16, expected_cumulative_sat_large_neg_sh, CMT);
+  TEST_VQRSHL(int, q, int, s, 16, 8, expected_cumulative_sat_large_neg_sh, CMT);
+  TEST_VQRSHL(int, q, int, s, 32, 4, expected_cumulative_sat_large_neg_sh, CMT);
+  TEST_VQRSHL(int, q, int, s, 64, 2, expected_cumulative_sat_large_neg_sh, CMT);
+  TEST_VQRSHL(int, q, uint, u, 8, 16, expected_cumulative_sat_large_neg_sh, CMT);
+  TEST_VQRSHL(int, q, uint, u, 16, 8, expected_cumulative_sat_large_neg_sh, CMT);
+  TEST_VQRSHL(int, q, uint, u, 32, 4, expected_cumulative_sat_large_neg_sh, CMT);
+  TEST_VQRSHL(int, q, uint, u, 64, 2, expected_cumulative_sat_large_neg_sh, CMT);
+
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_large_neg_sh, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_large_neg_sh, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_large_neg_sh, CMT);
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected_large_neg_sh, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_large_neg_sh, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_large_neg_sh, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_large_neg_sh, CMT);
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected_large_neg_sh, CMT);
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected_large_neg_sh, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_large_neg_sh, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_large_neg_sh, CMT);
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected_large_neg_sh, CMT);
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected_large_neg_sh, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_large_neg_sh, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_large_neg_sh, CMT);
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected_large_neg_sh, CMT);
+
+
+  /* Fill input vector with 0, to check saturation in case of large
+   * shift amount */
+  VDUP(vector, , int, s, 8, 8, 0);
+  VDUP(vector, , int, s, 16, 4, 0);
+  VDUP(vector, , int, s, 32, 2, 0);
+  VDUP(vector, , int, s, 64, 1, 0);
+  VDUP(vector, q, int, s, 8, 16, 0);
+  VDUP(vector, q, int, s, 16, 8, 0);
+  VDUP(vector, q, int, s, 32, 4, 0);
+  VDUP(vector, q, int, s, 64, 2, 0);
+
+  /* Use large shift amount  */
+  VDUP(vector_shift, , int, s, 8, 8, -10);
+  VDUP(vector_shift, , int, s, 16, 4, -20);
+  VDUP(vector_shift, , int, s, 32, 2, -40);
+  VDUP(vector_shift, , int, s, 64, 1, -70);
+  VDUP(vector_shift, q, int, s, 8, 16, -10);
+  VDUP(vector_shift, q, int, s, 16, 8, -20);
+  VDUP(vector_shift, q, int, s, 32, 4, -40);
+  VDUP(vector_shift, q, int, s, 64, 2, -70);
+
+#undef CMT
+#define CMT " (checking cumulative saturation: large negative shift amount with 0 input)"
+  TEST_VQRSHL(int, , int, s, 8, 8, expected_cumulative_sat_large_neg_sh, CMT);
+  TEST_VQRSHL(int, , int, s, 16, 4, expected_cumulative_sat_large_neg_sh, CMT);
+  TEST_VQRSHL(int, , int, s, 32, 2, expected_cumulative_sat_large_neg_sh, CMT);
+  TEST_VQRSHL(int, , int, s, 64, 1, expected_cumulative_sat_large_neg_sh, CMT);
+  TEST_VQRSHL(int, , uint, u, 8, 8, expected_cumulative_sat_large_neg_sh, CMT);
+  TEST_VQRSHL(int, , uint, u, 16, 4, expected_cumulative_sat_large_neg_sh, CMT);
+  TEST_VQRSHL(int, , uint, u, 32, 2, expected_cumulative_sat_large_neg_sh, CMT);
+  TEST_VQRSHL(int, , uint, u, 64, 1, expected_cumulative_sat_large_neg_sh, CMT);
+  TEST_VQRSHL(int, q, int, s, 8, 16, expected_cumulative_sat_large_neg_sh, CMT);
+  TEST_VQRSHL(int, q, int, s, 16, 8, expected_cumulative_sat_large_neg_sh, CMT);
+  TEST_VQRSHL(int, q, int, s, 32, 4, expected_cumulative_sat_large_neg_sh, CMT);
+  TEST_VQRSHL(int, q, int, s, 64, 2, expected_cumulative_sat_large_neg_sh, CMT);
+  TEST_VQRSHL(int, q, uint, u, 8, 16, expected_cumulative_sat_large_neg_sh, CMT);
+  TEST_VQRSHL(int, q, uint, u, 16, 8, expected_cumulative_sat_large_neg_sh, CMT);
+  TEST_VQRSHL(int, q, uint, u, 32, 4, expected_cumulative_sat_large_neg_sh, CMT);
+  TEST_VQRSHL(int, q, uint, u, 64, 2, expected_cumulative_sat_large_neg_sh, CMT);
+
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_large_neg_sh, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_large_neg_sh, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_large_neg_sh, CMT);
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected_large_neg_sh, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_large_neg_sh, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_large_neg_sh, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_large_neg_sh, CMT);
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected_large_neg_sh, CMT);
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected_large_neg_sh, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_large_neg_sh, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_large_neg_sh, CMT);
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected_large_neg_sh, CMT);
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected_large_neg_sh, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_large_neg_sh, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_large_neg_sh, CMT);
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected_large_neg_sh, CMT);
+}
+
+int main (void)
+{
+  exec_vqrshl ();
+  return 0;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vqrshrn_n.c
@@ -0,0 +1,174 @@
+#include <arm_neon.h>
+#include "arm-neon-ref.h"
+#include "compute-ref-data.h"
+
+/* Expected values of cumulative_saturation flag.  */
+int VECT_VAR(expected_cumulative_sat,int,16,8) = 0;
+int VECT_VAR(expected_cumulative_sat,int,32,4) = 0;
+int VECT_VAR(expected_cumulative_sat,int,64,2) = 0;
+int VECT_VAR(expected_cumulative_sat,uint,16,8) = 1;
+int VECT_VAR(expected_cumulative_sat,uint,32,4) = 1;
+int VECT_VAR(expected_cumulative_sat,uint,64,2) = 1;
+
+/* Expected results.  */
+VECT_VAR_DECL(expected,int,8,8) [] = { 0xf8, 0xf9, 0xf9, 0xfa,
+				       0xfa, 0xfb, 0xfb, 0xfc };
+VECT_VAR_DECL(expected,int,16,4) [] = { 0xfff8, 0xfff9, 0xfff9, 0xfffa };
+VECT_VAR_DECL(expected,int,32,2) [] = { 0xfffffffc, 0xfffffffc };
+VECT_VAR_DECL(expected,uint,8,8) [] = { 0xff, 0xff, 0xff, 0xff,
+					0xff, 0xff, 0xff, 0xff };
+VECT_VAR_DECL(expected,uint,16,4) [] = { 0xffff, 0xffff, 0xffff, 0xffff };
+VECT_VAR_DECL(expected,uint,32,2) [] = { 0xffffffff, 0xffffffff };
+
+/* Expected values of cumulative_saturation flag with shift by 3.  */
+int VECT_VAR(expected_cumulative_sat_sh3,int,16,8) = 1;
+int VECT_VAR(expected_cumulative_sat_sh3,int,32,4) = 1;
+int VECT_VAR(expected_cumulative_sat_sh3,int,64,2) = 1;
+int VECT_VAR(expected_cumulative_sat_sh3,uint,16,8) = 1;
+int VECT_VAR(expected_cumulative_sat_sh3,uint,32,4) = 1;
+int VECT_VAR(expected_cumulative_sat_sh3,uint,64,2) = 1;
+
+/* Expected results with shift by 3.  */
+VECT_VAR_DECL(expected_sh3,int,8,8) [] = { 0x7f, 0x7f, 0x7f, 0x7f,
+					   0x7f, 0x7f, 0x7f, 0x7f };
+VECT_VAR_DECL(expected_sh3,int,16,4) [] = { 0x7fff, 0x7fff, 0x7fff, 0x7fff };
+VECT_VAR_DECL(expected_sh3,int,32,2) [] = { 0x7fffffff, 0x7fffffff };
+VECT_VAR_DECL(expected_sh3,uint,8,8) [] = { 0xff, 0xff, 0xff, 0xff,
+					    0xff, 0xff, 0xff, 0xff };
+VECT_VAR_DECL(expected_sh3,uint,16,4) [] = { 0xffff, 0xffff, 0xffff, 0xffff };
+VECT_VAR_DECL(expected_sh3,uint,32,2) [] = { 0xffffffff, 0xffffffff };
+
+/* Expected values of cumulative_saturation flag with shift by max
+   amount.  */
+int VECT_VAR(expected_cumulative_sat_shmax,int,16,8) = 1;
+int VECT_VAR(expected_cumulative_sat_shmax,int,32,4) = 1;
+int VECT_VAR(expected_cumulative_sat_shmax,int,64,2) = 1;
+int VECT_VAR(expected_cumulative_sat_shmax,uint,16,8) = 1;
+int VECT_VAR(expected_cumulative_sat_shmax,uint,32,4) = 1;
+int VECT_VAR(expected_cumulative_sat_shmax,uint,64,2) = 1;
+
+/* Expected results with shift by max amount.  */
+VECT_VAR_DECL(expected_shmax,int,8,8) [] = { 0x7f, 0x7f, 0x7f, 0x7f,
+					     0x7f, 0x7f, 0x7f, 0x7f };
+VECT_VAR_DECL(expected_shmax,int,16,4) [] = { 0x7fff, 0x7fff, 0x7fff, 0x7fff };
+VECT_VAR_DECL(expected_shmax,int,32,2) [] = { 0x7fffffff, 0x7fffffff };
+VECT_VAR_DECL(expected_shmax,uint,8,8) [] = { 0xff, 0xff, 0xff, 0xff,
+					      0xff, 0xff, 0xff, 0xff };
+VECT_VAR_DECL(expected_shmax,uint,16,4) [] = { 0xffff, 0xffff, 0xffff, 0xffff };
+VECT_VAR_DECL(expected_shmax,uint,32,2) [] = { 0xffffffff, 0xffffffff };
+
+#define INSN vqrshrn_n
+#define TEST_MSG "VQRSHRN_N"
+
+#define FNNAME1(NAME) void exec_ ## NAME (void)
+#define FNNAME(NAME) FNNAME1(NAME)
+
+FNNAME (INSN)
+{
+  /* Basic test: y=vqrshrn_n(x,v), then store the result.  */
+#define TEST_VQRSHRN_N2(INSN, T1, T2, W, W2, N, V, EXPECTED_CUMULATIVE_SAT, CMT) \
+  Set_Neon_Cumulative_Sat(0, VECT_VAR(vector_res, T1, W2, N));		\
+  VECT_VAR(vector_res, T1, W2, N) =					\
+    INSN##_##T2##W(VECT_VAR(vector, T1, W, N),				\
+		   V);							\
+  vst1_##T2##W2(VECT_VAR(result, T1, W2, N),				\
+		VECT_VAR(vector_res, T1, W2, N));			\
+  CHECK_CUMULATIVE_SAT(TEST_MSG, T1, W, N, EXPECTED_CUMULATIVE_SAT, CMT)
+
+  /* Two auxliary macros are necessary to expand INSN */
+#define TEST_VQRSHRN_N1(INSN, T1, T2, W, W2, N, V, EXPECTED_CUMULATIVE_SAT, CMT) \
+  TEST_VQRSHRN_N2(INSN, T1, T2, W, W2, N, V, EXPECTED_CUMULATIVE_SAT, CMT)
+
+#define TEST_VQRSHRN_N(T1, T2, W, W2, N, V, EXPECTED_CUMULATIVE_SAT, CMT) \
+  TEST_VQRSHRN_N1(INSN, T1, T2, W, W2, N, V, EXPECTED_CUMULATIVE_SAT, CMT)
+
+
+  /* vector is twice as large as vector_res.  */
+  DECL_VARIABLE(vector, int, 16, 8);
+  DECL_VARIABLE(vector, int, 32, 4);
+  DECL_VARIABLE(vector, int, 64, 2);
+  DECL_VARIABLE(vector, uint, 16, 8);
+  DECL_VARIABLE(vector, uint, 32, 4);
+  DECL_VARIABLE(vector, uint, 64, 2);
+
+  DECL_VARIABLE(vector_res, int, 8, 8);
+  DECL_VARIABLE(vector_res, int, 16, 4);
+  DECL_VARIABLE(vector_res, int, 32, 2);
+  DECL_VARIABLE(vector_res, uint, 8, 8);
+  DECL_VARIABLE(vector_res, uint, 16, 4);
+  DECL_VARIABLE(vector_res, uint, 32, 2);
+
+  clean_results ();
+
+  VLOAD(vector, buffer, q, int, s, 16, 8);
+  VLOAD(vector, buffer, q, int, s, 32, 4);
+  VLOAD(vector, buffer, q, int, s, 64, 2);
+  VLOAD(vector, buffer, q, uint, u, 16, 8);
+  VLOAD(vector, buffer, q, uint, u, 32, 4);
+  VLOAD(vector, buffer, q, uint, u, 64, 2);
+
+  /* Choose shift amount arbitrarily.  */
+#define CMT ""
+  TEST_VQRSHRN_N(int, s, 16, 8, 8, 1, expected_cumulative_sat, CMT);
+  TEST_VQRSHRN_N(int, s, 32, 16, 4, 1, expected_cumulative_sat, CMT);
+  TEST_VQRSHRN_N(int, s, 64, 32, 2, 2, expected_cumulative_sat, CMT);
+  TEST_VQRSHRN_N(uint, u, 16, 8, 8, 2, expected_cumulative_sat, CMT);
+  TEST_VQRSHRN_N(uint, u, 32, 16, 4, 3, expected_cumulative_sat, CMT);
+  TEST_VQRSHRN_N(uint, u, 64, 32, 2, 3, expected_cumulative_sat, CMT);
+
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected, CMT);
+
+
+  /* Another set of tests, shifting max value by 3.  */
+  VDUP(vector, q, int, s, 16, 8, 0x7FFF);
+  VDUP(vector, q, int, s, 32, 4, 0x7FFFFFFF);
+  VDUP(vector, q, int, s, 64, 2, 0x7FFFFFFFFFFFFFFFLL);
+  VDUP(vector, q, uint, u, 16, 8, 0xFFFF);
+  VDUP(vector, q, uint, u, 32, 4, 0xFFFFFFFF);
+  VDUP(vector, q, uint, u, 64, 2, 0xFFFFFFFFFFFFFFFFULL);
+
+#undef CMT
+#define CMT " (check saturation: shift by 3)"
+  TEST_VQRSHRN_N(int, s, 16, 8, 8, 3, expected_cumulative_sat_sh3, CMT);
+  TEST_VQRSHRN_N(int, s, 32, 16, 4, 3, expected_cumulative_sat_sh3, CMT);
+  TEST_VQRSHRN_N(int, s, 64, 32, 2, 3, expected_cumulative_sat_sh3, CMT);
+  TEST_VQRSHRN_N(uint, u, 16, 8, 8, 3, expected_cumulative_sat_sh3, CMT);
+  TEST_VQRSHRN_N(uint, u, 32, 16, 4, 3, expected_cumulative_sat_sh3, CMT);
+  TEST_VQRSHRN_N(uint, u, 64, 32, 2, 3, expected_cumulative_sat_sh3, CMT);
+
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_sh3, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_sh3, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_sh3, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_sh3, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_sh3, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_sh3, CMT);
+
+
+  /* Shift by max amount.  */
+#undef CMT
+#define CMT " (check saturation: shift by max)"
+  TEST_VQRSHRN_N(int, s, 16, 8, 8, 8, expected_cumulative_sat_shmax, CMT);
+  TEST_VQRSHRN_N(int, s, 32, 16, 4, 16, expected_cumulative_sat_shmax, CMT);
+  TEST_VQRSHRN_N(int, s, 64, 32, 2, 32, expected_cumulative_sat_shmax, CMT);
+  TEST_VQRSHRN_N(uint, u, 16, 8, 8, 8, expected_cumulative_sat_shmax, CMT);
+  TEST_VQRSHRN_N(uint, u, 32, 16, 4, 16, expected_cumulative_sat_shmax, CMT);
+  TEST_VQRSHRN_N(uint, u, 64, 32, 2, 32, expected_cumulative_sat_shmax, CMT);
+
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_shmax, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_shmax, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_shmax, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_shmax, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_shmax, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_shmax, CMT);
+}
+
+int main (void)
+{
+  exec_vqrshrn_n ();
+  return 0;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vqrshrun_n.c
@@ -0,0 +1,189 @@
+#include <arm_neon.h>
+#include "arm-neon-ref.h"
+#include "compute-ref-data.h"
+
+/* Expected values of cumulative_saturation flag with negative unput.  */
+int VECT_VAR(expected_cumulative_sat_neg,int,16,8) = 0;
+int VECT_VAR(expected_cumulative_sat_neg,int,32,4) = 0;
+int VECT_VAR(expected_cumulative_sat_neg,int,64,2) = 1;
+
+/* Expected results with negative input.  */
+VECT_VAR_DECL(expected_neg,uint,8,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					    0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_neg,uint,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_neg,uint,32,2) [] = { 0x0, 0x0 };
+
+/* Expected values of cumulative_saturation flag with max input value
+   shifted by 1.  */
+int VECT_VAR(expected_cumulative_sat_max_sh1,int,16,8) = 1;
+int VECT_VAR(expected_cumulative_sat_max_sh1,int,32,4) = 1;
+int VECT_VAR(expected_cumulative_sat_max_sh1,int,64,2) = 1;
+
+/* Expected results with max input value shifted by 1.  */
+VECT_VAR_DECL(expected_max_sh1,uint,8,8) [] = { 0xff, 0xff, 0xff, 0xff,
+						0xff, 0xff, 0xff, 0xff };
+VECT_VAR_DECL(expected_max_sh1,uint,16,4) [] = { 0xffff, 0xffff,
+						 0xffff, 0xffff };
+VECT_VAR_DECL(expected_max_sh1,uint,32,2) [] = { 0xffffffff, 0xffffffff };
+VECT_VAR_DECL(expected_max_sh1,uint,64,1) [] = { 0x3333333333333333 };
+
+/* Expected values of cumulative_saturation flag with max input value
+   shifted by max amount.  */
+int VECT_VAR(expected_cumulative_sat_max_shmax,int,16,8) = 0;
+int VECT_VAR(expected_cumulative_sat_max_shmax,int,32,4) = 0;
+int VECT_VAR(expected_cumulative_sat_max_shmax,int,64,2) = 0;
+
+/* Expected results with max input value shifted by max amount.  */
+VECT_VAR_DECL(expected_max_shmax,uint,8,8) [] = { 0x80, 0x80, 0x80, 0x80,
+						  0x80, 0x80, 0x80, 0x80 };
+VECT_VAR_DECL(expected_max_shmax,uint,16,4) [] = { 0x8000, 0x8000,
+						   0x8000, 0x8000 };
+VECT_VAR_DECL(expected_max_shmax,uint,32,2) [] = { 0x80000000, 0x80000000 };
+
+/* Expected values of cumulative_saturation flag with min input value
+   shifted by max amount.  */
+int VECT_VAR(expected_cumulative_sat_min_shmax,int,16,8) = 1;
+int VECT_VAR(expected_cumulative_sat_min_shmax,int,32,4) = 1;
+int VECT_VAR(expected_cumulative_sat_min_shmax,int,64,2) = 1;
+
+/* Expected results with min input value shifted by max amount.  */
+VECT_VAR_DECL(expected_min_shmax,uint,8,8) [] = { 0x0, 0x0, 0x0, 0x0,
+						  0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_min_shmax,uint,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_min_shmax,uint,32,2) [] = { 0x0, 0x0 };
+
+/* Expected values of cumulative_saturation flag with inputs in usual
+   range.  */
+int VECT_VAR(expected_cumulative_sat,int,16,8) = 0;
+int VECT_VAR(expected_cumulative_sat,int,32,4) = 1;
+int VECT_VAR(expected_cumulative_sat,int,64,2) = 0;
+
+/* Expected results with inputs in usual range.  */
+VECT_VAR_DECL(expected,uint,8,8) [] = { 0x49, 0x49, 0x49, 0x49,
+					0x49, 0x49, 0x49, 0x49 };
+VECT_VAR_DECL(expected,uint,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected,uint,32,2) [] = { 0xdeadbf, 0xdeadbf };
+
+#define INSN vqrshrun_n
+#define TEST_MSG "VQRSHRUN_N"
+
+#define FNNAME1(NAME) void exec_ ## NAME (void)
+#define FNNAME(NAME) FNNAME1(NAME)
+
+FNNAME (INSN)
+{
+  /* Basic test: y=vqrshrun_n(x,v), then store the result.  */
+#define TEST_VQRSHRUN_N2(INSN, T1, T2, W, W2, N, V, EXPECTED_CUMULATIVE_SAT, CMT) \
+  Set_Neon_Cumulative_Sat(0, VECT_VAR(vector_res, uint, W2, N));	\
+  VECT_VAR(vector_res, uint, W2, N) =					\
+    INSN##_##T2##W(VECT_VAR(vector, T1, W, N),				\
+		   V);							\
+  vst1_u##W2(VECT_VAR(result, uint, W2, N),				\
+	     VECT_VAR(vector_res, uint, W2, N));			\
+  CHECK_CUMULATIVE_SAT(TEST_MSG, T1, W, N, EXPECTED_CUMULATIVE_SAT, CMT)
+
+  /* Two auxliary macros are necessary to expand INSN */
+#define TEST_VQRSHRUN_N1(INSN, T1, T2, W, W2, N, V, EXPECTED_CUMULATIVE_SAT, CMT) \
+  TEST_VQRSHRUN_N2(INSN, T1, T2, W, W2, N, V, EXPECTED_CUMULATIVE_SAT, CMT)
+
+#define TEST_VQRSHRUN_N(T1, T2, W, W2, N, V, EXPECTED_CUMULATIVE_SAT, CMT) \
+  TEST_VQRSHRUN_N1(INSN, T1, T2, W, W2, N, V, EXPECTED_CUMULATIVE_SAT, CMT)
+
+
+  /* vector is twice as large as vector_res.  */
+  DECL_VARIABLE(vector, int, 16, 8);
+  DECL_VARIABLE(vector, int, 32, 4);
+  DECL_VARIABLE(vector, int, 64, 2);
+
+  DECL_VARIABLE(vector_res, uint, 8, 8);
+  DECL_VARIABLE(vector_res, uint, 16, 4);
+  DECL_VARIABLE(vector_res, uint, 32, 2);
+
+  clean_results ();
+
+  /* Fill input vector with negative values, to check saturation on
+     limits.  */
+  VDUP(vector, q, int, s, 16, 8, -2);
+  VDUP(vector, q, int, s, 32, 4, -3);
+  VDUP(vector, q, int, s, 64, 2, -4);
+
+  /* Choose shift amount arbitrarily.   */
+#define CMT " (negative input)"
+  TEST_VQRSHRUN_N(int, s, 16, 8, 8, 3, expected_cumulative_sat_neg, CMT);
+  TEST_VQRSHRUN_N(int, s, 32, 16, 4, 4, expected_cumulative_sat_neg, CMT);
+  TEST_VQRSHRUN_N(int, s, 64, 32, 2, 2, expected_cumulative_sat_neg, CMT);
+
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_neg, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_neg, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_neg, CMT);
+
+
+  /* Fill input vector with max value, to check saturation on
+     limits.  */
+  VDUP(vector, q, int, s, 16, 8, 0x7FFF);
+  VDUP(vector, q, int, s, 32, 4, 0x7FFFFFFF);
+  VDUP(vector, q, int, s, 64, 2, 0x7FFFFFFFFFFFFFFFLL);
+
+  /* shift by 1.  */
+#undef CMT
+#define CMT " (check cumulative saturation: shift by 1)"
+  TEST_VQRSHRUN_N(int, s, 16, 8, 8, 1, expected_cumulative_sat_max_sh1, CMT);
+  TEST_VQRSHRUN_N(int, s, 32, 16, 4, 1, expected_cumulative_sat_max_sh1, CMT);
+  TEST_VQRSHRUN_N(int, s, 64, 32, 2, 1, expected_cumulative_sat_max_sh1, CMT);
+
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_max_sh1, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_max_sh1, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_max_sh1, CMT);
+
+
+  /* shift by max.  */
+#undef CMT
+#define CMT " (check cumulative saturation: shift by max, positive input)"
+  TEST_VQRSHRUN_N(int, s, 16, 8, 8, 8, expected_cumulative_sat_max_shmax, CMT);
+  TEST_VQRSHRUN_N(int, s, 32, 16, 4, 16, expected_cumulative_sat_max_shmax, CMT);
+  TEST_VQRSHRUN_N(int, s, 64, 32, 2, 32, expected_cumulative_sat_max_shmax, CMT);
+
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_max_shmax, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_max_shmax, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_max_shmax, CMT);
+
+
+  /* Fill input vector with min value, to check saturation on limits.  */
+  VDUP(vector, q, int, s, 16, 8, 0x8000);
+  VDUP(vector, q, int, s, 32, 4, 0x80000000);
+  VDUP(vector, q, int, s, 64, 2, 0x8000000000000000LL);
+
+  /* shift by max  */
+#undef CMT
+#define CMT " (check cumulative saturation: shift by max, negative input)"
+  TEST_VQRSHRUN_N(int, s, 16, 8, 8, 8, expected_cumulative_sat_min_shmax, CMT);
+  TEST_VQRSHRUN_N(int, s, 32, 16, 4, 16, expected_cumulative_sat_min_shmax, CMT);
+  TEST_VQRSHRUN_N(int, s, 64, 32, 2, 32, expected_cumulative_sat_min_shmax, CMT);
+
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_min_shmax, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_min_shmax, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_min_shmax, CMT);
+
+
+  /* Fill input vector with positive values, to check normal case.  */
+  VDUP(vector, q, int, s, 16, 8, 0x1234);
+  VDUP(vector, q, int, s, 32, 4, 0x87654321);
+  VDUP(vector, q, int, s, 64, 2, 0xDEADBEEF);
+
+  /* shift arbitrary amount.  */
+#undef CMT
+#define CMT ""
+  TEST_VQRSHRUN_N(int, s, 16, 8, 8, 6, expected_cumulative_sat, CMT);
+  TEST_VQRSHRUN_N(int, s, 32, 16, 4, 7, expected_cumulative_sat, CMT);
+  TEST_VQRSHRUN_N(int, s, 64, 32, 2, 8, expected_cumulative_sat, CMT);
+
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected, CMT);
+}
+
+int main (void)
+{
+  exec_vqrshrun_n ();
+  return 0;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vqshl.c
@@ -0,0 +1,829 @@
+#include <arm_neon.h>
+#include "arm-neon-ref.h"
+#include "compute-ref-data.h"
+
+/* Expected values of cumulative_saturation flag with input=0.  */
+int VECT_VAR(expected_cumulative_sat_0,int,8,8) = 0;
+int VECT_VAR(expected_cumulative_sat_0,int,16,4) = 0;
+int VECT_VAR(expected_cumulative_sat_0,int,32,2) = 0;
+int VECT_VAR(expected_cumulative_sat_0,int,64,1) = 0;
+int VECT_VAR(expected_cumulative_sat_0,uint,8,8) = 0;
+int VECT_VAR(expected_cumulative_sat_0,uint,16,4) = 0;
+int VECT_VAR(expected_cumulative_sat_0,uint,32,2) = 0;
+int VECT_VAR(expected_cumulative_sat_0,uint,64,1) = 0;
+int VECT_VAR(expected_cumulative_sat_0,int,8,16) = 0;
+int VECT_VAR(expected_cumulative_sat_0,int,16,8) = 0;
+int VECT_VAR(expected_cumulative_sat_0,int,32,4) = 0;
+int VECT_VAR(expected_cumulative_sat_0,int,64,2) = 0;
+int VECT_VAR(expected_cumulative_sat_0,uint,8,16) = 0;
+int VECT_VAR(expected_cumulative_sat_0,uint,16,8) = 0;
+int VECT_VAR(expected_cumulative_sat_0,uint,32,4) = 0;
+int VECT_VAR(expected_cumulative_sat_0,uint,64,2) = 0;
+
+/* Expected results with input=0.  */
+VECT_VAR_DECL(expected_0,int,8,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0,int,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0,int,32,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_0,int,64,1) [] = { 0x0 };
+VECT_VAR_DECL(expected_0,uint,8,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					  0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0,uint,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0,uint,32,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_0,uint,64,1) [] = { 0x0 };
+VECT_VAR_DECL(expected_0,int,8,16) [] = { 0x0, 0x0, 0x0, 0x0,
+					  0x0, 0x0, 0x0, 0x0,
+					  0x0, 0x0, 0x0, 0x0,
+					  0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0,int,16,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					  0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0,int,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0,int,64,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_0,uint,8,16) [] = { 0x0, 0x0, 0x0, 0x0,
+					   0x0, 0x0, 0x0, 0x0,
+					   0x0, 0x0, 0x0, 0x0,
+					   0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0,uint,16,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					   0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0,uint,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0,uint,64,2) [] = { 0x0, 0x0 };
+
+/* Expected values of cumulative_saturation flag with input=0 and
+   negative shift amount.  */
+int VECT_VAR(expected_cumulative_sat_0_neg,int,8,8) = 0;
+int VECT_VAR(expected_cumulative_sat_0_neg,int,16,4) = 0;
+int VECT_VAR(expected_cumulative_sat_0_neg,int,32,2) = 0;
+int VECT_VAR(expected_cumulative_sat_0_neg,int,64,1) = 0;
+int VECT_VAR(expected_cumulative_sat_0_neg,uint,8,8) = 0;
+int VECT_VAR(expected_cumulative_sat_0_neg,uint,16,4) = 0;
+int VECT_VAR(expected_cumulative_sat_0_neg,uint,32,2) = 0;
+int VECT_VAR(expected_cumulative_sat_0_neg,uint,64,1) = 0;
+int VECT_VAR(expected_cumulative_sat_0_neg,int,8,16) = 0;
+int VECT_VAR(expected_cumulative_sat_0_neg,int,16,8) = 0;
+int VECT_VAR(expected_cumulative_sat_0_neg,int,32,4) = 0;
+int VECT_VAR(expected_cumulative_sat_0_neg,int,64,2) = 0;
+int VECT_VAR(expected_cumulative_sat_0_neg,uint,8,16) = 0;
+int VECT_VAR(expected_cumulative_sat_0_neg,uint,16,8) = 0;
+int VECT_VAR(expected_cumulative_sat_0_neg,uint,32,4) = 0;
+int VECT_VAR(expected_cumulative_sat_0_neg,uint,64,2) = 0;
+
+/* Expected results with input=0 and negative shift amount.  */
+VECT_VAR_DECL(expected_0_neg,int,8,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					     0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0_neg,int,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0_neg,int,32,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_0_neg,int,64,1) [] = { 0x0 };
+VECT_VAR_DECL(expected_0_neg,uint,8,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					      0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0_neg,uint,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0_neg,uint,32,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_0_neg,uint,64,1) [] = { 0x0 };
+VECT_VAR_DECL(expected_0_neg,int,8,16) [] = { 0x0, 0x0, 0x0, 0x0,
+					      0x0, 0x0, 0x0, 0x0,
+					      0x0, 0x0, 0x0, 0x0,
+					      0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0_neg,int,16,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					      0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0_neg,int,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0_neg,int,64,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_0_neg,uint,8,16) [] = { 0x0, 0x0, 0x0, 0x0,
+					       0x0, 0x0, 0x0, 0x0,
+					       0x0, 0x0, 0x0, 0x0,
+					       0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0_neg,uint,16,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					       0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0_neg,uint,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0_neg,uint,64,2) [] = { 0x0, 0x0 };
+
+/* Expected values of cumulative_saturation flag.  */
+int VECT_VAR(expected_cumulative_sat,int,8,8) = 0;
+int VECT_VAR(expected_cumulative_sat,int,16,4) = 0;
+int VECT_VAR(expected_cumulative_sat,int,32,2) = 0;
+int VECT_VAR(expected_cumulative_sat,int,64,1) = 0;
+int VECT_VAR(expected_cumulative_sat,uint,8,8) = 1;
+int VECT_VAR(expected_cumulative_sat,uint,16,4) = 1;
+int VECT_VAR(expected_cumulative_sat,uint,32,2) = 1;
+int VECT_VAR(expected_cumulative_sat,uint,64,1) = 0;
+int VECT_VAR(expected_cumulative_sat,int,8,16) = 1;
+int VECT_VAR(expected_cumulative_sat,int,16,8) = 1;
+int VECT_VAR(expected_cumulative_sat,int,32,4) = 1;
+int VECT_VAR(expected_cumulative_sat,int,64,2) = 1;
+int VECT_VAR(expected_cumulative_sat,uint,8,16) = 1;
+int VECT_VAR(expected_cumulative_sat,uint,16,8) = 1;
+int VECT_VAR(expected_cumulative_sat,uint,32,4) = 1;
+int VECT_VAR(expected_cumulative_sat,uint,64,2) = 1;
+
+/* Expected results.  */
+VECT_VAR_DECL(expected,int,8,8) [] = { 0xe0, 0xe2, 0xe4, 0xe6,
+				       0xe8, 0xea, 0xec, 0xee };
+VECT_VAR_DECL(expected,int,16,4) [] = { 0xff80, 0xff88, 0xff90, 0xff98 };
+VECT_VAR_DECL(expected,int,32,2) [] = { 0xfffff000, 0xfffff100 };
+VECT_VAR_DECL(expected,int,64,1) [] = { 0xfffffffffffffffe };
+VECT_VAR_DECL(expected,uint,8,8) [] = { 0xff, 0xff, 0xff, 0xff,
+					0xff, 0xff, 0xff, 0xff };
+VECT_VAR_DECL(expected,uint,16,4) [] = { 0xffff, 0xffff, 0xffff, 0xffff };
+VECT_VAR_DECL(expected,uint,32,2) [] = { 0xffffffff, 0xffffffff };
+VECT_VAR_DECL(expected,uint,64,1) [] = { 0x1ffffffffffffffe };
+VECT_VAR_DECL(expected,int,8,16) [] = { 0x80, 0x80, 0x80, 0x80,
+					0x80, 0x80, 0x80, 0x80,
+					0x80, 0x80, 0x80, 0x80,
+					0x80, 0x80, 0x80, 0x80 };
+VECT_VAR_DECL(expected,int,16,8) [] = { 0x8000, 0x8000, 0x8000, 0x8000,
+					0x8000, 0x8000, 0x8000, 0x8000 };
+VECT_VAR_DECL(expected,int,32,4) [] = { 0x80000000, 0x80000000,
+					0x80000000, 0x80000000 };
+VECT_VAR_DECL(expected,int,64,2) [] = { 0x8000000000000000,
+					0x8000000000000000 };
+VECT_VAR_DECL(expected,uint,8,16) [] = { 0xff, 0xff, 0xff, 0xff,
+					 0xff, 0xff, 0xff, 0xff,
+					 0xff, 0xff, 0xff, 0xff,
+					 0xff, 0xff, 0xff, 0xff };
+VECT_VAR_DECL(expected,uint,16,8) [] = { 0xffff, 0xffff, 0xffff, 0xffff,
+					 0xffff, 0xffff, 0xffff, 0xffff };
+VECT_VAR_DECL(expected,uint,32,4) [] = { 0xffffffff, 0xffffffff,
+					 0xffffffff, 0xffffffff };
+VECT_VAR_DECL(expected,uint,64,2) [] = { 0xffffffffffffffff,
+					 0xffffffffffffffff };
+
+/* Expected values of cumulative_sat_saturation flag with negative shift
+   amount.  */
+int VECT_VAR(expected_cumulative_sat_neg,int,8,8) = 0;
+int VECT_VAR(expected_cumulative_sat_neg,int,16,4) = 0;
+int VECT_VAR(expected_cumulative_sat_neg,int,32,2) = 0;
+int VECT_VAR(expected_cumulative_sat_neg,int,64,1) = 0;
+int VECT_VAR(expected_cumulative_sat_neg,uint,8,8) = 0;
+int VECT_VAR(expected_cumulative_sat_neg,uint,16,4) = 0;
+int VECT_VAR(expected_cumulative_sat_neg,uint,32,2) = 0;
+int VECT_VAR(expected_cumulative_sat_neg,uint,64,1) = 0;
+int VECT_VAR(expected_cumulative_sat_neg,int,8,16) = 0;
+int VECT_VAR(expected_cumulative_sat_neg,int,16,8) = 0;
+int VECT_VAR(expected_cumulative_sat_neg,int,32,4) = 0;
+int VECT_VAR(expected_cumulative_sat_neg,int,64,2) = 0;
+int VECT_VAR(expected_cumulative_sat_neg,uint,8,16) = 0;
+int VECT_VAR(expected_cumulative_sat_neg,uint,16,8) = 0;
+int VECT_VAR(expected_cumulative_sat_neg,uint,32,4) = 0;
+int VECT_VAR(expected_cumulative_sat_neg,uint,64,2) = 0;
+
+/* Expected results with negative shift amount.  */
+VECT_VAR_DECL(expected_neg,int,8,8) [] = { 0xf8, 0xf8, 0xf9, 0xf9,
+					   0xfa, 0xfa, 0xfb, 0xfb };
+VECT_VAR_DECL(expected_neg,int,16,4) [] = { 0xfffc, 0xfffc, 0xfffc, 0xfffc };
+VECT_VAR_DECL(expected_neg,int,32,2) [] = { 0xfffffffe, 0xfffffffe };
+VECT_VAR_DECL(expected_neg,int,64,1) [] = { 0xffffffffffffffff };
+VECT_VAR_DECL(expected_neg,uint,8,8) [] = { 0x78, 0x78, 0x79, 0x79,
+					    0x7a, 0x7a, 0x7b, 0x7b };
+VECT_VAR_DECL(expected_neg,uint,16,4) [] = { 0x3ffc, 0x3ffc, 0x3ffc, 0x3ffc };
+VECT_VAR_DECL(expected_neg,uint,32,2) [] = { 0x1ffffffe, 0x1ffffffe };
+VECT_VAR_DECL(expected_neg,uint,64,1) [] = { 0xfffffffffffffff };
+VECT_VAR_DECL(expected_neg,int,8,16) [] = { 0xff, 0xff, 0xff, 0xff,
+					    0xff, 0xff, 0xff, 0xff,
+					    0xff, 0xff, 0xff, 0xff,
+					    0xff, 0xff, 0xff, 0xff };
+VECT_VAR_DECL(expected_neg,int,16,8) [] = { 0xffff, 0xffff, 0xffff, 0xffff,
+					    0xffff, 0xffff, 0xffff, 0xffff };
+VECT_VAR_DECL(expected_neg,int,32,4) [] = { 0xffffffff, 0xffffffff,
+					    0xffffffff, 0xffffffff };
+VECT_VAR_DECL(expected_neg,int,64,2) [] = { 0xffffffffffffffff,
+					    0xffffffffffffffff };
+VECT_VAR_DECL(expected_neg,uint,8,16) [] = { 0x1, 0x1, 0x1, 0x1,
+					     0x1, 0x1, 0x1, 0x1,
+					     0x1, 0x1, 0x1, 0x1,
+					     0x1, 0x1, 0x1, 0x1 };
+VECT_VAR_DECL(expected_neg,uint,16,8) [] = { 0x1f, 0x1f, 0x1f, 0x1f,
+					     0x1f, 0x1f, 0x1f, 0x1f };
+VECT_VAR_DECL(expected_neg,uint,32,4) [] = { 0x7ffff, 0x7ffff,
+					     0x7ffff, 0x7ffff };
+VECT_VAR_DECL(expected_neg,uint,64,2) [] = { 0xfffffffffff, 0xfffffffffff };
+
+/* Expected values of cumulative_sat_saturation flag with negative
+   input and large shift amount.  */
+int VECT_VAR(expected_cumulative_sat_neg_large,int,8,8) = 1;
+int VECT_VAR(expected_cumulative_sat_neg_large,int,16,4) = 1;
+int VECT_VAR(expected_cumulative_sat_neg_large,int,32,2) = 1;
+int VECT_VAR(expected_cumulative_sat_neg_large,int,64,1) = 1;
+int VECT_VAR(expected_cumulative_sat_neg_large,uint,8,8) = 1;
+int VECT_VAR(expected_cumulative_sat_neg_large,uint,16,4) = 1;
+int VECT_VAR(expected_cumulative_sat_neg_large,uint,32,2) = 1;
+int VECT_VAR(expected_cumulative_sat_neg_large,uint,64,1) = 1;
+int VECT_VAR(expected_cumulative_sat_neg_large,int,8,16) = 1;
+int VECT_VAR(expected_cumulative_sat_neg_large,int,16,8) = 1;
+int VECT_VAR(expected_cumulative_sat_neg_large,int,32,4) = 1;
+int VECT_VAR(expected_cumulative_sat_neg_large,int,64,2) = 1;
+int VECT_VAR(expected_cumulative_sat_neg_large,uint,8,16) = 1;
+int VECT_VAR(expected_cumulative_sat_neg_large,uint,16,8) = 1;
+int VECT_VAR(expected_cumulative_sat_neg_large,uint,32,4) = 1;
+int VECT_VAR(expected_cumulative_sat_neg_large,uint,64,2) = 1;
+
+/* Expected results with negative input and large shift amount.  */
+VECT_VAR_DECL(expected_neg_large,int,8,8) [] = { 0x80, 0x80, 0x80, 0x80,
+						 0x80, 0x80, 0x80, 0x80 };
+VECT_VAR_DECL(expected_neg_large,int,16,4) [] = { 0x8000, 0x8000,
+						  0x8000, 0x8000 };
+VECT_VAR_DECL(expected_neg_large,int,32,2) [] = { 0x80000000, 0x80000000 };
+VECT_VAR_DECL(expected_neg_large,int,64,1) [] = { 0x8000000000000000 };
+VECT_VAR_DECL(expected_neg_large,uint,8,8) [] = { 0xff, 0xff, 0xff, 0xff,
+						  0xff, 0xff, 0xff, 0xff };
+VECT_VAR_DECL(expected_neg_large,uint,16,4) [] = { 0xffff, 0xffff,
+						   0xffff, 0xffff };
+VECT_VAR_DECL(expected_neg_large,uint,32,2) [] = { 0xffffffff, 0xffffffff };
+VECT_VAR_DECL(expected_neg_large,uint,64,1) [] = { 0xffffffffffffffff };
+VECT_VAR_DECL(expected_neg_large,int,8,16) [] = { 0x80, 0x80, 0x80, 0x80,
+						  0x80, 0x80, 0x80, 0x80,
+						  0x80, 0x80, 0x80, 0x80,
+						  0x80, 0x80, 0x80, 0x80 };
+VECT_VAR_DECL(expected_neg_large,int,16,8) [] = { 0x8000, 0x8000,
+						  0x8000, 0x8000,
+						  0x8000, 0x8000,
+						  0x8000, 0x8000 };
+VECT_VAR_DECL(expected_neg_large,int,32,4) [] = { 0x80000000, 0x80000000,
+						  0x80000000, 0x80000000 };
+VECT_VAR_DECL(expected_neg_large,int,64,2) [] = { 0x8000000000000000,
+						  0x8000000000000000 };
+VECT_VAR_DECL(expected_neg_large,uint,8,16) [] = { 0xff, 0xff, 0xff, 0xff,
+						   0xff, 0xff, 0xff, 0xff,
+						   0xff, 0xff, 0xff, 0xff,
+						   0xff, 0xff, 0xff, 0xff };
+VECT_VAR_DECL(expected_neg_large,uint,16,8) [] = { 0xffff, 0xffff,
+						   0xffff, 0xffff,
+						   0xffff, 0xffff,
+						   0xffff, 0xffff };
+VECT_VAR_DECL(expected_neg_large,uint,32,4) [] = { 0xffffffff, 0xffffffff,
+						   0xffffffff, 0xffffffff };
+VECT_VAR_DECL(expected_neg_large,uint,64,2) [] = { 0xffffffffffffffff,
+						   0xffffffffffffffff };
+
+/* Expected values of cumulative_sat_saturation flag with max input
+   and shift by -1.  */
+int VECT_VAR(expected_cumulative_sat_max_minus1,int,8,8) = 0;
+int VECT_VAR(expected_cumulative_sat_max_minus1,int,16,4) = 0;
+int VECT_VAR(expected_cumulative_sat_max_minus1,int,32,2) = 0;
+int VECT_VAR(expected_cumulative_sat_max_minus1,int,64,1) = 0;
+int VECT_VAR(expected_cumulative_sat_max_minus1,uint,8,8) = 0;
+int VECT_VAR(expected_cumulative_sat_max_minus1,uint,16,4) = 0;
+int VECT_VAR(expected_cumulative_sat_max_minus1,uint,32,2) = 0;
+int VECT_VAR(expected_cumulative_sat_max_minus1,uint,64,1) = 0;
+int VECT_VAR(expected_cumulative_sat_max_minus1,int,8,16) = 0;
+int VECT_VAR(expected_cumulative_sat_max_minus1,int,16,8) = 0;
+int VECT_VAR(expected_cumulative_sat_max_minus1,int,32,4) = 0;
+int VECT_VAR(expected_cumulative_sat_max_minus1,int,64,2) = 0;
+int VECT_VAR(expected_cumulative_sat_max_minus1,uint,8,16) = 0;
+int VECT_VAR(expected_cumulative_sat_max_minus1,uint,16,8) = 0;
+int VECT_VAR(expected_cumulative_sat_max_minus1,uint,32,4) = 0;
+int VECT_VAR(expected_cumulative_sat_max_minus1,uint,64,2) = 0;
+
+/* Expected results with max input and shift by -1.  */
+VECT_VAR_DECL(expected_max_minus1,int,8,8) [] = { 0x3f, 0x3f, 0x3f, 0x3f,
+						  0x3f, 0x3f, 0x3f, 0x3f };
+VECT_VAR_DECL(expected_max_minus1,int,16,4) [] = { 0x3fff, 0x3fff,
+						   0x3fff, 0x3fff };
+VECT_VAR_DECL(expected_max_minus1,int,32,2) [] = { 0x3fffffff, 0x3fffffff };
+VECT_VAR_DECL(expected_max_minus1,int,64,1) [] = { 0x3fffffffffffffff };
+VECT_VAR_DECL(expected_max_minus1,uint,8,8) [] = { 0x7f, 0x7f, 0x7f, 0x7f,
+						   0x7f, 0x7f, 0x7f, 0x7f };
+VECT_VAR_DECL(expected_max_minus1,uint,16,4) [] = { 0x7fff, 0x7fff,
+						    0x7fff, 0x7fff };
+VECT_VAR_DECL(expected_max_minus1,uint,32,2) [] = { 0x7fffffff, 0x7fffffff };
+VECT_VAR_DECL(expected_max_minus1,uint,64,1) [] = { 0x7fffffffffffffff };
+VECT_VAR_DECL(expected_max_minus1,int,8,16) [] = { 0x3f, 0x3f, 0x3f, 0x3f,
+						   0x3f, 0x3f, 0x3f, 0x3f,
+						   0x3f, 0x3f, 0x3f, 0x3f,
+						   0x3f, 0x3f, 0x3f, 0x3f };
+VECT_VAR_DECL(expected_max_minus1,int,16,8) [] = { 0x3fff, 0x3fff,
+						   0x3fff, 0x3fff,
+						   0x3fff, 0x3fff,
+						   0x3fff, 0x3fff };
+VECT_VAR_DECL(expected_max_minus1,int,32,4) [] = { 0x3fffffff, 0x3fffffff,
+						   0x3fffffff, 0x3fffffff };
+VECT_VAR_DECL(expected_max_minus1,int,64,2) [] = { 0x3fffffffffffffff,
+						   0x3fffffffffffffff };
+VECT_VAR_DECL(expected_max_minus1,uint,8,16) [] = { 0x7f, 0x7f, 0x7f, 0x7f,
+						    0x7f, 0x7f, 0x7f, 0x7f,
+						    0x7f, 0x7f, 0x7f, 0x7f,
+						    0x7f, 0x7f, 0x7f, 0x7f };
+VECT_VAR_DECL(expected_max_minus1,uint,16,8) [] = { 0x7fff, 0x7fff,
+						    0x7fff, 0x7fff,
+						    0x7fff, 0x7fff,
+						    0x7fff, 0x7fff };
+VECT_VAR_DECL(expected_max_minus1,uint,32,4) [] = { 0x7fffffff, 0x7fffffff,
+						    0x7fffffff, 0x7fffffff };
+VECT_VAR_DECL(expected_max_minus1,uint,64,2) [] = { 0x7fffffffffffffff,
+						    0x7fffffffffffffff };
+
+/* Expected values of cumulative_sat_saturation flag with max input
+   and large shift amount.  */
+int VECT_VAR(expected_cumulative_sat_max_large,int,8,8) = 1;
+int VECT_VAR(expected_cumulative_sat_max_large,int,16,4) = 1;
+int VECT_VAR(expected_cumulative_sat_max_large,int,32,2) = 1;
+int VECT_VAR(expected_cumulative_sat_max_large,int,64,1) = 1;
+int VECT_VAR(expected_cumulative_sat_max_large,uint,8,8) = 1;
+int VECT_VAR(expected_cumulative_sat_max_large,uint,16,4) = 1;
+int VECT_VAR(expected_cumulative_sat_max_large,uint,32,2) = 1;
+int VECT_VAR(expected_cumulative_sat_max_large,uint,64,1) = 1;
+int VECT_VAR(expected_cumulative_sat_max_large,int,8,16) = 1;
+int VECT_VAR(expected_cumulative_sat_max_large,int,16,8) = 1;
+int VECT_VAR(expected_cumulative_sat_max_large,int,32,4) = 1;
+int VECT_VAR(expected_cumulative_sat_max_large,int,64,2) = 1;
+int VECT_VAR(expected_cumulative_sat_max_large,uint,8,16) = 1;
+int VECT_VAR(expected_cumulative_sat_max_large,uint,16,8) = 1;
+int VECT_VAR(expected_cumulative_sat_max_large,uint,32,4) = 1;
+int VECT_VAR(expected_cumulative_sat_max_large,uint,64,2) = 1;
+
+/* Expected results with max input and large shift amount.  */
+VECT_VAR_DECL(expected_max_large,int,8,8) [] = { 0x7f, 0x7f, 0x7f, 0x7f,
+					       0x7f, 0x7f, 0x7f, 0x7f };
+VECT_VAR_DECL(expected_max_large,int,16,4) [] = { 0x7fff, 0x7fff,
+						0x7fff, 0x7fff };
+VECT_VAR_DECL(expected_max_large,int,32,2) [] = { 0x7fffffff, 0x7fffffff };
+VECT_VAR_DECL(expected_max_large,int,64,1) [] = { 0x7fffffffffffffff };
+VECT_VAR_DECL(expected_max_large,uint,8,8) [] = { 0xff, 0xff, 0xff, 0xff,
+						0xff, 0xff, 0xff, 0xff };
+VECT_VAR_DECL(expected_max_large,uint,16,4) [] = { 0xffff, 0xffff,
+						 0xffff, 0xffff };
+VECT_VAR_DECL(expected_max_large,uint,32,2) [] = { 0xffffffff, 0xffffffff };
+VECT_VAR_DECL(expected_max_large,uint,64,1) [] = { 0xffffffffffffffff };
+VECT_VAR_DECL(expected_max_large,int,8,16) [] = { 0x7f, 0x7f, 0x7f, 0x7f,
+						0x7f, 0x7f, 0x7f, 0x7f,
+						0x7f, 0x7f, 0x7f, 0x7f,
+						0x7f, 0x7f, 0x7f, 0x7f };
+VECT_VAR_DECL(expected_max_large,int,16,8) [] = { 0x7fff, 0x7fff,
+						0x7fff, 0x7fff,
+						0x7fff, 0x7fff,
+						0x7fff, 0x7fff };
+VECT_VAR_DECL(expected_max_large,int,32,4) [] = { 0x7fffffff, 0x7fffffff,
+						0x7fffffff, 0x7fffffff };
+VECT_VAR_DECL(expected_max_large,int,64,2) [] = { 0x7fffffffffffffff,
+						0x7fffffffffffffff };
+VECT_VAR_DECL(expected_max_large,uint,8,16) [] = { 0xff, 0xff, 0xff, 0xff,
+						 0xff, 0xff, 0xff, 0xff,
+						 0xff, 0xff, 0xff, 0xff,
+						 0xff, 0xff, 0xff, 0xff };
+VECT_VAR_DECL(expected_max_large,uint,16,8) [] = { 0xffff, 0xffff,
+						 0xffff, 0xffff,
+						 0xffff, 0xffff,
+						 0xffff, 0xffff };
+VECT_VAR_DECL(expected_max_large,uint,32,4) [] = { 0xffffffff, 0xffffffff,
+						 0xffffffff, 0xffffffff };
+VECT_VAR_DECL(expected_max_large,uint,64,2) [] = { 0xffffffffffffffff,
+						 0xffffffffffffffff };
+
+/* Expected values of cumulative_sat_saturation flag with saturation
+   on 64-bits values.  */
+int VECT_VAR(expected_cumulative_sat_64,int,64,1) = 1;
+int VECT_VAR(expected_cumulative_sat_64,int,64,2) = 1;
+
+/* Expected results with saturation on 64-bits values..  */
+VECT_VAR_DECL(expected_64,int,64,1) [] = { 0x8000000000000000 };
+VECT_VAR_DECL(expected_64,int,64,2) [] = { 0x7fffffffffffffff,
+					   0x7fffffffffffffff };
+
+#define INSN vqshl
+#define TEST_MSG "VQSHL/VQSHLQ"
+
+#define FNNAME1(NAME) void exec_ ## NAME (void)
+#define FNNAME(NAME) FNNAME1(NAME)
+
+FNNAME (INSN)
+{
+  /* Basic test: v3=vqshl(v1,v2), then store the result.  */
+#define TEST_VQSHL2(INSN, T3, Q, T1, T2, W, N, EXPECTED_CUMULATIVE_SAT, CMT) \
+  Set_Neon_Cumulative_Sat(0, VECT_VAR(vector_res, T1, W, N));		\
+  VECT_VAR(vector_res, T1, W, N) =					\
+    INSN##Q##_##T2##W(VECT_VAR(vector, T1, W, N),			\
+		      VECT_VAR(vector_shift, T3, W, N));		\
+  vst1##Q##_##T2##W(VECT_VAR(result, T1, W, N),				\
+		    VECT_VAR(vector_res, T1, W, N));			\
+  CHECK_CUMULATIVE_SAT(TEST_MSG, T1, W, N, EXPECTED_CUMULATIVE_SAT, CMT)
+
+  /* Two auxliary macros are necessary to expand INSN */
+#define TEST_VQSHL1(INSN, T3, Q, T1, T2, W, N, EXPECTED_CUMULATIVE_SAT, CMT) \
+  TEST_VQSHL2(INSN, T3, Q, T1, T2, W, N, EXPECTED_CUMULATIVE_SAT, CMT)
+
+#define TEST_VQSHL(T3, Q, T1, T2, W, N, EXPECTED_CUMULATIVE_SAT, CMT)	\
+  TEST_VQSHL1(INSN, T3, Q, T1, T2, W, N, EXPECTED_CUMULATIVE_SAT, CMT)
+
+
+  DECL_VARIABLE_ALL_VARIANTS(vector);
+  DECL_VARIABLE_ALL_VARIANTS(vector_res);
+
+  DECL_VARIABLE_SIGNED_VARIANTS(vector_shift);
+
+  clean_results ();
+
+  /* Fill input vector with 0, to check saturation on limits.  */
+  VDUP(vector, , int, s, 8, 8, 0);
+  VDUP(vector, , int, s, 16, 4, 0);
+  VDUP(vector, , int, s, 32, 2, 0);
+  VDUP(vector, , int, s, 64, 1, 0);
+  VDUP(vector, , uint, u, 8, 8, 0);
+  VDUP(vector, , uint, u, 16, 4, 0);
+  VDUP(vector, , uint, u, 32, 2, 0);
+  VDUP(vector, , uint, u, 64, 1, 0);
+  VDUP(vector, q, int, s, 8, 16, 0);
+  VDUP(vector, q, int, s, 16, 8, 0);
+  VDUP(vector, q, int, s, 32, 4, 0);
+  VDUP(vector, q, int, s, 64, 2, 0);
+  VDUP(vector, q, uint, u, 8, 16, 0);
+  VDUP(vector, q, uint, u, 16, 8, 0);
+  VDUP(vector, q, uint, u, 32, 4, 0);
+  VDUP(vector, q, uint, u, 64, 2, 0);
+
+  /* Choose init value arbitrarily, will be used as shift amount */
+  /* Use values equal or one-less-than the type width to check
+     behaviour on limits.  */
+
+  /* 64-bits vectors first.  */
+  /* Shift 8-bits lanes by 7...  */
+  VDUP(vector_shift, , int, s, 8, 8, 7);
+  /* ... except: lane 0 (by 6), lane 1 (by 8) and lane 2 (by 9).  */
+  VSET_LANE(vector_shift, , int, s, 8, 8, 0, 6);
+  VSET_LANE(vector_shift, , int, s, 8, 8, 1, 8);
+  VSET_LANE(vector_shift, , int, s, 8, 8, 2, 9);
+
+  /* Shift 16-bits lanes by 15... */
+  VDUP(vector_shift, , int, s, 16, 4, 15);
+  /* ... except: lane 0 (by 14), lane 1 (by 16), and lane 2 (by 17).  */
+  VSET_LANE(vector_shift, , int, s, 16, 4, 0, 14);
+  VSET_LANE(vector_shift, , int, s, 16, 4, 1, 16);
+  VSET_LANE(vector_shift, , int, s, 16, 4, 2, 17);
+
+  /* Shift 32-bits lanes by 31... */
+  VDUP(vector_shift, , int, s, 32, 2, 31);
+  /* ... except lane 1 (by 30).  */
+  VSET_LANE(vector_shift, , int, s, 32, 2, 1, 30);
+
+  /* Shift 64 bits lane by 63.  */
+  VDUP(vector_shift, , int, s, 64, 1, 63);
+
+  /* 128-bits vectors.  */
+  /* Shift 8-bits lanes by 8.  */
+  VDUP(vector_shift, q, int, s, 8, 16, 8);
+  /* Shift 16-bits lanes by 16.  */
+  VDUP(vector_shift, q, int, s, 16, 8, 16);
+  /* Shift 32-bits lanes by 32...  */
+  VDUP(vector_shift, q, int, s, 32, 4, 32);
+  /* ... except lane 1 (by 33).  */
+  VSET_LANE(vector_shift, q, int, s, 32, 4, 1, 33);
+
+  /* Shift 64-bits lanes by 64... */
+  VDUP(vector_shift, q, int, s, 64, 2, 64);
+  /* ... except lane 1 (by 62).  */
+  VSET_LANE(vector_shift, q, int, s, 64, 2, 1, 62);
+
+#define CMT " (with input = 0)"
+  TEST_VQSHL(int, , int, s, 8, 8, expected_cumulative_sat_0, CMT);
+  TEST_VQSHL(int, , int, s, 16, 4, expected_cumulative_sat_0, CMT);
+  TEST_VQSHL(int, , int, s, 32, 2, expected_cumulative_sat_0, CMT);
+  TEST_VQSHL(int, , int, s, 64, 1, expected_cumulative_sat_0, CMT);
+  TEST_VQSHL(int, , uint, u, 8, 8, expected_cumulative_sat_0, CMT);
+  TEST_VQSHL(int, , uint, u, 16, 4, expected_cumulative_sat_0, CMT);
+  TEST_VQSHL(int, , uint, u, 32, 2, expected_cumulative_sat_0, CMT);
+  TEST_VQSHL(int, , uint, u, 64, 1, expected_cumulative_sat_0, CMT);
+  TEST_VQSHL(int, q, int, s, 8, 16, expected_cumulative_sat_0, CMT);
+  TEST_VQSHL(int, q, int, s, 16, 8, expected_cumulative_sat_0, CMT);
+  TEST_VQSHL(int, q, int, s, 32, 4, expected_cumulative_sat_0, CMT);
+  TEST_VQSHL(int, q, int, s, 64, 2, expected_cumulative_sat_0, CMT);
+  TEST_VQSHL(int, q, uint, u, 8, 16, expected_cumulative_sat_0, CMT);
+  TEST_VQSHL(int, q, uint, u, 16, 8, expected_cumulative_sat_0, CMT);
+  TEST_VQSHL(int, q, uint, u, 32, 4, expected_cumulative_sat_0, CMT);
+  TEST_VQSHL(int, q, uint, u, 64, 2, expected_cumulative_sat_0, CMT);
+
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_0, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_0, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_0, CMT);
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected_0, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_0, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_0, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_0, CMT);
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected_0, CMT);
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected_0, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_0, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_0, CMT);
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected_0, CMT);
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected_0, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_0, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_0, CMT);
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected_0, CMT);
+
+
+  /* Use negative shift amounts */
+  VDUP(vector_shift, , int, s, 8, 8, -1);
+  VDUP(vector_shift, , int, s, 16, 4, -2);
+  VDUP(vector_shift, , int, s, 32, 2, -3);
+  VDUP(vector_shift, , int, s, 64, 1, -4);
+  VDUP(vector_shift, q, int, s, 8, 16, -7);
+  VDUP(vector_shift, q, int, s, 16, 8, -11);
+  VDUP(vector_shift, q, int, s, 32, 4, -13);
+  VDUP(vector_shift, q, int, s, 64, 2, -20);
+
+#undef CMT
+#define CMT " (input 0 and negative shift amount)"
+  TEST_VQSHL(int, , int, s, 8, 8, expected_cumulative_sat_0_neg, CMT);
+  TEST_VQSHL(int, , int, s, 16, 4, expected_cumulative_sat_0_neg, CMT);
+  TEST_VQSHL(int, , int, s, 32, 2, expected_cumulative_sat_0_neg, CMT);
+  TEST_VQSHL(int, , int, s, 64, 1, expected_cumulative_sat_0_neg, CMT);
+  TEST_VQSHL(int, , uint, u, 8, 8, expected_cumulative_sat_0_neg, CMT);
+  TEST_VQSHL(int, , uint, u, 16, 4, expected_cumulative_sat_0_neg, CMT);
+  TEST_VQSHL(int, , uint, u, 32, 2, expected_cumulative_sat_0_neg, CMT);
+  TEST_VQSHL(int, , uint, u, 64, 1, expected_cumulative_sat_0_neg, CMT);
+  TEST_VQSHL(int, q, int, s, 8, 16, expected_cumulative_sat_0_neg, CMT);
+  TEST_VQSHL(int, q, int, s, 16, 8, expected_cumulative_sat_0_neg, CMT);
+  TEST_VQSHL(int, q, int, s, 32, 4, expected_cumulative_sat_0_neg, CMT);
+  TEST_VQSHL(int, q, int, s, 64, 2, expected_cumulative_sat_0_neg, CMT);
+  TEST_VQSHL(int, q, uint, u, 8, 16, expected_cumulative_sat_0_neg, CMT);
+  TEST_VQSHL(int, q, uint, u, 16, 8, expected_cumulative_sat_0_neg, CMT);
+  TEST_VQSHL(int, q, uint, u, 32, 4, expected_cumulative_sat_0_neg, CMT);
+  TEST_VQSHL(int, q, uint, u, 64, 2, expected_cumulative_sat_0_neg, CMT);
+
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_0_neg, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_0_neg, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_0_neg, CMT);
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected_0_neg, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_0_neg, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_0_neg, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_0_neg, CMT);
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected_0_neg, CMT);
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected_0_neg, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_0_neg, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_0_neg, CMT);
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected_0_neg, CMT);
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected_0_neg, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_0_neg, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_0_neg, CMT);
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected_0_neg, CMT);
+
+  /* Test again, with predefined input values.  */
+  TEST_MACRO_ALL_VARIANTS_2_5(VLOAD, vector, buffer);
+
+  /* Choose init value arbitrarily, will be used as shift amount.  */
+  VDUP(vector_shift, , int, s, 8, 8, 1);
+  VDUP(vector_shift, , int, s, 16, 4, 3);
+  VDUP(vector_shift, , int, s, 32, 2, 8);
+  VDUP(vector_shift, , int, s, 64, 1, -3);
+  VDUP(vector_shift, q, int, s, 8, 16, 10);
+  VDUP(vector_shift, q, int, s, 16, 8, 12);
+  VDUP(vector_shift, q, int, s, 32, 4, 32);
+  VDUP(vector_shift, q, int, s, 64, 2, 63);
+
+#undef CMT
+#define CMT ""
+  TEST_VQSHL(int, , int, s, 8, 8, expected_cumulative_sat, CMT);
+  TEST_VQSHL(int, , int, s, 16, 4, expected_cumulative_sat, CMT);
+  TEST_VQSHL(int, , int, s, 32, 2, expected_cumulative_sat, CMT);
+  TEST_VQSHL(int, , int, s, 64, 1, expected_cumulative_sat, CMT);
+  TEST_VQSHL(int, , uint, u, 8, 8, expected_cumulative_sat, CMT);
+  TEST_VQSHL(int, , uint, u, 16, 4, expected_cumulative_sat, CMT);
+  TEST_VQSHL(int, , uint, u, 32, 2, expected_cumulative_sat, CMT);
+  TEST_VQSHL(int, , uint, u, 64, 1, expected_cumulative_sat, CMT);
+  TEST_VQSHL(int, q, int, s, 8, 16, expected_cumulative_sat, CMT);
+  TEST_VQSHL(int, q, int, s, 16, 8, expected_cumulative_sat, CMT);
+  TEST_VQSHL(int, q, int, s, 32, 4, expected_cumulative_sat, CMT);
+  TEST_VQSHL(int, q, int, s, 64, 2, expected_cumulative_sat, CMT);
+  TEST_VQSHL(int, q, uint, u, 8, 16, expected_cumulative_sat, CMT);
+  TEST_VQSHL(int, q, uint, u, 16, 8, expected_cumulative_sat, CMT);
+  TEST_VQSHL(int, q, uint, u, 32, 4, expected_cumulative_sat, CMT);
+  TEST_VQSHL(int, q, uint, u, 64, 2, expected_cumulative_sat, CMT);
+
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected, CMT);
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected, CMT);
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected, CMT);
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected, CMT);
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected, CMT);
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected, CMT);
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected, CMT);
+
+
+  /* Use negative shift amounts */
+  VDUP(vector_shift, , int, s, 8, 8, -1);
+  VDUP(vector_shift, , int, s, 16, 4, -2);
+  VDUP(vector_shift, , int, s, 32, 2, -3);
+  VDUP(vector_shift, , int, s, 64, 1, -4);
+  VDUP(vector_shift, q, int, s, 8, 16, -7);
+  VDUP(vector_shift, q, int, s, 16, 8, -11);
+  VDUP(vector_shift, q, int, s, 32, 4, -13);
+  VDUP(vector_shift, q, int, s, 64, 2, -20);
+
+#undef CMT
+#define CMT " (negative shift amount)"
+  TEST_VQSHL(int, , int, s, 8, 8, expected_cumulative_sat_neg, CMT);
+  TEST_VQSHL(int, , int, s, 16, 4, expected_cumulative_sat_neg, CMT);
+  TEST_VQSHL(int, , int, s, 32, 2, expected_cumulative_sat_neg, CMT);
+  TEST_VQSHL(int, , int, s, 64, 1, expected_cumulative_sat_neg, CMT);
+  TEST_VQSHL(int, , uint, u, 8, 8, expected_cumulative_sat_neg, CMT);
+  TEST_VQSHL(int, , uint, u, 16, 4, expected_cumulative_sat_neg, CMT);
+  TEST_VQSHL(int, , uint, u, 32, 2, expected_cumulative_sat_neg, CMT);
+  TEST_VQSHL(int, , uint, u, 64, 1, expected_cumulative_sat_neg, CMT);
+  TEST_VQSHL(int, q, int, s, 8, 16, expected_cumulative_sat_neg, CMT);
+  TEST_VQSHL(int, q, int, s, 16, 8, expected_cumulative_sat_neg, CMT);
+  TEST_VQSHL(int, q, int, s, 32, 4, expected_cumulative_sat_neg, CMT);
+  TEST_VQSHL(int, q, int, s, 64, 2, expected_cumulative_sat_neg, CMT);
+  TEST_VQSHL(int, q, uint, u, 8, 16, expected_cumulative_sat_neg, CMT);
+  TEST_VQSHL(int, q, uint, u, 16, 8, expected_cumulative_sat_neg, CMT);
+  TEST_VQSHL(int, q, uint, u, 32, 4, expected_cumulative_sat_neg, CMT);
+  TEST_VQSHL(int, q, uint, u, 64, 2, expected_cumulative_sat_neg, CMT);
+
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_neg, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_neg, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_neg, CMT);
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected_neg, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_neg, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_neg, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_neg, CMT);
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected_neg, CMT);
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected_neg, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_neg, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_neg, CMT);
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected_neg, CMT);
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected_neg, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_neg, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_neg, CMT);
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected_neg, CMT);
+
+
+  /* Use large shift amounts.  */
+  VDUP(vector_shift, , int, s, 8, 8, 8);
+  VDUP(vector_shift, , int, s, 16, 4, 16);
+  VDUP(vector_shift, , int, s, 32, 2, 32);
+  VDUP(vector_shift, , int, s, 64, 1, 64);
+  VDUP(vector_shift, q, int, s, 8, 16, 8);
+  VDUP(vector_shift, q, int, s, 16, 8, 16);
+  VDUP(vector_shift, q, int, s, 32, 4, 32);
+  VDUP(vector_shift, q, int, s, 64, 2, 64);
+
+#undef CMT
+#define CMT " (large shift amount, negative input)"
+  TEST_VQSHL(int, , int, s, 8, 8, expected_cumulative_sat_neg_large, CMT);
+  TEST_VQSHL(int, , int, s, 16, 4, expected_cumulative_sat_neg_large, CMT);
+  TEST_VQSHL(int, , int, s, 32, 2, expected_cumulative_sat_neg_large, CMT);
+  TEST_VQSHL(int, , int, s, 64, 1, expected_cumulative_sat_neg_large, CMT);
+  TEST_VQSHL(int, , uint, u, 8, 8, expected_cumulative_sat_neg_large, CMT);
+  TEST_VQSHL(int, , uint, u, 16, 4, expected_cumulative_sat_neg_large, CMT);
+  TEST_VQSHL(int, , uint, u, 32, 2, expected_cumulative_sat_neg_large, CMT);
+  TEST_VQSHL(int, , uint, u, 64, 1, expected_cumulative_sat_neg_large, CMT);
+  TEST_VQSHL(int, q, int, s, 8, 16, expected_cumulative_sat_neg_large, CMT);
+  TEST_VQSHL(int, q, int, s, 16, 8, expected_cumulative_sat_neg_large, CMT);
+  TEST_VQSHL(int, q, int, s, 32, 4, expected_cumulative_sat_neg_large, CMT);
+  TEST_VQSHL(int, q, int, s, 64, 2, expected_cumulative_sat_neg_large, CMT);
+  TEST_VQSHL(int, q, uint, u, 8, 16, expected_cumulative_sat_neg_large, CMT);
+  TEST_VQSHL(int, q, uint, u, 16, 8, expected_cumulative_sat_neg_large, CMT);
+  TEST_VQSHL(int, q, uint, u, 32, 4, expected_cumulative_sat_neg_large, CMT);
+  TEST_VQSHL(int, q, uint, u, 64, 2, expected_cumulative_sat_neg_large, CMT);
+
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_neg_large, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_neg_large, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_neg_large, CMT);
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected_neg_large, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_neg_large, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_neg_large, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_neg_large, CMT);
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected_neg_large, CMT);
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected_neg_large, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_neg_large, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_neg_large, CMT);
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected_neg_large, CMT);
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected_neg_large, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_neg_large, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_neg_large, CMT);
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected_neg_large, CMT);
+
+
+  /* Fill input vector with max value, to check saturation on limits */
+  VDUP(vector, , int, s, 8, 8, 0x7F);
+  VDUP(vector, , int, s, 16, 4, 0x7FFF);
+  VDUP(vector, , int, s, 32, 2, 0x7FFFFFFF);
+  VDUP(vector, , int, s, 64, 1, 0x7FFFFFFFFFFFFFFFLL);
+  VDUP(vector, , uint, u, 8, 8, 0xFF);
+  VDUP(vector, , uint, u, 16, 4, 0xFFFF);
+  VDUP(vector, , uint, u, 32, 2, 0xFFFFFFFF);
+  VDUP(vector, , uint, u, 64, 1, 0xFFFFFFFFFFFFFFFFULL);
+  VDUP(vector, q, int, s, 8, 16, 0x7F);
+  VDUP(vector, q, int, s, 16, 8, 0x7FFF);
+  VDUP(vector, q, int, s, 32, 4, 0x7FFFFFFF);
+  VDUP(vector, q, int, s, 64, 2, 0x7FFFFFFFFFFFFFFFLL);
+  VDUP(vector, q, uint, u, 8, 16, 0xFF);
+  VDUP(vector, q, uint, u, 16, 8, 0xFFFF);
+  VDUP(vector, q, uint, u, 32, 4, 0xFFFFFFFF);
+  VDUP(vector, q, uint, u, 64, 2, 0xFFFFFFFFFFFFFFFFULL);
+
+  /* Shift by -1 */
+  VDUP(vector_shift, , int, s, 8, 8, -1);
+  VDUP(vector_shift, , int, s, 16, 4, -1);
+  VDUP(vector_shift, , int, s, 32, 2, -1);
+  VDUP(vector_shift, , int, s, 64, 1, -1);
+  VDUP(vector_shift, q, int, s, 8, 16, -1);
+  VDUP(vector_shift, q, int, s, 16, 8, -1);
+  VDUP(vector_shift, q, int, s, 32, 4, -1);
+  VDUP(vector_shift, q, int, s, 64, 2, -1);
+
+#undef CMT
+#define CMT " (max input, shift by -1)"
+  TEST_VQSHL(int, , int, s, 8, 8, expected_cumulative_sat_max_minus1, CMT);
+  TEST_VQSHL(int, , int, s, 16, 4, expected_cumulative_sat_max_minus1, CMT);
+  TEST_VQSHL(int, , int, s, 32, 2, expected_cumulative_sat_max_minus1, CMT);
+  TEST_VQSHL(int, , int, s, 64, 1, expected_cumulative_sat_max_minus1, CMT);
+  TEST_VQSHL(int, , uint, u, 8, 8, expected_cumulative_sat_max_minus1, CMT);
+  TEST_VQSHL(int, , uint, u, 16, 4, expected_cumulative_sat_max_minus1, CMT);
+  TEST_VQSHL(int, , uint, u, 32, 2, expected_cumulative_sat_max_minus1, CMT);
+  TEST_VQSHL(int, , uint, u, 64, 1, expected_cumulative_sat_max_minus1, CMT);
+  TEST_VQSHL(int, q, int, s, 8, 16, expected_cumulative_sat_max_minus1, CMT);
+  TEST_VQSHL(int, q, int, s, 16, 8, expected_cumulative_sat_max_minus1, CMT);
+  TEST_VQSHL(int, q, int, s, 32, 4, expected_cumulative_sat_max_minus1, CMT);
+  TEST_VQSHL(int, q, int, s, 64, 2, expected_cumulative_sat_max_minus1, CMT);
+  TEST_VQSHL(int, q, uint, u, 8, 16, expected_cumulative_sat_max_minus1, CMT);
+  TEST_VQSHL(int, q, uint, u, 16, 8, expected_cumulative_sat_max_minus1, CMT);
+  TEST_VQSHL(int, q, uint, u, 32, 4, expected_cumulative_sat_max_minus1, CMT);
+  TEST_VQSHL(int, q, uint, u, 64, 2, expected_cumulative_sat_max_minus1, CMT);
+
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_max_minus1, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_max_minus1, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_max_minus1, CMT);
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected_max_minus1, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_max_minus1, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_max_minus1, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_max_minus1, CMT);
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected_max_minus1, CMT);
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected_max_minus1, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_max_minus1, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_max_minus1, CMT);
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected_max_minus1, CMT);
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected_max_minus1, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_max_minus1, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_max_minus1, CMT);
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected_max_minus1, CMT);
+
+
+  /* Use large shift amounts */
+  VDUP(vector_shift, , int, s, 8, 8, 8);
+  VDUP(vector_shift, , int, s, 16, 4, 16);
+  VDUP(vector_shift, , int, s, 32, 2, 32);
+  VDUP(vector_shift, , int, s, 64, 1, 64);
+  VDUP(vector_shift, q, int, s, 8, 16, 8);
+  VDUP(vector_shift, q, int, s, 16, 8, 16);
+  VDUP(vector_shift, q, int, s, 32, 4, 32);
+  VDUP(vector_shift, q, int, s, 64, 2, 64);
+
+#undef CMT
+#define CMT " (max input, large shift amount)"
+  TEST_VQSHL(int, , int, s, 8, 8, expected_cumulative_sat_max_large, CMT);
+  TEST_VQSHL(int, , int, s, 16, 4, expected_cumulative_sat_max_large, CMT);
+  TEST_VQSHL(int, , int, s, 32, 2, expected_cumulative_sat_max_large, CMT);
+  TEST_VQSHL(int, , int, s, 64, 1, expected_cumulative_sat_max_large, CMT);
+  TEST_VQSHL(int, , uint, u, 8, 8, expected_cumulative_sat_max_large, CMT);
+  TEST_VQSHL(int, , uint, u, 16, 4, expected_cumulative_sat_max_large, CMT);
+  TEST_VQSHL(int, , uint, u, 32, 2, expected_cumulative_sat_max_large, CMT);
+  TEST_VQSHL(int, , uint, u, 64, 1, expected_cumulative_sat_max_large, CMT);
+  TEST_VQSHL(int, q, int, s, 8, 16, expected_cumulative_sat_max_large, CMT);
+  TEST_VQSHL(int, q, int, s, 16, 8, expected_cumulative_sat_max_large, CMT);
+  TEST_VQSHL(int, q, int, s, 32, 4, expected_cumulative_sat_max_large, CMT);
+  TEST_VQSHL(int, q, int, s, 64, 2, expected_cumulative_sat_max_large, CMT);
+  TEST_VQSHL(int, q, uint, u, 8, 16, expected_cumulative_sat_max_large, CMT);
+  TEST_VQSHL(int, q, uint, u, 16, 8, expected_cumulative_sat_max_large, CMT);
+  TEST_VQSHL(int, q, uint, u, 32, 4, expected_cumulative_sat_max_large, CMT);
+  TEST_VQSHL(int, q, uint, u, 64, 2, expected_cumulative_sat_max_large, CMT);
+
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_max_large, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_max_large, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_max_large, CMT);
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected_max_large, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_max_large, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_max_large, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_max_large, CMT);
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected_max_large, CMT);
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected_max_large, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_max_large, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_max_large, CMT);
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected_max_large, CMT);
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected_max_large, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_max_large, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_max_large, CMT);
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected_max_large, CMT);
+
+
+  /* Check 64 bits saturation.  */
+  VDUP(vector, , int, s, 64, 1, -10);
+  VDUP(vector_shift, , int, s, 64, 1, 64);
+  VDUP(vector, q, int, s, 64, 2, 10);
+  VDUP(vector_shift, q, int, s, 64, 2, 64);
+
+#undef CMT
+#define CMT " (check saturation on 64 bits)"
+  TEST_VQSHL(int, , int, s, 64, 1, expected_cumulative_sat_64, CMT);
+  TEST_VQSHL(int, q, int, s, 64, 2, expected_cumulative_sat_64, CMT);
+
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected_64, CMT);
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected_64, CMT);
+}
+
+int main (void)
+{
+  exec_vqshl ();
+  return 0;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vqshl_n.c
@@ -0,0 +1,234 @@
+#include <arm_neon.h>
+#include "arm-neon-ref.h"
+#include "compute-ref-data.h"
+
+/* Expected values of cumulative_saturation flag.  */
+int VECT_VAR(expected_cumulative_sat,int,8,8) = 0;
+int VECT_VAR(expected_cumulative_sat,int,16,4) = 0;
+int VECT_VAR(expected_cumulative_sat,int,32,2) = 0;
+int VECT_VAR(expected_cumulative_sat,int,64,1) = 0;
+int VECT_VAR(expected_cumulative_sat,uint,8,8) = 1;
+int VECT_VAR(expected_cumulative_sat,uint,16,4) = 1;
+int VECT_VAR(expected_cumulative_sat,uint,32,2) = 1;
+int VECT_VAR(expected_cumulative_sat,uint,64,1) = 1;
+int VECT_VAR(expected_cumulative_sat,int,8,16) = 0;
+int VECT_VAR(expected_cumulative_sat,int,16,8) = 0;
+int VECT_VAR(expected_cumulative_sat,int,32,4) = 0;
+int VECT_VAR(expected_cumulative_sat,int,64,2) = 0;
+int VECT_VAR(expected_cumulative_sat,uint,8,16) = 1;
+int VECT_VAR(expected_cumulative_sat,uint,16,8) = 1;
+int VECT_VAR(expected_cumulative_sat,uint,32,4) = 1;
+int VECT_VAR(expected_cumulative_sat,uint,64,2) = 1;
+
+/* Expected results.  */
+VECT_VAR_DECL(expected,int,8,8) [] = { 0xc0, 0xc4, 0xc8, 0xcc,
+				       0xd0, 0xd4, 0xd8, 0xdc };
+VECT_VAR_DECL(expected,int,16,4) [] = { 0xffe0, 0xffe2, 0xffe4, 0xffe6 };
+VECT_VAR_DECL(expected,int,32,2) [] = { 0xffffffe0, 0xffffffe2 };
+VECT_VAR_DECL(expected,int,64,1) [] = { 0xffffffffffffffc0 };
+VECT_VAR_DECL(expected,uint,8,8) [] = { 0xff, 0xff, 0xff, 0xff,
+					0xff, 0xff, 0xff, 0xff };
+VECT_VAR_DECL(expected,uint,16,4) [] = { 0xffff, 0xffff, 0xffff, 0xffff };
+VECT_VAR_DECL(expected,uint,32,2) [] = { 0xffffffff, 0xffffffff };
+VECT_VAR_DECL(expected,uint,64,1) [] = { 0xffffffffffffffff };
+VECT_VAR_DECL(expected,int,8,16) [] = { 0xc0, 0xc4, 0xc8, 0xcc,
+					0xd0, 0xd4, 0xd8, 0xdc,
+					0xe0, 0xe4, 0xe8, 0xec,
+					0xf0, 0xf4, 0xf8, 0xfc };
+VECT_VAR_DECL(expected,int,16,8) [] = { 0xffe0, 0xffe2, 0xffe4, 0xffe6,
+					0xffe8, 0xffea, 0xffec, 0xffee };
+VECT_VAR_DECL(expected,int,32,4) [] = { 0xffffffe0, 0xffffffe2,
+					0xffffffe4, 0xffffffe6 };
+VECT_VAR_DECL(expected,int,64,2) [] = { 0xffffffffffffffc0, 0xffffffffffffffc4 };
+VECT_VAR_DECL(expected,uint,8,16) [] = { 0xff, 0xff, 0xff, 0xff,
+					 0xff, 0xff, 0xff, 0xff,
+					 0xff, 0xff, 0xff, 0xff,
+					 0xff, 0xff, 0xff, 0xff };
+VECT_VAR_DECL(expected,uint,16,8) [] = { 0xffff, 0xffff, 0xffff, 0xffff,
+					 0xffff, 0xffff, 0xffff, 0xffff };
+VECT_VAR_DECL(expected,uint,32,4) [] = { 0xffffffff, 0xffffffff,
+					 0xffffffff, 0xffffffff };
+VECT_VAR_DECL(expected,uint,64,2) [] = { 0xffffffffffffffff,
+					 0xffffffffffffffff };
+
+/* Expected values of cumulative_saturation flag with max positive input.  */
+int VECT_VAR(expected_cumulative_sat_max,int,8,8) = 1;
+int VECT_VAR(expected_cumulative_sat_max,int,16,4) = 1;
+int VECT_VAR(expected_cumulative_sat_max,int,32,2) = 1;
+int VECT_VAR(expected_cumulative_sat_max,int,64,1) = 1;
+int VECT_VAR(expected_cumulative_sat_max,uint,8,8) = 1;
+int VECT_VAR(expected_cumulative_sat_max,uint,16,4) = 1;
+int VECT_VAR(expected_cumulative_sat_max,uint,32,2) = 1;
+int VECT_VAR(expected_cumulative_sat_max,uint,64,1) = 1;
+int VECT_VAR(expected_cumulative_sat_max,int,8,16) = 1;
+int VECT_VAR(expected_cumulative_sat_max,int,16,8) = 1;
+int VECT_VAR(expected_cumulative_sat_max,int,32,4) = 1;
+int VECT_VAR(expected_cumulative_sat_max,int,64,2) = 1;
+int VECT_VAR(expected_cumulative_sat_max,uint,8,16) = 1;
+int VECT_VAR(expected_cumulative_sat_max,uint,16,8) = 1;
+int VECT_VAR(expected_cumulative_sat_max,uint,32,4) = 1;
+int VECT_VAR(expected_cumulative_sat_max,uint,64,2) = 1;
+
+/* Expected results with max positive input.  */
+VECT_VAR_DECL(expected_max,int,8,8) [] = { 0x7f, 0x7f, 0x7f, 0x7f,
+					   0x7f, 0x7f, 0x7f, 0x7f };
+VECT_VAR_DECL(expected_max,int,16,4) [] = { 0x7fff, 0x7fff, 0x7fff, 0x7fff };
+VECT_VAR_DECL(expected_max,int,32,2) [] = { 0x7fffffff, 0x7fffffff };
+VECT_VAR_DECL(expected_max,int,64,1) [] = { 0x7fffffffffffffff };
+VECT_VAR_DECL(expected_max,uint,8,8) [] = { 0xff, 0xff, 0xff, 0xff,
+					    0xff, 0xff, 0xff, 0xff };
+VECT_VAR_DECL(expected_max,uint,16,4) [] = { 0xffff, 0xffff, 0xffff, 0xffff };
+VECT_VAR_DECL(expected_max,uint,32,2) [] = { 0xffffffff, 0xffffffff };
+VECT_VAR_DECL(expected_max,uint,64,1) [] = { 0xffffffffffffffff };
+VECT_VAR_DECL(expected_max,int,8,16) [] = { 0x7f, 0x7f, 0x7f, 0x7f,
+					    0x7f, 0x7f, 0x7f, 0x7f,
+					    0x7f, 0x7f, 0x7f, 0x7f,
+					    0x7f, 0x7f, 0x7f, 0x7f };
+VECT_VAR_DECL(expected_max,int,16,8) [] = { 0x7fff, 0x7fff, 0x7fff, 0x7fff,
+					    0x7fff, 0x7fff, 0x7fff, 0x7fff };
+VECT_VAR_DECL(expected_max,int,32,4) [] = { 0x7fffffff, 0x7fffffff,
+					    0x7fffffff, 0x7fffffff };
+VECT_VAR_DECL(expected_max,int,64,2) [] = { 0x7fffffffffffffff,
+					    0x7fffffffffffffff };
+VECT_VAR_DECL(expected_max,uint,8,16) [] = { 0xff, 0xff, 0xff, 0xff,
+					     0xff, 0xff, 0xff, 0xff,
+					     0xff, 0xff, 0xff, 0xff,
+					     0xff, 0xff, 0xff, 0xff };
+VECT_VAR_DECL(expected_max,uint,16,8) [] = { 0xffff, 0xffff, 0xffff, 0xffff,
+					     0xffff, 0xffff, 0xffff, 0xffff };
+VECT_VAR_DECL(expected_max,uint,32,4) [] = { 0xffffffff, 0xffffffff,
+					     0xffffffff, 0xffffffff };
+VECT_VAR_DECL(expected_max,uint,64,2) [] = { 0xffffffffffffffff,
+					     0xffffffffffffffff };
+
+#define INSN vqshl
+#define TEST_MSG "VQSHL_N/VQSHLQ_N"
+
+#define FNNAME1(NAME) void exec_ ## NAME ##_n (void)
+#define FNNAME(NAME) FNNAME1(NAME)
+
+FNNAME (INSN)
+{
+  /* Basic test: v2=vqshl_n(v1,v), then store the result.  */
+#define TEST_VQSHL_N2(INSN, Q, T1, T2, W, N, V, EXPECTED_CUMULATIVE_SAT, CMT) \
+  Set_Neon_Cumulative_Sat(0, VECT_VAR(vector_res, T1, W, N));		\
+  VECT_VAR(vector_res, T1, W, N) =					\
+    INSN##Q##_n_##T2##W(VECT_VAR(vector, T1, W, N),			\
+			V);						\
+  vst1##Q##_##T2##W(VECT_VAR(result, T1, W, N),				\
+		    VECT_VAR(vector_res, T1, W, N));			\
+  CHECK_CUMULATIVE_SAT(TEST_MSG, T1, W, N, EXPECTED_CUMULATIVE_SAT, CMT)
+
+  /* Two auxliary macros are necessary to expand INSN */
+#define TEST_VQSHL_N1(INSN, T3, Q, T1, T2, W, N, EXPECTED_CUMULATIVE_SAT, CMT) \
+  TEST_VQSHL_N2(INSN, T3, Q, T1, T2, W, N, EXPECTED_CUMULATIVE_SAT, CMT)
+
+#define TEST_VQSHL_N(T3, Q, T1, T2, W, N, EXPECTED_CUMULATIVE_SAT, CMT)	\
+  TEST_VQSHL_N1(INSN, T3, Q, T1, T2, W, N, EXPECTED_CUMULATIVE_SAT, CMT)
+
+  DECL_VARIABLE_ALL_VARIANTS(vector);
+  DECL_VARIABLE_ALL_VARIANTS(vector_res);
+
+  clean_results ();
+
+  TEST_MACRO_ALL_VARIANTS_2_5(VLOAD, vector, buffer);
+
+  /* Choose shift amount arbitrarily.  */
+#define CMT ""
+  TEST_VQSHL_N(, int, s, 8, 8, 2, expected_cumulative_sat, CMT);
+  TEST_VQSHL_N(, int, s, 16, 4, 1, expected_cumulative_sat, CMT);
+  TEST_VQSHL_N(, int, s, 32, 2, 1, expected_cumulative_sat, CMT);
+  TEST_VQSHL_N(, int, s, 64, 1, 2, expected_cumulative_sat, CMT);
+  TEST_VQSHL_N(, uint, u, 8, 8, 3, expected_cumulative_sat, CMT);
+  TEST_VQSHL_N(, uint, u, 16, 4, 2, expected_cumulative_sat, CMT);
+  TEST_VQSHL_N(, uint, u, 32, 2, 3, expected_cumulative_sat, CMT);
+  TEST_VQSHL_N(, uint, u, 64, 1, 3, expected_cumulative_sat, CMT);
+
+  TEST_VQSHL_N(q, int, s, 8, 16, 2, expected_cumulative_sat, CMT);
+  TEST_VQSHL_N(q, int, s, 16, 8, 1, expected_cumulative_sat, CMT);
+  TEST_VQSHL_N(q, int, s, 32, 4, 1, expected_cumulative_sat, CMT);
+  TEST_VQSHL_N(q, int, s, 64, 2, 2, expected_cumulative_sat, CMT);
+  TEST_VQSHL_N(q, uint, u, 8, 16, 3, expected_cumulative_sat, CMT);
+  TEST_VQSHL_N(q, uint, u, 16, 8, 2, expected_cumulative_sat, CMT);
+  TEST_VQSHL_N(q, uint, u, 32, 4, 3, expected_cumulative_sat, CMT);
+  TEST_VQSHL_N(q, uint, u, 64, 2, 3, expected_cumulative_sat, CMT);
+
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected, CMT);
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected, CMT);
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected, CMT);
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected, CMT);
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected, CMT);
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected, CMT);
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected, CMT);
+
+
+  /* Fill input vector with max value, to check saturation on limits.  */
+  VDUP(vector, , int, s, 8, 8, 0x7F);
+  VDUP(vector, , int, s, 16, 4, 0x7FFF);
+  VDUP(vector, , int, s, 32, 2, 0x7FFFFFFF);
+  VDUP(vector, , int, s, 64, 1, 0x7FFFFFFFFFFFFFFFLL);
+  VDUP(vector, , uint, u, 8, 8, 0xFF);
+  VDUP(vector, , uint, u, 16, 4, 0xFFFF);
+  VDUP(vector, , uint, u, 32, 2, 0xFFFFFFFF);
+  VDUP(vector, , uint, u, 64, 1, 0xFFFFFFFFFFFFFFFFULL);
+  VDUP(vector, q, int, s, 8, 16, 0x7F);
+  VDUP(vector, q, int, s, 16, 8, 0x7FFF);
+  VDUP(vector, q, int, s, 32, 4, 0x7FFFFFFF);
+  VDUP(vector, q, int, s, 64, 2, 0x7FFFFFFFFFFFFFFFLL);
+  VDUP(vector, q, uint, u, 8, 16, 0xFF);
+  VDUP(vector, q, uint, u, 16, 8, 0xFFFF);
+  VDUP(vector, q, uint, u, 32, 4, 0xFFFFFFFF);
+  VDUP(vector, q, uint, u, 64, 2, 0xFFFFFFFFFFFFFFFFULL);
+
+#undef CMT
+#define CMT " (with max input)"
+  TEST_VQSHL_N(, int, s, 8, 8, 2, expected_cumulative_sat_max, CMT);
+  TEST_VQSHL_N(, int, s, 16, 4, 1, expected_cumulative_sat_max, CMT);
+  TEST_VQSHL_N(, int, s, 32, 2, 1, expected_cumulative_sat_max, CMT);
+  TEST_VQSHL_N(, int, s, 64, 1, 2, expected_cumulative_sat_max, CMT);
+  TEST_VQSHL_N(, uint, u, 8, 8, 3, expected_cumulative_sat_max, CMT);
+  TEST_VQSHL_N(, uint, u, 16, 4, 2, expected_cumulative_sat_max, CMT);
+  TEST_VQSHL_N(, uint, u, 32, 2, 3, expected_cumulative_sat_max, CMT);
+  TEST_VQSHL_N(, uint, u, 64, 1, 3, expected_cumulative_sat_max, CMT);
+
+  TEST_VQSHL_N(q, int, s, 8, 16, 2, expected_cumulative_sat_max, CMT);
+  TEST_VQSHL_N(q, int, s, 16, 8, 1, expected_cumulative_sat_max, CMT);
+  TEST_VQSHL_N(q, int, s, 32, 4, 1, expected_cumulative_sat_max, CMT);
+  TEST_VQSHL_N(q, int, s, 64, 2, 2, expected_cumulative_sat_max, CMT);
+  TEST_VQSHL_N(q, uint, u, 8, 16, 3, expected_cumulative_sat_max, CMT);
+  TEST_VQSHL_N(q, uint, u, 16, 8, 2, expected_cumulative_sat_max, CMT);
+  TEST_VQSHL_N(q, uint, u, 32, 4, 3, expected_cumulative_sat_max, CMT);
+  TEST_VQSHL_N(q, uint, u, 64, 2, 3, expected_cumulative_sat_max, CMT);
+
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_max, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_max, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_max, CMT);
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected_max, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_max, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_max, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_max, CMT);
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected_max, CMT);
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected_max, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_max, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_max, CMT);
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected_max, CMT);
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected_max, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_max, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_max, CMT);
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected_max, CMT);
+}
+
+int main (void)
+{
+  exec_vqshl_n ();
+  return 0;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vqshlu_n.c
@@ -0,0 +1,263 @@
+#include <arm_neon.h>
+#include "arm-neon-ref.h"
+#include "compute-ref-data.h"
+
+/* Expected values of cumulative_saturation flag with negative
+   input.  */
+int VECT_VAR(expected_cumulative_sat_neg,int,8,8) = 1;
+int VECT_VAR(expected_cumulative_sat_neg,int,16,4) = 1;
+int VECT_VAR(expected_cumulative_sat_neg,int,32,2) = 1;
+int VECT_VAR(expected_cumulative_sat_neg,int,64,1) = 1;
+int VECT_VAR(expected_cumulative_sat_neg,int,8,16) = 1;
+int VECT_VAR(expected_cumulative_sat_neg,int,16,8) = 1;
+int VECT_VAR(expected_cumulative_sat_neg,int,32,4) = 1;
+int VECT_VAR(expected_cumulative_sat_neg,int,64,2) = 1;
+
+/* Expected results with negative input.  */
+VECT_VAR_DECL(expected_neg,uint,8,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					    0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_neg,uint,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_neg,uint,32,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_neg,uint,64,1) [] = { 0x0 };
+VECT_VAR_DECL(expected_neg,uint,8,16) [] = { 0x0, 0x0, 0x0, 0x0,
+					     0x0, 0x0, 0x0, 0x0,
+					     0x0, 0x0, 0x0, 0x0,
+					     0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_neg,uint,16,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					     0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_neg,uint,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_neg,uint,64,2) [] = { 0x0, 0x0 };
+
+/* Expected values of cumulative_saturation flag with shift by 1.  */
+int VECT_VAR(expected_cumulative_sat_sh1,int,8,8) = 0;
+int VECT_VAR(expected_cumulative_sat_sh1,int,16,4) = 0;
+int VECT_VAR(expected_cumulative_sat_sh1,int,32,2) = 0;
+int VECT_VAR(expected_cumulative_sat_sh1,int,64,1) = 0;
+int VECT_VAR(expected_cumulative_sat_sh1,int,8,16) = 0;
+int VECT_VAR(expected_cumulative_sat_sh1,int,16,8) = 0;
+int VECT_VAR(expected_cumulative_sat_sh1,int,32,4) = 0;
+int VECT_VAR(expected_cumulative_sat_sh1,int,64,2) = 0;
+
+/* Expected results with shift by 1.  */
+VECT_VAR_DECL(expected_sh1,uint,8,8) [] = { 0xfe, 0xfe, 0xfe, 0xfe,
+					    0xfe, 0xfe, 0xfe, 0xfe };
+VECT_VAR_DECL(expected_sh1,uint,16,4) [] = { 0xfffe, 0xfffe, 0xfffe, 0xfffe };
+VECT_VAR_DECL(expected_sh1,uint,32,2) [] = { 0xfffffffe, 0xfffffffe };
+VECT_VAR_DECL(expected_sh1,uint,64,1) [] = { 0xfffffffffffffffe };
+VECT_VAR_DECL(expected_sh1,uint,8,16) [] = { 0xfe, 0xfe, 0xfe, 0xfe,
+					     0xfe, 0xfe, 0xfe, 0xfe,
+					     0xfe, 0xfe, 0xfe, 0xfe,
+					     0xfe, 0xfe, 0xfe, 0xfe };
+VECT_VAR_DECL(expected_sh1,uint,16,8) [] = { 0xfffe, 0xfffe, 0xfffe, 0xfffe,
+					     0xfffe, 0xfffe, 0xfffe, 0xfffe };
+VECT_VAR_DECL(expected_sh1,uint,32,4) [] = { 0xfffffffe, 0xfffffffe,
+					     0xfffffffe, 0xfffffffe };
+VECT_VAR_DECL(expected_sh1,uint,64,2) [] = { 0xfffffffffffffffe,
+					     0xfffffffffffffffe };
+
+/* Expected values of cumulative_saturation flag with shift by 2.  */
+int VECT_VAR(expected_cumulative_sat_sh2,int,8,8) = 1;
+int VECT_VAR(expected_cumulative_sat_sh2,int,16,4) = 1;
+int VECT_VAR(expected_cumulative_sat_sh2,int,32,2) = 1;
+int VECT_VAR(expected_cumulative_sat_sh2,int,64,1) = 1;
+int VECT_VAR(expected_cumulative_sat_sh2,int,8,16) = 1;
+int VECT_VAR(expected_cumulative_sat_sh2,int,16,8) = 1;
+int VECT_VAR(expected_cumulative_sat_sh2,int,32,4) = 1;
+int VECT_VAR(expected_cumulative_sat_sh2,int,64,2) = 1;
+
+/* Expected results with shift by 2.  */
+VECT_VAR_DECL(expected_sh2,uint,8,8) [] = { 0xff, 0xff, 0xff, 0xff,
+					    0xff, 0xff, 0xff, 0xff };
+VECT_VAR_DECL(expected_sh2,uint,16,4) [] = { 0xffff, 0xffff, 0xffff, 0xffff };
+VECT_VAR_DECL(expected_sh2,uint,32,2) [] = { 0xffffffff, 0xffffffff };
+VECT_VAR_DECL(expected_sh2,uint,64,1) [] = { 0xffffffffffffffff };
+VECT_VAR_DECL(expected_sh2,uint,8,16) [] = { 0xff, 0xff, 0xff, 0xff,
+					     0xff, 0xff, 0xff, 0xff,
+					     0xff, 0xff, 0xff, 0xff,
+					     0xff, 0xff, 0xff, 0xff };
+VECT_VAR_DECL(expected_sh2,uint,16,8) [] = { 0xffff, 0xffff, 0xffff, 0xffff,
+					     0xffff, 0xffff, 0xffff, 0xffff };
+VECT_VAR_DECL(expected_sh2,uint,32,4) [] = { 0xffffffff, 0xffffffff,
+					     0xffffffff, 0xffffffff };
+VECT_VAR_DECL(expected_sh2,uint,64,2) [] = { 0xffffffffffffffff,
+					     0xffffffffffffffff };
+
+/* Expected values of cumulative_saturation flag.  */
+int VECT_VAR(expected_cumulative_sat,int,8,8) = 0;
+int VECT_VAR(expected_cumulative_sat,int,16,4) = 0;
+int VECT_VAR(expected_cumulative_sat,int,32,2) = 0;
+int VECT_VAR(expected_cumulative_sat,int,64,1) = 0;
+int VECT_VAR(expected_cumulative_sat,int,8,16) = 0;
+int VECT_VAR(expected_cumulative_sat,int,16,8) = 0;
+int VECT_VAR(expected_cumulative_sat,int,32,4) = 0;
+int VECT_VAR(expected_cumulative_sat,int,64,2) = 0;
+
+/* Expected results.  */
+VECT_VAR_DECL(expected,uint,8,8) [] = { 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2 };
+VECT_VAR_DECL(expected,uint,16,4) [] = { 0x8, 0x8, 0x8, 0x8 };
+VECT_VAR_DECL(expected,uint,32,2) [] = { 0x18, 0x18 };
+VECT_VAR_DECL(expected,uint,64,1) [] = { 0x40 };
+VECT_VAR_DECL(expected,uint,8,16) [] = { 0xa0, 0xa0, 0xa0, 0xa0,
+					 0xa0, 0xa0, 0xa0, 0xa0,
+					 0xa0, 0xa0, 0xa0, 0xa0,
+					 0xa0, 0xa0, 0xa0, 0xa0 };
+VECT_VAR_DECL(expected,uint,16,8) [] = { 0x180, 0x180, 0x180, 0x180,
+					 0x180, 0x180, 0x180, 0x180 };
+VECT_VAR_DECL(expected,uint,32,4) [] = { 0x380, 0x380, 0x380, 0x380 };
+VECT_VAR_DECL(expected,uint,64,2) [] = { 0x800, 0x800 };
+
+
+#define INSN vqshlu
+#define TEST_MSG "VQSHLU_N/VQSHLUQ_N"
+
+#define FNNAME1(NAME) void exec_ ## NAME ## _n(void)
+#define FNNAME(NAME) FNNAME1(NAME)
+
+FNNAME (INSN)
+{
+  /* Basic test: v2=vqshlu_n(v1,v), then store the result.  */
+#define TEST_VQSHLU_N2(INSN, Q, T1, T2, T3, T4, W, N, V, EXPECTED_CUMULATIVE_SAT, CMT) \
+  Set_Neon_Cumulative_Sat(0, VECT_VAR(vector_res, T3, W, N));		\
+  VECT_VAR(vector_res, T3, W, N) =					\
+    INSN##Q##_n_##T2##W(VECT_VAR(vector, T1, W, N),			\
+			V);						\
+  vst1##Q##_##T4##W(VECT_VAR(result, T3, W, N),				\
+		    VECT_VAR(vector_res, T3, W, N));			\
+  CHECK_CUMULATIVE_SAT(TEST_MSG, T1, W, N, EXPECTED_CUMULATIVE_SAT, CMT)
+
+  /* Two auxliary macros are necessary to expand INSN */
+#define TEST_VQSHLU_N1(INSN, Q, T1, T2, T3, T4, W, N, V, EXPECTED_CUMULATIVE_SAT, CMT) \
+  TEST_VQSHLU_N2(INSN, Q, T1, T2, T3, T4, W, N, V, EXPECTED_CUMULATIVE_SAT, CMT)
+
+#define TEST_VQSHLU_N(Q, T1, T2, T3, T4, W, N, V, EXPECTED_CUMULATIVE_SAT, CMT) \
+  TEST_VQSHLU_N1(INSN, Q, T1, T2, T3, T4, W, N, V, EXPECTED_CUMULATIVE_SAT, CMT)
+
+
+  DECL_VARIABLE_ALL_VARIANTS(vector);
+  DECL_VARIABLE_ALL_VARIANTS(vector_res);
+
+  clean_results ();
+
+  /* Fill input vector with negative values, to check saturation on
+     limits.  */
+  VDUP(vector, , int, s, 8, 8, -1);
+  VDUP(vector, , int, s, 16, 4, -2);
+  VDUP(vector, , int, s, 32, 2, -3);
+  VDUP(vector, , int, s, 64, 1, -4);
+  VDUP(vector, q, int, s, 8, 16, -1);
+  VDUP(vector, q, int, s, 16, 8, -2);
+  VDUP(vector, q, int, s, 32, 4, -3);
+  VDUP(vector, q, int, s, 64, 2, -4);
+
+  /* Choose shift amount arbitrarily.  */
+#define CMT " (negative input)"
+  TEST_VQSHLU_N(, int, s, uint, u, 8, 8, 2, expected_cumulative_sat_neg, CMT);
+  TEST_VQSHLU_N(, int, s, uint, u, 16, 4, 1, expected_cumulative_sat_neg, CMT);
+  TEST_VQSHLU_N(, int, s, uint, u, 32, 2, 1, expected_cumulative_sat_neg, CMT);
+  TEST_VQSHLU_N(, int, s, uint, u, 64, 1, 2, expected_cumulative_sat_neg, CMT);
+  TEST_VQSHLU_N(q, int, s, uint, u, 8, 16, 2, expected_cumulative_sat_neg, CMT);
+  TEST_VQSHLU_N(q, int, s, uint, u, 16, 8, 1, expected_cumulative_sat_neg, CMT);
+  TEST_VQSHLU_N(q, int, s, uint, u, 32, 4, 1, expected_cumulative_sat_neg, CMT);
+  TEST_VQSHLU_N(q, int, s, uint, u, 64, 2, 2, expected_cumulative_sat_neg, CMT);
+
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_neg, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_neg, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_neg, CMT);
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected_neg, CMT);
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected_neg, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_neg, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_neg, CMT);
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected_neg, CMT);
+
+  
+  /* Fill input vector with max value, to check saturation on
+     limits.  */
+  VDUP(vector, , int, s, 8, 8, 0x7F);
+  VDUP(vector, , int, s, 16, 4, 0x7FFF);
+  VDUP(vector, , int, s, 32, 2, 0x7FFFFFFF);
+  VDUP(vector, , int, s, 64, 1, 0x7FFFFFFFFFFFFFFFLL);
+  VDUP(vector, q, int, s, 8, 16, 0x7F);
+  VDUP(vector, q, int, s, 16, 8, 0x7FFF);
+  VDUP(vector, q, int, s, 32, 4, 0x7FFFFFFF);
+  VDUP(vector, q, int, s, 64, 2, 0x7FFFFFFFFFFFFFFFULL);
+
+  /* shift by 1.  */
+#undef CMT
+#define CMT " (shift by 1)"
+  TEST_VQSHLU_N(, int, s, uint, u, 8, 8, 1, expected_cumulative_sat_sh1, CMT);
+  TEST_VQSHLU_N(, int, s, uint, u, 16, 4, 1, expected_cumulative_sat_sh1, CMT);
+  TEST_VQSHLU_N(, int, s, uint, u, 32, 2, 1, expected_cumulative_sat_sh1, CMT);
+  TEST_VQSHLU_N(, int, s, uint, u, 64, 1, 1, expected_cumulative_sat_sh1, CMT);
+  TEST_VQSHLU_N(q, int, s, uint, u, 8, 16, 1, expected_cumulative_sat_sh1, CMT);
+  TEST_VQSHLU_N(q, int, s, uint, u, 16, 8, 1, expected_cumulative_sat_sh1, CMT);
+  TEST_VQSHLU_N(q, int, s, uint, u, 32, 4, 1, expected_cumulative_sat_sh1, CMT);
+  TEST_VQSHLU_N(q, int, s, uint, u, 64, 2, 1, expected_cumulative_sat_sh1, CMT);
+
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_sh1, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_sh1, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_sh1, CMT);
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected_sh1, CMT);
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected_sh1, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_sh1, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_sh1, CMT);
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected_sh1, CMT);
+
+  /* shift by 2 to force saturation.  */
+#undef CMT
+#define CMT " (shift by 2)"
+  TEST_VQSHLU_N(, int, s, uint, u, 8, 8, 2, expected_cumulative_sat_sh2, CMT);
+  TEST_VQSHLU_N(, int, s, uint, u, 16, 4, 2, expected_cumulative_sat_sh2, CMT);
+  TEST_VQSHLU_N(, int, s, uint, u, 32, 2, 2, expected_cumulative_sat_sh2, CMT);
+  TEST_VQSHLU_N(, int, s, uint, u, 64, 1, 2, expected_cumulative_sat_sh2, CMT);
+  TEST_VQSHLU_N(q, int, s, uint, u, 8, 16, 2, expected_cumulative_sat_sh2, CMT);
+  TEST_VQSHLU_N(q, int, s, uint, u, 16, 8, 2, expected_cumulative_sat_sh2, CMT);
+  TEST_VQSHLU_N(q, int, s, uint, u, 32, 4, 2, expected_cumulative_sat_sh2, CMT);
+  TEST_VQSHLU_N(q, int, s, uint, u, 64, 2, 2, expected_cumulative_sat_sh2, CMT);
+
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_sh2, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_sh2, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_sh2, CMT);
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected_sh2, CMT);
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected_sh2, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_sh2, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_sh2, CMT);
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected_sh2, CMT);
+
+  
+  /* Fill input vector with positive values, to check normal case.  */
+  VDUP(vector, , int, s, 8, 8, 1);
+  VDUP(vector, , int, s, 16, 4, 2);
+  VDUP(vector, , int, s, 32, 2, 3);
+  VDUP(vector, , int, s, 64, 1, 4);
+  VDUP(vector, q, int, s, 8, 16, 5);
+  VDUP(vector, q, int, s, 16, 8, 6);
+  VDUP(vector, q, int, s, 32, 4, 7);
+  VDUP(vector, q, int, s, 64, 2, 8);
+
+  /* Arbitrary shift amount.  */
+#undef CMT
+#define CMT ""
+  TEST_VQSHLU_N(, int, s, uint, u, 8, 8, 1, expected_cumulative_sat, CMT);
+  TEST_VQSHLU_N(, int, s, uint, u, 16, 4, 2, expected_cumulative_sat, CMT);
+  TEST_VQSHLU_N(, int, s, uint, u, 32, 2, 3, expected_cumulative_sat, CMT);
+  TEST_VQSHLU_N(, int, s, uint, u, 64, 1, 4, expected_cumulative_sat, CMT);
+  TEST_VQSHLU_N(q, int, s, uint, u, 8, 16, 5, expected_cumulative_sat, CMT);
+  TEST_VQSHLU_N(q, int, s, uint, u, 16, 8, 6, expected_cumulative_sat, CMT);
+  TEST_VQSHLU_N(q, int, s, uint, u, 32, 4, 7, expected_cumulative_sat, CMT);
+  TEST_VQSHLU_N(q, int, s, uint, u, 64, 2, 8, expected_cumulative_sat, CMT);
+
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected, CMT);
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected, CMT);
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected, CMT);
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected, CMT);
+}
+
+int main (void)
+{
+  exec_vqshlu_n ();
+  return 0;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vqshrn_n.c
@@ -0,0 +1,177 @@
+#include <arm_neon.h>
+#include "arm-neon-ref.h"
+#include "compute-ref-data.h"
+
+/* Expected values of cumulative_saturation flag.  */
+int VECT_VAR(expected_cumulative_sat,int,16,8) = 0;
+int VECT_VAR(expected_cumulative_sat,int,32,4) = 0;
+int VECT_VAR(expected_cumulative_sat,int,64,2) = 0;
+int VECT_VAR(expected_cumulative_sat,uint,16,8) = 1;
+int VECT_VAR(expected_cumulative_sat,uint,32,4) = 1;
+int VECT_VAR(expected_cumulative_sat,uint,64,2) = 1;
+
+/* Expected results.  */
+VECT_VAR_DECL(expected,int,8,8) [] = { 0xf8, 0xf8, 0xf9, 0xf9,
+				       0xfa, 0xfa, 0xfb, 0xfb };
+VECT_VAR_DECL(expected,int,16,4) [] = { 0xfff8, 0xfff8, 0xfff9, 0xfff9 };
+VECT_VAR_DECL(expected,int,32,2) [] = { 0xfffffffc, 0xfffffffc };
+VECT_VAR_DECL(expected,uint,8,8) [] = { 0xff, 0xff, 0xff, 0xff,
+					0xff, 0xff, 0xff, 0xff };
+VECT_VAR_DECL(expected,uint,16,4) [] = { 0xffff, 0xffff, 0xffff, 0xffff };
+VECT_VAR_DECL(expected,uint,32,2) [] = { 0xffffffff, 0xffffffff };
+
+/* Expected values of cumulative_saturation flag with max input value
+   shifted by 3.  */
+int VECT_VAR(expected_cumulative_sat_max_sh3,int,16,8) = 1;
+int VECT_VAR(expected_cumulative_sat_max_sh3,int,32,4) = 1;
+int VECT_VAR(expected_cumulative_sat_max_sh3,int,64,2) = 1;
+int VECT_VAR(expected_cumulative_sat_max_sh3,uint,16,8) = 1;
+int VECT_VAR(expected_cumulative_sat_max_sh3,uint,32,4) = 1;
+int VECT_VAR(expected_cumulative_sat_max_sh3,uint,64,2) = 1;
+
+/* Expected results with max input value shifted by 3.  */
+VECT_VAR_DECL(expected_max_sh3,int,8,8) [] = { 0x7f, 0x7f, 0x7f, 0x7f,
+					       0x7f, 0x7f, 0x7f, 0x7f };
+VECT_VAR_DECL(expected_max_sh3,int,16,4) [] = { 0x7fff, 0x7fff, 0x7fff, 0x7fff };
+VECT_VAR_DECL(expected_max_sh3,int,32,2) [] = { 0x7fffffff, 0x7fffffff };
+VECT_VAR_DECL(expected_max_sh3,uint,8,8) [] = { 0xff, 0xff, 0xff, 0xff,
+						0xff, 0xff, 0xff, 0xff };
+VECT_VAR_DECL(expected_max_sh3,uint,16,4) [] = { 0xffff, 0xffff,
+						 0xffff, 0xffff };
+VECT_VAR_DECL(expected_max_sh3,uint,32,2) [] = { 0xffffffff, 0xffffffff };
+
+/* Expected values of cumulative_saturation flag with max input value
+   shifted by type size.  */
+int VECT_VAR(expected_cumulative_sat_max_shmax,int,16,8) = 0;
+int VECT_VAR(expected_cumulative_sat_max_shmax,int,32,4) = 0;
+int VECT_VAR(expected_cumulative_sat_max_shmax,int,64,2) = 0;
+int VECT_VAR(expected_cumulative_sat_max_shmax,uint,16,8) = 0;
+int VECT_VAR(expected_cumulative_sat_max_shmax,uint,32,4) = 0;
+int VECT_VAR(expected_cumulative_sat_max_shmax,uint,64,2) = 0;
+
+/* Expected results with max input value shifted by type size.  */
+VECT_VAR_DECL(expected_max_shmax,int,8,8) [] = { 0x7f, 0x7f, 0x7f, 0x7f,
+						 0x7f, 0x7f, 0x7f, 0x7f };
+VECT_VAR_DECL(expected_max_shmax,int,16,4) [] = { 0x7fff, 0x7fff,
+						  0x7fff, 0x7fff };
+VECT_VAR_DECL(expected_max_shmax,int,32,2) [] = { 0x7fffffff, 0x7fffffff };
+VECT_VAR_DECL(expected_max_shmax,uint,8,8) [] = { 0xff, 0xff, 0xff, 0xff,
+						  0xff, 0xff, 0xff, 0xff };
+VECT_VAR_DECL(expected_max_shmax,uint,16,4) [] = { 0xffff, 0xffff,
+						   0xffff, 0xffff };
+VECT_VAR_DECL(expected_max_shmax,uint,32,2) [] = { 0xffffffff, 0xffffffff };
+
+#define INSN vqshrn_n
+#define TEST_MSG "VQSHRN_N"
+
+#define FNNAME1(NAME) void exec_ ## NAME (void)
+#define FNNAME(NAME) FNNAME1(NAME)
+
+FNNAME (INSN)
+{
+  /* Basic test: y=vqshrn_n(x,v), then store the result.  */
+#define TEST_VQSHRN_N2(INSN, T1, T2, W, W2, N, V, EXPECTED_CUMULATIVE_SAT, CMT) \
+  Set_Neon_Cumulative_Sat(0, VECT_VAR(vector_res, T1, W2, N));		\
+  VECT_VAR(vector_res, T1, W2, N) =					\
+    INSN##_##T2##W(VECT_VAR(vector, T1, W, N),				\
+		   V);							\
+  vst1_##T2##W2(VECT_VAR(result, T1, W2, N),				\
+		VECT_VAR(vector_res, T1, W2, N));			\
+  CHECK_CUMULATIVE_SAT(TEST_MSG, T1, W, N, EXPECTED_CUMULATIVE_SAT, CMT)
+
+  /* Two auxliary macros are necessary to expand INSN */
+#define TEST_VQSHRN_N1(INSN, T1, T2, W, W2, N, V, EXPECTED_CUMULATIVE_SAT, CMT) \
+  TEST_VQSHRN_N2(INSN, T1, T2, W, W2, N, V, EXPECTED_CUMULATIVE_SAT, CMT)
+
+#define TEST_VQSHRN_N(T1, T2, W, W2, N, V, EXPECTED_CUMULATIVE_SAT, CMT) \
+  TEST_VQSHRN_N1(INSN, T1, T2, W, W2, N, V, EXPECTED_CUMULATIVE_SAT, CMT)
+
+
+  /* vector is twice as large as vector_res.  */
+  DECL_VARIABLE(vector, int, 16, 8);
+  DECL_VARIABLE(vector, int, 32, 4);
+  DECL_VARIABLE(vector, int, 64, 2);
+  DECL_VARIABLE(vector, uint, 16, 8);
+  DECL_VARIABLE(vector, uint, 32, 4);
+  DECL_VARIABLE(vector, uint, 64, 2);
+
+  DECL_VARIABLE(vector_res, int, 8, 8);
+  DECL_VARIABLE(vector_res, int, 16, 4);
+  DECL_VARIABLE(vector_res, int, 32, 2);
+  DECL_VARIABLE(vector_res, uint, 8, 8);
+  DECL_VARIABLE(vector_res, uint, 16, 4);
+  DECL_VARIABLE(vector_res, uint, 32, 2);
+
+  clean_results ();
+
+  VLOAD(vector, buffer, q, int, s, 16, 8);
+  VLOAD(vector, buffer, q, int, s, 32, 4);
+  VLOAD(vector, buffer, q, int, s, 64, 2);
+  VLOAD(vector, buffer, q, uint, u, 16, 8);
+  VLOAD(vector, buffer, q, uint, u, 32, 4);
+  VLOAD(vector, buffer, q, uint, u, 64, 2);
+
+  /* Choose shift amount arbitrarily.  */
+#define CMT ""
+  TEST_VQSHRN_N(int, s, 16, 8, 8, 1, expected_cumulative_sat, CMT);
+  TEST_VQSHRN_N(int, s, 32, 16, 4, 1, expected_cumulative_sat, CMT);
+  TEST_VQSHRN_N(int, s, 64, 32, 2, 2, expected_cumulative_sat, CMT);
+  TEST_VQSHRN_N(uint, u, 16, 8, 8, 2, expected_cumulative_sat, CMT);
+  TEST_VQSHRN_N(uint, u, 32, 16, 4, 3, expected_cumulative_sat, CMT);
+  TEST_VQSHRN_N(uint, u, 64, 32, 2, 3, expected_cumulative_sat, CMT);
+
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected, CMT);
+
+
+  /* Use max possible value as input.  */
+  VDUP(vector, q, int, s, 16, 8, 0x7FFF);
+  VDUP(vector, q, int, s, 32, 4, 0x7FFFFFFF);
+  VDUP(vector, q, int, s, 64, 2, 0x7FFFFFFFFFFFFFFFLL);
+  VDUP(vector, q, uint, u, 16, 8, 0xFFFF);
+  VDUP(vector, q, uint, u, 32, 4, 0xFFFFFFFF);
+  VDUP(vector, q, uint, u, 64, 2, 0xFFFFFFFFFFFFFFFFULL);
+
+#undef CMT
+#define CMT " (check saturation: shift by 3)"
+  TEST_VQSHRN_N(int, s, 16, 8, 8, 3, expected_cumulative_sat_max_sh3, CMT);
+  TEST_VQSHRN_N(int, s, 32, 16, 4, 3, expected_cumulative_sat_max_sh3, CMT);
+  TEST_VQSHRN_N(int, s, 64, 32, 2, 3, expected_cumulative_sat_max_sh3, CMT);
+  TEST_VQSHRN_N(uint, u, 16, 8, 8, 3, expected_cumulative_sat_max_sh3, CMT);
+  TEST_VQSHRN_N(uint, u, 32, 16, 4, 3, expected_cumulative_sat_max_sh3, CMT);
+  TEST_VQSHRN_N(uint, u, 64, 32, 2, 3, expected_cumulative_sat_max_sh3, CMT);
+
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_max_sh3, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_max_sh3, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_max_sh3, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_max_sh3, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_max_sh3, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_max_sh3, CMT);
+
+
+#undef CMT
+#define CMT " (check saturation: shift by max)"
+  TEST_VQSHRN_N(int, s, 16, 8, 8, 8, expected_cumulative_sat_max_shmax, CMT);
+  TEST_VQSHRN_N(int, s, 32, 16, 4, 16, expected_cumulative_sat_max_shmax, CMT);
+  TEST_VQSHRN_N(int, s, 64, 32, 2, 32, expected_cumulative_sat_max_shmax, CMT);
+  TEST_VQSHRN_N(uint, u, 16, 8, 8, 8, expected_cumulative_sat_max_shmax, CMT);
+  TEST_VQSHRN_N(uint, u, 32, 16, 4, 16, expected_cumulative_sat_max_shmax, CMT);
+  TEST_VQSHRN_N(uint, u, 64, 32, 2, 32, expected_cumulative_sat_max_shmax, CMT);
+
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_max_shmax, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_max_shmax, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_max_shmax, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_max_shmax, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_max_shmax, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_max_shmax, CMT);
+}
+
+int main (void)
+{
+  exec_vqshrn_n ();
+  return 0;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vqshrun_n.c
@@ -0,0 +1,133 @@
+#include <arm_neon.h>
+#include "arm-neon-ref.h"
+#include "compute-ref-data.h"
+
+/* Expected values of cumulative_saturation flag with negative input.  */
+int VECT_VAR(expected_cumulative_sat_neg,int,16,8) = 1;
+int VECT_VAR(expected_cumulative_sat_neg,int,32,4) = 1;
+int VECT_VAR(expected_cumulative_sat_neg,int,64,2) = 1;
+
+/* Expected results with negative input.  */
+VECT_VAR_DECL(expected_neg,uint,8,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					    0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_neg,uint,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_neg,uint,32,2) [] = { 0x0, 0x0 };
+
+/* Expected values of cumulative_saturation flag with max input value
+   shifted by 1.  */
+int VECT_VAR(expected_cumulative_sat_max_sh1,int,16,8) = 1;
+int VECT_VAR(expected_cumulative_sat_max_sh1,int,32,4) = 1;
+int VECT_VAR(expected_cumulative_sat_max_sh1,int,64,2) = 1;
+
+/* Expected results with max input value shifted by 1.  */
+VECT_VAR_DECL(expected_max_sh1,uint,8,8) [] = { 0xff, 0xff, 0xff, 0xff,
+						0xff, 0xff, 0xff, 0xff };
+VECT_VAR_DECL(expected_max_sh1,uint,16,4) [] = { 0xffff, 0xffff,
+						 0xffff, 0xffff };
+VECT_VAR_DECL(expected_max_sh1,uint,32,2) [] = { 0xffffffff, 0xffffffff };
+VECT_VAR_DECL(expected_max_sh1,uint,64,1) [] = { 0x3333333333333333 };
+
+/* Expected values of cumulative_saturation flag.  */
+int VECT_VAR(expected_cumulative_sat,int,16,8) = 0;
+int VECT_VAR(expected_cumulative_sat,int,32,4) = 1;
+int VECT_VAR(expected_cumulative_sat,int,64,2) = 0;
+
+/* Expected results.  */
+VECT_VAR_DECL(expected,uint,8,8) [] = { 0x48, 0x48, 0x48, 0x48,
+					0x48, 0x48, 0x48, 0x48 };
+VECT_VAR_DECL(expected,uint,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected,uint,32,2) [] = { 0xdeadbe, 0xdeadbe };
+
+
+#define INSN vqshrun_n
+#define TEST_MSG "VQSHRUN_N"
+
+#define FNNAME1(NAME) void exec_ ## NAME (void)
+#define FNNAME(NAME) FNNAME1(NAME)
+
+FNNAME (INSN)
+{
+  /* Basic test: y=vqshrun_n(x,v), then store the result.  */
+#define TEST_VQSHRUN_N2(INSN, T1, T2, W, W2, N, V, EXPECTED_CUMULATIVE_SAT, CMT) \
+  Set_Neon_Cumulative_Sat(0, VECT_VAR(vector_res, uint, W2, N));	\
+  VECT_VAR(vector_res, uint, W2, N) =					\
+    INSN##_##T2##W(VECT_VAR(vector, T1, W, N),				\
+		   V);							\
+  vst1_u##W2(VECT_VAR(result, uint, W2, N),				\
+	     VECT_VAR(vector_res, uint, W2, N));			\
+  CHECK_CUMULATIVE_SAT(TEST_MSG, T1, W, N, EXPECTED_CUMULATIVE_SAT, CMT)
+
+  /* Two auxliary macros are necessary to expand INSN */
+#define TEST_VQSHRUN_N1(INSN, T1, T2, W, W2, N, V, EXPECTED_CUMULATIVE_SAT, CMT) \
+  TEST_VQSHRUN_N2(INSN, T1, T2, W, W2, N, V, EXPECTED_CUMULATIVE_SAT, CMT)
+
+#define TEST_VQSHRUN_N(T1, T2, W, W2, N, V, EXPECTED_CUMULATIVE_SAT, CMT) \
+  TEST_VQSHRUN_N1(INSN, T1, T2, W, W2, N, V, EXPECTED_CUMULATIVE_SAT, CMT)
+
+
+  /* vector is twice as large as vector_res.  */
+  DECL_VARIABLE(vector, int, 16, 8);
+  DECL_VARIABLE(vector, int, 32, 4);
+  DECL_VARIABLE(vector, int, 64, 2);
+
+  DECL_VARIABLE(vector_res, uint, 8, 8);
+  DECL_VARIABLE(vector_res, uint, 16, 4);
+  DECL_VARIABLE(vector_res, uint, 32, 2);
+
+  clean_results ();
+
+  /* Fill input vector with negative values, to check saturation on
+     limits.  */
+  VDUP(vector, q, int, s, 16, 8, -2);
+  VDUP(vector, q, int, s, 32, 4, -3);
+  VDUP(vector, q, int, s, 64, 2, -4);
+
+  /* Choose shift amount arbitrarily.  */
+#define CMT " (negative input)"
+  TEST_VQSHRUN_N(int, s, 16, 8, 8, 3, expected_cumulative_sat_neg, CMT);
+  TEST_VQSHRUN_N(int, s, 32, 16, 4, 4, expected_cumulative_sat_neg, CMT);
+  TEST_VQSHRUN_N(int, s, 64, 32, 2, 2, expected_cumulative_sat_neg, CMT);
+
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_neg, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_neg, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_neg, CMT);
+
+  
+  /* Fill input vector with max value, to check saturation on
+     limits.  */
+  VDUP(vector, q, int, s, 16, 8, 0x7FFF);
+  VDUP(vector, q, int, s, 32, 4, 0x7FFFFFFF);
+  VDUP(vector, q, int, s, 64, 2, 0x7FFFFFFFFFFFFFFFLL);
+
+#undef CMT
+#define CMT " (check cumulative saturation)"
+  TEST_VQSHRUN_N(int, s, 16, 8, 8, 1, expected_cumulative_sat_max_sh1, CMT);
+  TEST_VQSHRUN_N(int, s, 32, 16, 4, 1, expected_cumulative_sat_max_sh1, CMT);
+  TEST_VQSHRUN_N(int, s, 64, 32, 2, 1, expected_cumulative_sat_max_sh1, CMT);
+
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_max_sh1, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_max_sh1, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_max_sh1, CMT);
+
+  
+  /* Fill input vector with positive values, to check normal case.  */
+  VDUP(vector, q, int, s, 16, 8, 0x1234);
+  VDUP(vector, q, int, s, 32, 4, 0x87654321);
+  VDUP(vector, q, int, s, 64, 2, 0xDEADBEEF);
+
+#undef CMT
+#define CMT ""
+  TEST_VQSHRUN_N(int, s, 16, 8, 8, 6, expected_cumulative_sat, CMT);
+  TEST_VQSHRUN_N(int, s, 32, 16, 4, 7, expected_cumulative_sat, CMT);
+  TEST_VQSHRUN_N(int, s, 64, 32, 2, 8, expected_cumulative_sat, CMT);
+
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected, CMT);
+}
+
+int main (void)
+{
+  exec_vqshrun_n ();
+  return 0;
+}
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vqsub.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vqsub.c
@@ -25,10 +25,6 @@ VECT_VAR_DECL(expected,uint,16,4) [] = { 0xff8a, 0xff8b,
 					 0xff8c, 0xff8d };
 VECT_VAR_DECL(expected,uint,32,2) [] = { 0xffffff79, 0xffffff7a };
 VECT_VAR_DECL(expected,uint,64,1) [] = { 0xffffffffffffff68 };
-VECT_VAR_DECL(expected,poly,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0x33333333, 0x33333333 };
 VECT_VAR_DECL(expected,int,8,16) [] = { 0xdf, 0xe0, 0xe1, 0xe2,
 					0xe3, 0xe4, 0xe5, 0xe6,
 					0xe7, 0xe8, 0xe9, 0xea,
@@ -49,14 +45,6 @@ VECT_VAR_DECL(expected,uint,32,4) [] = { 0xffffff79, 0xffffff7a,
 					 0xffffff7b, 0xffffff7c };
 VECT_VAR_DECL(expected,uint,64,2) [] = { 0xffffffffffffff68,
 					 0xffffffffffffff69 };
-VECT_VAR_DECL(expected,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0x33333333, 0x33333333,
-					   0x33333333, 0x33333333 };
 
 /* Expected values of cumulative saturation flag.  */
 int VECT_VAR(expected_cumulative_sat,int,8,8) = 0;
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vrecpe.c
@@ -0,0 +1,154 @@
+#include <arm_neon.h>
+#include "arm-neon-ref.h"
+#include "compute-ref-data.h"
+#include <math.h>
+
+/* Expected results with positive input.  */
+VECT_VAR_DECL(expected_positive,uint,32,2) [] = { 0xffffffff, 0xffffffff };
+VECT_VAR_DECL(expected_positive,uint,32,4) [] = { 0xbf000000, 0xbf000000,
+						  0xbf000000, 0xbf000000 };
+VECT_VAR_DECL(expected_positive,hfloat,32,2) [] = { 0x3f068000, 0x3f068000 };
+VECT_VAR_DECL(expected_positive,hfloat,32,4) [] = { 0x3c030000, 0x3c030000,
+						    0x3c030000, 0x3c030000 };
+
+/* Expected results with negative input.  */
+VECT_VAR_DECL(expected_negative,uint,32,2) [] = { 0x80000000, 0x80000000 };
+VECT_VAR_DECL(expected_negative,uint,32,4) [] = { 0xee800000, 0xee800000,
+						  0xee800000, 0xee800000 };
+VECT_VAR_DECL(expected_negative,hfloat,32,2) [] = { 0xbdcc8000, 0xbdcc8000 };
+VECT_VAR_DECL(expected_negative,hfloat,32,4) [] = { 0xbc030000, 0xbc030000,
+						    0xbc030000, 0xbc030000 };
+
+/* Expected results with FP special values (NaN, infinity).  */
+VECT_VAR_DECL(expected_fp1,hfloat,32,2) [] = { 0x7fc00000, 0x7fc00000 };
+VECT_VAR_DECL(expected_fp1,hfloat,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+
+/* Expected results with FP special values (zero, large value).  */
+VECT_VAR_DECL(expected_fp2,hfloat,32,2) [] = { 0x7f800000, 0x7f800000 };
+VECT_VAR_DECL(expected_fp2,hfloat,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+
+/* Expected results with FP special values (-0, -infinity).  */
+VECT_VAR_DECL(expected_fp3,hfloat,32,2) [] = { 0xff800000, 0xff800000 };
+VECT_VAR_DECL(expected_fp3,hfloat,32,4) [] = { 0x80000000, 0x80000000,
+					       0x80000000, 0x80000000 };
+
+/* Expected results with FP special large negative value.  */
+VECT_VAR_DECL(expected_fp4,hfloat,32,2) [] = { 0x80000000, 0x80000000 };
+
+#define TEST_MSG "VRECPE/VRECPEQ"
+void exec_vrecpe(void)
+{
+  int i;
+
+  /* Basic test: y=vrecpe(x), then store the result.  */
+#define TEST_VRECPE(Q, T1, T2, W, N)			\
+  VECT_VAR(vector_res, T1, W, N) =			\
+    vrecpe##Q##_##T2##W(VECT_VAR(vector, T1, W, N));	\
+  vst1##Q##_##T2##W(VECT_VAR(result, T1, W, N),		\
+		    VECT_VAR(vector_res, T1, W, N))
+
+  /* No need for 64 bits variants.  */
+  DECL_VARIABLE(vector, uint, 32, 2);
+  DECL_VARIABLE(vector, uint, 32, 4);
+  DECL_VARIABLE(vector, float, 32, 2);
+  DECL_VARIABLE(vector, float, 32, 4);
+
+  DECL_VARIABLE(vector_res, uint, 32, 2);
+  DECL_VARIABLE(vector_res, uint, 32, 4);
+  DECL_VARIABLE(vector_res, float, 32, 2);
+  DECL_VARIABLE(vector_res, float, 32, 4);
+
+  clean_results ();
+
+  /* Choose init value arbitrarily, positive.  */
+  VDUP(vector, , uint, u, 32, 2, 0x12345678);
+  VDUP(vector, , float, f, 32, 2, 1.9f);
+  VDUP(vector, q, uint, u, 32, 4, 0xABCDEF10);
+  VDUP(vector, q, float, f, 32, 4, 125.0f);
+
+  /* Apply the operator.  */
+  TEST_VRECPE(, uint, u, 32, 2);
+  TEST_VRECPE(, float, f, 32, 2);
+  TEST_VRECPE(q, uint, u, 32, 4);
+  TEST_VRECPE(q, float, f, 32, 4);
+
+#define CMT " (positive input)"
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_positive, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_positive, CMT);
+  CHECK_FP(TEST_MSG, float, 32, 2, PRIx32, expected_positive, CMT);
+  CHECK_FP(TEST_MSG, float, 32, 4, PRIx32, expected_positive, CMT);
+
+  /* Choose init value arbitrarily,negative.  */
+  VDUP(vector, , uint, u, 32, 2, 0xFFFFFFFF);
+  VDUP(vector, , float, f, 32, 2, -10.0f);
+  VDUP(vector, q, uint, u, 32, 4, 0x89081234);
+  VDUP(vector, q, float, f, 32, 4, -125.0f);
+
+  /* Apply the operator.  */
+  TEST_VRECPE(, uint, u, 32, 2);
+  TEST_VRECPE(, float, f, 32, 2);
+  TEST_VRECPE(q, uint, u, 32, 4);
+  TEST_VRECPE(q, float, f, 32, 4);
+
+#undef CMT
+#define CMT " (negative input)"
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_negative, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_negative, CMT);
+  CHECK_FP(TEST_MSG, float, 32, 2, PRIx32, expected_negative, CMT);
+  CHECK_FP(TEST_MSG, float, 32, 4, PRIx32, expected_negative, CMT);
+
+  /* Test FP variants with special input values (NaN, infinity).  */
+  VDUP(vector, , float, f, 32, 2, NAN);
+  VDUP(vector, q, float, f, 32, 4, HUGE_VALF);
+
+  /* Apply the operator.  */
+  TEST_VRECPE(, float, f, 32, 2);
+  TEST_VRECPE(q, float, f, 32, 4);
+
+#undef CMT
+#define CMT " FP special (NaN, infinity)"
+  CHECK_FP(TEST_MSG, float, 32, 2, PRIx32, expected_fp1, CMT);
+  CHECK_FP(TEST_MSG, float, 32, 4, PRIx32, expected_fp1, CMT);
+
+  /* Test FP variants with special input values (zero, large value).  */
+  VDUP(vector, , float, f, 32, 2, 0.0f);
+  VDUP(vector, q, float, f, 32, 4, 8.97229e37f /*9.0e37f*/);
+
+  /* Apply the operator.  */
+  TEST_VRECPE(, float, f, 32, 2);
+  TEST_VRECPE(q, float, f, 32, 4);
+
+#undef CMT
+#define CMT " FP special (zero, large value)"
+  CHECK_FP(TEST_MSG, float, 32, 2, PRIx32, expected_fp2, CMT);
+  CHECK_FP(TEST_MSG, float, 32, 4, PRIx32, expected_fp2, CMT);
+
+  /* Test FP variants with special input values (-0, -infinity).  */
+  VDUP(vector, , float, f, 32, 2, -0.0f);
+  VDUP(vector, q, float, f, 32, 4, -HUGE_VALF);
+
+  /* Apply the operator.  */
+  TEST_VRECPE(, float, f, 32, 2);
+  TEST_VRECPE(q, float, f, 32, 4);
+
+#undef CMT
+#define CMT " FP special (-0, -infinity)"
+  CHECK_FP(TEST_MSG, float, 32, 2, PRIx32, expected_fp3, CMT);
+  CHECK_FP(TEST_MSG, float, 32, 4, PRIx32, expected_fp3, CMT);
+
+  /* Test FP variants with special input values (large negative value).  */
+  VDUP(vector, , float, f, 32, 2, -9.0e37f);
+
+  /* Apply the operator.  */
+  TEST_VRECPE(, float, f, 32, 2);
+
+#undef CMT
+#define CMT " FP special (large negative value)"
+  CHECK_FP(TEST_MSG, float, 32, 2, PRIx32, expected_fp4, CMT);
+}
+
+int main (void)
+{
+  exec_vrecpe ();
+  return 0;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vrecps.c
@@ -0,0 +1,117 @@
+#include <arm_neon.h>
+#include "arm-neon-ref.h"
+#include "compute-ref-data.h"
+#include <math.h>
+
+/* Expected results with positive input.  */
+VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0xc2e19eb7, 0xc2e19eb7 };
+VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0xc1db851f, 0xc1db851f,
+					   0xc1db851f, 0xc1db851f };
+
+/* Expected results with FP special values (NaN).  */
+VECT_VAR_DECL(expected_fp1,hfloat,32,2) [] = { 0x7fc00000, 0x7fc00000 };
+VECT_VAR_DECL(expected_fp1,hfloat,32,4) [] = { 0x7fc00000, 0x7fc00000,
+					       0x7fc00000, 0x7fc00000 };
+
+/* Expected results with FP special values (infinity, 0) and normal
+   values.  */
+VECT_VAR_DECL(expected_fp2,hfloat,32,2) [] = { 0xff800000, 0xff800000 };
+VECT_VAR_DECL(expected_fp2,hfloat,32,4) [] = { 0x40000000, 0x40000000,
+					       0x40000000, 0x40000000 };
+
+/* Expected results with FP special values (infinity, 0).  */
+VECT_VAR_DECL(expected_fp3,hfloat,32,2) [] = { 0x40000000, 0x40000000 };
+VECT_VAR_DECL(expected_fp3,hfloat,32,4) [] = { 0x40000000, 0x40000000,
+					       0x40000000, 0x40000000 };
+
+#define TEST_MSG "VRECPS/VRECPSQ"
+void exec_vrecps(void)
+{
+  int i;
+
+  /* Basic test: y=vrecps(x), then store the result.  */
+#define TEST_VRECPS(Q, T1, T2, W, N)			\
+  VECT_VAR(vector_res, T1, W, N) =			\
+    vrecps##Q##_##T2##W(VECT_VAR(vector, T1, W, N),	\
+			VECT_VAR(vector2, T1, W, N));	\
+  vst1##Q##_##T2##W(VECT_VAR(result, T1, W, N),		\
+		    VECT_VAR(vector_res, T1, W, N))
+
+  /* No need for integer variants.  */
+  DECL_VARIABLE(vector, float, 32, 2);
+  DECL_VARIABLE(vector, float, 32, 4);
+
+  DECL_VARIABLE(vector2, float, 32, 2);
+  DECL_VARIABLE(vector2, float, 32, 4);
+
+  DECL_VARIABLE(vector_res, float, 32, 2);
+  DECL_VARIABLE(vector_res, float, 32, 4);
+
+  clean_results ();
+
+  /* Choose init value arbitrarily.  */
+  VDUP(vector, , float, f, 32, 2, 12.9f);
+  VDUP(vector, q, float, f, 32, 4, 9.2f);
+
+  VDUP(vector2, , float, f, 32, 2, 8.9f);
+  VDUP(vector2, q, float, f, 32, 4, 3.2f);
+
+  /* Apply the operator.  */
+  TEST_VRECPS(, float, f, 32, 2);
+  TEST_VRECPS(q, float, f, 32, 4);
+
+#define CMT " (positive input)"
+  CHECK_FP(TEST_MSG, float, 32, 2, PRIx32, expected, CMT);
+  CHECK_FP(TEST_MSG, float, 32, 4, PRIx32, expected, CMT);
+
+
+  /* Test FP variants with special input values (NaN).  */
+  VDUP(vector, , float, f, 32, 2, NAN);
+  VDUP(vector2, q, float, f, 32, 4, NAN);
+
+  /* Apply the operator.  */
+  TEST_VRECPS(, float, f, 32, 2);
+  TEST_VRECPS(q, float, f, 32, 4);
+
+#undef CMT
+#define CMT " FP special (NaN)"
+  CHECK_FP(TEST_MSG, float, 32, 2, PRIx32, expected_fp1, CMT);
+  CHECK_FP(TEST_MSG, float, 32, 4, PRIx32, expected_fp1, CMT);
+
+
+  /* Test FP variants with special input values (infinity, 0).  */
+  VDUP(vector, , float, f, 32, 2, HUGE_VALF);
+  VDUP(vector, q, float, f, 32, 4, 0.0f);
+  VDUP(vector2, q, float, f, 32, 4, 3.2f); /* Restore a normal value.  */
+
+  /* Apply the operator.  */
+  TEST_VRECPS(, float, f, 32, 2);
+  TEST_VRECPS(q, float, f, 32, 4);
+
+#undef CMT
+#define CMT " FP special (infinity, 0) and normal value"
+  CHECK_FP(TEST_MSG, float, 32, 2, PRIx32, expected_fp2, CMT);
+  CHECK_FP(TEST_MSG, float, 32, 4, PRIx32, expected_fp2, CMT);
+
+
+  /* Test FP variants with only special input values (infinity, 0).  */
+  VDUP(vector, , float, f, 32, 2, HUGE_VALF);
+  VDUP(vector, q, float, f, 32, 4, 0.0f);
+  VDUP(vector2, , float, f, 32, 2, 0.0f);
+  VDUP(vector2, q, float, f, 32, 4, HUGE_VALF);
+
+  /* Apply the operator */
+  TEST_VRECPS(, float, f, 32, 2);
+  TEST_VRECPS(q, float, f, 32, 4);
+
+#undef CMT
+#define CMT " FP special (infinity, 0)"
+  CHECK_FP(TEST_MSG, float, 32, 2, PRIx32, expected_fp3, CMT);
+  CHECK_FP(TEST_MSG, float, 32, 4, PRIx32, expected_fp3, CMT);
+}
+
+int main (void)
+{
+  exec_vrecps ();
+  return 0;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vreinterpret.c
@@ -0,0 +1,741 @@
+#include <arm_neon.h>
+#include "arm-neon-ref.h"
+#include "compute-ref-data.h"
+
+/* Expected results for vreinterpret_s8_xx.  */
+VECT_VAR_DECL(expected_s8_1,int,8,8) [] = { 0xf0, 0xff, 0xf1, 0xff,
+					    0xf2, 0xff, 0xf3, 0xff };
+VECT_VAR_DECL(expected_s8_2,int,8,8) [] = { 0xf0, 0xff, 0xff, 0xff,
+					    0xf1, 0xff, 0xff, 0xff };
+VECT_VAR_DECL(expected_s8_3,int,8,8) [] = { 0xf0, 0xff, 0xff, 0xff,
+					    0xff, 0xff, 0xff, 0xff };
+VECT_VAR_DECL(expected_s8_4,int,8,8) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
+					    0xf4, 0xf5, 0xf6, 0xf7 };
+VECT_VAR_DECL(expected_s8_5,int,8,8) [] = { 0xf0, 0xff, 0xf1, 0xff,
+					    0xf2, 0xff, 0xf3, 0xff };
+VECT_VAR_DECL(expected_s8_6,int,8,8) [] = { 0xf0, 0xff, 0xff, 0xff,
+					    0xf1, 0xff, 0xff, 0xff };
+VECT_VAR_DECL(expected_s8_7,int,8,8) [] = { 0xf0, 0xff, 0xff, 0xff,
+					    0xff, 0xff, 0xff, 0xff };
+VECT_VAR_DECL(expected_s8_8,int,8,8) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
+					    0xf4, 0xf5, 0xf6, 0xf7 };
+VECT_VAR_DECL(expected_s8_9,int,8,8) [] = { 0xf0, 0xff, 0xf1, 0xff,
+					    0xf2, 0xff, 0xf3, 0xff };
+
+/* Expected results for vreinterpret_s16_xx.  */
+VECT_VAR_DECL(expected_s16_1,int,16,4) [] = { 0xf1f0, 0xf3f2, 0xf5f4, 0xf7f6 };
+VECT_VAR_DECL(expected_s16_2,int,16,4) [] = { 0xfff0, 0xffff, 0xfff1, 0xffff };
+VECT_VAR_DECL(expected_s16_3,int,16,4) [] = { 0xfff0, 0xffff, 0xffff, 0xffff };
+VECT_VAR_DECL(expected_s16_4,int,16,4) [] = { 0xf1f0, 0xf3f2, 0xf5f4, 0xf7f6 };
+VECT_VAR_DECL(expected_s16_5,int,16,4) [] = { 0xfff0, 0xfff1, 0xfff2, 0xfff3 };
+VECT_VAR_DECL(expected_s16_6,int,16,4) [] = { 0xfff0, 0xffff, 0xfff1, 0xffff };
+VECT_VAR_DECL(expected_s16_7,int,16,4) [] = { 0xfff0, 0xffff, 0xffff, 0xffff };
+VECT_VAR_DECL(expected_s16_8,int,16,4) [] = { 0xf1f0, 0xf3f2, 0xf5f4, 0xf7f6 };
+VECT_VAR_DECL(expected_s16_9,int,16,4) [] = { 0xfff0, 0xfff1, 0xfff2, 0xfff3 };
+
+/* Expected results for vreinterpret_s32_xx.  */
+VECT_VAR_DECL(expected_s32_1,int,32,2) [] = { 0xf3f2f1f0, 0xf7f6f5f4 };
+VECT_VAR_DECL(expected_s32_2,int,32,2) [] = { 0xfff1fff0, 0xfff3fff2 };
+VECT_VAR_DECL(expected_s32_3,int,32,2) [] = { 0xfffffff0, 0xffffffff };
+VECT_VAR_DECL(expected_s32_4,int,32,2) [] = { 0xf3f2f1f0, 0xf7f6f5f4 };
+VECT_VAR_DECL(expected_s32_5,int,32,2) [] = { 0xfff1fff0, 0xfff3fff2 };
+VECT_VAR_DECL(expected_s32_6,int,32,2) [] = { 0xfffffff0, 0xfffffff1 };
+VECT_VAR_DECL(expected_s32_7,int,32,2) [] = { 0xfffffff0, 0xffffffff };
+VECT_VAR_DECL(expected_s32_8,int,32,2) [] = { 0xf3f2f1f0, 0xf7f6f5f4 };
+VECT_VAR_DECL(expected_s32_9,int,32,2) [] = { 0xfff1fff0, 0xfff3fff2 };
+
+/* Expected results for vreinterpret_s64_xx.  */
+VECT_VAR_DECL(expected_s64_1,int,64,1) [] = { 0xf7f6f5f4f3f2f1f0 };
+VECT_VAR_DECL(expected_s64_2,int,64,1) [] = { 0xfff3fff2fff1fff0 };
+VECT_VAR_DECL(expected_s64_3,int,64,1) [] = { 0xfffffff1fffffff0 };
+VECT_VAR_DECL(expected_s64_4,int,64,1) [] = { 0xf7f6f5f4f3f2f1f0 };
+VECT_VAR_DECL(expected_s64_5,int,64,1) [] = { 0xfff3fff2fff1fff0 };
+VECT_VAR_DECL(expected_s64_6,int,64,1) [] = { 0xfffffff1fffffff0 };
+VECT_VAR_DECL(expected_s64_7,int,64,1) [] = { 0xfffffffffffffff0 };
+VECT_VAR_DECL(expected_s64_8,int,64,1) [] = { 0xf7f6f5f4f3f2f1f0 };
+VECT_VAR_DECL(expected_s64_9,int,64,1) [] = { 0xfff3fff2fff1fff0 };
+
+/* Expected results for vreinterpret_u8_xx.  */
+VECT_VAR_DECL(expected_u8_1,uint,8,8) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
+					     0xf4, 0xf5, 0xf6, 0xf7 };
+VECT_VAR_DECL(expected_u8_2,uint,8,8) [] = { 0xf0, 0xff, 0xf1, 0xff,
+					     0xf2, 0xff, 0xf3, 0xff };
+VECT_VAR_DECL(expected_u8_3,uint,8,8) [] = { 0xf0, 0xff, 0xff, 0xff,
+					     0xf1, 0xff, 0xff, 0xff };
+VECT_VAR_DECL(expected_u8_4,uint,8,8) [] = { 0xf0, 0xff, 0xff, 0xff,
+					     0xff, 0xff, 0xff, 0xff };
+VECT_VAR_DECL(expected_u8_5,uint,8,8) [] = { 0xf0, 0xff, 0xf1, 0xff,
+					     0xf2, 0xff, 0xf3, 0xff };
+VECT_VAR_DECL(expected_u8_6,uint,8,8) [] = { 0xf0, 0xff, 0xff, 0xff,
+					     0xf1, 0xff, 0xff, 0xff };
+VECT_VAR_DECL(expected_u8_7,uint,8,8) [] = { 0xf0, 0xff, 0xff, 0xff,
+					     0xff, 0xff, 0xff, 0xff };
+VECT_VAR_DECL(expected_u8_8,uint,8,8) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
+					     0xf4, 0xf5, 0xf6, 0xf7 };
+VECT_VAR_DECL(expected_u8_9,uint,8,8) [] = { 0xf0, 0xff, 0xf1, 0xff,
+					     0xf2, 0xff, 0xf3, 0xff };
+
+/* Expected results for vreinterpret_u16_xx.  */
+VECT_VAR_DECL(expected_u16_1,uint,16,4) [] = { 0xf1f0, 0xf3f2, 0xf5f4, 0xf7f6 };
+VECT_VAR_DECL(expected_u16_2,uint,16,4) [] = { 0xfff0, 0xfff1, 0xfff2, 0xfff3 };
+VECT_VAR_DECL(expected_u16_3,uint,16,4) [] = { 0xfff0, 0xffff, 0xfff1, 0xffff };
+VECT_VAR_DECL(expected_u16_4,uint,16,4) [] = { 0xfff0, 0xffff, 0xffff, 0xffff };
+VECT_VAR_DECL(expected_u16_5,uint,16,4) [] = { 0xf1f0, 0xf3f2, 0xf5f4, 0xf7f6 };
+VECT_VAR_DECL(expected_u16_6,uint,16,4) [] = { 0xfff0, 0xffff, 0xfff1, 0xffff };
+VECT_VAR_DECL(expected_u16_7,uint,16,4) [] = { 0xfff0, 0xffff, 0xffff, 0xffff };
+VECT_VAR_DECL(expected_u16_8,uint,16,4) [] = { 0xf1f0, 0xf3f2, 0xf5f4, 0xf7f6 };
+VECT_VAR_DECL(expected_u16_9,uint,16,4) [] = { 0xfff0, 0xfff1, 0xfff2, 0xfff3 };
+
+/* Expected results for vreinterpret_u32_xx.  */
+VECT_VAR_DECL(expected_u32_1,uint,32,2) [] = { 0xf3f2f1f0, 0xf7f6f5f4 };
+VECT_VAR_DECL(expected_u32_2,uint,32,2) [] = { 0xfff1fff0, 0xfff3fff2 };
+VECT_VAR_DECL(expected_u32_3,uint,32,2) [] = { 0xfffffff0, 0xfffffff1 };
+VECT_VAR_DECL(expected_u32_4,uint,32,2) [] = { 0xfffffff0, 0xffffffff };
+VECT_VAR_DECL(expected_u32_5,uint,32,2) [] = { 0xf3f2f1f0, 0xf7f6f5f4 };
+VECT_VAR_DECL(expected_u32_6,uint,32,2) [] = { 0xfff1fff0, 0xfff3fff2 };
+VECT_VAR_DECL(expected_u32_7,uint,32,2) [] = { 0xfffffff0, 0xffffffff };
+VECT_VAR_DECL(expected_u32_8,uint,32,2) [] = { 0xf3f2f1f0, 0xf7f6f5f4 };
+VECT_VAR_DECL(expected_u32_9,uint,32,2) [] = { 0xfff1fff0, 0xfff3fff2 };
+
+/* Expected results for vreinterpret_u64_xx.  */
+VECT_VAR_DECL(expected_u64_1,uint,64,1) [] = { 0xf7f6f5f4f3f2f1f0 };
+VECT_VAR_DECL(expected_u64_2,uint,64,1) [] = { 0xfff3fff2fff1fff0 };
+VECT_VAR_DECL(expected_u64_3,uint,64,1) [] = { 0xfffffff1fffffff0 };
+VECT_VAR_DECL(expected_u64_4,uint,64,1) [] = { 0xfffffffffffffff0 };
+VECT_VAR_DECL(expected_u64_5,uint,64,1) [] = { 0xf7f6f5f4f3f2f1f0 };
+VECT_VAR_DECL(expected_u64_6,uint,64,1) [] = { 0xfff3fff2fff1fff0 };
+VECT_VAR_DECL(expected_u64_7,uint,64,1) [] = { 0xfffffff1fffffff0 };
+VECT_VAR_DECL(expected_u64_8,uint,64,1) [] = { 0xf7f6f5f4f3f2f1f0 };
+VECT_VAR_DECL(expected_u64_9,uint,64,1) [] = { 0xfff3fff2fff1fff0 };
+
+/* Expected results for vreinterpret_p8_xx.  */
+VECT_VAR_DECL(expected_p8_1,poly,8,8) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
+					     0xf4, 0xf5, 0xf6, 0xf7 };
+VECT_VAR_DECL(expected_p8_2,poly,8,8) [] = { 0xf0, 0xff, 0xf1, 0xff,
+					     0xf2, 0xff, 0xf3, 0xff };
+VECT_VAR_DECL(expected_p8_3,poly,8,8) [] = { 0xf0, 0xff, 0xff, 0xff,
+					     0xf1, 0xff, 0xff, 0xff };
+VECT_VAR_DECL(expected_p8_4,poly,8,8) [] = { 0xf0, 0xff, 0xff, 0xff,
+					     0xff, 0xff, 0xff, 0xff };
+VECT_VAR_DECL(expected_p8_5,poly,8,8) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
+					     0xf4, 0xf5, 0xf6, 0xf7 };
+VECT_VAR_DECL(expected_p8_6,poly,8,8) [] = { 0xf0, 0xff, 0xf1, 0xff,
+					     0xf2, 0xff, 0xf3, 0xff };
+VECT_VAR_DECL(expected_p8_7,poly,8,8) [] = { 0xf0, 0xff, 0xff, 0xff,
+					     0xf1, 0xff, 0xff, 0xff };
+VECT_VAR_DECL(expected_p8_8,poly,8,8) [] = { 0xf0, 0xff, 0xff, 0xff,
+					     0xff, 0xff, 0xff, 0xff };
+VECT_VAR_DECL(expected_p8_9,poly,8,8) [] = { 0xf0, 0xff, 0xf1, 0xff,
+					     0xf2, 0xff, 0xf3, 0xff };
+
+/* Expected results for vreinterpret_p16_xx.  */
+VECT_VAR_DECL(expected_p16_1,poly,16,4) [] = { 0xf1f0, 0xf3f2, 0xf5f4, 0xf7f6 };
+VECT_VAR_DECL(expected_p16_2,poly,16,4) [] = { 0xfff0, 0xfff1, 0xfff2, 0xfff3 };
+VECT_VAR_DECL(expected_p16_3,poly,16,4) [] = { 0xfff0, 0xffff, 0xfff1, 0xffff };
+VECT_VAR_DECL(expected_p16_4,poly,16,4) [] = { 0xfff0, 0xffff, 0xffff, 0xffff };
+VECT_VAR_DECL(expected_p16_5,poly,16,4) [] = { 0xf1f0, 0xf3f2, 0xf5f4, 0xf7f6 };
+VECT_VAR_DECL(expected_p16_6,poly,16,4) [] = { 0xfff0, 0xfff1, 0xfff2, 0xfff3 };
+VECT_VAR_DECL(expected_p16_7,poly,16,4) [] = { 0xfff0, 0xffff, 0xfff1, 0xffff };
+VECT_VAR_DECL(expected_p16_8,poly,16,4) [] = { 0xfff0, 0xffff, 0xffff, 0xffff };
+VECT_VAR_DECL(expected_p16_9,poly,16,4) [] = { 0xf1f0, 0xf3f2, 0xf5f4, 0xf7f6 };
+
+/* Expected results for vreinterpretq_s8_xx.  */
+VECT_VAR_DECL(expected_q_s8_1,int,8,16) [] = { 0xf0, 0xff, 0xf1, 0xff,
+					       0xf2, 0xff, 0xf3, 0xff,
+					       0xf4, 0xff, 0xf5, 0xff,
+					       0xf6, 0xff, 0xf7, 0xff };
+VECT_VAR_DECL(expected_q_s8_2,int,8,16) [] = { 0xf0, 0xff, 0xff, 0xff,
+					       0xf1, 0xff, 0xff, 0xff,
+					       0xf2, 0xff, 0xff, 0xff,
+					       0xf3, 0xff, 0xff, 0xff };
+VECT_VAR_DECL(expected_q_s8_3,int,8,16) [] = { 0xf0, 0xff, 0xff, 0xff,
+					       0xff, 0xff, 0xff, 0xff,
+					       0xf1, 0xff, 0xff, 0xff,
+					       0xff, 0xff, 0xff, 0xff };
+VECT_VAR_DECL(expected_q_s8_4,int,8,16) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
+					       0xf4, 0xf5, 0xf6, 0xf7,
+					       0xf8, 0xf9, 0xfa, 0xfb,
+					       0xfc, 0xfd, 0xfe, 0xff };
+VECT_VAR_DECL(expected_q_s8_5,int,8,16) [] = { 0xf0, 0xff, 0xf1, 0xff,
+					       0xf2, 0xff, 0xf3, 0xff,
+					       0xf4, 0xff, 0xf5, 0xff,
+					       0xf6, 0xff, 0xf7, 0xff };
+VECT_VAR_DECL(expected_q_s8_6,int,8,16) [] = { 0xf0, 0xff, 0xff, 0xff,
+					       0xf1, 0xff, 0xff, 0xff,
+					       0xf2, 0xff, 0xff, 0xff,
+					       0xf3, 0xff, 0xff, 0xff };
+VECT_VAR_DECL(expected_q_s8_7,int,8,16) [] = { 0xf0, 0xff, 0xff, 0xff,
+					       0xff, 0xff, 0xff, 0xff,
+					       0xf1, 0xff, 0xff, 0xff,
+					       0xff, 0xff, 0xff, 0xff };
+VECT_VAR_DECL(expected_q_s8_8,int,8,16) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
+					       0xf4, 0xf5, 0xf6, 0xf7,
+					       0xf8, 0xf9, 0xfa, 0xfb,
+					       0xfc, 0xfd, 0xfe, 0xff };
+VECT_VAR_DECL(expected_q_s8_9,int,8,16) [] = { 0xf0, 0xff, 0xf1, 0xff,
+					       0xf2, 0xff, 0xf3, 0xff,
+					       0xf4, 0xff, 0xf5, 0xff,
+					       0xf6, 0xff, 0xf7, 0xff };
+
+/* Expected results for vreinterpretq_s16_xx.  */
+VECT_VAR_DECL(expected_q_s16_1,int,16,8) [] = { 0xf1f0, 0xf3f2,
+						0xf5f4, 0xf7f6,
+						0xf9f8, 0xfbfa,
+						0xfdfc, 0xfffe };
+VECT_VAR_DECL(expected_q_s16_2,int,16,8) [] = { 0xfff0, 0xffff,
+						0xfff1, 0xffff,
+						0xfff2, 0xffff,
+						0xfff3, 0xffff };
+VECT_VAR_DECL(expected_q_s16_3,int,16,8) [] = { 0xfff0, 0xffff,
+						0xffff, 0xffff,
+						0xfff1, 0xffff,
+						0xffff, 0xffff };
+VECT_VAR_DECL(expected_q_s16_4,int,16,8) [] = { 0xf1f0, 0xf3f2,
+						0xf5f4, 0xf7f6,
+						0xf9f8, 0xfbfa,
+						0xfdfc, 0xfffe };
+VECT_VAR_DECL(expected_q_s16_5,int,16,8) [] = { 0xfff0, 0xfff1,
+						0xfff2, 0xfff3,
+						0xfff4, 0xfff5,
+						0xfff6, 0xfff7 };
+VECT_VAR_DECL(expected_q_s16_6,int,16,8) [] = { 0xfff0, 0xffff,
+						0xfff1, 0xffff,
+						0xfff2, 0xffff,
+						0xfff3, 0xffff };
+VECT_VAR_DECL(expected_q_s16_7,int,16,8) [] = { 0xfff0, 0xffff,
+						0xffff, 0xffff,
+						0xfff1, 0xffff,
+						0xffff, 0xffff };
+VECT_VAR_DECL(expected_q_s16_8,int,16,8) [] = { 0xf1f0, 0xf3f2,
+						0xf5f4, 0xf7f6,
+						0xf9f8, 0xfbfa,
+						0xfdfc, 0xfffe };
+VECT_VAR_DECL(expected_q_s16_9,int,16,8) [] = { 0xfff0, 0xfff1,
+						0xfff2, 0xfff3,
+						0xfff4, 0xfff5,
+						0xfff6, 0xfff7 };
+
+/* Expected results for vreinterpretq_s32_xx.  */
+VECT_VAR_DECL(expected_q_s32_1,int,32,4) [] = { 0xf3f2f1f0, 0xf7f6f5f4,
+						0xfbfaf9f8, 0xfffefdfc };
+VECT_VAR_DECL(expected_q_s32_2,int,32,4) [] = { 0xfff1fff0, 0xfff3fff2,
+						0xfff5fff4, 0xfff7fff6 };
+VECT_VAR_DECL(expected_q_s32_3,int,32,4) [] = { 0xfffffff0, 0xffffffff,
+						0xfffffff1, 0xffffffff };
+VECT_VAR_DECL(expected_q_s32_4,int,32,4) [] = { 0xf3f2f1f0, 0xf7f6f5f4,
+						0xfbfaf9f8, 0xfffefdfc };
+VECT_VAR_DECL(expected_q_s32_5,int,32,4) [] = { 0xfff1fff0, 0xfff3fff2,
+						0xfff5fff4, 0xfff7fff6 };
+VECT_VAR_DECL(expected_q_s32_6,int,32,4) [] = { 0xfffffff0, 0xfffffff1,
+						0xfffffff2, 0xfffffff3 };
+VECT_VAR_DECL(expected_q_s32_7,int,32,4) [] = { 0xfffffff0, 0xffffffff,
+						0xfffffff1, 0xffffffff };
+VECT_VAR_DECL(expected_q_s32_8,int,32,4) [] = { 0xf3f2f1f0, 0xf7f6f5f4,
+						0xfbfaf9f8, 0xfffefdfc };
+VECT_VAR_DECL(expected_q_s32_9,int,32,4) [] = { 0xfff1fff0, 0xfff3fff2,
+						0xfff5fff4, 0xfff7fff6 };
+
+/* Expected results for vreinterpretq_s64_xx.  */
+VECT_VAR_DECL(expected_q_s64_1,int,64,2) [] = { 0xf7f6f5f4f3f2f1f0,
+						0xfffefdfcfbfaf9f8 };
+VECT_VAR_DECL(expected_q_s64_2,int,64,2) [] = { 0xfff3fff2fff1fff0,
+						0xfff7fff6fff5fff4 };
+VECT_VAR_DECL(expected_q_s64_3,int,64,2) [] = { 0xfffffff1fffffff0,
+						0xfffffff3fffffff2 };
+VECT_VAR_DECL(expected_q_s64_4,int,64,2) [] = { 0xf7f6f5f4f3f2f1f0,
+						0xfffefdfcfbfaf9f8 };
+VECT_VAR_DECL(expected_q_s64_5,int,64,2) [] = { 0xfff3fff2fff1fff0,
+						0xfff7fff6fff5fff4 };
+VECT_VAR_DECL(expected_q_s64_6,int,64,2) [] = { 0xfffffff1fffffff0,
+						0xfffffff3fffffff2 };
+VECT_VAR_DECL(expected_q_s64_7,int,64,2) [] = { 0xfffffffffffffff0,
+						0xfffffffffffffff1 };
+VECT_VAR_DECL(expected_q_s64_8,int,64,2) [] = { 0xf7f6f5f4f3f2f1f0,
+						0xfffefdfcfbfaf9f8 };
+VECT_VAR_DECL(expected_q_s64_9,int,64,2) [] = { 0xfff3fff2fff1fff0,
+						0xfff7fff6fff5fff4 };
+
+/* Expected results for vreinterpretq_u8_xx.  */
+VECT_VAR_DECL(expected_q_u8_1,uint,8,16) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
+						0xf4, 0xf5, 0xf6, 0xf7,
+						0xf8, 0xf9, 0xfa, 0xfb,
+						0xfc, 0xfd, 0xfe, 0xff };
+VECT_VAR_DECL(expected_q_u8_2,uint,8,16) [] = { 0xf0, 0xff, 0xf1, 0xff,
+						0xf2, 0xff, 0xf3, 0xff,
+						0xf4, 0xff, 0xf5, 0xff,
+						0xf6, 0xff, 0xf7, 0xff };
+VECT_VAR_DECL(expected_q_u8_3,uint,8,16) [] = { 0xf0, 0xff, 0xff, 0xff,
+						0xf1, 0xff, 0xff, 0xff,
+						0xf2, 0xff, 0xff, 0xff,
+						0xf3, 0xff, 0xff, 0xff };
+VECT_VAR_DECL(expected_q_u8_4,uint,8,16) [] = { 0xf0, 0xff, 0xff, 0xff,
+						0xff, 0xff, 0xff, 0xff,
+						0xf1, 0xff, 0xff, 0xff,
+						0xff, 0xff, 0xff, 0xff };
+VECT_VAR_DECL(expected_q_u8_5,uint,8,16) [] = { 0xf0, 0xff, 0xf1, 0xff,
+						0xf2, 0xff, 0xf3, 0xff,
+						0xf4, 0xff, 0xf5, 0xff,
+						0xf6, 0xff, 0xf7, 0xff };
+VECT_VAR_DECL(expected_q_u8_6,uint,8,16) [] = { 0xf0, 0xff, 0xff, 0xff,
+						0xf1, 0xff, 0xff, 0xff,
+						0xf2, 0xff, 0xff, 0xff,
+						0xf3, 0xff, 0xff, 0xff };
+VECT_VAR_DECL(expected_q_u8_7,uint,8,16) [] = { 0xf0, 0xff, 0xff, 0xff,
+						0xff, 0xff, 0xff, 0xff,
+						0xf1, 0xff, 0xff, 0xff,
+						0xff, 0xff, 0xff, 0xff };
+VECT_VAR_DECL(expected_q_u8_8,uint,8,16) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
+						0xf4, 0xf5, 0xf6, 0xf7,
+						0xf8, 0xf9, 0xfa, 0xfb,
+						0xfc, 0xfd, 0xfe, 0xff };
+VECT_VAR_DECL(expected_q_u8_9,uint,8,16) [] = { 0xf0, 0xff, 0xf1, 0xff,
+						0xf2, 0xff, 0xf3, 0xff,
+						0xf4, 0xff, 0xf5, 0xff,
+						0xf6, 0xff, 0xf7, 0xff };
+
+/* Expected results for vreinterpretq_u16_xx.  */
+VECT_VAR_DECL(expected_q_u16_1,uint,16,8) [] = { 0xf1f0, 0xf3f2,
+						 0xf5f4, 0xf7f6,
+						 0xf9f8, 0xfbfa,
+						 0xfdfc, 0xfffe };
+VECT_VAR_DECL(expected_q_u16_2,uint,16,8) [] = { 0xfff0, 0xfff1,
+						 0xfff2, 0xfff3,
+						 0xfff4, 0xfff5,
+						 0xfff6, 0xfff7 };
+VECT_VAR_DECL(expected_q_u16_3,uint,16,8) [] = { 0xfff0, 0xffff,
+						 0xfff1, 0xffff,
+						 0xfff2, 0xffff,
+						 0xfff3, 0xffff };
+VECT_VAR_DECL(expected_q_u16_4,uint,16,8) [] = { 0xfff0, 0xffff,
+						 0xffff, 0xffff,
+						 0xfff1, 0xffff,
+						 0xffff, 0xffff };
+VECT_VAR_DECL(expected_q_u16_5,uint,16,8) [] = { 0xf1f0, 0xf3f2,
+						 0xf5f4, 0xf7f6,
+						 0xf9f8, 0xfbfa,
+						 0xfdfc, 0xfffe };
+VECT_VAR_DECL(expected_q_u16_6,uint,16,8) [] = { 0xfff0, 0xffff,
+						 0xfff1, 0xffff,
+						 0xfff2, 0xffff,
+						 0xfff3, 0xffff };
+VECT_VAR_DECL(expected_q_u16_7,uint,16,8) [] = { 0xfff0, 0xffff,
+						 0xffff, 0xffff,
+						 0xfff1, 0xffff,
+						 0xffff, 0xffff };
+VECT_VAR_DECL(expected_q_u16_8,uint,16,8) [] = { 0xf1f0, 0xf3f2,
+						 0xf5f4, 0xf7f6,
+						 0xf9f8, 0xfbfa,
+						 0xfdfc, 0xfffe };
+VECT_VAR_DECL(expected_q_u16_9,uint,16,8) [] = { 0xfff0, 0xfff1,
+						 0xfff2, 0xfff3,
+						 0xfff4, 0xfff5,
+						 0xfff6, 0xfff7 };
+
+/* Expected results for vreinterpretq_u32_xx.  */
+VECT_VAR_DECL(expected_q_u32_1,uint,32,4) [] = { 0xf3f2f1f0, 0xf7f6f5f4,
+						 0xfbfaf9f8, 0xfffefdfc };
+VECT_VAR_DECL(expected_q_u32_2,uint,32,4) [] = { 0xfff1fff0, 0xfff3fff2,
+						 0xfff5fff4, 0xfff7fff6 };
+VECT_VAR_DECL(expected_q_u32_3,uint,32,4) [] = { 0xfffffff0, 0xfffffff1,
+						 0xfffffff2, 0xfffffff3 };
+VECT_VAR_DECL(expected_q_u32_4,uint,32,4) [] = { 0xfffffff0, 0xffffffff,
+						 0xfffffff1, 0xffffffff };
+VECT_VAR_DECL(expected_q_u32_5,uint,32,4) [] = { 0xf3f2f1f0, 0xf7f6f5f4,
+						 0xfbfaf9f8, 0xfffefdfc };
+VECT_VAR_DECL(expected_q_u32_6,uint,32,4) [] = { 0xfff1fff0, 0xfff3fff2,
+						 0xfff5fff4, 0xfff7fff6 };
+VECT_VAR_DECL(expected_q_u32_7,uint,32,4) [] = { 0xfffffff0, 0xffffffff,
+						 0xfffffff1, 0xffffffff };
+VECT_VAR_DECL(expected_q_u32_8,uint,32,4) [] = { 0xf3f2f1f0, 0xf7f6f5f4,
+						 0xfbfaf9f8, 0xfffefdfc };
+VECT_VAR_DECL(expected_q_u32_9,uint,32,4) [] = { 0xfff1fff0, 0xfff3fff2,
+						 0xfff5fff4, 0xfff7fff6 };
+
+/* Expected results for vreinterpretq_u64_xx.  */
+VECT_VAR_DECL(expected_q_u64_1,uint,64,2) [] = { 0xf7f6f5f4f3f2f1f0,
+						0xfffefdfcfbfaf9f8 };
+VECT_VAR_DECL(expected_q_u64_2,uint,64,2) [] = { 0xfff3fff2fff1fff0,
+						0xfff7fff6fff5fff4 };
+VECT_VAR_DECL(expected_q_u64_3,uint,64,2) [] = { 0xfffffff1fffffff0,
+						0xfffffff3fffffff2 };
+VECT_VAR_DECL(expected_q_u64_4,uint,64,2) [] = { 0xfffffffffffffff0,
+						0xfffffffffffffff1 };
+VECT_VAR_DECL(expected_q_u64_5,uint,64,2) [] = { 0xf7f6f5f4f3f2f1f0,
+						0xfffefdfcfbfaf9f8 };
+VECT_VAR_DECL(expected_q_u64_6,uint,64,2) [] = { 0xfff3fff2fff1fff0,
+						0xfff7fff6fff5fff4 };
+VECT_VAR_DECL(expected_q_u64_7,uint,64,2) [] = { 0xfffffff1fffffff0,
+						0xfffffff3fffffff2 };
+VECT_VAR_DECL(expected_q_u64_8,uint,64,2) [] = { 0xf7f6f5f4f3f2f1f0,
+						0xfffefdfcfbfaf9f8 };
+VECT_VAR_DECL(expected_q_u64_9,uint,64,2) [] = { 0xfff3fff2fff1fff0,
+						 0xfff7fff6fff5fff4 };
+
+/* Expected results for vreinterpret_f32_xx.  */
+VECT_VAR_DECL(expected_f32_1,hfloat,32,2) [] = { 0xf3f2f1f0, 0xf7f6f5f4 };
+VECT_VAR_DECL(expected_f32_2,hfloat,32,2) [] = { 0xfff1fff0, 0xfff3fff2 };
+VECT_VAR_DECL(expected_f32_3,hfloat,32,2) [] = { 0xfffffff0, 0xfffffff1 };
+VECT_VAR_DECL(expected_f32_4,hfloat,32,2) [] = { 0xfffffff0, 0xffffffff };
+VECT_VAR_DECL(expected_f32_5,hfloat,32,2) [] = { 0xf3f2f1f0, 0xf7f6f5f4 };
+VECT_VAR_DECL(expected_f32_6,hfloat,32,2) [] = { 0xfff1fff0, 0xfff3fff2 };
+VECT_VAR_DECL(expected_f32_7,hfloat,32,2) [] = { 0xfffffff0, 0xfffffff1 };
+VECT_VAR_DECL(expected_f32_8,hfloat,32,2) [] = { 0xfffffff0, 0xffffffff };
+VECT_VAR_DECL(expected_f32_9,hfloat,32,2) [] = { 0xf3f2f1f0, 0xf7f6f5f4 };
+VECT_VAR_DECL(expected_f32_10,hfloat,32,2) [] = { 0xfff1fff0, 0xfff3fff2 };
+
+/* Expected results for vreinterpretq_f32_xx.  */
+VECT_VAR_DECL(expected_q_f32_1,hfloat,32,4) [] = { 0xf3f2f1f0, 0xf7f6f5f4,
+						   0xfbfaf9f8, 0xfffefdfc };
+VECT_VAR_DECL(expected_q_f32_2,hfloat,32,4) [] = { 0xfff1fff0, 0xfff3fff2,
+						   0xfff5fff4, 0xfff7fff6 };
+VECT_VAR_DECL(expected_q_f32_3,hfloat,32,4) [] = { 0xfffffff0, 0xfffffff1,
+						   0xfffffff2, 0xfffffff3 };
+VECT_VAR_DECL(expected_q_f32_4,hfloat,32,4) [] = { 0xfffffff0, 0xffffffff,
+						   0xfffffff1, 0xffffffff };
+VECT_VAR_DECL(expected_q_f32_5,hfloat,32,4) [] = { 0xf3f2f1f0, 0xf7f6f5f4,
+						   0xfbfaf9f8, 0xfffefdfc };
+VECT_VAR_DECL(expected_q_f32_6,hfloat,32,4) [] = { 0xfff1fff0, 0xfff3fff2,
+						   0xfff5fff4, 0xfff7fff6 };
+VECT_VAR_DECL(expected_q_f32_7,hfloat,32,4) [] = { 0xfffffff0, 0xfffffff1,
+						   0xfffffff2, 0xfffffff3 };
+VECT_VAR_DECL(expected_q_f32_8,hfloat,32,4) [] = { 0xfffffff0, 0xffffffff,
+						   0xfffffff1, 0xffffffff };
+VECT_VAR_DECL(expected_q_f32_9,hfloat,32,4) [] = { 0xf3f2f1f0, 0xf7f6f5f4,
+						   0xfbfaf9f8, 0xfffefdfc };
+VECT_VAR_DECL(expected_q_f32_10,hfloat,32,4) [] = { 0xfff1fff0, 0xfff3fff2,
+						    0xfff5fff4, 0xfff7fff6 };
+
+/* Expected results for vreinterpretq_xx_f32.  */
+VECT_VAR_DECL(expected_xx_f32_1,int,8,8) [] = { 0x0, 0x0, 0x80, 0xc1,
+						0x0, 0x0, 0x70, 0xc1 };
+VECT_VAR_DECL(expected_xx_f32_2,int,16,4) [] = { 0x0, 0xc180, 0x0, 0xc170 };
+VECT_VAR_DECL(expected_xx_f32_3,int,32,2) [] = { 0xc1800000, 0xc1700000 };
+VECT_VAR_DECL(expected_xx_f32_4,int,64,1) [] = { 0xc1700000c1800000 };
+VECT_VAR_DECL(expected_xx_f32_5,uint,8,8) [] = { 0x0, 0x0, 0x80, 0xc1,
+						 0x0, 0x0, 0x70, 0xc1 };
+VECT_VAR_DECL(expected_xx_f32_6,uint,16,4) [] = { 0x0, 0xc180, 0x0, 0xc170 };
+VECT_VAR_DECL(expected_xx_f32_7,uint,32,2) [] = { 0xc1800000, 0xc1700000 };
+VECT_VAR_DECL(expected_xx_f32_8,uint,64,1) [] = { 0xc1700000c1800000 };
+VECT_VAR_DECL(expected_xx_f32_9,poly,8,8) [] = { 0x0, 0x0, 0x80, 0xc1,
+						 0x0, 0x0, 0x70, 0xc1 };
+VECT_VAR_DECL(expected_xx_f32_10,poly,16,4) [] = { 0x0, 0xc180, 0x0, 0xc170 };
+
+/* Expected results for vreinterpretq_xx_f32.  */
+VECT_VAR_DECL(expected_q_xx_f32_1,int,8,16) [] = { 0x0, 0x0, 0x80, 0xc1,
+						   0x0, 0x0, 0x70, 0xc1,
+						   0x0, 0x0, 0x60, 0xc1,
+						   0x0, 0x0, 0x50, 0xc1 };
+VECT_VAR_DECL(expected_q_xx_f32_2,int,16,8) [] = { 0x0, 0xc180, 0x0, 0xc170,
+						   0x0, 0xc160, 0x0, 0xc150 };
+VECT_VAR_DECL(expected_q_xx_f32_3,int,32,4) [] = { 0xc1800000, 0xc1700000,
+						   0xc1600000, 0xc1500000 };
+VECT_VAR_DECL(expected_q_xx_f32_4,int,64,2) [] = { 0xc1700000c1800000,
+						   0xc1500000c1600000 };
+VECT_VAR_DECL(expected_q_xx_f32_5,uint,8,16) [] = { 0x0, 0x0, 0x80, 0xc1,
+						    0x0, 0x0, 0x70, 0xc1,
+						    0x0, 0x0, 0x60, 0xc1,
+						    0x0, 0x0, 0x50, 0xc1 };
+VECT_VAR_DECL(expected_q_xx_f32_6,uint,16,8) [] = { 0x0, 0xc180, 0x0, 0xc170,
+						    0x0, 0xc160, 0x0, 0xc150 };
+VECT_VAR_DECL(expected_q_xx_f32_7,uint,32,4) [] = { 0xc1800000, 0xc1700000,
+						    0xc1600000, 0xc1500000 };
+VECT_VAR_DECL(expected_q_xx_f32_8,uint,64,2) [] = { 0xc1700000c1800000,
+						    0xc1500000c1600000 };
+VECT_VAR_DECL(expected_q_xx_f32_9,poly,8,16) [] = { 0x0, 0x0, 0x80, 0xc1,
+						    0x0, 0x0, 0x70, 0xc1,
+						    0x0, 0x0, 0x60, 0xc1,
+						    0x0, 0x0, 0x50, 0xc1 };
+VECT_VAR_DECL(expected_q_xx_f32_10,poly,16,8) [] = { 0x0, 0xc180, 0x0, 0xc170,
+						     0x0, 0xc160, 0x0, 0xc150 };
+
+#define TEST_MSG "VREINTERPRET/VREINTERPRETQ"
+
+void exec_vreinterpret (void)
+{
+  int i;
+
+  /* Basic test: y=vreinterpret(x), then store the result.  */
+#define TEST_VREINTERPRET(Q, T1, T2, W, N, TS1, TS2, WS, NS, EXPECTED)	\
+  VECT_VAR(vector_res, T1, W, N) =					\
+    vreinterpret##Q##_##T2##W##_##TS2##WS(VECT_VAR(vector, TS1, WS, NS)); \
+  vst1##Q##_##T2##W(VECT_VAR(result, T1, W, N),				\
+		    VECT_VAR(vector_res, T1, W, N));			\
+  CHECK(TEST_MSG, T1, W, N, PRIx##W, EXPECTED, "");
+
+#define TEST_VREINTERPRET_POLY(Q, T1, T2, W, N, TS1, TS2, WS, NS, EXPECTED) \
+  VECT_VAR(vector_res, T1, W, N) =					\
+    vreinterpret##Q##_##T2##W##_##TS2##WS(VECT_VAR(vector, TS1, WS, NS)); \
+  vst1##Q##_##T2##W(VECT_VAR(result, T1, W, N),				\
+		    VECT_VAR(vector_res, T1, W, N));			\
+  CHECK(TEST_MSG, T1, W, N, PRIx##W, EXPECTED, "");
+
+#define TEST_VREINTERPRET_FP(Q, T1, T2, W, N, TS1, TS2, WS, NS, EXPECTED) \
+  VECT_VAR(vector_res, T1, W, N) =					\
+    vreinterpret##Q##_##T2##W##_##TS2##WS(VECT_VAR(vector, TS1, WS, NS)); \
+  vst1##Q##_##T2##W(VECT_VAR(result, T1, W, N),				\
+		    VECT_VAR(vector_res, T1, W, N));			\
+  CHECK_FP(TEST_MSG, T1, W, N, PRIx##W, EXPECTED, "");
+
+  DECL_VARIABLE_ALL_VARIANTS(vector);
+  DECL_VARIABLE_ALL_VARIANTS(vector_res);
+
+  clean_results ();
+
+
+  /* Initialize input "vector" from "buffer".  */
+  TEST_MACRO_ALL_VARIANTS_2_5(VLOAD, vector, buffer);
+  VLOAD(vector, buffer, , float, f, 32, 2);
+  VLOAD(vector, buffer, q, float, f, 32, 4);
+
+  /* vreinterpret_s8_xx.  */
+  TEST_VREINTERPRET(, int, s, 8, 8, int, s, 16, 4, expected_s8_1);
+  TEST_VREINTERPRET(, int, s, 8, 8, int, s, 32, 2, expected_s8_2);
+  TEST_VREINTERPRET(, int, s, 8, 8, int, s, 64, 1, expected_s8_3);
+  TEST_VREINTERPRET(, int, s, 8, 8, uint, u, 8, 8, expected_s8_4);
+  TEST_VREINTERPRET(, int, s, 8, 8, uint, u, 16, 4, expected_s8_5);
+  TEST_VREINTERPRET(, int, s, 8, 8, uint, u, 32, 2, expected_s8_6);
+  TEST_VREINTERPRET(, int, s, 8, 8, uint, u, 64, 1, expected_s8_7);
+  TEST_VREINTERPRET(, int, s, 8, 8, poly, p, 8, 8, expected_s8_8);
+  TEST_VREINTERPRET(, int, s, 8, 8, poly, p, 16, 4, expected_s8_9);
+
+  /* vreinterpret_s16_xx.  */
+  TEST_VREINTERPRET(, int, s, 16, 4, int, s, 8, 8, expected_s16_1);
+  TEST_VREINTERPRET(, int, s, 16, 4, int, s, 32, 2, expected_s16_2);
+  TEST_VREINTERPRET(, int, s, 16, 4, int, s, 64, 1, expected_s16_3);
+  TEST_VREINTERPRET(, int, s, 16, 4, uint, u, 8, 8, expected_s16_4);
+  TEST_VREINTERPRET(, int, s, 16, 4, uint, u, 16, 4, expected_s16_5);
+  TEST_VREINTERPRET(, int, s, 16, 4, uint, u, 32, 2, expected_s16_6);
+  TEST_VREINTERPRET(, int, s, 16, 4, uint, u, 64, 1, expected_s16_7);
+  TEST_VREINTERPRET(, int, s, 16, 4, poly, p, 8, 8, expected_s16_8);
+  TEST_VREINTERPRET(, int, s, 16, 4, poly, p, 16, 4, expected_s16_9);
+
+  /* vreinterpret_s32_xx.  */
+  TEST_VREINTERPRET(, int, s, 32, 2, int, s, 8, 8, expected_s32_1);
+  TEST_VREINTERPRET(, int, s, 32, 2, int, s, 16, 4, expected_s32_2);
+  TEST_VREINTERPRET(, int, s, 32, 2, int, s, 64, 1, expected_s32_3);
+  TEST_VREINTERPRET(, int, s, 32, 2, uint, u, 8, 8, expected_s32_4);
+  TEST_VREINTERPRET(, int, s, 32, 2, uint, u, 16, 4, expected_s32_5);
+  TEST_VREINTERPRET(, int, s, 32, 2, uint, u, 32, 2, expected_s32_6);
+  TEST_VREINTERPRET(, int, s, 32, 2, uint, u, 64, 1, expected_s32_7);
+  TEST_VREINTERPRET(, int, s, 32, 2, poly, p, 8, 8, expected_s32_8);
+  TEST_VREINTERPRET(, int, s, 32, 2, poly, p, 16, 4, expected_s32_9);
+
+  /* vreinterpret_s64_xx.  */
+  TEST_VREINTERPRET(, int, s, 64, 1, int, s, 8, 8, expected_s64_1);
+  TEST_VREINTERPRET(, int, s, 64, 1, int, s, 16, 4, expected_s64_2);
+  TEST_VREINTERPRET(, int, s, 64, 1, int, s, 32, 2, expected_s64_3);
+  TEST_VREINTERPRET(, int, s, 64, 1, uint, u, 8, 8, expected_s64_4);
+  TEST_VREINTERPRET(, int, s, 64, 1, uint, u, 16, 4, expected_s64_5);
+  TEST_VREINTERPRET(, int, s, 64, 1, uint, u, 32, 2, expected_s64_6);
+  TEST_VREINTERPRET(, int, s, 64, 1, uint, u, 64, 1, expected_s64_7);
+  TEST_VREINTERPRET(, int, s, 64, 1, poly, p, 8, 8, expected_s64_8);
+  TEST_VREINTERPRET(, int, s, 64, 1, poly, p, 16, 4, expected_s64_9);
+
+  /* vreinterpret_u8_xx.  */
+  TEST_VREINTERPRET(, uint, u, 8, 8, int, s, 8, 8, expected_u8_1);
+  TEST_VREINTERPRET(, uint, u, 8, 8, int, s, 16, 4, expected_u8_2);
+  TEST_VREINTERPRET(, uint, u, 8, 8, int, s, 32, 2, expected_u8_3);
+  TEST_VREINTERPRET(, uint, u, 8, 8, int, s, 64, 1, expected_u8_4);
+  TEST_VREINTERPRET(, uint, u, 8, 8, uint, u, 16, 4, expected_u8_5);
+  TEST_VREINTERPRET(, uint, u, 8, 8, uint, u, 32, 2, expected_u8_6);
+  TEST_VREINTERPRET(, uint, u, 8, 8, uint, u, 64, 1, expected_u8_7);
+  TEST_VREINTERPRET(, uint, u, 8, 8, poly, p, 8, 8, expected_u8_8);
+  TEST_VREINTERPRET(, uint, u, 8, 8, poly, p, 16, 4, expected_u8_9);
+
+  /* vreinterpret_u16_xx.  */
+  TEST_VREINTERPRET(, uint, u, 16, 4, int, s, 8, 8, expected_u16_1);
+  TEST_VREINTERPRET(, uint, u, 16, 4, int, s, 16, 4, expected_u16_2);
+  TEST_VREINTERPRET(, uint, u, 16, 4, int, s, 32, 2, expected_u16_3);
+  TEST_VREINTERPRET(, uint, u, 16, 4, int, s, 64, 1, expected_u16_4);
+  TEST_VREINTERPRET(, uint, u, 16, 4, uint, u, 8, 8, expected_u16_5);
+  TEST_VREINTERPRET(, uint, u, 16, 4, uint, u, 32, 2, expected_u16_6);
+  TEST_VREINTERPRET(, uint, u, 16, 4, uint, u, 64, 1, expected_u16_7);
+  TEST_VREINTERPRET(, uint, u, 16, 4, poly, p, 8, 8, expected_u16_8);
+  TEST_VREINTERPRET(, uint, u, 16, 4, poly, p, 16, 4, expected_u16_9);
+
+  /* vreinterpret_u32_xx.  */
+  TEST_VREINTERPRET(, uint, u, 32, 2, int, s, 8, 8, expected_u32_1);
+  TEST_VREINTERPRET(, uint, u, 32, 2, int, s, 16, 4, expected_u32_2);
+  TEST_VREINTERPRET(, uint, u, 32, 2, int, s, 32, 2, expected_u32_3);
+  TEST_VREINTERPRET(, uint, u, 32, 2, int, s, 64, 1, expected_u32_4);
+  TEST_VREINTERPRET(, uint, u, 32, 2, uint, u, 8, 8, expected_u32_5);
+  TEST_VREINTERPRET(, uint, u, 32, 2, uint, u, 16, 4, expected_u32_6);
+  TEST_VREINTERPRET(, uint, u, 32, 2, uint, u, 64, 1, expected_u32_7);
+  TEST_VREINTERPRET(, uint, u, 32, 2, poly, p, 8, 8, expected_u32_8);
+  TEST_VREINTERPRET(, uint, u, 32, 2, poly, p, 16, 4, expected_u32_9);
+
+  /* vreinterpret_u64_xx.  */
+  TEST_VREINTERPRET(, uint, u, 64, 1, int, s, 8, 8, expected_u64_1);
+  TEST_VREINTERPRET(, uint, u, 64, 1, int, s, 16, 4, expected_u64_2);
+  TEST_VREINTERPRET(, uint, u, 64, 1, int, s, 32, 2, expected_u64_3);
+  TEST_VREINTERPRET(, uint, u, 64, 1, int, s, 64, 1, expected_u64_4);
+  TEST_VREINTERPRET(, uint, u, 64, 1, uint, u, 8, 8, expected_u64_5);
+  TEST_VREINTERPRET(, uint, u, 64, 1, uint, u, 16, 4, expected_u64_6);
+  TEST_VREINTERPRET(, uint, u, 64, 1, uint, u, 32, 2, expected_u64_7);
+  TEST_VREINTERPRET(, uint, u, 64, 1, poly, p, 8, 8, expected_u64_8);
+  TEST_VREINTERPRET(, uint, u, 64, 1, poly, p, 16, 4, expected_u64_9);
+
+  /* vreinterpret_p8_xx.  */
+  TEST_VREINTERPRET_POLY(, poly, p, 8, 8, int, s, 8, 8, expected_p8_1);
+  TEST_VREINTERPRET_POLY(, poly, p, 8, 8, int, s, 16, 4, expected_p8_2);
+  TEST_VREINTERPRET_POLY(, poly, p, 8, 8, int, s, 32, 2, expected_p8_3);
+  TEST_VREINTERPRET_POLY(, poly, p, 8, 8, int, s, 64, 1, expected_p8_4);
+  TEST_VREINTERPRET_POLY(, poly, p, 8, 8, uint, u, 8, 8, expected_p8_5);
+  TEST_VREINTERPRET_POLY(, poly, p, 8, 8, uint, u, 16, 4, expected_p8_6);
+  TEST_VREINTERPRET_POLY(, poly, p, 8, 8, uint, u, 32, 2, expected_p8_7);
+  TEST_VREINTERPRET_POLY(, poly, p, 8, 8, uint, u, 64, 1, expected_p8_8);
+  TEST_VREINTERPRET_POLY(, poly, p, 8, 8, poly, p, 16, 4, expected_p8_9);
+
+  /* vreinterpret_p16_xx.  */
+  TEST_VREINTERPRET_POLY(, poly, p, 16, 4, int, s, 8, 8, expected_p16_1);
+  TEST_VREINTERPRET_POLY(, poly, p, 16, 4, int, s, 16, 4, expected_p16_2);
+  TEST_VREINTERPRET_POLY(, poly, p, 16, 4, int, s, 32, 2, expected_p16_3);
+  TEST_VREINTERPRET_POLY(, poly, p, 16, 4, int, s, 64, 1, expected_p16_4);
+  TEST_VREINTERPRET_POLY(, poly, p, 16, 4, uint, u, 8, 8, expected_p16_5);
+  TEST_VREINTERPRET_POLY(, poly, p, 16, 4, uint, u, 16, 4, expected_p16_6);
+  TEST_VREINTERPRET_POLY(, poly, p, 16, 4, uint, u, 32, 2, expected_p16_7);
+  TEST_VREINTERPRET_POLY(, poly, p, 16, 4, uint, u, 64, 1, expected_p16_8);
+  TEST_VREINTERPRET_POLY(, poly, p, 16, 4, poly, p, 8, 8, expected_p16_9);
+
+  /* vreinterpretq_s8_xx.  */
+  TEST_VREINTERPRET(q, int, s, 8, 16, int, s, 16, 8, expected_q_s8_1);
+  TEST_VREINTERPRET(q, int, s, 8, 16, int, s, 32, 4, expected_q_s8_2);
+  TEST_VREINTERPRET(q, int, s, 8, 16, int, s, 64, 2, expected_q_s8_3);
+  TEST_VREINTERPRET(q, int, s, 8, 16, uint, u, 8, 16, expected_q_s8_4);
+  TEST_VREINTERPRET(q, int, s, 8, 16, uint, u, 16, 8, expected_q_s8_5);
+  TEST_VREINTERPRET(q, int, s, 8, 16, uint, u, 32, 4, expected_q_s8_6);
+  TEST_VREINTERPRET(q, int, s, 8, 16, uint, u, 64, 2, expected_q_s8_7);
+  TEST_VREINTERPRET(q, int, s, 8, 16, poly, p, 8, 16, expected_q_s8_8);
+  TEST_VREINTERPRET(q, int, s, 8, 16, poly, p, 16, 8, expected_q_s8_9);
+
+  /* vreinterpretq_s16_xx.  */
+  TEST_VREINTERPRET(q, int, s, 16, 8, int, s, 8, 16, expected_q_s16_1);
+  TEST_VREINTERPRET(q, int, s, 16, 8, int, s, 32, 4, expected_q_s16_2);
+  TEST_VREINTERPRET(q, int, s, 16, 8, int, s, 64, 2, expected_q_s16_3);
+  TEST_VREINTERPRET(q, int, s, 16, 8, uint, u, 8, 16, expected_q_s16_4);
+  TEST_VREINTERPRET(q, int, s, 16, 8, uint, u, 16, 8, expected_q_s16_5);
+  TEST_VREINTERPRET(q, int, s, 16, 8, uint, u, 32, 4, expected_q_s16_6);
+  TEST_VREINTERPRET(q, int, s, 16, 8, uint, u, 64, 2, expected_q_s16_7);
+  TEST_VREINTERPRET(q, int, s, 16, 8, poly, p, 8, 16, expected_q_s16_8);
+  TEST_VREINTERPRET(q, int, s, 16, 8, poly, p, 16, 8, expected_q_s16_9);
+
+  /* vreinterpretq_s32_xx.  */
+  TEST_VREINTERPRET(q, int, s, 32, 4, int, s, 8, 16, expected_q_s32_1);
+  TEST_VREINTERPRET(q, int, s, 32, 4, int, s, 16, 8, expected_q_s32_2);
+  TEST_VREINTERPRET(q, int, s, 32, 4, int, s, 64, 2, expected_q_s32_3);
+  TEST_VREINTERPRET(q, int, s, 32, 4, uint, u, 8, 16, expected_q_s32_4);
+  TEST_VREINTERPRET(q, int, s, 32, 4, uint, u, 16, 8, expected_q_s32_5);
+  TEST_VREINTERPRET(q, int, s, 32, 4, uint, u, 32, 4, expected_q_s32_6);
+  TEST_VREINTERPRET(q, int, s, 32, 4, uint, u, 64, 2, expected_q_s32_7);
+  TEST_VREINTERPRET(q, int, s, 32, 4, poly, p, 8, 16, expected_q_s32_8);
+  TEST_VREINTERPRET(q, int, s, 32, 4, poly, p, 16, 8, expected_q_s32_9);
+
+  /* vreinterpretq_s64_xx.  */
+  TEST_VREINTERPRET(q, int, s, 64, 2, int, s, 8, 16, expected_q_s64_1);
+  TEST_VREINTERPRET(q, int, s, 64, 2, int, s, 16, 8, expected_q_s64_2);
+  TEST_VREINTERPRET(q, int, s, 64, 2, int, s, 32, 4, expected_q_s64_3);
+  TEST_VREINTERPRET(q, int, s, 64, 2, uint, u, 8, 16, expected_q_s64_4);
+  TEST_VREINTERPRET(q, int, s, 64, 2, uint, u, 16, 8, expected_q_s64_5);
+  TEST_VREINTERPRET(q, int, s, 64, 2, uint, u, 32, 4, expected_q_s64_6);
+  TEST_VREINTERPRET(q, int, s, 64, 2, uint, u, 64, 2, expected_q_s64_7);
+  TEST_VREINTERPRET(q, int, s, 64, 2, poly, p, 8, 16, expected_q_s64_8);
+  TEST_VREINTERPRET(q, int, s, 64, 2, poly, p, 16, 8, expected_q_s64_9);
+
+  /* vreinterpretq_u8_xx.  */
+  TEST_VREINTERPRET(q, uint, u, 8, 16, int, s, 8, 16, expected_q_u8_1);
+  TEST_VREINTERPRET(q, uint, u, 8, 16, int, s, 16, 8, expected_q_u8_2);
+  TEST_VREINTERPRET(q, uint, u, 8, 16, int, s, 32, 4, expected_q_u8_3);
+  TEST_VREINTERPRET(q, uint, u, 8, 16, int, s, 64, 2, expected_q_u8_4);
+  TEST_VREINTERPRET(q, uint, u, 8, 16, uint, u, 16, 8, expected_q_u8_5);
+  TEST_VREINTERPRET(q, uint, u, 8, 16, uint, u, 32, 4, expected_q_u8_6);
+  TEST_VREINTERPRET(q, uint, u, 8, 16, uint, u, 64, 2, expected_q_u8_7);
+  TEST_VREINTERPRET(q, uint, u, 8, 16, poly, p, 8, 16, expected_q_u8_8);
+  TEST_VREINTERPRET(q, uint, u, 8, 16, poly, p, 16, 8, expected_q_u8_9);
+
+  /* vreinterpretq_u16_xx.  */
+  TEST_VREINTERPRET(q, uint, u, 16, 8, int, s, 8, 16, expected_q_u16_1);
+  TEST_VREINTERPRET(q, uint, u, 16, 8, int, s, 16, 8, expected_q_u16_2);
+  TEST_VREINTERPRET(q, uint, u, 16, 8, int, s, 32, 4, expected_q_u16_3);
+  TEST_VREINTERPRET(q, uint, u, 16, 8, int, s, 64, 2, expected_q_u16_4);
+  TEST_VREINTERPRET(q, uint, u, 16, 8, uint, u, 8, 16, expected_q_u16_5);
+  TEST_VREINTERPRET(q, uint, u, 16, 8, uint, u, 32, 4, expected_q_u16_6);
+  TEST_VREINTERPRET(q, uint, u, 16, 8, uint, u, 64, 2, expected_q_u16_7);
+  TEST_VREINTERPRET(q, uint, u, 16, 8, poly, p, 8, 16, expected_q_u16_8);
+  TEST_VREINTERPRET(q, uint, u, 16, 8, poly, p, 16, 8, expected_q_u16_9);
+
+  /* vreinterpretq_u32_xx.  */
+  TEST_VREINTERPRET(q, uint, u, 32, 4, int, s, 8, 16, expected_q_u32_1);
+  TEST_VREINTERPRET(q, uint, u, 32, 4, int, s, 16, 8, expected_q_u32_2);
+  TEST_VREINTERPRET(q, uint, u, 32, 4, int, s, 32, 4, expected_q_u32_3);
+  TEST_VREINTERPRET(q, uint, u, 32, 4, int, s, 64, 2, expected_q_u32_4);
+  TEST_VREINTERPRET(q, uint, u, 32, 4, uint, u, 8, 16, expected_q_u32_5);
+  TEST_VREINTERPRET(q, uint, u, 32, 4, uint, u, 16, 8, expected_q_u32_6);
+  TEST_VREINTERPRET(q, uint, u, 32, 4, uint, u, 64, 2, expected_q_u32_7);
+  TEST_VREINTERPRET(q, uint, u, 32, 4, poly, p, 8, 16, expected_q_u32_8);
+  TEST_VREINTERPRET(q, uint, u, 32, 4, poly, p, 16, 8, expected_q_u32_9);
+
+  /* vreinterpretq_u64_xx.  */
+  TEST_VREINTERPRET(q, uint, u, 64, 2, int, s, 8, 16, expected_q_u64_1);
+  TEST_VREINTERPRET(q, uint, u, 64, 2, int, s, 16, 8, expected_q_u64_2);
+  TEST_VREINTERPRET(q, uint, u, 64, 2, int, s, 32, 4, expected_q_u64_3);
+  TEST_VREINTERPRET(q, uint, u, 64, 2, int, s, 64, 2, expected_q_u64_4);
+  TEST_VREINTERPRET(q, uint, u, 64, 2, uint, u, 8, 16, expected_q_u64_5);
+  TEST_VREINTERPRET(q, uint, u, 64, 2, uint, u, 16, 8, expected_q_u64_6);
+  TEST_VREINTERPRET(q, uint, u, 64, 2, uint, u, 32, 4, expected_q_u64_7);
+  TEST_VREINTERPRET(q, uint, u, 64, 2, poly, p, 8, 16, expected_q_u64_8);
+  TEST_VREINTERPRET(q, uint, u, 64, 2, poly, p, 16, 8, expected_q_u64_9);
+
+  /* vreinterpret_f32_xx.  */
+  TEST_VREINTERPRET_FP(, float, f, 32, 2, int, s, 8, 8, expected_f32_1);
+  TEST_VREINTERPRET_FP(, float, f, 32, 2, int, s, 16, 4, expected_f32_2);
+  TEST_VREINTERPRET_FP(, float, f, 32, 2, int, s, 32, 2, expected_f32_3);
+  TEST_VREINTERPRET_FP(, float, f, 32, 2, int, s, 64, 1, expected_f32_4);
+  TEST_VREINTERPRET_FP(, float, f, 32, 2, uint, u, 8, 8, expected_f32_5);
+  TEST_VREINTERPRET_FP(, float, f, 32, 2, uint, u, 16, 4, expected_f32_6);
+  TEST_VREINTERPRET_FP(, float, f, 32, 2, uint, u, 32, 2, expected_f32_7);
+  TEST_VREINTERPRET_FP(, float, f, 32, 2, uint, u, 64, 1, expected_f32_8);
+  TEST_VREINTERPRET_FP(, float, f, 32, 2, poly, p, 8, 8, expected_f32_9);
+  TEST_VREINTERPRET_FP(, float, f, 32, 2, poly, p, 16, 4, expected_f32_10);
+
+  /* vreinterpretq_f32_xx.  */
+  TEST_VREINTERPRET_FP(q, float, f, 32, 4, int, s, 8, 16, expected_q_f32_1);
+  TEST_VREINTERPRET_FP(q, float, f, 32, 4, int, s, 16, 8, expected_q_f32_2);
+  TEST_VREINTERPRET_FP(q, float, f, 32, 4, int, s, 32, 4, expected_q_f32_3);
+  TEST_VREINTERPRET_FP(q, float, f, 32, 4, int, s, 64, 2, expected_q_f32_4);
+  TEST_VREINTERPRET_FP(q, float, f, 32, 4, uint, u, 8, 16, expected_q_f32_5);
+  TEST_VREINTERPRET_FP(q, float, f, 32, 4, uint, u, 16, 8, expected_q_f32_6);
+  TEST_VREINTERPRET_FP(q, float, f, 32, 4, uint, u, 32, 4, expected_q_f32_7);
+  TEST_VREINTERPRET_FP(q, float, f, 32, 4, uint, u, 64, 2, expected_q_f32_8);
+  TEST_VREINTERPRET_FP(q, float, f, 32, 4, poly, p, 8, 16, expected_q_f32_9);
+  TEST_VREINTERPRET_FP(q, float, f, 32, 4, poly, p, 16, 8, expected_q_f32_10);
+
+  /* vreinterpret_xx_f32.  */
+  TEST_VREINTERPRET(, int, s, 8, 8, float, f, 32, 2, expected_xx_f32_1);
+  TEST_VREINTERPRET(, int, s, 16, 4, float, f, 32, 2, expected_xx_f32_2);
+  TEST_VREINTERPRET(, int, s, 32, 2, float, f, 32, 2, expected_xx_f32_3);
+  TEST_VREINTERPRET(, int, s, 64, 1, float, f, 32, 2, expected_xx_f32_4);
+  TEST_VREINTERPRET(, uint, u, 8, 8, float, f, 32, 2, expected_xx_f32_5);
+  TEST_VREINTERPRET(, uint, u, 16, 4, float, f, 32, 2, expected_xx_f32_6);
+  TEST_VREINTERPRET(, uint, u, 32, 2, float, f, 32, 2, expected_xx_f32_7);
+  TEST_VREINTERPRET(, uint, u, 64, 1, float, f, 32, 2, expected_xx_f32_8);
+  TEST_VREINTERPRET_POLY(, poly, p, 8, 8, float, f, 32, 2, expected_xx_f32_9);
+  TEST_VREINTERPRET_POLY(, poly, p, 16, 4, float, f, 32, 2, expected_xx_f32_10);
+
+  /* vreinterpretq_xx_f32.  */
+  TEST_VREINTERPRET(q, int, s, 8, 16, float, f, 32, 4, expected_q_xx_f32_1);
+  TEST_VREINTERPRET(q, int, s, 16, 8, float, f, 32, 4, expected_q_xx_f32_2);
+  TEST_VREINTERPRET(q, int, s, 32, 4, float, f, 32, 4, expected_q_xx_f32_3);
+  TEST_VREINTERPRET(q, int, s, 64, 2, float, f, 32, 4, expected_q_xx_f32_4);
+  TEST_VREINTERPRET(q, uint, u, 8, 16, float, f, 32, 4, expected_q_xx_f32_5);
+  TEST_VREINTERPRET(q, uint, u, 16, 8, float, f, 32, 4, expected_q_xx_f32_6);
+  TEST_VREINTERPRET(q, uint, u, 32, 4, float, f, 32, 4, expected_q_xx_f32_7);
+  TEST_VREINTERPRET(q, uint, u, 64, 2, float, f, 32, 4, expected_q_xx_f32_8);
+  TEST_VREINTERPRET_POLY(q, poly, p, 8, 16, float, f, 32, 4, expected_q_xx_f32_9);
+  TEST_VREINTERPRET_POLY(q, poly, p, 16, 8, float, f, 32, 4, expected_q_xx_f32_10);
+}
+
+int main (void)
+{
+  exec_vreinterpret ();
+  return 0;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vrev.c
@@ -0,0 +1,200 @@
+#include <arm_neon.h>
+#include "arm-neon-ref.h"
+#include "compute-ref-data.h"
+
+/* Expected results for vrev16.  */
+VECT_VAR_DECL(expected_vrev16,int,8,8) [] = { 0xf1, 0xf0, 0xf3, 0xf2,
+					      0xf5, 0xf4, 0xf7, 0xf6 };
+VECT_VAR_DECL(expected_vrev16,uint,8,8) [] = { 0xf1, 0xf0, 0xf3, 0xf2,
+					       0xf5, 0xf4, 0xf7, 0xf6 };
+VECT_VAR_DECL(expected_vrev16,poly,8,8) [] = { 0xf1, 0xf0, 0xf3, 0xf2,
+					       0xf5, 0xf4, 0xf7, 0xf6 };
+VECT_VAR_DECL(expected_vrev16,int,8,16) [] = { 0xf1, 0xf0, 0xf3, 0xf2,
+					       0xf5, 0xf4, 0xf7, 0xf6,
+					       0xf9, 0xf8, 0xfb, 0xfa,
+					       0xfd, 0xfc, 0xff, 0xfe };
+VECT_VAR_DECL(expected_vrev16,uint,8,16) [] = { 0xf1, 0xf0, 0xf3, 0xf2,
+						0xf5, 0xf4, 0xf7, 0xf6,
+						0xf9, 0xf8, 0xfb, 0xfa,
+						0xfd, 0xfc, 0xff, 0xfe };
+VECT_VAR_DECL(expected_vrev16,poly,8,16) [] = { 0xf1, 0xf0, 0xf3, 0xf2,
+						0xf5, 0xf4, 0xf7, 0xf6,
+						0xf9, 0xf8, 0xfb, 0xfa,
+						0xfd, 0xfc, 0xff, 0xfe };
+
+/* Expected results for vrev32.  */
+VECT_VAR_DECL(expected_vrev32,int,8,8) [] = { 0xf3, 0xf2, 0xf1, 0xf0,
+					      0xf7, 0xf6, 0xf5, 0xf4 };
+VECT_VAR_DECL(expected_vrev32,int,16,4) [] = { 0xfff1, 0xfff0, 0xfff3, 0xfff2 };
+VECT_VAR_DECL(expected_vrev32,uint,8,8) [] = { 0xf3, 0xf2, 0xf1, 0xf0,
+					       0xf7, 0xf6, 0xf5, 0xf4 };
+VECT_VAR_DECL(expected_vrev32,uint,16,4) [] = { 0xfff1, 0xfff0, 0xfff3, 0xfff2 };
+VECT_VAR_DECL(expected_vrev32,poly,8,8) [] = { 0xf3, 0xf2, 0xf1, 0xf0,
+					       0xf7, 0xf6, 0xf5, 0xf4 };
+VECT_VAR_DECL(expected_vrev32,poly,16,4) [] = { 0xfff1, 0xfff0, 0xfff3, 0xfff2 };
+VECT_VAR_DECL(expected_vrev32,int,8,16) [] = { 0xf3, 0xf2, 0xf1, 0xf0,
+					       0xf7, 0xf6, 0xf5, 0xf4,
+					       0xfb, 0xfa, 0xf9, 0xf8,
+					       0xff, 0xfe, 0xfd, 0xfc };
+VECT_VAR_DECL(expected_vrev32,int,16,8) [] = { 0xfff1, 0xfff0, 0xfff3, 0xfff2,
+					       0xfff5, 0xfff4, 0xfff7, 0xfff6 };
+VECT_VAR_DECL(expected_vrev32,uint,8,16) [] = { 0xf3, 0xf2, 0xf1, 0xf0,
+						0xf7, 0xf6, 0xf5, 0xf4,
+						0xfb, 0xfa, 0xf9, 0xf8,
+						0xff, 0xfe, 0xfd, 0xfc };
+VECT_VAR_DECL(expected_vrev32,uint,16,8) [] = { 0xfff1, 0xfff0, 0xfff3, 0xfff2,
+						0xfff5, 0xfff4, 0xfff7, 0xfff6 };
+VECT_VAR_DECL(expected_vrev32,poly,8,16) [] = { 0xf3, 0xf2, 0xf1, 0xf0,
+						0xf7, 0xf6, 0xf5, 0xf4,
+						0xfb, 0xfa, 0xf9, 0xf8,
+						0xff, 0xfe, 0xfd, 0xfc };
+VECT_VAR_DECL(expected_vrev32,poly,16,8) [] = { 0xfff1, 0xfff0, 0xfff3, 0xfff2,
+						0xfff5, 0xfff4, 0xfff7, 0xfff6 };
+
+/* Expected results for vrev64.  */
+VECT_VAR_DECL(expected_vrev64,int,8,8) [] = { 0xf7, 0xf6, 0xf5, 0xf4,
+					      0xf3, 0xf2, 0xf1, 0xf0 };
+VECT_VAR_DECL(expected_vrev64,int,16,4) [] = { 0xfff3, 0xfff2, 0xfff1, 0xfff0 };
+VECT_VAR_DECL(expected_vrev64,int,32,2) [] = { 0xfffffff1, 0xfffffff0 };
+VECT_VAR_DECL(expected_vrev64,uint,8,8) [] = { 0xf7, 0xf6, 0xf5, 0xf4, 0xf3,
+					       0xf2, 0xf1, 0xf0 };
+VECT_VAR_DECL(expected_vrev64,uint,16,4) [] = { 0xfff3, 0xfff2, 0xfff1, 0xfff0 };
+VECT_VAR_DECL(expected_vrev64,uint,32,2) [] = { 0xfffffff1, 0xfffffff0 };
+VECT_VAR_DECL(expected_vrev64,poly,8,8) [] = { 0xf7, 0xf6, 0xf5, 0xf4,
+					       0xf3, 0xf2, 0xf1, 0xf0 };
+VECT_VAR_DECL(expected_vrev64,poly,16,4) [] = { 0xfff3, 0xfff2, 0xfff1, 0xfff0 };
+VECT_VAR_DECL(expected_vrev64,hfloat,32,2) [] = { 0xc1700000, 0xc1800000 };
+VECT_VAR_DECL(expected_vrev64,int,8,16) [] = { 0xf7, 0xf6, 0xf5, 0xf4,
+					       0xf3, 0xf2, 0xf1, 0xf0,
+					       0xff, 0xfe, 0xfd, 0xfc,
+					       0xfb, 0xfa, 0xf9, 0xf8 };
+VECT_VAR_DECL(expected_vrev64,int,16,8) [] = { 0xfff3, 0xfff2, 0xfff1, 0xfff0,
+					       0xfff7, 0xfff6, 0xfff5, 0xfff4 };
+VECT_VAR_DECL(expected_vrev64,int,32,4) [] = { 0xfffffff1, 0xfffffff0,
+					       0xfffffff3, 0xfffffff2 };
+VECT_VAR_DECL(expected_vrev64,uint,8,16) [] = { 0xf7, 0xf6, 0xf5, 0xf4,
+						0xf3, 0xf2, 0xf1, 0xf0,
+						0xff, 0xfe, 0xfd, 0xfc,
+						0xfb, 0xfa, 0xf9, 0xf8 };
+VECT_VAR_DECL(expected_vrev64,uint,16,8) [] = { 0xfff3, 0xfff2, 0xfff1, 0xfff0,
+						0xfff7, 0xfff6, 0xfff5, 0xfff4 };
+VECT_VAR_DECL(expected_vrev64,uint,32,4) [] = { 0xfffffff1, 0xfffffff0,
+						0xfffffff3, 0xfffffff2 };
+VECT_VAR_DECL(expected_vrev64,poly,8,16) [] = { 0xf7, 0xf6, 0xf5, 0xf4,
+						0xf3, 0xf2, 0xf1, 0xf0,
+						0xff, 0xfe, 0xfd, 0xfc,
+						0xfb, 0xfa, 0xf9, 0xf8 };
+VECT_VAR_DECL(expected_vrev64,poly,16,8) [] = { 0xfff3, 0xfff2, 0xfff1, 0xfff0,
+						0xfff7, 0xfff6, 0xfff5, 0xfff4 };
+VECT_VAR_DECL(expected_vrev64,hfloat,32,4) [] = { 0xc1700000, 0xc1800000,
+						  0xc1500000, 0xc1600000 };
+
+void exec_vrev (void)
+{
+  /* Basic test: y=vrev(x), then store the result.  */
+#define TEST_VREV(Q, T1, T2, W, N, W2)					\
+  VECT_VAR(vector_res, T1, W, N) =					\
+    vrev##W2##Q##_##T2##W(VECT_VAR(vector, T1, W, N));			\
+  vst1##Q##_##T2##W(VECT_VAR(result, T1, W, N), VECT_VAR(vector_res, T1, W, N))
+
+  DECL_VARIABLE_ALL_VARIANTS(vector);
+  DECL_VARIABLE_ALL_VARIANTS(vector_res);
+
+  clean_results ();
+
+  /* Initialize input "vector" from "buffer".  */
+  TEST_MACRO_ALL_VARIANTS_2_5(VLOAD, vector, buffer);
+  VLOAD(vector, buffer, , float, f, 32, 2);
+  VLOAD(vector, buffer, q, float, f, 32, 4);
+
+  /* Check vrev in each of the existing combinations.  */
+#define TEST_MSG "VREV16"
+  TEST_VREV(, int, s, 8, 8, 16);
+  TEST_VREV(, uint, u, 8, 8, 16);
+  TEST_VREV(, poly, p, 8, 8, 16);
+  TEST_VREV(q, int, s, 8, 16, 16);
+  TEST_VREV(q, uint, u, 8, 16, 16);
+  TEST_VREV(q, poly, p, 8, 16, 16);
+
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_vrev16, "");
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_vrev16, "");
+  CHECK(TEST_MSG, poly, 8, 8, PRIx8, expected_vrev16, "");
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected_vrev16, "");
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected_vrev16, "");
+  CHECK(TEST_MSG, poly, 8, 16, PRIx8, expected_vrev16, "");
+
+#undef TEST_MSG
+#define TEST_MSG "VREV32"
+  TEST_VREV(, int, s, 8, 8, 32);
+  TEST_VREV(, int, s, 16, 4, 32);
+  TEST_VREV(, uint, u, 8, 8, 32);
+  TEST_VREV(, uint, u, 16, 4, 32);
+  TEST_VREV(, poly, p, 8, 8, 32);
+  TEST_VREV(, poly, p, 16, 4, 32);
+  TEST_VREV(q, int, s, 8, 16, 32);
+  TEST_VREV(q, int, s, 16, 8, 32);
+  TEST_VREV(q, uint, u, 8, 16, 32);
+  TEST_VREV(q, uint, u, 16, 8, 32);
+  TEST_VREV(q, poly, p, 8, 16, 32);
+  TEST_VREV(q, poly, p, 16, 8, 32);
+
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_vrev32, "");
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_vrev32, "");
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_vrev32, "");
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_vrev32, "");
+  CHECK(TEST_MSG, poly, 8, 8, PRIx8, expected_vrev32, "");
+  CHECK(TEST_MSG, poly, 16, 4, PRIx16, expected_vrev32, "");
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected_vrev32, "");
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_vrev32, "");
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected_vrev32, "");
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_vrev32, "");
+  CHECK(TEST_MSG, poly, 8, 16, PRIx8, expected_vrev32, "");
+  CHECK(TEST_MSG, poly, 16, 8, PRIx16, expected_vrev32, "");
+
+#undef TEST_MSG
+#define TEST_MSG "VREV64"
+  TEST_VREV(, int, s, 8, 8, 64);
+  TEST_VREV(, int, s, 16, 4, 64);
+  TEST_VREV(, int, s, 32, 2, 64);
+  TEST_VREV(, uint, u, 8, 8, 64);
+  TEST_VREV(, uint, u, 16, 4, 64);
+  TEST_VREV(, uint, u, 32, 2, 64);
+  TEST_VREV(, poly, p, 8, 8, 64);
+  TEST_VREV(, poly, p, 16, 4, 64);
+  TEST_VREV(q, int, s, 8, 16, 64);
+  TEST_VREV(q, int, s, 16, 8, 64);
+  TEST_VREV(q, int, s, 32, 4, 64);
+  TEST_VREV(q, uint, u, 8, 16, 64);
+  TEST_VREV(q, uint, u, 16, 8, 64);
+  TEST_VREV(q, uint, u, 32, 4, 64);
+  TEST_VREV(q, poly, p, 8, 16, 64);
+  TEST_VREV(q, poly, p, 16, 8, 64);
+
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_vrev64, "");
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_vrev64, "");
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_vrev64, "");
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_vrev64, "");
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_vrev64, "");
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_vrev64, "");
+  CHECK(TEST_MSG, poly, 8, 8, PRIx8, expected_vrev64, "");
+  CHECK(TEST_MSG, poly, 16, 4, PRIx16, expected_vrev64, "");
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected_vrev64, "");
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_vrev64, "");
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_vrev64, "");
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected_vrev64, "");
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_vrev64, "");
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_vrev64, "");
+  CHECK(TEST_MSG, poly, 8, 16, PRIx8, expected_vrev64, "");
+  CHECK(TEST_MSG, poly, 16, 8, PRIx16, expected_vrev64, "");
+
+  TEST_VREV(, float, f, 32, 2, 64);
+  TEST_VREV(q, float, f, 32, 4, 64);
+  CHECK_FP(TEST_MSG, float, 32, 2, PRIx32, expected_vrev64, "");
+  CHECK_FP(TEST_MSG, float, 32, 4, PRIx32, expected_vrev64, "");
+}
+
+int main (void)
+{
+  exec_vrev ();
+  return 0;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vrshl.c
@@ -0,0 +1,627 @@
+#include <arm_neon.h>
+#include "arm-neon-ref.h"
+#include "compute-ref-data.h"
+
+/* Expected results with input=0.  */
+VECT_VAR_DECL(expected_0,int,8,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0,int,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0,int,32,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_0,int,64,1) [] = { 0x0 };
+VECT_VAR_DECL(expected_0,uint,8,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					  0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0,uint,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0,uint,32,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_0,uint,64,1) [] = { 0x0 };
+VECT_VAR_DECL(expected_0,int,8,16) [] = { 0x0, 0x0, 0x0, 0x0,
+					  0x0, 0x0, 0x0, 0x0,
+					  0x0, 0x0, 0x0, 0x0,
+					  0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0,int,16,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					  0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0,int,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0,int,64,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_0,uint,8,16) [] = { 0x0, 0x0, 0x0, 0x0,
+					   0x0, 0x0, 0x0, 0x0,
+					   0x0, 0x0, 0x0, 0x0,
+					   0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0,uint,16,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					   0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0,uint,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0,uint,64,2) [] = { 0x0, 0x0 };
+
+/* Expected results with input=0 and negative shift amount.  */
+VECT_VAR_DECL(expected_0_sh_neg,int,8,8) [] = { 0x0, 0x0, 0x0, 0x0,
+						0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0_sh_neg,int,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0_sh_neg,int,32,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_0_sh_neg,int,64,1) [] = { 0x0 };
+VECT_VAR_DECL(expected_0_sh_neg,uint,8,8) [] = { 0x0, 0x0, 0x0, 0x0,
+						 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0_sh_neg,uint,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0_sh_neg,uint,32,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_0_sh_neg,uint,64,1) [] = { 0x0 };
+VECT_VAR_DECL(expected_0_sh_neg,int,8,16) [] = { 0x0, 0x0, 0x0, 0x0,
+						 0x0, 0x0, 0x0, 0x0,
+						 0x0, 0x0, 0x0, 0x0,
+						 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0_sh_neg,int,16,8) [] = { 0x0, 0x0, 0x0, 0x0,
+						 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0_sh_neg,int,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0_sh_neg,int,64,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_0_sh_neg,uint,8,16) [] = { 0x0, 0x0, 0x0, 0x0,
+						  0x0, 0x0, 0x0, 0x0,
+						  0x0, 0x0, 0x0, 0x0,
+						  0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0_sh_neg,uint,16,8) [] = { 0x0, 0x0, 0x0, 0x0,
+						  0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0_sh_neg,uint,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0_sh_neg,uint,64,2) [] = { 0x0, 0x0 };
+
+/* Expected results.  */
+VECT_VAR_DECL(expected,int,8,8) [] = { 0xe0, 0xe2, 0xe4, 0xe6,
+				       0xe8, 0xea, 0xec, 0xee };
+VECT_VAR_DECL(expected,int,16,4) [] = { 0xff80, 0xff88, 0xff90, 0xff98 };
+VECT_VAR_DECL(expected,int,32,2) [] = { 0xfffff000, 0xfffff100 };
+VECT_VAR_DECL(expected,int,64,1) [] = { 0xfffffffffffffffe };
+VECT_VAR_DECL(expected,uint,8,8) [] = { 0xe0, 0xe2, 0xe4, 0xe6,
+					0xe8, 0xea, 0xec, 0xee };
+VECT_VAR_DECL(expected,uint,16,4) [] = { 0xff80, 0xff88, 0xff90, 0xff98 };
+VECT_VAR_DECL(expected,uint,32,2) [] = { 0xfffff000, 0xfffff100 };
+VECT_VAR_DECL(expected,uint,64,1) [] = { 0x1ffffffffffffffe };
+VECT_VAR_DECL(expected,int,8,16) [] = { 0x0, 0x0, 0x0, 0x0,
+					0x0, 0x0, 0x0, 0x0,
+					0x0, 0x0, 0x0, 0x0,
+					0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected,int,16,8) [] = { 0x0, 0x1000, 0x2000, 0x3000,
+					0x4000, 0x5000, 0x6000, 0x7000 };
+VECT_VAR_DECL(expected,int,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected,int,64,2) [] = { 0x0, 0x8000000000000000 };
+VECT_VAR_DECL(expected,uint,8,16) [] = { 0x0, 0x0, 0x0, 0x0,
+					 0x0, 0x0, 0x0, 0x0,
+					 0x0, 0x0, 0x0, 0x0,
+					 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected,uint,16,8) [] = { 0x0, 0x1000, 0x2000, 0x3000,
+					 0x4000, 0x5000, 0x6000, 0x7000 };
+VECT_VAR_DECL(expected,uint,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected,uint,64,2) [] = { 0x0, 0x8000000000000000 };
+
+/* Expected results with negative shift amount.  */
+VECT_VAR_DECL(expected_sh_neg,int,8,8) [] = { 0xf8, 0xf9, 0xf9, 0xfa,
+					      0xfa, 0xfb, 0xfb, 0xfc };
+VECT_VAR_DECL(expected_sh_neg,int,16,4) [] = { 0xfffc, 0xfffc, 0xfffd, 0xfffd };
+VECT_VAR_DECL(expected_sh_neg,int,32,2) [] = { 0xfffffffe, 0xfffffffe };
+VECT_VAR_DECL(expected_sh_neg,int,64,1) [] = { 0xffffffffffffffff };
+VECT_VAR_DECL(expected_sh_neg,uint,8,8) [] = { 0x78, 0x79, 0x79, 0x7a,
+					       0x7a, 0x7b, 0x7b, 0x7c };
+VECT_VAR_DECL(expected_sh_neg,uint,16,4) [] = { 0x3ffc, 0x3ffc, 0x3ffd, 0x3ffd };
+VECT_VAR_DECL(expected_sh_neg,uint,32,2) [] = { 0x1ffffffe, 0x1ffffffe };
+VECT_VAR_DECL(expected_sh_neg,uint,64,1) [] = { 0xfffffffffffffff };
+VECT_VAR_DECL(expected_sh_neg,int,8,16) [] = { 0x0, 0x0, 0x0, 0x0,
+					       0x0, 0x0, 0x0, 0x0,
+					       0x0, 0x0, 0x0, 0x0,
+					       0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_sh_neg,int,16,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					       0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_sh_neg,int,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_sh_neg,int,64,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_sh_neg,uint,8,16) [] = { 0x2, 0x2, 0x2, 0x2,
+						0x2, 0x2, 0x2, 0x2,
+						0x2, 0x2, 0x2, 0x2,
+						0x2, 0x2, 0x2, 0x2 };
+VECT_VAR_DECL(expected_sh_neg,uint,16,8) [] = { 0x20, 0x20, 0x20, 0x20,
+						0x20, 0x20, 0x20, 0x20 };
+VECT_VAR_DECL(expected_sh_neg,uint,32,4) [] = { 0x80000, 0x80000,
+						0x80000, 0x80000 };
+VECT_VAR_DECL(expected_sh_neg,uint,64,2) [] = { 0x100000000000, 0x100000000000 };
+
+/* Expected results with max input value shifted by -1 to test
+   round_const.  */
+VECT_VAR_DECL(expected_max_sh_minus1,int,8,8) [] = { 0x40, 0x40, 0x40, 0x40,
+						     0x40, 0x40, 0x40, 0x40 };
+VECT_VAR_DECL(expected_max_sh_minus1,int,16,4) [] = { 0x4000, 0x4000,
+						      0x4000, 0x4000 };
+VECT_VAR_DECL(expected_max_sh_minus1,int,32,2) [] = { 0x40000000, 0x40000000 };
+VECT_VAR_DECL(expected_max_sh_minus1,int,64,1) [] = { 0x4000000000000000 };
+VECT_VAR_DECL(expected_max_sh_minus1,uint,8,8) [] = { 0x80, 0x80, 0x80, 0x80,
+						      0x80, 0x80, 0x80, 0x80 };
+VECT_VAR_DECL(expected_max_sh_minus1,uint,16,4) [] = { 0x8000, 0x8000,
+						       0x8000, 0x8000 };
+VECT_VAR_DECL(expected_max_sh_minus1,uint,32,2) [] = { 0x80000000, 0x80000000 };
+VECT_VAR_DECL(expected_max_sh_minus1,uint,64,1) [] = { 0x8000000000000000 };
+VECT_VAR_DECL(expected_max_sh_minus1,int,8,16) [] = { 0x40, 0x40, 0x40, 0x40,
+						      0x40, 0x40, 0x40, 0x40,
+						      0x40, 0x40, 0x40, 0x40,
+						      0x40, 0x40, 0x40, 0x40 };
+VECT_VAR_DECL(expected_max_sh_minus1,int,16,8) [] = { 0x4000, 0x4000,
+						      0x4000, 0x4000,
+						      0x4000, 0x4000,
+						      0x4000, 0x4000 };
+VECT_VAR_DECL(expected_max_sh_minus1,int,32,4) [] = { 0x40000000, 0x40000000,
+						      0x40000000, 0x40000000 };
+VECT_VAR_DECL(expected_max_sh_minus1,int,64,2) [] = { 0x4000000000000000,
+						      0x4000000000000000 };
+VECT_VAR_DECL(expected_max_sh_minus1,uint,8,16) [] = { 0x80, 0x80, 0x80, 0x80,
+						       0x80, 0x80, 0x80, 0x80,
+						       0x80, 0x80, 0x80, 0x80,
+						       0x80, 0x80, 0x80, 0x80 };
+VECT_VAR_DECL(expected_max_sh_minus1,uint,16,8) [] = { 0x8000, 0x8000,
+						       0x8000, 0x8000,
+						       0x8000, 0x8000,
+						       0x8000, 0x8000 };
+VECT_VAR_DECL(expected_max_sh_minus1,uint,32,4) [] = { 0x80000000, 0x80000000,
+						       0x80000000, 0x80000000 };
+VECT_VAR_DECL(expected_max_sh_minus1,uint,64,2) [] = { 0x8000000000000000,
+						       0x8000000000000000 };
+
+/* Expected results with max input value shifted by -3 to test
+   round_const.  */
+VECT_VAR_DECL(expected_max_sh_minus3,int,8,8) [] = { 0x10, 0x10, 0x10, 0x10,
+						     0x10, 0x10, 0x10, 0x10 };
+VECT_VAR_DECL(expected_max_sh_minus3,int,16,4) [] = { 0x1000, 0x1000,
+						      0x1000, 0x1000 };
+VECT_VAR_DECL(expected_max_sh_minus3,int,32,2) [] = { 0x10000000, 0x10000000 };
+VECT_VAR_DECL(expected_max_sh_minus3,int,64,1) [] = { 0x1000000000000000 };
+VECT_VAR_DECL(expected_max_sh_minus3,uint,8,8) [] = { 0x20, 0x20, 0x20, 0x20,
+						      0x20, 0x20, 0x20, 0x20 };
+VECT_VAR_DECL(expected_max_sh_minus3,uint,16,4) [] = { 0x2000, 0x2000,
+						       0x2000, 0x2000 };
+VECT_VAR_DECL(expected_max_sh_minus3,uint,32,2) [] = { 0x20000000, 0x20000000 };
+VECT_VAR_DECL(expected_max_sh_minus3,uint,64,1) [] = { 0x2000000000000000 };
+VECT_VAR_DECL(expected_max_sh_minus3,int,8,16) [] = { 0x10, 0x10, 0x10, 0x10,
+						      0x10, 0x10, 0x10, 0x10,
+						      0x10, 0x10, 0x10, 0x10,
+						      0x10, 0x10, 0x10, 0x10 };
+VECT_VAR_DECL(expected_max_sh_minus3,int,16,8) [] = { 0x1000, 0x1000,
+						      0x1000, 0x1000,
+						      0x1000, 0x1000,
+						      0x1000, 0x1000 };
+VECT_VAR_DECL(expected_max_sh_minus3,int,32,4) [] = { 0x10000000, 0x10000000,
+						      0x10000000, 0x10000000 };
+VECT_VAR_DECL(expected_max_sh_minus3,int,64,2) [] = { 0x1000000000000000,
+						      0x1000000000000000 };
+VECT_VAR_DECL(expected_max_sh_minus3,uint,8,16) [] = { 0x20, 0x20, 0x20, 0x20,
+						       0x20, 0x20, 0x20, 0x20,
+						       0x20, 0x20, 0x20, 0x20,
+						       0x20, 0x20, 0x20, 0x20 };
+VECT_VAR_DECL(expected_max_sh_minus3,uint,16,8) [] = { 0x2000, 0x2000,
+						       0x2000, 0x2000,
+						       0x2000, 0x2000,
+						       0x2000, 0x2000 };
+VECT_VAR_DECL(expected_max_sh_minus3,uint,32,4) [] = { 0x20000000, 0x20000000,
+						       0x20000000, 0x20000000 };
+VECT_VAR_DECL(expected_max_sh_minus3,uint,64,2) [] = { 0x2000000000000000,
+						       0x2000000000000000 };
+
+/* Expected results with negative shift by vector width.  */
+VECT_VAR_DECL(expected_max_sh_minus_width,int,8,8) [] = { 0x0, 0x0, 0x0, 0x0,
+							  0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_max_sh_minus_width,int,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_max_sh_minus_width,int,32,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_max_sh_minus_width,int,64,1) [] = { 0x0 };
+VECT_VAR_DECL(expected_max_sh_minus_width,uint,8,8) [] = { 0x1, 0x1, 0x1, 0x1,
+							   0x1, 0x1, 0x1, 0x1 };
+VECT_VAR_DECL(expected_max_sh_minus_width,uint,16,4) [] = { 0x1, 0x1, 0x1, 0x1 };
+VECT_VAR_DECL(expected_max_sh_minus_width,uint,32,2) [] = { 0x1, 0x1 };
+VECT_VAR_DECL(expected_max_sh_minus_width,uint,64,1) [] = { 0x1 };
+VECT_VAR_DECL(expected_max_sh_minus_width,int,8,16) [] = { 0x0, 0x0, 0x0, 0x0,
+							   0x0, 0x0, 0x0, 0x0,
+							   0x0, 0x0, 0x0, 0x0,
+							   0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_max_sh_minus_width,int,16,8) [] = { 0x0, 0x0, 0x0, 0x0,
+							   0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_max_sh_minus_width,int,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_max_sh_minus_width,int,64,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_max_sh_minus_width,uint,8,16) [] = { 0x1, 0x1, 0x1, 0x1,
+							    0x1, 0x1, 0x1, 0x1,
+							    0x1, 0x1, 0x1, 0x1,
+							    0x1, 0x1, 0x1, 0x1 };
+VECT_VAR_DECL(expected_max_sh_minus_width,uint,16,8) [] = { 0x1, 0x1, 0x1, 0x1,
+							    0x1, 0x1, 0x1, 0x1 };
+VECT_VAR_DECL(expected_max_sh_minus_width,uint,32,4) [] = { 0x1, 0x1, 0x1, 0x1 };
+VECT_VAR_DECL(expected_max_sh_minus_width,uint,64,2) [] = { 0x1, 0x1 };
+
+/* Expected results with large shift amount.  */
+VECT_VAR_DECL(expected_max_sh_large,int,8,8) [] = { 0x0, 0x0, 0x0, 0x0,
+						    0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_max_sh_large,int,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_max_sh_large,int,32,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_max_sh_large,int,64,1) [] = { 0x0 };
+VECT_VAR_DECL(expected_max_sh_large,uint,8,8) [] = { 0x0, 0x0, 0x0, 0x0,
+						     0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_max_sh_large,uint,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_max_sh_large,uint,32,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_max_sh_large,uint,64,1) [] = { 0x0 };
+VECT_VAR_DECL(expected_max_sh_large,int,8,16) [] = { 0x0, 0x0, 0x0, 0x0,
+						     0x0, 0x0, 0x0, 0x0,
+						     0x0, 0x0, 0x0, 0x0,
+						     0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_max_sh_large,int,16,8) [] = { 0x0, 0x0, 0x0, 0x0,
+						     0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_max_sh_large,int,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_max_sh_large,int,64,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_max_sh_large,uint,8,16) [] = { 0x0, 0x0, 0x0, 0x0,
+						      0x0, 0x0, 0x0, 0x0,
+						      0x0, 0x0, 0x0, 0x0,
+						      0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_max_sh_large,uint,16,8) [] = { 0x0, 0x0, 0x0, 0x0,
+						      0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_max_sh_large,uint,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_max_sh_large,uint,64,2) [] = { 0x0, 0x0 };
+
+/* Expected results with large negative shift amount.  */
+VECT_VAR_DECL(expected_max_sh_large_neg,int,8,8) [] = { 0x0, 0x0, 0x0, 0x0,
+							0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_max_sh_large_neg,int,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_max_sh_large_neg,int,32,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_max_sh_large_neg,int,64,1) [] = { 0x0 };
+VECT_VAR_DECL(expected_max_sh_large_neg,uint,8,8) [] = { 0x0, 0x0, 0x0, 0x0,
+							 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_max_sh_large_neg,uint,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_max_sh_large_neg,uint,32,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_max_sh_large_neg,uint,64,1) [] = { 0x0 };
+VECT_VAR_DECL(expected_max_sh_large_neg,int,8,16) [] = { 0x0, 0x0, 0x0, 0x0,
+							 0x0, 0x0, 0x0, 0x0,
+							 0x0, 0x0, 0x0, 0x0,
+							 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_max_sh_large_neg,int,16,8) [] = { 0x0, 0x0, 0x0, 0x0,
+							 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_max_sh_large_neg,int,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_max_sh_large_neg,int,64,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_max_sh_large_neg,uint,8,16) [] = { 0x0, 0x0, 0x0, 0x0,
+							  0x0, 0x0, 0x0, 0x0,
+							  0x0, 0x0, 0x0, 0x0,
+							  0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_max_sh_large_neg,uint,16,8) [] = { 0x1, 0x1, 0x1, 0x1,
+							  0x1, 0x1, 0x1, 0x1 };
+VECT_VAR_DECL(expected_max_sh_large_neg,uint,32,4) [] = { 0x1, 0x1, 0x1, 0x1 };
+VECT_VAR_DECL(expected_max_sh_large_neg,uint,64,2) [] = { 0x1, 0x1 };
+
+#define TEST_MSG "VRSHL/VRSHLQ"
+void exec_vrshl (void)
+{
+  /* Basic test: v3=vrshl(v1,v2), then store the result.  */
+#define TEST_VRSHL(T3, Q, T1, T2, W, N)					\
+  VECT_VAR(vector_res, T1, W, N) =					\
+    vrshl##Q##_##T2##W(VECT_VAR(vector, T1, W, N),			\
+		       VECT_VAR(vector_shift, T3, W, N));		\
+  vst1##Q##_##T2##W(VECT_VAR(result, T1, W, N), VECT_VAR(vector_res, T1, W, N))
+
+  DECL_VARIABLE_ALL_VARIANTS(vector);
+  DECL_VARIABLE_ALL_VARIANTS(vector_res);
+
+  DECL_VARIABLE_SIGNED_VARIANTS(vector_shift);
+
+  clean_results ();
+
+  /* Fill input vector with 0, to check behavior on limits.  */
+  VDUP(vector, , int, s, 8, 8, 0);
+  VDUP(vector, , int, s, 16, 4, 0);
+  VDUP(vector, , int, s, 32, 2, 0);
+  VDUP(vector, , int, s, 64, 1, 0);
+  VDUP(vector, , uint, u, 8, 8, 0);
+  VDUP(vector, , uint, u, 16, 4, 0);
+  VDUP(vector, , uint, u, 32, 2, 0);
+  VDUP(vector, , uint, u, 64, 1, 0);
+  VDUP(vector, q, int, s, 8, 16, 0);
+  VDUP(vector, q, int, s, 16, 8, 0);
+  VDUP(vector, q, int, s, 32, 4, 0);
+  VDUP(vector, q, int, s, 64, 2, 0);
+  VDUP(vector, q, uint, u, 8, 16, 0);
+  VDUP(vector, q, uint, u, 16, 8, 0);
+  VDUP(vector, q, uint, u, 32, 4, 0);
+  VDUP(vector, q, uint, u, 64, 2, 0);
+
+  /* Choose init value arbitrarily, will be used as shift amount.  */
+  /* Use values equal to one-less-than the type width to check
+     behaviour on limits.  */
+  VDUP(vector_shift, , int, s, 8, 8, 7);
+  VDUP(vector_shift, , int, s, 16, 4, 15);
+  VDUP(vector_shift, , int, s, 32, 2, 31);
+  VDUP(vector_shift, , int, s, 64, 1, 63);
+  VDUP(vector_shift, q, int, s, 8, 16, 7);
+  VDUP(vector_shift, q, int, s, 16, 8, 15);
+  VDUP(vector_shift, q, int, s, 32, 4, 31);
+  VDUP(vector_shift, q, int, s, 64, 2, 63);
+
+  TEST_MACRO_ALL_VARIANTS_1_5(TEST_VRSHL, int);
+
+#define CMT " (with input = 0)"
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_0, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_0, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_0, CMT);
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected_0, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_0, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_0, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_0, CMT);
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected_0, CMT);
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected_0, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_0, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_0, CMT);
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected_0, CMT);
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected_0, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_0, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_0, CMT);
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected_0, CMT);
+
+
+  /* Use negative shift amounts.  */
+  VDUP(vector_shift, , int, s, 8, 8, -1);
+  VDUP(vector_shift, , int, s, 16, 4, -2);
+  VDUP(vector_shift, , int, s, 32, 2, -3);
+  VDUP(vector_shift, , int, s, 64, 1, -4);
+  VDUP(vector_shift, q, int, s, 8, 16, -7);
+  VDUP(vector_shift, q, int, s, 16, 8, -11);
+  VDUP(vector_shift, q, int, s, 32, 4, -13);
+  VDUP(vector_shift, q, int, s, 64, 2, -20);
+
+  TEST_MACRO_ALL_VARIANTS_1_5(TEST_VRSHL, int);
+
+#undef CMT
+#define CMT " (input 0 and negative shift amount)"
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_0_sh_neg, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_0_sh_neg, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_0_sh_neg, CMT);
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected_0_sh_neg, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_0_sh_neg, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_0_sh_neg, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_0_sh_neg, CMT);
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected_0_sh_neg, CMT);
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected_0_sh_neg, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_0_sh_neg, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_0_sh_neg, CMT);
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected_0_sh_neg, CMT);
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected_0_sh_neg, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_0_sh_neg, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_0_sh_neg, CMT);
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected_0_sh_neg, CMT);
+
+
+  /* Test again, with predefined input values.  */
+  TEST_MACRO_ALL_VARIANTS_2_5(VLOAD, vector, buffer);
+
+  /* Choose init value arbitrarily, will be used as shift amount.  */
+  VDUP(vector_shift, , int, s, 8, 8, 1);
+  VDUP(vector_shift, , int, s, 16, 4, 3);
+  VDUP(vector_shift, , int, s, 32, 2, 8);
+  VDUP(vector_shift, , int, s, 64, 1, -3);
+  VDUP(vector_shift, q, int, s, 8, 16, 10);
+  VDUP(vector_shift, q, int, s, 16, 8, 12);
+  VDUP(vector_shift, q, int, s, 32, 4, 32);
+  VDUP(vector_shift, q, int, s, 64, 2, 63);
+
+  TEST_MACRO_ALL_VARIANTS_1_5(TEST_VRSHL, int);
+
+#undef CMT
+#define CMT ""
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected, CMT);
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected, CMT);
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected, CMT);
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected, CMT);
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected, CMT);
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected, CMT);
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected, CMT);
+
+
+  /* Use negative shift amounts.  */
+  VDUP(vector_shift, , int, s, 8, 8, -1);
+  VDUP(vector_shift, , int, s, 16, 4, -2);
+  VDUP(vector_shift, , int, s, 32, 2, -3);
+  VDUP(vector_shift, , int, s, 64, 1, -4);
+  VDUP(vector_shift, q, int, s, 8, 16, -7);
+  VDUP(vector_shift, q, int, s, 16, 8, -11);
+  VDUP(vector_shift, q, int, s, 32, 4, -13);
+  VDUP(vector_shift, q, int, s, 64, 2, -20);
+
+  TEST_MACRO_ALL_VARIANTS_1_5(TEST_VRSHL, int);
+
+#undef CMT
+#define CMT " (negative shift amount)"
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_sh_neg, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_sh_neg, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_sh_neg, CMT);
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected_sh_neg, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_sh_neg, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_sh_neg, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_sh_neg, CMT);
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected_sh_neg, CMT);
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected_sh_neg, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_sh_neg, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_sh_neg, CMT);
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected_sh_neg, CMT);
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected_sh_neg, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_sh_neg, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_sh_neg, CMT);
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected_sh_neg, CMT);
+
+  /* Fill input vector with max value, to check behavior on limits.  */
+  VDUP(vector, , int, s, 8, 8, 0x7F);
+  VDUP(vector, , int, s, 16, 4, 0x7FFF);
+  VDUP(vector, , int, s, 32, 2, 0x7FFFFFFF);
+  VDUP(vector, , int, s, 64, 1, 0x7FFFFFFFFFFFFFFFLL);
+  VDUP(vector, , uint, u, 8, 8, 0xFF);
+  VDUP(vector, , uint, u, 16, 4, 0xFFFF);
+  VDUP(vector, , uint, u, 32, 2, 0xFFFFFFFF);
+  VDUP(vector, , uint, u, 64, 1, 0xFFFFFFFFFFFFFFFFULL);
+  VDUP(vector, q, int, s, 8, 16, 0x7F);
+  VDUP(vector, q, int, s, 16, 8, 0x7FFF);
+  VDUP(vector, q, int, s, 32, 4, 0x7FFFFFFF);
+  VDUP(vector, q, int, s, 64, 2, 0x7FFFFFFFFFFFFFFFLL);
+  VDUP(vector, q, uint, u, 8, 16, 0xFF);
+  VDUP(vector, q, uint, u, 16, 8, 0xFFFF);
+  VDUP(vector, q, uint, u, 32, 4, 0xFFFFFFFF);
+  VDUP(vector, q, uint, u, 64, 2, 0xFFFFFFFFFFFFFFFFULL);
+
+  /* Use -1 shift amount to check overflow with round_const.  */
+  VDUP(vector_shift, , int, s, 8, 8, -1);
+  VDUP(vector_shift, , int, s, 16, 4, -1);
+  VDUP(vector_shift, , int, s, 32, 2, -1);
+  VDUP(vector_shift, , int, s, 64, 1, -1);
+  VDUP(vector_shift, q, int, s, 8, 16, -1);
+  VDUP(vector_shift, q, int, s, 16, 8, -1);
+  VDUP(vector_shift, q, int, s, 32, 4, -1);
+  VDUP(vector_shift, q, int, s, 64, 2, -1);
+
+  TEST_MACRO_ALL_VARIANTS_1_5(TEST_VRSHL, int);
+
+#undef CMT
+#define CMT " (max input, shift by -1)"
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_max_sh_minus1, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_max_sh_minus1, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_max_sh_minus1, CMT);
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected_max_sh_minus1, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_max_sh_minus1, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_max_sh_minus1, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_max_sh_minus1, CMT);
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected_max_sh_minus1, CMT);
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected_max_sh_minus1, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_max_sh_minus1, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_max_sh_minus1, CMT);
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected_max_sh_minus1, CMT);
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected_max_sh_minus1, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_max_sh_minus1, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_max_sh_minus1, CMT);
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected_max_sh_minus1, CMT);
+
+  /* Use -3 shift amount to check overflow with round_const.  */
+  VDUP(vector_shift, , int, s, 8, 8, -3);
+  VDUP(vector_shift, , int, s, 16, 4, -3);
+  VDUP(vector_shift, , int, s, 32, 2, -3);
+  VDUP(vector_shift, , int, s, 64, 1, -3);
+  VDUP(vector_shift, q, int, s, 8, 16, -3);
+  VDUP(vector_shift, q, int, s, 16, 8, -3);
+  VDUP(vector_shift, q, int, s, 32, 4, -3);
+  VDUP(vector_shift, q, int, s, 64, 2, -3);
+
+  TEST_MACRO_ALL_VARIANTS_1_5(TEST_VRSHL, int);
+
+#undef CMT
+#define CMT " (check rounding constant: max input, shift by -3)"
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_max_sh_minus3, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_max_sh_minus3, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_max_sh_minus3, CMT);
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected_max_sh_minus3, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_max_sh_minus3, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_max_sh_minus3, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_max_sh_minus3, CMT);
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected_max_sh_minus3, CMT);
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected_max_sh_minus3, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_max_sh_minus3, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_max_sh_minus3, CMT);
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected_max_sh_minus3, CMT);
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected_max_sh_minus3, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_max_sh_minus3, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_max_sh_minus3, CMT);
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected_max_sh_minus3, CMT);
+
+
+  /* Use negative shift amount as large as input vector width.  */
+  VDUP(vector_shift, , int, s, 8, 8, -8);
+  VDUP(vector_shift, , int, s, 16, 4, -16);
+  VDUP(vector_shift, , int, s, 32, 2, -32);
+  VDUP(vector_shift, , int, s, 64, 1, -64);
+  VDUP(vector_shift, q, int, s, 8, 16, -8);
+  VDUP(vector_shift, q, int, s, 16, 8, -16);
+  VDUP(vector_shift, q, int, s, 32, 4, -32);
+  VDUP(vector_shift, q, int, s, 64, 2, -64);
+
+  TEST_MACRO_ALL_VARIANTS_1_5(TEST_VRSHL, int);
+
+#undef CMT
+#define CMT " (max input, right shift by vector width)"
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_max_sh_minus_width, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_max_sh_minus_width, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_max_sh_minus_width, CMT);
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected_max_sh_minus_width, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_max_sh_minus_width, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_max_sh_minus_width, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_max_sh_minus_width, CMT);
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected_max_sh_minus_width, CMT);
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected_max_sh_minus_width, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_max_sh_minus_width, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_max_sh_minus_width, CMT);
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected_max_sh_minus_width, CMT);
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected_max_sh_minus_width, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_max_sh_minus_width, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_max_sh_minus_width, CMT);
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected_max_sh_minus_width, CMT);
+
+
+  /* Test large shift amount.  */
+  VDUP(vector_shift, , int, s, 8, 8, 10);
+  VDUP(vector_shift, , int, s, 16, 4, 20);
+  VDUP(vector_shift, , int, s, 32, 2, 33);
+  VDUP(vector_shift, , int, s, 64, 1, 65);
+  VDUP(vector_shift, q, int, s, 8, 16, 9);
+  VDUP(vector_shift, q, int, s, 16, 8, 16);
+  VDUP(vector_shift, q, int, s, 32, 4, 32);
+  VDUP(vector_shift, q, int, s, 64, 2, 64);
+
+  TEST_MACRO_ALL_VARIANTS_1_5(TEST_VRSHL, int);
+
+#undef CMT
+#define CMT " (max input, large shift amount)"
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_max_sh_large, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_max_sh_large, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_max_sh_large, CMT);
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected_max_sh_large, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_max_sh_large, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_max_sh_large, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_max_sh_large, CMT);
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected_max_sh_large, CMT);
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected_max_sh_large, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_max_sh_large, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_max_sh_large, CMT);
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected_max_sh_large, CMT);
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected_max_sh_large, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_max_sh_large, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_max_sh_large, CMT);
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected_max_sh_large, CMT);
+
+  
+  /* Test large negative shift amount.  */
+  VDUP(vector_shift, , int, s, 8, 8, -10);
+  VDUP(vector_shift, , int, s, 16, 4, -20);
+  VDUP(vector_shift, , int, s, 32, 2, -33);
+  VDUP(vector_shift, , int, s, 64, 1, -65);
+  VDUP(vector_shift, q, int, s, 8, 16, -9);
+  VDUP(vector_shift, q, int, s, 16, 8, -16);
+  VDUP(vector_shift, q, int, s, 32, 4, -32);
+  VDUP(vector_shift, q, int, s, 64, 2, -64);
+
+  TEST_MACRO_ALL_VARIANTS_1_5(TEST_VRSHL, int);
+
+#undef CMT
+#define CMT " (max input, large negative shift amount)"
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_max_sh_large_neg, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_max_sh_large_neg, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_max_sh_large_neg, CMT);
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected_max_sh_large_neg, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_max_sh_large_neg, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_max_sh_large_neg, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_max_sh_large_neg, CMT);
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected_max_sh_large_neg, CMT);
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected_max_sh_large_neg, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_max_sh_large_neg, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_max_sh_large_neg, CMT);
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected_max_sh_large_neg, CMT);
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected_max_sh_large_neg, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_max_sh_large_neg, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_max_sh_large_neg, CMT);
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected_max_sh_large_neg, CMT);
+}
+
+int main (void)
+{
+  exec_vrshl ();
+  return 0;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vrshr_n.c
@@ -0,0 +1,504 @@
+#include <arm_neon.h>
+#include "arm-neon-ref.h"
+#include "compute-ref-data.h"
+
+/* Expected results.  */
+VECT_VAR_DECL(expected,int,8,8) [] = { 0xf8, 0xf9, 0xf9, 0xfa,
+				       0xfa, 0xfb, 0xfb, 0xfc };
+VECT_VAR_DECL(expected,int,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected,int,32,2) [] = { 0xfffffffc, 0xfffffffc };
+VECT_VAR_DECL(expected,int,64,1) [] = { 0x0 };
+VECT_VAR_DECL(expected,uint,8,8) [] = { 0x3c, 0x3c, 0x3d, 0x3d,
+					0x3d, 0x3d, 0x3e, 0x3e };
+VECT_VAR_DECL(expected,uint,16,4) [] = { 0x1ffe, 0x1ffe, 0x1ffe, 0x1ffe };
+VECT_VAR_DECL(expected,uint,32,2) [] = { 0x8000000, 0x8000000 };
+VECT_VAR_DECL(expected,uint,64,1) [] = { 0x80000000 };
+VECT_VAR_DECL(expected,int,8,16) [] = { 0xf8, 0xf9, 0xf9, 0xfa,
+					0xfa, 0xfb, 0xfb, 0xfc,
+					0xfc, 0xfd, 0xfd, 0xfe,
+					0xfe, 0xff, 0xff, 0x0 };
+VECT_VAR_DECL(expected,int,16,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected,int,32,4) [] = { 0xfffffffc, 0xfffffffc,
+					0xfffffffd, 0xfffffffd };
+VECT_VAR_DECL(expected,int,64,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected,uint,8,16) [] = { 0x3c, 0x3c, 0x3d, 0x3d,
+					 0x3d, 0x3d, 0x3e, 0x3e,
+					 0x3e, 0x3e, 0x3f, 0x3f,
+					 0x3f, 0x3f, 0x40, 0x40 };
+VECT_VAR_DECL(expected,uint,16,8) [] = { 0x1ffe, 0x1ffe, 0x1ffe, 0x1ffe,
+					 0x1fff, 0x1fff, 0x1fff, 0x1fff };
+VECT_VAR_DECL(expected,uint,32,4) [] = { 0x8000000, 0x8000000,
+					 0x8000000, 0x8000000 };
+VECT_VAR_DECL(expected,uint,64,2) [] = { 0x80000000, 0x80000000 };
+
+/* Expected results with maximum input and max shift amount.  */
+VECT_VAR_DECL(expected_max_sh_max,int,8,8) [] = { 0x0, 0x0, 0x0, 0x0,
+						  0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_max_sh_max,int,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_max_sh_max,int,32,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_max_sh_max,int,64,1) [] = { 0x0 };
+VECT_VAR_DECL(expected_max_sh_max,uint,8,8) [] = { 0x1, 0x1, 0x1, 0x1,
+						   0x1, 0x1, 0x1, 0x1 };
+VECT_VAR_DECL(expected_max_sh_max,uint,16,4) [] = { 0x1, 0x1, 0x1, 0x1 };
+VECT_VAR_DECL(expected_max_sh_max,uint,32,2) [] = { 0x1, 0x1 };
+VECT_VAR_DECL(expected_max_sh_max,uint,64,1) [] = { 0x1 };
+VECT_VAR_DECL(expected_max_sh_max,int,8,16) [] = { 0x0, 0x0, 0x0, 0x0,
+						   0x0, 0x0, 0x0, 0x0,
+						   0x0, 0x0, 0x0, 0x0,
+						   0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_max_sh_max,int,16,8) [] = { 0x0, 0x0, 0x0, 0x0,
+						   0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_max_sh_max,int,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_max_sh_max,int,64,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_max_sh_max,uint,8,16) [] = { 0x1, 0x1, 0x1, 0x1,
+						    0x1, 0x1, 0x1, 0x1,
+						    0x1, 0x1, 0x1, 0x1,
+						    0x1, 0x1, 0x1, 0x1 };
+VECT_VAR_DECL(expected_max_sh_max,uint,16,8) [] = { 0x1, 0x1, 0x1, 0x1,
+						    0x1, 0x1, 0x1, 0x1 };
+VECT_VAR_DECL(expected_max_sh_max,uint,32,4) [] = { 0x1, 0x1, 0x1, 0x1 };
+VECT_VAR_DECL(expected_max_sh_max,uint,64,2) [] = { 0x1, 0x1 };
+
+/* Expected results with maximum input and shift by 1.  */
+VECT_VAR_DECL(expected_max_sh_1,int,8,8) [] = { 0x40, 0x40, 0x40, 0x40,
+						0x40, 0x40, 0x40, 0x40 };
+VECT_VAR_DECL(expected_max_sh_1,int,16,4) [] = { 0x4000, 0x4000,
+						 0x4000, 0x4000 };
+VECT_VAR_DECL(expected_max_sh_1,int,32,2) [] = { 0x40000000, 0x40000000 };
+VECT_VAR_DECL(expected_max_sh_1,int,64,1) [] = { 0x4000000000000000 };
+VECT_VAR_DECL(expected_max_sh_1,uint,8,8) [] = { 0x80, 0x80, 0x80, 0x80,
+						 0x80, 0x80, 0x80, 0x80 };
+VECT_VAR_DECL(expected_max_sh_1,uint,16,4) [] = { 0x8000, 0x8000,
+						  0x8000, 0x8000 };
+VECT_VAR_DECL(expected_max_sh_1,uint,32,2) [] = { 0x80000000, 0x80000000 };
+VECT_VAR_DECL(expected_max_sh_1,uint,64,1) [] = { 0x8000000000000000 };
+VECT_VAR_DECL(expected_max_sh_1,int,8,16) [] = { 0x40, 0x40, 0x40, 0x40,
+						 0x40, 0x40, 0x40, 0x40,
+						 0x40, 0x40, 0x40, 0x40,
+						 0x40, 0x40, 0x40, 0x40 };
+VECT_VAR_DECL(expected_max_sh_1,int,16,8) [] = { 0x4000, 0x4000,
+						 0x4000, 0x4000,
+						 0x4000, 0x4000,
+						 0x4000, 0x4000 };
+VECT_VAR_DECL(expected_max_sh_1,int,32,4) [] = { 0x40000000, 0x40000000,
+						 0x40000000, 0x40000000 };
+VECT_VAR_DECL(expected_max_sh_1,int,64,2) [] = { 0x4000000000000000,
+						 0x4000000000000000 };
+VECT_VAR_DECL(expected_max_sh_1,uint,8,16) [] = { 0x80, 0x80, 0x80, 0x80,
+						  0x80, 0x80, 0x80, 0x80,
+						  0x80, 0x80, 0x80, 0x80,
+						  0x80, 0x80, 0x80, 0x80 };
+VECT_VAR_DECL(expected_max_sh_1,uint,16,8) [] = { 0x8000, 0x8000,
+						  0x8000, 0x8000,
+						  0x8000, 0x8000,
+						  0x8000, 0x8000 };
+VECT_VAR_DECL(expected_max_sh_1,uint,32,4) [] = { 0x80000000, 0x80000000,
+						  0x80000000, 0x80000000 };
+VECT_VAR_DECL(expected_max_sh_1,uint,64,2) [] = { 0x8000000000000000,
+						  0x8000000000000000 };
+
+/* Expected results with maximum input and shift by 3.  */
+VECT_VAR_DECL(expected_max_sh_3,int,8,8) [] = { 0x10, 0x10, 0x10, 0x10,
+						0x10, 0x10, 0x10, 0x10 };
+VECT_VAR_DECL(expected_max_sh_3,int,16,4) [] = { 0x1000, 0x1000,
+						 0x1000, 0x1000 };
+VECT_VAR_DECL(expected_max_sh_3,int,32,2) [] = { 0x10000000, 0x10000000 };
+VECT_VAR_DECL(expected_max_sh_3,int,64,1) [] = { 0x1000000000000000 };
+VECT_VAR_DECL(expected_max_sh_3,uint,8,8) [] = { 0x20, 0x20, 0x20, 0x20,
+						 0x20, 0x20, 0x20, 0x20 };
+VECT_VAR_DECL(expected_max_sh_3,uint,16,4) [] = { 0x2000, 0x2000,
+						  0x2000, 0x2000 };
+VECT_VAR_DECL(expected_max_sh_3,uint,32,2) [] = { 0x20000000, 0x20000000 };
+VECT_VAR_DECL(expected_max_sh_3,uint,64,1) [] = { 0x2000000000000000 };
+VECT_VAR_DECL(expected_max_sh_3,int,8,16) [] = { 0x10, 0x10, 0x10, 0x10,
+						 0x10, 0x10, 0x10, 0x10,
+						 0x10, 0x10, 0x10, 0x10,
+						 0x10, 0x10, 0x10, 0x10 };
+VECT_VAR_DECL(expected_max_sh_3,int,16,8) [] = { 0x1000, 0x1000,
+						 0x1000, 0x1000,
+						 0x1000, 0x1000,
+						 0x1000, 0x1000 };
+VECT_VAR_DECL(expected_max_sh_3,int,32,4) [] = { 0x10000000, 0x10000000,
+						 0x10000000, 0x10000000 };
+VECT_VAR_DECL(expected_max_sh_3,int,64,2) [] = { 0x1000000000000000,
+						 0x1000000000000000 };
+VECT_VAR_DECL(expected_max_sh_3,uint,8,16) [] = { 0x20, 0x20, 0x20, 0x20,
+						  0x20, 0x20, 0x20, 0x20,
+						  0x20, 0x20, 0x20, 0x20,
+						  0x20, 0x20, 0x20, 0x20 };
+VECT_VAR_DECL(expected_max_sh_3,uint,16,8) [] = { 0x2000, 0x2000,
+						  0x2000, 0x2000,
+						  0x2000, 0x2000,
+						  0x2000, 0x2000 };
+VECT_VAR_DECL(expected_max_sh_3,uint,32,4) [] = { 0x20000000, 0x20000000,
+						  0x20000000, 0x20000000 };
+VECT_VAR_DECL(expected_max_sh_3,uint,64,2) [] = { 0x2000000000000000,
+						  0x2000000000000000 };
+
+/* Expected results with max negative input (for signed types, shift
+   by 1.  */
+VECT_VAR_DECL(expected_max_neg_sh_1,int,8,8) [] = { 0xc0, 0xc0, 0xc0, 0xc0,
+						    0xc0, 0xc0, 0xc0, 0xc0 };
+VECT_VAR_DECL(expected_max_neg_sh_1,int,16,4) [] = { 0xc000, 0xc000,
+						     0xc000, 0xc000 };
+VECT_VAR_DECL(expected_max_neg_sh_1,int,32,2) [] = { 0xc0000000, 0xc0000000 };
+VECT_VAR_DECL(expected_max_neg_sh_1,int,64,1) [] = { 0xc000000000000000 };
+VECT_VAR_DECL(expected_max_neg_sh_1,uint,8,8) [] = { 0x80, 0x80, 0x80, 0x80,
+						     0x80, 0x80, 0x80, 0x80 };
+VECT_VAR_DECL(expected_max_neg_sh_1,uint,16,4) [] = { 0x8000, 0x8000,
+						      0x8000, 0x8000 };
+VECT_VAR_DECL(expected_max_neg_sh_1,uint,32,2) [] = { 0x80000000, 0x80000000 };
+VECT_VAR_DECL(expected_max_neg_sh_1,uint,64,1) [] = { 0x8000000000000000 };
+VECT_VAR_DECL(expected_max_neg_sh_1,int,8,16) [] = { 0xc0, 0xc0, 0xc0, 0xc0,
+						     0xc0, 0xc0, 0xc0, 0xc0,
+						     0xc0, 0xc0, 0xc0, 0xc0,
+						     0xc0, 0xc0, 0xc0, 0xc0 };
+VECT_VAR_DECL(expected_max_neg_sh_1,int,16,8) [] = { 0xc000, 0xc000,
+						     0xc000, 0xc000,
+						     0xc000, 0xc000,
+						     0xc000, 0xc000 };
+VECT_VAR_DECL(expected_max_neg_sh_1,int,32,4) [] = { 0xc0000000, 0xc0000000,
+						     0xc0000000, 0xc0000000 };
+VECT_VAR_DECL(expected_max_neg_sh_1,int,64,2) [] = { 0xc000000000000000,
+						     0xc000000000000000 };
+VECT_VAR_DECL(expected_max_neg_sh_1,uint,8,16) [] = { 0x80, 0x80, 0x80, 0x80,
+						      0x80, 0x80, 0x80, 0x80,
+						      0x80, 0x80, 0x80, 0x80,
+						      0x80, 0x80, 0x80, 0x80 };
+VECT_VAR_DECL(expected_max_neg_sh_1,uint,16,8) [] = { 0x8000, 0x8000,
+						      0x8000, 0x8000,
+						      0x8000, 0x8000,
+						      0x8000, 0x8000 };
+VECT_VAR_DECL(expected_max_neg_sh_1,uint,32,4) [] = { 0x80000000, 0x80000000,
+						      0x80000000, 0x80000000 };
+VECT_VAR_DECL(expected_max_neg_sh_1,uint,64,2) [] = { 0x8000000000000000,
+						      0x8000000000000000 };
+
+/* Expected results with max negative input (for signed types, shift
+   by 3.  */
+VECT_VAR_DECL(expected_max_neg_sh_3,int,8,8) [] = { 0xf0, 0xf0, 0xf0, 0xf0,
+						    0xf0, 0xf0, 0xf0, 0xf0 };
+VECT_VAR_DECL(expected_max_neg_sh_3,int,16,4) [] = { 0xf000, 0xf000,
+						     0xf000, 0xf000 };
+VECT_VAR_DECL(expected_max_neg_sh_3,int,32,2) [] = { 0xf0000000, 0xf0000000 };
+VECT_VAR_DECL(expected_max_neg_sh_3,int,64,1) [] = { 0xf000000000000000 };
+VECT_VAR_DECL(expected_max_neg_sh_3,uint,8,8) [] = { 0x20, 0x20, 0x20, 0x20,
+						     0x20, 0x20, 0x20, 0x20 };
+VECT_VAR_DECL(expected_max_neg_sh_3,uint,16,4) [] = { 0x2000, 0x2000,
+						      0x2000, 0x2000 };
+VECT_VAR_DECL(expected_max_neg_sh_3,uint,32,2) [] = { 0x20000000, 0x20000000 };
+VECT_VAR_DECL(expected_max_neg_sh_3,uint,64,1) [] = { 0x2000000000000000 };
+VECT_VAR_DECL(expected_max_neg_sh_3,int,8,16) [] = { 0xf0, 0xf0, 0xf0, 0xf0,
+						     0xf0, 0xf0, 0xf0, 0xf0,
+						     0xf0, 0xf0, 0xf0, 0xf0,
+						     0xf0, 0xf0, 0xf0, 0xf0 };
+VECT_VAR_DECL(expected_max_neg_sh_3,int,16,8) [] = { 0xf000, 0xf000,
+						     0xf000, 0xf000,
+						     0xf000, 0xf000,
+						     0xf000, 0xf000 };
+VECT_VAR_DECL(expected_max_neg_sh_3,int,32,4) [] = { 0xf0000000, 0xf0000000,
+						     0xf0000000, 0xf0000000 };
+VECT_VAR_DECL(expected_max_neg_sh_3,int,64,2) [] = { 0xf000000000000000,
+						     0xf000000000000000 };
+VECT_VAR_DECL(expected_max_neg_sh_3,uint,8,16) [] = { 0x20, 0x20, 0x20, 0x20,
+						      0x20, 0x20, 0x20, 0x20,
+						      0x20, 0x20, 0x20, 0x20,
+						      0x20, 0x20, 0x20, 0x20 };
+VECT_VAR_DECL(expected_max_neg_sh_3,uint,16,8) [] = { 0x2000, 0x2000,
+						      0x2000, 0x2000,
+						      0x2000, 0x2000,
+						      0x2000, 0x2000 };
+VECT_VAR_DECL(expected_max_neg_sh_3,uint,32,4) [] = { 0x20000000, 0x20000000,
+						      0x20000000, 0x20000000 };
+VECT_VAR_DECL(expected_max_neg_sh_3,uint,64,2) [] = { 0x2000000000000000,
+						      0x2000000000000000 };
+
+#define TEST_MSG "VRSHR_N"
+void exec_vrshr_n (void)
+{
+  /* Basic test: y=vrshr_n(x,v), then store the result.  */
+#define TEST_VRSHR_N(Q, T1, T2, W, N, V)				\
+  VECT_VAR(vector_res, T1, W, N) =					\
+    vrshr##Q##_n_##T2##W(VECT_VAR(vector, T1, W, N),			\
+			 V);						\
+  vst1##Q##_##T2##W(VECT_VAR(result, T1, W, N), VECT_VAR(vector_res, T1, W, N))
+
+  DECL_VARIABLE_ALL_VARIANTS(vector);
+  DECL_VARIABLE_ALL_VARIANTS(vector_res);
+
+  clean_results ();
+
+  /* Initialize input "vector" from "buffer".  */
+  TEST_MACRO_ALL_VARIANTS_2_5(VLOAD, vector, buffer);
+
+  /* Choose shift amount arbitrarily.  */
+  TEST_VRSHR_N(, int, s, 8, 8, 1);
+  TEST_VRSHR_N(, int, s, 16, 4, 12);
+  TEST_VRSHR_N(, int, s, 32, 2, 2);
+  TEST_VRSHR_N(, int, s, 64, 1, 32);
+  TEST_VRSHR_N(, uint, u, 8, 8, 2);
+  TEST_VRSHR_N(, uint, u, 16, 4, 3);
+  TEST_VRSHR_N(, uint, u, 32, 2, 5);
+  TEST_VRSHR_N(, uint, u, 64, 1, 33);
+
+  TEST_VRSHR_N(q, int, s, 8, 16, 1);
+  TEST_VRSHR_N(q, int, s, 16, 8, 12);
+  TEST_VRSHR_N(q, int, s, 32, 4, 2);
+  TEST_VRSHR_N(q, int, s, 64, 2, 32);
+  TEST_VRSHR_N(q, uint, u, 8, 16, 2);
+  TEST_VRSHR_N(q, uint, u, 16, 8, 3);
+  TEST_VRSHR_N(q, uint, u, 32, 4, 5);
+  TEST_VRSHR_N(q, uint, u, 64, 2, 33);
+
+#define CMT ""
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected, CMT);
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected, CMT);
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected, CMT);
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected, CMT);
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected, CMT);
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected, CMT);
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected, CMT);
+
+
+  /* Use maximum positive input value.  */
+  VDUP(vector, , int, s, 8, 8, 0x7F);
+  VDUP(vector, , int, s, 16, 4, 0x7FFF);
+  VDUP(vector, , int, s, 32, 2, 0x7FFFFFFF);
+  VDUP(vector, , int, s, 64, 1, 0x7FFFFFFFFFFFFFFFLL);
+  VDUP(vector, , uint, u, 8, 8, 0xFF);
+  VDUP(vector, , uint, u, 16, 4, 0xFFFF);
+  VDUP(vector, , uint, u, 32, 2, 0xFFFFFFFF);
+  VDUP(vector, , uint, u, 64, 1, 0xFFFFFFFFFFFFFFFFULL);
+  VDUP(vector, q, int, s, 8, 16, 0x7F);
+  VDUP(vector, q, int, s, 16, 8, 0x7FFF);
+  VDUP(vector, q, int, s, 32, 4, 0x7FFFFFFF);
+  VDUP(vector, q, int, s, 64, 2, 0x7FFFFFFFFFFFFFFFLL);
+  VDUP(vector, q, uint, u, 8, 16, 0xFF);
+  VDUP(vector, q, uint, u, 16, 8, 0xFFFF);
+  VDUP(vector, q, uint, u, 32, 4, 0xFFFFFFFF);
+  VDUP(vector, q, uint, u, 64, 2, 0xFFFFFFFFFFFFFFFFULL);
+
+  /* Use max shift amount, to exercise saturation.  */
+  TEST_VRSHR_N(, int, s, 8, 8, 8);
+  TEST_VRSHR_N(, int, s, 16, 4, 16);
+  TEST_VRSHR_N(, int, s, 32, 2, 32);
+  TEST_VRSHR_N(, int, s, 64, 1, 64);
+  TEST_VRSHR_N(, uint, u, 8, 8, 8);
+  TEST_VRSHR_N(, uint, u, 16, 4, 16);
+  TEST_VRSHR_N(, uint, u, 32, 2, 32);
+  TEST_VRSHR_N(, uint, u, 64, 1, 64);
+  TEST_VRSHR_N(q, int, s, 8, 16, 8);
+  TEST_VRSHR_N(q, int, s, 16, 8, 16);
+  TEST_VRSHR_N(q, int, s, 32, 4, 32);
+  TEST_VRSHR_N(q, int, s, 64, 2, 64);
+  TEST_VRSHR_N(q, uint, u, 8, 16, 8);
+  TEST_VRSHR_N(q, uint, u, 16, 8, 16);
+  TEST_VRSHR_N(q, uint, u, 32, 4, 32);
+  TEST_VRSHR_N(q, uint, u, 64, 2, 64);
+
+#undef CMT
+#define CMT " (overflow test: max shift amount, max positive input)"
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_max_sh_max, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_max_sh_max, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_max_sh_max, CMT);
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected_max_sh_max, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_max_sh_max, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_max_sh_max, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_max_sh_max, CMT);
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected_max_sh_max, CMT);
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected_max_sh_max, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_max_sh_max, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_max_sh_max, CMT);
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected_max_sh_max, CMT);
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected_max_sh_max, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_max_sh_max, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_max_sh_max, CMT);
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected_max_sh_max, CMT);
+
+
+  /* Use 1 as shift amount, to exercise saturation.  */
+  TEST_VRSHR_N(, int, s, 8, 8, 1);
+  TEST_VRSHR_N(, int, s, 16, 4, 1);
+  TEST_VRSHR_N(, int, s, 32, 2, 1);
+  TEST_VRSHR_N(, int, s, 64, 1, 1);
+  TEST_VRSHR_N(, uint, u, 8, 8, 1);
+  TEST_VRSHR_N(, uint, u, 16, 4, 1);
+  TEST_VRSHR_N(, uint, u, 32, 2, 1);
+  TEST_VRSHR_N(, uint, u, 64, 1, 1);
+  TEST_VRSHR_N(q, int, s, 8, 16, 1);
+  TEST_VRSHR_N(q, int, s, 16, 8, 1);
+  TEST_VRSHR_N(q, int, s, 32, 4, 1);
+  TEST_VRSHR_N(q, int, s, 64, 2, 1);
+  TEST_VRSHR_N(q, uint, u, 8, 16, 1);
+  TEST_VRSHR_N(q, uint, u, 16, 8, 1);
+  TEST_VRSHR_N(q, uint, u, 32, 4, 1);
+  TEST_VRSHR_N(q, uint, u, 64, 2, 1);
+
+#undef CMT
+#define CMT " (overflow test: shift by 1, with max input)"
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_max_sh_1, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_max_sh_1, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_max_sh_1, CMT);
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected_max_sh_1, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_max_sh_1, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_max_sh_1, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_max_sh_1, CMT);
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected_max_sh_1, CMT);
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected_max_sh_1, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_max_sh_1, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_max_sh_1, CMT);
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected_max_sh_1, CMT);
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected_max_sh_1, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_max_sh_1, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_max_sh_1, CMT);
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected_max_sh_1, CMT);
+
+
+  /* Use 3 as shift amount, to exercise saturation.  */
+  TEST_VRSHR_N(, int, s, 8, 8, 3);
+  TEST_VRSHR_N(, int, s, 16, 4, 3);
+  TEST_VRSHR_N(, int, s, 32, 2, 3);
+  TEST_VRSHR_N(, int, s, 64, 1, 3);
+  TEST_VRSHR_N(, uint, u, 8, 8, 3);
+  TEST_VRSHR_N(, uint, u, 16, 4, 3);
+  TEST_VRSHR_N(, uint, u, 32, 2, 3);
+  TEST_VRSHR_N(, uint, u, 64, 1, 3);
+  TEST_VRSHR_N(q, int, s, 8, 16, 3);
+  TEST_VRSHR_N(q, int, s, 16, 8, 3);
+  TEST_VRSHR_N(q, int, s, 32, 4, 3);
+  TEST_VRSHR_N(q, int, s, 64, 2, 3);
+  TEST_VRSHR_N(q, uint, u, 8, 16, 3);
+  TEST_VRSHR_N(q, uint, u, 16, 8, 3);
+  TEST_VRSHR_N(q, uint, u, 32, 4, 3);
+  TEST_VRSHR_N(q, uint, u, 64, 2, 3);
+
+#undef CMT
+#define CMT " (overflow test: shift by 3, with max input)"
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_max_sh_3, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_max_sh_3, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_max_sh_3, CMT);
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected_max_sh_3, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_max_sh_3, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_max_sh_3, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_max_sh_3, CMT);
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected_max_sh_3, CMT);
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected_max_sh_3, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_max_sh_3, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_max_sh_3, CMT);
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected_max_sh_3, CMT);
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected_max_sh_3, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_max_sh_3, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_max_sh_3, CMT);
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected_max_sh_3, CMT);
+
+
+  /* Use minimum negative input for signed types.  */
+  VDUP(vector, , int, s, 8, 8, 0x80);
+  VDUP(vector, , int, s, 16, 4, 0x8000);
+  VDUP(vector, , int, s, 32, 2, 0x80000000);
+  VDUP(vector, , int, s, 64, 1, 0x8000000000000000LL);
+  VDUP(vector, , uint, u, 8, 8, 0xFF);
+  VDUP(vector, , uint, u, 16, 4, 0xFFFF);
+  VDUP(vector, , uint, u, 32, 2, 0xFFFFFFFF);
+  VDUP(vector, , uint, u, 64, 1, 0xFFFFFFFFFFFFFFFFULL);
+  VDUP(vector, q, int, s, 8, 16, 0x80);
+  VDUP(vector, q, int, s, 16, 8, 0x8000);
+  VDUP(vector, q, int, s, 32, 4, 0x80000000);
+  VDUP(vector, q, int, s, 64, 2, 0x8000000000000000LL);
+  VDUP(vector, q, uint, u, 8, 16, 0xFF);
+  VDUP(vector, q, uint, u, 16, 8, 0xFFFF);
+  VDUP(vector, q, uint, u, 32, 4, 0xFFFFFFFF);
+  VDUP(vector, q, uint, u, 64, 2, 0xFFFFFFFFFFFFFFFFULL);
+
+
+  /* Use 1 as shift amount, to exercise saturation code.  */
+  TEST_VRSHR_N(, int, s, 8, 8, 1);
+  TEST_VRSHR_N(, int, s, 16, 4, 1);
+  TEST_VRSHR_N(, int, s, 32, 2, 1);
+  TEST_VRSHR_N(, int, s, 64, 1, 1);
+  TEST_VRSHR_N(, uint, u, 8, 8, 1);
+  TEST_VRSHR_N(, uint, u, 16, 4, 1);
+  TEST_VRSHR_N(, uint, u, 32, 2, 1);
+  TEST_VRSHR_N(, uint, u, 64, 1, 1);
+  TEST_VRSHR_N(q, int, s, 8, 16, 1);
+  TEST_VRSHR_N(q, int, s, 16, 8, 1);
+  TEST_VRSHR_N(q, int, s, 32, 4, 1);
+  TEST_VRSHR_N(q, int, s, 64, 2, 1);
+  TEST_VRSHR_N(q, uint, u, 8, 16, 1);
+  TEST_VRSHR_N(q, uint, u, 16, 8, 1);
+  TEST_VRSHR_N(q, uint, u, 32, 4, 1);
+  TEST_VRSHR_N(q, uint, u, 64, 2, 1);
+
+#undef CMT
+#define CMT " (overflow test: shift by 1, with negative input)"
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_max_neg_sh_1, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_max_neg_sh_1, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_max_neg_sh_1, CMT);
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected_max_neg_sh_1, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_max_neg_sh_1, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_max_neg_sh_1, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_max_neg_sh_1, CMT);
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected_max_neg_sh_1, CMT);
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected_max_neg_sh_1, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_max_neg_sh_1, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_max_neg_sh_1, CMT);
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected_max_neg_sh_1, CMT);
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected_max_neg_sh_1, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_max_neg_sh_1, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_max_neg_sh_1, CMT);
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected_max_neg_sh_1, CMT);
+
+
+  /* Use 3 as shift amount, to exercise saturation code.  */
+  TEST_VRSHR_N(, int, s, 8, 8, 3);
+  TEST_VRSHR_N(, int, s, 16, 4, 3);
+  TEST_VRSHR_N(, int, s, 32, 2, 3);
+  TEST_VRSHR_N(, int, s, 64, 1, 3);
+  TEST_VRSHR_N(, uint, u, 8, 8, 3);
+  TEST_VRSHR_N(, uint, u, 16, 4, 3);
+  TEST_VRSHR_N(, uint, u, 32, 2, 3);
+  TEST_VRSHR_N(, uint, u, 64, 1, 3);
+  TEST_VRSHR_N(q, int, s, 8, 16, 3);
+  TEST_VRSHR_N(q, int, s, 16, 8, 3);
+  TEST_VRSHR_N(q, int, s, 32, 4, 3);
+  TEST_VRSHR_N(q, int, s, 64, 2, 3);
+  TEST_VRSHR_N(q, uint, u, 8, 16, 3);
+  TEST_VRSHR_N(q, uint, u, 16, 8, 3);
+  TEST_VRSHR_N(q, uint, u, 32, 4, 3);
+  TEST_VRSHR_N(q, uint, u, 64, 2, 3);
+
+#undef CMT
+#define CMT " (overflow test: shift by 3, with negative input)"
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_max_neg_sh_3, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_max_neg_sh_3, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_max_neg_sh_3, CMT);
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected_max_neg_sh_3, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_max_neg_sh_3, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_max_neg_sh_3, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_max_neg_sh_3, CMT);
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected_max_neg_sh_3, CMT);
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected_max_neg_sh_3, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_max_neg_sh_3, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_max_neg_sh_3, CMT);
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected_max_neg_sh_3, CMT);
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected_max_neg_sh_3, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_max_neg_sh_3, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_max_neg_sh_3, CMT);
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected_max_neg_sh_3, CMT);
+}
+
+int main (void)
+{
+  exec_vrshr_n ();
+  return 0;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vrshrn_n.c
@@ -0,0 +1,143 @@
+#include <arm_neon.h>
+#include "arm-neon-ref.h"
+#include "compute-ref-data.h"
+
+/* Expected results with input=0.  */
+VECT_VAR_DECL(expected_0,int,8,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0,int,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0,int,32,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_0,uint,8,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					  0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0,uint,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_0,uint,32,2) [] = { 0x0, 0x0 };
+
+/* Expected results.  */
+VECT_VAR_DECL(expected,int,8,8) [] = { 0xf8, 0xf9, 0xf9, 0xfa,
+				       0xfa, 0xfb, 0xfb, 0xfc };
+VECT_VAR_DECL(expected,int,16,4) [] = { 0xfff8, 0xfff9, 0xfff9, 0xfffa };
+VECT_VAR_DECL(expected,int,32,2) [] = { 0xfffffffc, 0xfffffffc };
+VECT_VAR_DECL(expected,uint,8,8) [] = { 0xfc, 0xfc, 0xfd, 0xfd,
+					0xfd, 0xfd, 0xfe, 0xfe };
+VECT_VAR_DECL(expected,uint,16,4) [] = { 0xfffe, 0xfffe, 0xfffe, 0xfffe };
+VECT_VAR_DECL(expected,uint,32,2) [] = { 0xfffffffe, 0xfffffffe };
+
+/* Expected results with large shift amount.  */
+VECT_VAR_DECL(expected_sh_large,int,8,8) [] = { 0x0, 0x0, 0x0, 0x0,
+						0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_sh_large,int,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_sh_large,int,32,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_sh_large,uint,8,8) [] = { 0x0, 0x0, 0x0, 0x0,
+						 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_sh_large,uint,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_sh_large,uint,32,2) [] = { 0x0, 0x0 };
+
+#define TEST_MSG "VRSHRN_N"
+void exec_vrshrn_n (void)
+{
+  /* Basic test: v2=vrshrn_n(v1,v), then store the result.  */
+#define TEST_VRSHRN_N(T1, T2, W, N, W2, V)				\
+  VECT_VAR(vector_res, T1, W2, N) =					\
+    vrshrn_n_##T2##W(VECT_VAR(vector, T1, W, N),			\
+		     V);						\
+  vst1_##T2##W2(VECT_VAR(result, T1, W2, N), VECT_VAR(vector_res, T1, W2, N))
+
+  /* vector is twice as large as vector_res.  */
+  DECL_VARIABLE(vector, int, 16, 8);
+  DECL_VARIABLE(vector, int, 32, 4);
+  DECL_VARIABLE(vector, int, 64, 2);
+  DECL_VARIABLE(vector, uint, 16, 8);
+  DECL_VARIABLE(vector, uint, 32, 4);
+  DECL_VARIABLE(vector, uint, 64, 2);
+
+  DECL_VARIABLE(vector_res, int, 8, 8);
+  DECL_VARIABLE(vector_res, int, 16, 4);
+  DECL_VARIABLE(vector_res, int, 32, 2);
+  DECL_VARIABLE(vector_res, uint, 8, 8);
+  DECL_VARIABLE(vector_res, uint, 16, 4);
+  DECL_VARIABLE(vector_res, uint, 32, 2);
+
+  clean_results ();
+
+  /* Fill input vector with 0, to check behavior on limits.  */
+  VDUP(vector, q, int, s, 16, 8, 0);
+  VDUP(vector, q, int, s, 32, 4, 0);
+  VDUP(vector, q, int, s, 64, 2, 0);
+  VDUP(vector, q, uint, u, 16, 8, 0);
+  VDUP(vector, q, uint, u, 32, 4, 0);
+  VDUP(vector, q, uint, u, 64, 2, 0);
+
+  /* Choose shift amount arbitrarily.  */
+  TEST_VRSHRN_N(int, s, 16, 8, 8, 1);
+  TEST_VRSHRN_N(int, s, 32, 4, 16, 1);
+  TEST_VRSHRN_N(int, s, 64, 2, 32, 2);
+  TEST_VRSHRN_N(uint, u, 16, 8, 8, 2);
+  TEST_VRSHRN_N(uint, u, 32, 4, 16, 3);
+  TEST_VRSHRN_N(uint, u, 64, 2, 32, 3);
+
+#define CMT " (with input = 0)"
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_0, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_0, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_0, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_0, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_0, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_0, CMT);
+
+
+  /* Test again, with predefined input values.  */
+  VLOAD(vector, buffer, q, int, s, 16, 8);
+  VLOAD(vector, buffer, q, int, s, 32, 4);
+  VLOAD(vector, buffer, q, int, s, 64, 2);
+  VLOAD(vector, buffer, q, uint, u, 16, 8);
+  VLOAD(vector, buffer, q, uint, u, 32, 4);
+  VLOAD(vector, buffer, q, uint, u, 64, 2);
+
+  /* Choose shift amount arbitrarily.  */
+  TEST_VRSHRN_N(int, s, 16, 8, 8, 1);
+  TEST_VRSHRN_N(int, s, 32, 4, 16, 1);
+  TEST_VRSHRN_N(int, s, 64, 2, 32, 2);
+  TEST_VRSHRN_N(uint, u, 16, 8, 8, 2);
+  TEST_VRSHRN_N(uint, u, 32, 4, 16, 3);
+  TEST_VRSHRN_N(uint, u, 64, 2, 32, 3);
+
+#undef CMT
+#define CMT ""
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected, CMT);
+
+
+  /* Fill input arbitrary values.  */
+  VDUP(vector, q, int, s, 16, 8, 30);
+  VDUP(vector, q, int, s, 32, 4, 0);
+  VDUP(vector, q, int, s, 64, 2, 0);
+  VDUP(vector, q, uint, u, 16, 8, 0xFFF0);
+  VDUP(vector, q, uint, u, 32, 4, 0xFFFFFFF0);
+  VDUP(vector, q, uint, u, 64, 2, 0);
+
+  /* Choose large shift amount arbitrarily.  */
+  TEST_VRSHRN_N(int, s, 16, 8, 8, 7);
+  TEST_VRSHRN_N(int, s, 32, 4, 16, 14);
+  TEST_VRSHRN_N(int, s, 64, 2, 32, 31);
+  TEST_VRSHRN_N(uint, u, 16, 8, 8, 7);
+  TEST_VRSHRN_N(uint, u, 32, 4, 16, 16);
+  TEST_VRSHRN_N(uint, u, 64, 2, 32, 3);
+
+#undef CMT
+#define CMT " (with large shift amount)"
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_sh_large, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_sh_large, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_sh_large, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_sh_large, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_sh_large, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_sh_large, CMT);
+}
+
+int main (void)
+{
+  exec_vrshrn_n ();
+  return 0;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vrsqrte.c
@@ -0,0 +1,157 @@
+#include <arm_neon.h>
+#include "arm-neon-ref.h"
+#include "compute-ref-data.h"
+#include <math.h>
+
+/* Expected results.  */
+VECT_VAR_DECL(expected,uint,32,2) [] = { 0xffffffff, 0xffffffff };
+VECT_VAR_DECL(expected,uint,32,4) [] = { 0x9c800000, 0x9c800000,
+					 0x9c800000, 0x9c800000 };
+VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0x3e498000, 0x3e498000 };
+VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0x3e700000, 0x3e700000,
+					   0x3e700000, 0x3e700000 };
+
+/* Expected results with large uint #1.  */
+VECT_VAR_DECL(expected_1,uint,32,2) [] = { 0x80000000, 0x80000000 };
+VECT_VAR_DECL(expected_1,uint,32,4) [] = { 0xae800000, 0xae800000,
+					   0xae800000, 0xae800000 };
+
+/* Expected results with large uint #2.  */
+VECT_VAR_DECL(expected_2,uint,32,2) [] = { 0xb4800000, 0xb4800000 };
+VECT_VAR_DECL(expected_2,uint,32,4) [] = { 0xed000000, 0xed000000,
+					   0xed000000, 0xed000000 };
+
+/* Expected results with FP special inputs values (NaNs, ...).  */
+VECT_VAR_DECL(expected_fp1,hfloat,32,2) [] = { 0x7fc00000, 0x7fc00000 };
+VECT_VAR_DECL(expected_fp1,hfloat,32,4) [] = { 0x7f800000, 0x7f800000,
+					       0x7f800000, 0x7f800000 };
+
+/* Expected results with FP special inputs values
+   (negative, infinity).  */
+VECT_VAR_DECL(expected_fp2,hfloat,32,2) [] = { 0x7fc00000, 0x7fc00000 };
+VECT_VAR_DECL(expected_fp2,hfloat,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+
+/* Expected results with FP special inputs values
+   (-0, -infinity).  */
+VECT_VAR_DECL(expected_fp3,hfloat,32,2) [] = { 0xff800000, 0xff800000 };
+VECT_VAR_DECL(expected_fp3,hfloat,32,4) [] = { 0x7fc00000, 0x7fc00000,
+					       0x7fc00000, 0x7fc00000 };
+
+#define TEST_MSG "VRSQRTE/VRSQRTEQ"
+void exec_vrsqrte(void)
+{
+  int i;
+
+  /* Basic test: y=vrsqrte(x), then store the result.  */
+#define TEST_VRSQRTE(Q, T1, T2, W, N)			\
+  VECT_VAR(vector_res, T1, W, N) =			\
+    vrsqrte##Q##_##T2##W(VECT_VAR(vector, T1, W, N));	\
+  vst1##Q##_##T2##W(VECT_VAR(result, T1, W, N),		\
+		    VECT_VAR(vector_res, T1, W, N))
+
+  DECL_VARIABLE(vector, uint, 32, 2);
+  DECL_VARIABLE(vector, float, 32, 2);
+  DECL_VARIABLE(vector, uint, 32, 4);
+  DECL_VARIABLE(vector, float, 32, 4);
+
+  DECL_VARIABLE(vector_res, uint, 32, 2);
+  DECL_VARIABLE(vector_res, float, 32, 2);
+  DECL_VARIABLE(vector_res, uint, 32, 4);
+  DECL_VARIABLE(vector_res, float, 32, 4);
+
+  clean_results ();
+
+  /* Choose init value arbitrarily.  */
+  VDUP(vector, , uint, u, 32, 2, 0x12345678);
+  VDUP(vector, , float, f, 32, 2, 25.799999f);
+  VDUP(vector, q, uint, u, 32, 4, 0xABCDEF10);
+  VDUP(vector, q, float, f, 32, 4, 18.2f);
+
+  /* Apply the operator.  */
+  TEST_VRSQRTE(, uint, u, 32, 2);
+  TEST_VRSQRTE(, float, f, 32, 2);
+  TEST_VRSQRTE(q, uint, u, 32, 4);
+  TEST_VRSQRTE(q, float, f, 32, 4);
+
+#define CMT ""
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected, CMT);
+  CHECK_FP(TEST_MSG, float, 32, 2, PRIx32, expected, CMT);
+  CHECK_FP(TEST_MSG, float, 32, 4, PRIx32, expected, CMT);
+
+
+  /* Don't test FP variants with negative inputs.  */
+  /* Use input with various values of bits 30 and 31.  */
+  VDUP(vector, , uint, u, 32, 2, 0xFFFFFFFF);
+  VDUP(vector, q, uint, u, 32, 4, 0x89081234);
+
+  /* Apply the operator.  */
+  TEST_VRSQRTE(, uint, u, 32, 2);
+  TEST_VRSQRTE(q, uint, u, 32, 4);
+
+#undef CMT
+#define CMT " (large uint #1)"
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_1, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_1, CMT);
+
+
+  /* Choose init value arbitrarily.  */
+  VDUP(vector, , uint, u, 32, 2, 0x80000000);
+  VDUP(vector, q, uint, u, 32, 4, 0x4ABCDEF0);
+
+  /* Apply the operator.  */
+  TEST_VRSQRTE(, uint, u, 32, 2);
+  TEST_VRSQRTE(q, uint, u, 32, 4);
+
+#undef CMT
+#define CMT " (large uint #2)"
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_2, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_2, CMT);
+
+
+  /* Test FP variants with special input values (NaNs, ...).  */
+  VDUP(vector, , float, f, 32, 2, NAN);
+  VDUP(vector, q, float, f, 32, 4, 0.0f);
+
+  /* Apply the operator.  */
+  TEST_VRSQRTE(, float, f, 32, 2);
+  TEST_VRSQRTE(q, float, f, 32, 4);
+
+#undef CMT
+#define CMT " FP special (NaN, 0)"
+  CHECK_FP(TEST_MSG, float, 32, 2, PRIx32, expected_fp1, CMT);
+  CHECK_FP(TEST_MSG, float, 32, 4, PRIx32, expected_fp1, CMT);
+
+
+  /* Test FP variants with special input values (negative, infinity).  */
+  VDUP(vector, , float, f, 32, 2, -1.0f);
+  VDUP(vector, q, float, f, 32, 4, HUGE_VALF);
+
+  /* Apply the operator.  */
+  TEST_VRSQRTE(, float, f, 32, 2);
+  TEST_VRSQRTE(q, float, f, 32, 4);
+
+#undef CMT
+#define CMT " FP special (negative, infinity)"
+  CHECK_FP(TEST_MSG, float, 32, 2, PRIx32, expected_fp2, CMT);
+  CHECK_FP(TEST_MSG, float, 32, 4, PRIx32, expected_fp2, CMT);
+
+  /* Test FP variants with special input values (-0, -infinity).  */
+  VDUP(vector, , float, f, 32, 2, -0.0f);
+  VDUP(vector, q, float, f, 32, 4, -HUGE_VALF);
+
+  /* Apply the operator.  */
+  TEST_VRSQRTE(, float, f, 32, 2);
+  TEST_VRSQRTE(q, float, f, 32, 4);
+
+#undef CMT
+#define CMT " FP special (-0, -infinity)"
+  CHECK_FP(TEST_MSG, float, 32, 2, PRIx32, expected_fp3, CMT);
+  CHECK_FP(TEST_MSG, float, 32, 4, PRIx32, expected_fp3, CMT);
+}
+
+int main (void)
+{
+  exec_vrsqrte ();
+  return 0;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vrsqrts.c
@@ -0,0 +1,118 @@
+#include <arm_neon.h>
+#include "arm-neon-ref.h"
+#include "compute-ref-data.h"
+#include <math.h>
+
+/* Expected results.  */
+VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0xc2796b84, 0xc2796b84 };
+VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0xc0e4a3d8, 0xc0e4a3d8,
+					   0xc0e4a3d8, 0xc0e4a3d8 };
+
+/* Expected results with input=NaN.  */
+VECT_VAR_DECL(expected_nan,hfloat,32,2) [] = { 0x7fc00000, 0x7fc00000 };
+VECT_VAR_DECL(expected_nan,hfloat,32,4) [] = { 0x7fc00000, 0x7fc00000,
+					       0x7fc00000, 0x7fc00000 };
+
+/* Expected results with FP special inputs values (infinity, 0).  */
+VECT_VAR_DECL(expected_fp1,hfloat,32,2) [] = { 0xff800000, 0xff800000 };
+VECT_VAR_DECL(expected_fp1,hfloat,32,4) [] = { 0x3fc00000, 0x3fc00000,
+					       0x3fc00000, 0x3fc00000 };
+
+/* Expected results with only FP special inputs values (infinity,
+   0).  */
+VECT_VAR_DECL(expected_fp2,hfloat,32,2) [] = { 0x3fc00000, 0x3fc00000 };
+VECT_VAR_DECL(expected_fp2,hfloat,32,4) [] = { 0x3fc00000, 0x3fc00000,
+					       0x3fc00000, 0x3fc00000 };
+
+#define TEST_MSG "VRSQRTS/VRSQRTSQ"
+void exec_vrsqrts(void)
+{
+  int i;
+
+  /* Basic test: y=vrsqrts(x), then store the result.  */
+#define TEST_VRSQRTS(Q, T1, T2, W, N)			\
+  VECT_VAR(vector_res, T1, W, N) =			\
+    vrsqrts##Q##_##T2##W(VECT_VAR(vector, T1, W, N),	\
+			 VECT_VAR(vector2, T1, W, N));	\
+  vst1##Q##_##T2##W(VECT_VAR(result, T1, W, N),		\
+		    VECT_VAR(vector_res, T1, W, N))
+
+  /* No need for integer variants.  */
+  DECL_VARIABLE(vector, float, 32, 2);
+  DECL_VARIABLE(vector, float, 32, 4);
+
+  DECL_VARIABLE(vector2, float, 32, 2);
+  DECL_VARIABLE(vector2, float, 32, 4);
+
+  DECL_VARIABLE(vector_res, float, 32, 2);
+  DECL_VARIABLE(vector_res, float, 32, 4);
+
+  clean_results ();
+
+  /* Choose init value arbitrarily.  */
+  VDUP(vector, , float, f, 32, 2, 12.9f);
+  VDUP(vector, q, float, f, 32, 4, 9.1f);
+
+  VDUP(vector2, , float, f, 32, 2, 9.9f);
+  VDUP(vector2, q, float, f, 32, 4, 1.9f);
+
+  /* Apply the operator.  */
+  TEST_VRSQRTS(, float, f, 32, 2);
+  TEST_VRSQRTS(q, float, f, 32, 4);
+
+#define CMT ""
+  CHECK_FP(TEST_MSG, float, 32, 2, PRIx32, expected, CMT);
+  CHECK_FP(TEST_MSG, float, 32, 4, PRIx32, expected, CMT);
+
+
+  /* Test FP variants with special input values (NaN).  */
+  VDUP(vector, , float, f, 32, 2, NAN);
+  VDUP(vector2, q, float, f, 32, 4, NAN);
+
+  /* Apply the operator.  */
+  TEST_VRSQRTS(, float, f, 32, 2);
+  TEST_VRSQRTS(q, float, f, 32, 4);
+
+#undef CMT
+#define CMT " FP special (NAN) and normal values"
+  CHECK_FP(TEST_MSG, float, 32, 2, PRIx32, expected_nan, CMT);
+  CHECK_FP(TEST_MSG, float, 32, 4, PRIx32, expected_nan, CMT);
+
+
+  /* Test FP variants with special input values (infinity, 0).  */
+  VDUP(vector, , float, f, 32, 2, HUGE_VALF);
+  VDUP(vector, q, float, f, 32, 4, 0.0f);
+  /* Restore a normal value in vector2.  */
+  VDUP(vector2, q, float, f, 32, 4, 3.2f);
+
+  /* Apply the operator.  */
+  TEST_VRSQRTS(, float, f, 32, 2);
+  TEST_VRSQRTS(q, float, f, 32, 4);
+
+#undef CMT
+#define CMT " FP special (infinity, 0) and normal values"
+  CHECK_FP(TEST_MSG, float, 32, 2, PRIx32, expected_fp1, CMT);
+  CHECK_FP(TEST_MSG, float, 32, 4, PRIx32, expected_fp1, CMT);
+
+
+  /* Test FP variants with only special input values (infinity, 0).  */
+  VDUP(vector, , float, f, 32, 2, HUGE_VALF);
+  VDUP(vector, q, float, f, 32, 4, 0.0f);
+  VDUP(vector2, , float, f, 32, 2, -0.0f);
+  VDUP(vector2, q, float, f, 32, 4, HUGE_VALF);
+
+  /* Apply the operator.  */
+  TEST_VRSQRTS(, float, f, 32, 2);
+  TEST_VRSQRTS(q, float, f, 32, 4);
+
+#undef CMT
+#define CMT " only FP special (infinity, 0)"
+  CHECK_FP(TEST_MSG, float, 32, 2, PRIx32, expected_fp2, CMT);
+  CHECK_FP(TEST_MSG, float, 32, 4, PRIx32, expected_fp2, CMT);
+}
+
+int main (void)
+{
+  exec_vrsqrts ();
+  return 0;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vrsra_n.c
@@ -0,0 +1,553 @@
+#include <arm_neon.h>
+#include "arm-neon-ref.h"
+#include "compute-ref-data.h"
+
+/* Expected results.  */
+VECT_VAR_DECL(expected,int,8,8) [] = { 0xf9, 0xfa, 0xfb, 0xfc,
+				       0xfd, 0xfe, 0xff, 0x0 };
+VECT_VAR_DECL(expected,int,16,4) [] = { 0xfff0, 0xfff1, 0xfff2, 0xfff3 };
+VECT_VAR_DECL(expected,int,32,2) [] = { 0xfffffffd, 0xfffffffe };
+VECT_VAR_DECL(expected,int,64,1) [] = { 0xfffffffffffffff0 };
+VECT_VAR_DECL(expected,uint,8,8) [] = { 0x5, 0x6, 0x7, 0x8,
+					0x9, 0xa, 0xb, 0xc };
+VECT_VAR_DECL(expected,uint,16,4) [] = { 0xfffd, 0xfffe, 0xffff, 0x0 };
+VECT_VAR_DECL(expected,uint,32,2) [] = { 0xfffffff4, 0xfffffff5 };
+VECT_VAR_DECL(expected,uint,64,1) [] = { 0xfffffffffffffff0 };
+VECT_VAR_DECL(expected,int,8,16) [] = { 0xf9, 0xfa, 0xfb, 0xfc,
+					0xfd, 0xfe, 0xff, 0x0,
+					0x1, 0x2, 0x3, 0x4,
+					0x5, 0x6, 0x7, 0x8 };
+VECT_VAR_DECL(expected,int,16,8) [] = { 0xfff0, 0xfff1, 0xfff2, 0xfff3,
+					0xfff4, 0xfff5, 0xfff6, 0xfff7 };
+VECT_VAR_DECL(expected,int,32,4) [] = { 0xfffffffd, 0xfffffffe,
+					0xffffffff, 0x0 };
+VECT_VAR_DECL(expected,int,64,2) [] = { 0xfffffffffffffff0, 0xfffffffffffffff1 };
+VECT_VAR_DECL(expected,uint,8,16) [] = { 0x5, 0x6, 0x7, 0x8,
+					 0x9, 0xa, 0xb, 0xc,
+					 0xd, 0xe, 0xf, 0x10,
+					 0x11, 0x12, 0x13, 0x14 };
+VECT_VAR_DECL(expected,uint,16,8) [] = { 0xfffd, 0xfffe, 0xffff, 0x0,
+					 0x1, 0x2, 0x3, 0x4 };
+VECT_VAR_DECL(expected,uint,32,4) [] = { 0xfffffff4, 0xfffffff5,
+					 0xfffffff6, 0xfffffff7 };
+VECT_VAR_DECL(expected,uint,64,2) [] = { 0xfffffffffffffff0,
+					 0xfffffffffffffff1 };
+
+/* Expected results with max input and shift by 1.  */
+VECT_VAR_DECL(expected_max_sh1,int,8,8) [] = { 0x40, 0x40, 0x40, 0x40,
+					       0x40, 0x40, 0x40, 0x40 };
+VECT_VAR_DECL(expected_max_sh1,int,16,4) [] = { 0x4000, 0x4000, 0x4000, 0x4000 };
+VECT_VAR_DECL(expected_max_sh1,int,32,2) [] = { 0x40000000, 0x40000000 };
+VECT_VAR_DECL(expected_max_sh1,int,64,1) [] = { 0x4000000000000000 };
+VECT_VAR_DECL(expected_max_sh1,uint,8,8) [] = { 0x80, 0x80, 0x80, 0x80,
+						0x80, 0x80, 0x80, 0x80 };
+VECT_VAR_DECL(expected_max_sh1,uint,16,4) [] = { 0x8000, 0x8000,
+						 0x8000, 0x8000 };
+VECT_VAR_DECL(expected_max_sh1,uint,32,2) [] = { 0x80000000, 0x80000000 };
+VECT_VAR_DECL(expected_max_sh1,uint,64,1) [] = { 0x8000000000000000 };
+VECT_VAR_DECL(expected_max_sh1,int,8,16) [] = { 0x40, 0x40, 0x40, 0x40,
+						0x40, 0x40, 0x40, 0x40,
+						0x40, 0x40, 0x40, 0x40,
+						0x40, 0x40, 0x40, 0x40 };
+VECT_VAR_DECL(expected_max_sh1,int,16,8) [] = { 0x4000, 0x4000, 0x4000, 0x4000,
+						0x4000, 0x4000, 0x4000, 0x4000 };
+VECT_VAR_DECL(expected_max_sh1,int,32,4) [] = { 0x40000000, 0x40000000,
+						0x40000000, 0x40000000 };
+VECT_VAR_DECL(expected_max_sh1,int,64,2) [] = { 0x4000000000000000,
+						0x4000000000000000 };
+VECT_VAR_DECL(expected_max_sh1,uint,8,16) [] = { 0x80, 0x80, 0x80, 0x80,
+						 0x80, 0x80, 0x80, 0x80,
+						 0x80, 0x80, 0x80, 0x80,
+						 0x80, 0x80, 0x80, 0x80 };
+VECT_VAR_DECL(expected_max_sh1,uint,16,8) [] = { 0x8000, 0x8000,
+						 0x8000, 0x8000,
+						 0x8000, 0x8000,
+						 0x8000, 0x8000 };
+VECT_VAR_DECL(expected_max_sh1,uint,32,4) [] = { 0x80000000, 0x80000000,
+						 0x80000000, 0x80000000 };
+VECT_VAR_DECL(expected_max_sh1,uint,64,2) [] = { 0x8000000000000000,
+						 0x8000000000000000 };
+
+/* Expected results with max input and shift by 3.  */
+VECT_VAR_DECL(expected_max_sh3,int,8,8) [] = { 0x10, 0x10, 0x10, 0x10,
+					       0x10, 0x10, 0x10, 0x10 };
+VECT_VAR_DECL(expected_max_sh3,int,16,4) [] = { 0x1000, 0x1000, 0x1000, 0x1000 };
+VECT_VAR_DECL(expected_max_sh3,int,32,2) [] = { 0x10000000, 0x10000000 };
+VECT_VAR_DECL(expected_max_sh3,int,64,1) [] = { 0x1000000000000000 };
+VECT_VAR_DECL(expected_max_sh3,uint,8,8) [] = { 0x20, 0x20, 0x20, 0x20,
+						0x20, 0x20, 0x20, 0x20 };
+VECT_VAR_DECL(expected_max_sh3,uint,16,4) [] = { 0x2000, 0x2000,
+						 0x2000, 0x2000 };
+VECT_VAR_DECL(expected_max_sh3,uint,32,2) [] = { 0x20000000, 0x20000000 };
+VECT_VAR_DECL(expected_max_sh3,uint,64,1) [] = { 0x2000000000000000 };
+VECT_VAR_DECL(expected_max_sh3,int,8,16) [] = { 0x10, 0x10, 0x10, 0x10,
+						0x10, 0x10, 0x10, 0x10,
+						0x10, 0x10, 0x10, 0x10,
+						0x10, 0x10, 0x10, 0x10 };
+VECT_VAR_DECL(expected_max_sh3,int,16,8) [] = { 0x1000, 0x1000, 0x1000, 0x1000,
+						0x1000, 0x1000, 0x1000, 0x1000 };
+VECT_VAR_DECL(expected_max_sh3,int,32,4) [] = { 0x10000000, 0x10000000,
+						0x10000000, 0x10000000 };
+VECT_VAR_DECL(expected_max_sh3,int,64,2) [] = { 0x1000000000000000,
+						0x1000000000000000 };
+VECT_VAR_DECL(expected_max_sh3,uint,8,16) [] = { 0x20, 0x20, 0x20, 0x20,
+						 0x20, 0x20, 0x20, 0x20,
+						 0x20, 0x20, 0x20, 0x20,
+						 0x20, 0x20, 0x20, 0x20 };
+VECT_VAR_DECL(expected_max_sh3,uint,16,8) [] = { 0x2000, 0x2000,
+						 0x2000, 0x2000,
+						 0x2000, 0x2000,
+						 0x2000, 0x2000 };
+VECT_VAR_DECL(expected_max_sh3,uint,32,4) [] = { 0x20000000, 0x20000000,
+						 0x20000000, 0x20000000 };
+VECT_VAR_DECL(expected_max_sh3,uint,64,2) [] = { 0x2000000000000000,
+						 0x2000000000000000 };
+
+/* Expected results with max input and shift by type width.  */
+VECT_VAR_DECL(expected_max_shmax,int,8,8) [] = { 0x0, 0x0, 0x0, 0x0,
+						 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_max_shmax,int,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_max_shmax,int,32,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_max_shmax,int,64,1) [] = { 0x0 };
+VECT_VAR_DECL(expected_max_shmax,uint,8,8) [] = { 0x1, 0x1, 0x1, 0x1,
+						  0x1, 0x1, 0x1, 0x1 };
+VECT_VAR_DECL(expected_max_shmax,uint,16,4) [] = { 0x1, 0x1, 0x1, 0x1 };
+VECT_VAR_DECL(expected_max_shmax,uint,32,2) [] = { 0x1, 0x1 };
+VECT_VAR_DECL(expected_max_shmax,uint,64,1) [] = { 0x1 };
+VECT_VAR_DECL(expected_max_shmax,int,8,16) [] = { 0x0, 0x0, 0x0, 0x0,
+						  0x0, 0x0, 0x0, 0x0,
+						  0x0, 0x0, 0x0, 0x0,
+						  0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_max_shmax,int,16,8) [] = { 0x0, 0x0, 0x0, 0x0,
+						  0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_max_shmax,int,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_max_shmax,int,64,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_max_shmax,uint,8,16) [] = { 0x1, 0x1, 0x1, 0x1,
+						   0x1, 0x1, 0x1, 0x1,
+						   0x1, 0x1, 0x1, 0x1,
+						   0x1, 0x1, 0x1, 0x1 };
+VECT_VAR_DECL(expected_max_shmax,uint,16,8) [] = { 0x1, 0x1, 0x1, 0x1,
+						   0x1, 0x1, 0x1, 0x1 };
+VECT_VAR_DECL(expected_max_shmax,uint,32,4) [] = { 0x1, 0x1, 0x1, 0x1 };
+VECT_VAR_DECL(expected_max_shmax,uint,64,2) [] = { 0x1, 0x1 };
+
+/* Expected results with min negative input and shift by 1.  */
+VECT_VAR_DECL(expected_min_sh1,int,8,8) [] = { 0xc0, 0xc0, 0xc0, 0xc0,
+					       0xc0, 0xc0, 0xc0, 0xc0 };
+VECT_VAR_DECL(expected_min_sh1,int,16,4) [] = { 0xc000, 0xc000, 0xc000, 0xc000 };
+VECT_VAR_DECL(expected_min_sh1,int,32,2) [] = { 0xc0000000, 0xc0000000 };
+VECT_VAR_DECL(expected_min_sh1,int,64,1) [] = { 0xc000000000000000 };
+VECT_VAR_DECL(expected_min_sh1,uint,8,8) [] = { 0x1, 0x1, 0x1, 0x1,
+						0x1, 0x1, 0x1, 0x1 };
+VECT_VAR_DECL(expected_min_sh1,uint,16,4) [] = { 0x1, 0x1, 0x1, 0x1 };
+VECT_VAR_DECL(expected_min_sh1,uint,32,2) [] = { 0x1, 0x1 };
+VECT_VAR_DECL(expected_min_sh1,uint,64,1) [] = { 0x1 };
+VECT_VAR_DECL(expected_min_sh1,int,8,16) [] = { 0xc0, 0xc0, 0xc0, 0xc0,
+						0xc0, 0xc0, 0xc0, 0xc0,
+						0xc0, 0xc0, 0xc0, 0xc0,
+						0xc0, 0xc0, 0xc0, 0xc0 };
+VECT_VAR_DECL(expected_min_sh1,int,16,8) [] = { 0xc000, 0xc000, 0xc000, 0xc000,
+						0xc000, 0xc000, 0xc000, 0xc000 };
+VECT_VAR_DECL(expected_min_sh1,int,32,4) [] = { 0xc0000000, 0xc0000000,
+						0xc0000000, 0xc0000000 };
+VECT_VAR_DECL(expected_min_sh1,int,64,2) [] = { 0xc000000000000000,
+						0xc000000000000000 };
+VECT_VAR_DECL(expected_min_sh1,uint,8,16) [] = { 0x1, 0x1, 0x1, 0x1,
+						 0x1, 0x1, 0x1, 0x1,
+						 0x1, 0x1, 0x1, 0x1,
+						 0x1, 0x1, 0x1, 0x1 };
+VECT_VAR_DECL(expected_min_sh1,uint,16,8) [] = { 0x1, 0x1, 0x1, 0x1,
+						 0x1, 0x1, 0x1, 0x1 };
+VECT_VAR_DECL(expected_min_sh1,uint,32,4) [] = { 0x1, 0x1, 0x1, 0x1 };
+VECT_VAR_DECL(expected_min_sh1,uint,64,2) [] = { 0x1, 0x1 };
+
+/* Expected results with min negative input and shift by 3.  */
+VECT_VAR_DECL(expected_min_sh3,int,8,8) [] = { 0xf0, 0xf0, 0xf0, 0xf0,
+					       0xf0, 0xf0, 0xf0, 0xf0 };
+VECT_VAR_DECL(expected_min_sh3,int,16,4) [] = { 0xf000, 0xf000, 0xf000, 0xf000 };
+VECT_VAR_DECL(expected_min_sh3,int,32,2) [] = { 0xf0000000, 0xf0000000 };
+VECT_VAR_DECL(expected_min_sh3,int,64,1) [] = { 0xf000000000000000 };
+VECT_VAR_DECL(expected_min_sh3,uint,8,8) [] = { 0x1, 0x1, 0x1, 0x1,
+						0x1, 0x1, 0x1, 0x1 };
+VECT_VAR_DECL(expected_min_sh3,uint,16,4) [] = { 0x1, 0x1, 0x1, 0x1 };
+VECT_VAR_DECL(expected_min_sh3,uint,32,2) [] = { 0x1, 0x1 };
+VECT_VAR_DECL(expected_min_sh3,uint,64,1) [] = { 0x1 };
+VECT_VAR_DECL(expected_min_sh3,int,8,16) [] = { 0xf0, 0xf0, 0xf0, 0xf0,
+						0xf0, 0xf0, 0xf0, 0xf0,
+						0xf0, 0xf0, 0xf0, 0xf0,
+						0xf0, 0xf0, 0xf0, 0xf0 };
+VECT_VAR_DECL(expected_min_sh3,int,16,8) [] = { 0xf000, 0xf000, 0xf000, 0xf000,
+						0xf000, 0xf000, 0xf000, 0xf000 };
+VECT_VAR_DECL(expected_min_sh3,int,32,4) [] = { 0xf0000000, 0xf0000000,
+						0xf0000000, 0xf0000000 };
+VECT_VAR_DECL(expected_min_sh3,int,64,2) [] = { 0xf000000000000000,
+						0xf000000000000000 };
+VECT_VAR_DECL(expected_min_sh3,uint,8,16) [] = { 0x1, 0x1, 0x1, 0x1,
+						 0x1, 0x1, 0x1, 0x1,
+						 0x1, 0x1, 0x1, 0x1,
+						 0x1, 0x1, 0x1, 0x1 };
+VECT_VAR_DECL(expected_min_sh3,uint,16,8) [] = { 0x1, 0x1, 0x1, 0x1,
+						 0x1, 0x1, 0x1, 0x1 };
+VECT_VAR_DECL(expected_min_sh3,uint,32,4) [] = { 0x1, 0x1, 0x1, 0x1 };
+VECT_VAR_DECL(expected_min_sh3,uint,64,2) [] = { 0x1, 0x1 };
+
+/* Expected results with min negative input and shift by type width.  */
+VECT_VAR_DECL(expected_min_shmax,int,8,8) [] = { 0x0, 0x0, 0x0, 0x0,
+						 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_min_shmax,int,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_min_shmax,int,32,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_min_shmax,int,64,1) [] = { 0x0 };
+VECT_VAR_DECL(expected_min_shmax,uint,8,8) [] = { 0x1, 0x1, 0x1, 0x1,
+						  0x1, 0x1, 0x1, 0x1 };
+VECT_VAR_DECL(expected_min_shmax,uint,16,4) [] = { 0x1, 0x1, 0x1, 0x1 };
+VECT_VAR_DECL(expected_min_shmax,uint,32,2) [] = { 0x1, 0x1 };
+VECT_VAR_DECL(expected_min_shmax,uint,64,1) [] = { 0x1 };
+VECT_VAR_DECL(expected_min_shmax,int,8,16) [] = { 0x0, 0x0, 0x0, 0x0,
+						  0x0, 0x0, 0x0, 0x0,
+						  0x0, 0x0, 0x0, 0x0,
+						  0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_min_shmax,int,16,8) [] = { 0x0, 0x0, 0x0, 0x0,
+						  0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_min_shmax,int,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_min_shmax,int,64,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_min_shmax,uint,8,16) [] = { 0x1, 0x1, 0x1, 0x1,
+						   0x1, 0x1, 0x1, 0x1,
+						   0x1, 0x1, 0x1, 0x1,
+						   0x1, 0x1, 0x1, 0x1 };
+VECT_VAR_DECL(expected_min_shmax,uint,16,8) [] = { 0x1, 0x1, 0x1, 0x1,
+						   0x1, 0x1, 0x1, 0x1 };
+VECT_VAR_DECL(expected_min_shmax,uint,32,4) [] = { 0x1, 0x1, 0x1, 0x1 };
+VECT_VAR_DECL(expected_min_shmax,uint,64,2) [] = { 0x1, 0x1 };
+
+#define TEST_MSG "VRSRA_N"
+void exec_vrsra_n (void)
+{
+  /* Basic test: y=vrsra_n(x,v), then store the result.  */
+#define TEST_VRSRA_N(Q, T1, T2, W, N, V)				\
+  VECT_VAR(vector_res, T1, W, N) =					\
+    vrsra##Q##_n_##T2##W(VECT_VAR(vector, T1, W, N),			\
+			 VECT_VAR(vector2, T1, W, N),			\
+			 V);						\
+  vst1##Q##_##T2##W(VECT_VAR(result, T1, W, N), VECT_VAR(vector_res, T1, W, N))
+
+  DECL_VARIABLE_ALL_VARIANTS(vector);
+  DECL_VARIABLE_ALL_VARIANTS(vector2);
+  DECL_VARIABLE_ALL_VARIANTS(vector_res);
+
+  clean_results ();
+
+  /* Initialize input "vector" from "buffer".  */
+  TEST_MACRO_ALL_VARIANTS_2_5(VLOAD, vector, buffer);
+
+  /* Choose arbitrary initialization values.  */
+  VDUP(vector2, , int, s, 8, 8, 0x11);
+  VDUP(vector2, , int, s, 16, 4, 0x22);
+  VDUP(vector2, , int, s, 32, 2, 0x33);
+  VDUP(vector2, , int, s, 64, 1, 0x44);
+  VDUP(vector2, , uint, u, 8, 8, 0x55);
+  VDUP(vector2, , uint, u, 16, 4, 0x66);
+  VDUP(vector2, , uint, u, 32, 2, 0x77);
+  VDUP(vector2, , uint, u, 64, 1, 0x88);
+
+  VDUP(vector2, q, int, s, 8, 16, 0x11);
+  VDUP(vector2, q, int, s, 16, 8, 0x22);
+  VDUP(vector2, q, int, s, 32, 4, 0x33);
+  VDUP(vector2, q, int, s, 64, 2, 0x44);
+  VDUP(vector2, q, uint, u, 8, 16, 0x55);
+  VDUP(vector2, q, uint, u, 16, 8, 0x66);
+  VDUP(vector2, q, uint, u, 32, 4, 0x77);
+  VDUP(vector2, q, uint, u, 64, 2, 0x88);
+
+  /* Choose shift amount arbitrarily.  */
+  TEST_VRSRA_N(, int, s, 8, 8, 1);
+  TEST_VRSRA_N(, int, s, 16, 4, 12);
+  TEST_VRSRA_N(, int, s, 32, 2, 2);
+  TEST_VRSRA_N(, int, s, 64, 1, 32);
+  TEST_VRSRA_N(, uint, u, 8, 8, 2);
+  TEST_VRSRA_N(, uint, u, 16, 4, 3);
+  TEST_VRSRA_N(, uint, u, 32, 2, 5);
+  TEST_VRSRA_N(, uint, u, 64, 1, 33);
+
+  TEST_VRSRA_N(q, int, s, 8, 16, 1);
+  TEST_VRSRA_N(q, int, s, 16, 8, 12);
+  TEST_VRSRA_N(q, int, s, 32, 4, 2);
+  TEST_VRSRA_N(q, int, s, 64, 2, 32);
+  TEST_VRSRA_N(q, uint, u, 8, 16, 2);
+  TEST_VRSRA_N(q, uint, u, 16, 8, 3);
+  TEST_VRSRA_N(q, uint, u, 32, 4, 5);
+  TEST_VRSRA_N(q, uint, u, 64, 2, 33);
+
+#define CMT ""
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected, CMT);
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected, CMT);
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected, CMT);
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected, CMT);
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected, CMT);
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected, CMT);
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected, CMT);
+
+
+  /* Initialize the accumulator with 0.  */
+  VDUP(vector, , int, s, 8, 8, 0);
+  VDUP(vector, , int, s, 16, 4, 0);
+  VDUP(vector, , int, s, 32, 2, 0);
+  VDUP(vector, , int, s, 64, 1, 0);
+  VDUP(vector, , uint, u, 8, 8, 0);
+  VDUP(vector, , uint, u, 16, 4, 0);
+  VDUP(vector, , uint, u, 32, 2, 0);
+  VDUP(vector, , uint, u, 64, 1, 0);
+  VDUP(vector, q, int, s, 8, 16, 0);
+  VDUP(vector, q, int, s, 16, 8, 0);
+  VDUP(vector, q, int, s, 32, 4, 0);
+  VDUP(vector, q, int, s, 64, 2, 0);
+  VDUP(vector, q, uint, u, 8, 16, 0);
+  VDUP(vector, q, uint, u, 16, 8, 0);
+  VDUP(vector, q, uint, u, 32, 4, 0);
+  VDUP(vector, q, uint, u, 64, 2, 0);
+
+  /* Initialize with max values to check overflow.  */
+  VDUP(vector2, , int, s, 8, 8, 0x7F);
+  VDUP(vector2, , int, s, 16, 4, 0x7FFF);
+  VDUP(vector2, , int, s, 32, 2, 0x7FFFFFFF);
+  VDUP(vector2, , int, s, 64, 1, 0x7FFFFFFFFFFFFFFFLL);
+  VDUP(vector2, , uint, u, 8, 8, 0xFF);
+  VDUP(vector2, , uint, u, 16, 4, 0xFFFF);
+  VDUP(vector2, , uint, u, 32, 2, 0xFFFFFFFF);
+  VDUP(vector2, , uint, u, 64, 1, 0xFFFFFFFFFFFFFFFFULL);
+  VDUP(vector2, q, int, s, 8, 16, 0x7F);
+  VDUP(vector2, q, int, s, 16, 8, 0x7FFF);
+  VDUP(vector2, q, int, s, 32, 4, 0x7FFFFFFF);
+  VDUP(vector2, q, int, s, 64, 2, 0x7FFFFFFFFFFFFFFFLL);
+  VDUP(vector2, q, uint, u, 8, 16, 0xFF);
+  VDUP(vector2, q, uint, u, 16, 8, 0xFFFF);
+  VDUP(vector2, q, uint, u, 32, 4, 0xFFFFFFFF);
+  VDUP(vector2, q, uint, u, 64, 2, 0xFFFFFFFFFFFFFFFFULL);
+
+  /* Shift by 1 to check overflow with rounding constant.  */
+  TEST_VRSRA_N(, int, s, 8, 8, 1);
+  TEST_VRSRA_N(, int, s, 16, 4, 1);
+  TEST_VRSRA_N(, int, s, 32, 2, 1);
+  TEST_VRSRA_N(, int, s, 64, 1, 1);
+  TEST_VRSRA_N(, uint, u, 8, 8, 1);
+  TEST_VRSRA_N(, uint, u, 16, 4, 1);
+  TEST_VRSRA_N(, uint, u, 32, 2, 1);
+  TEST_VRSRA_N(, uint, u, 64, 1, 1);
+  TEST_VRSRA_N(q, int, s, 8, 16, 1);
+  TEST_VRSRA_N(q, int, s, 16, 8, 1);
+  TEST_VRSRA_N(q, int, s, 32, 4, 1);
+  TEST_VRSRA_N(q, int, s, 64, 2, 1);
+  TEST_VRSRA_N(q, uint, u, 8, 16, 1);
+  TEST_VRSRA_N(q, uint, u, 16, 8, 1);
+  TEST_VRSRA_N(q, uint, u, 32, 4, 1);
+  TEST_VRSRA_N(q, uint, u, 64, 2, 1);
+
+#undef CMT
+#define CMT " (checking overflow: shift by 1, max input)"
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_max_sh1, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_max_sh1, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_max_sh1, CMT);
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected_max_sh1, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_max_sh1, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_max_sh1, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_max_sh1, CMT);
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected_max_sh1, CMT);
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected_max_sh1, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_max_sh1, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_max_sh1, CMT);
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected_max_sh1, CMT);
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected_max_sh1, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_max_sh1, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_max_sh1, CMT);
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected_max_sh1, CMT);
+
+
+  /* Shift by 3 to check overflow with rounding constant.  */
+  TEST_VRSRA_N(, int, s, 8, 8, 3);
+  TEST_VRSRA_N(, int, s, 16, 4, 3);
+  TEST_VRSRA_N(, int, s, 32, 2, 3);
+  TEST_VRSRA_N(, int, s, 64, 1, 3);
+  TEST_VRSRA_N(, uint, u, 8, 8, 3);
+  TEST_VRSRA_N(, uint, u, 16, 4, 3);
+  TEST_VRSRA_N(, uint, u, 32, 2, 3);
+  TEST_VRSRA_N(, uint, u, 64, 1, 3);
+  TEST_VRSRA_N(q, int, s, 8, 16, 3);
+  TEST_VRSRA_N(q, int, s, 16, 8, 3);
+  TEST_VRSRA_N(q, int, s, 32, 4, 3);
+  TEST_VRSRA_N(q, int, s, 64, 2, 3);
+  TEST_VRSRA_N(q, uint, u, 8, 16, 3);
+  TEST_VRSRA_N(q, uint, u, 16, 8, 3);
+  TEST_VRSRA_N(q, uint, u, 32, 4, 3);
+  TEST_VRSRA_N(q, uint, u, 64, 2, 3);
+
+#undef CMT
+#define CMT " (checking overflow: shift by 3, max input)"
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_max_sh3, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_max_sh3, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_max_sh3, CMT);
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected_max_sh3, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_max_sh3, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_max_sh3, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_max_sh3, CMT);
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected_max_sh3, CMT);
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected_max_sh3, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_max_sh3, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_max_sh3, CMT);
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected_max_sh3, CMT);
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected_max_sh3, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_max_sh3, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_max_sh3, CMT);
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected_max_sh3, CMT);
+
+
+  /* Shift by max to check overflow with rounding constant.  */
+  TEST_VRSRA_N(, int, s, 8, 8, 8);
+  TEST_VRSRA_N(, int, s, 16, 4, 16);
+  TEST_VRSRA_N(, int, s, 32, 2, 32);
+  TEST_VRSRA_N(, int, s, 64, 1, 64);
+  TEST_VRSRA_N(, uint, u, 8, 8, 8);
+  TEST_VRSRA_N(, uint, u, 16, 4, 16);
+  TEST_VRSRA_N(, uint, u, 32, 2, 32);
+  TEST_VRSRA_N(, uint, u, 64, 1, 64);
+  TEST_VRSRA_N(q, int, s, 8, 16, 8);
+  TEST_VRSRA_N(q, int, s, 16, 8, 16);
+  TEST_VRSRA_N(q, int, s, 32, 4, 32);
+  TEST_VRSRA_N(q, int, s, 64, 2, 64);
+  TEST_VRSRA_N(q, uint, u, 8, 16, 8);
+  TEST_VRSRA_N(q, uint, u, 16, 8, 16);
+  TEST_VRSRA_N(q, uint, u, 32, 4, 32);
+  TEST_VRSRA_N(q, uint, u, 64, 2, 64);
+
+#undef CMT
+#define CMT " (checking overflow: shift by max, max input)"
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_max_shmax, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_max_shmax, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_max_shmax, CMT);
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected_max_shmax, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_max_shmax, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_max_shmax, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_max_shmax, CMT);
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected_max_shmax, CMT);
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected_max_shmax, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_max_shmax, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_max_shmax, CMT);
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected_max_shmax, CMT);
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected_max_shmax, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_max_shmax, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_max_shmax, CMT);
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected_max_shmax, CMT);
+
+
+  /* Initialize with min values to check overflow.  */
+  VDUP(vector2, , int, s, 8, 8, 0x80);
+  VDUP(vector2, , int, s, 16, 4, 0x8000);
+  VDUP(vector2, , int, s, 32, 2, 0x80000000);
+  VDUP(vector2, , int, s, 64, 1, 0x8000000000000000LL);
+  VDUP(vector2, q, int, s, 8, 16, 0x80);
+  VDUP(vector2, q, int, s, 16, 8, 0x8000);
+  VDUP(vector2, q, int, s, 32, 4, 0x80000000);
+  VDUP(vector2, q, int, s, 64, 2, 0x8000000000000000ULL);
+
+  /* Shift by 1 to check overflow with rounding constant.  */
+  TEST_VRSRA_N(, int, s, 8, 8, 1);
+  TEST_VRSRA_N(, int, s, 16, 4, 1);
+  TEST_VRSRA_N(, int, s, 32, 2, 1);
+  TEST_VRSRA_N(, int, s, 64, 1, 1);
+  TEST_VRSRA_N(q, int, s, 8, 16, 1);
+  TEST_VRSRA_N(q, int, s, 16, 8, 1);
+  TEST_VRSRA_N(q, int, s, 32, 4, 1);
+  TEST_VRSRA_N(q, int, s, 64, 2, 1);
+
+#undef CMT
+#define CMT " (checking overflow: shift by 1, min negative input)"
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_min_sh1, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_min_sh1, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_min_sh1, CMT);
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected_min_sh1, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_min_sh1, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_min_sh1, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_min_sh1, CMT);
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected_min_sh1, CMT);
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected_min_sh1, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_min_sh1, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_min_sh1, CMT);
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected_min_sh1, CMT);
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected_min_sh1, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_min_sh1, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_min_sh1, CMT);
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected_min_sh1, CMT);
+
+
+  /* Shift by 3 to check overflow with rounding constant.  */
+  TEST_VRSRA_N(, int, s, 8, 8, 3);
+  TEST_VRSRA_N(, int, s, 16, 4, 3);
+  TEST_VRSRA_N(, int, s, 32, 2, 3);
+  TEST_VRSRA_N(, int, s, 64, 1, 3);
+  TEST_VRSRA_N(q, int, s, 8, 16, 3);
+  TEST_VRSRA_N(q, int, s, 16, 8, 3);
+  TEST_VRSRA_N(q, int, s, 32, 4, 3);
+  TEST_VRSRA_N(q, int, s, 64, 2, 3);
+
+#undef CMT
+#define CMT " (checking overflow: shift by 3, min negative input)"
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_min_sh3, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_min_sh3, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_min_sh3, CMT);
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected_min_sh3, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_min_sh3, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_min_sh3, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_min_sh3, CMT);
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected_min_sh3, CMT);
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected_min_sh3, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_min_sh3, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_min_sh3, CMT);
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected_min_sh3, CMT);
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected_min_sh3, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_min_sh3, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_min_sh3, CMT);
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected_min_sh3, CMT);
+
+
+  /* Shift by max to check overflow with rounding constant.  */
+  TEST_VRSRA_N(, int, s, 8, 8, 8);
+  TEST_VRSRA_N(, int, s, 16, 4, 16);
+  TEST_VRSRA_N(, int, s, 32, 2, 32);
+  TEST_VRSRA_N(, int, s, 64, 1, 64);
+  TEST_VRSRA_N(q, int, s, 8, 16, 8);
+  TEST_VRSRA_N(q, int, s, 16, 8, 16);
+  TEST_VRSRA_N(q, int, s, 32, 4, 32);
+  TEST_VRSRA_N(q, int, s, 64, 2, 64);
+
+#undef CMT
+#define CMT " (checking overflow: shift by max, min negative input)"
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_min_shmax, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_min_shmax, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_min_shmax, CMT);
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected_min_shmax, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_min_shmax, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_min_shmax, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_min_shmax, CMT);
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected_min_shmax, CMT);
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected_min_shmax, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_min_shmax, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_min_shmax, CMT);
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected_min_shmax, CMT);
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected_min_shmax, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_min_shmax, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_min_shmax, CMT);
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected_min_shmax, CMT);
+}
+
+int main (void)
+{
+  exec_vrsra_n ();
+  return 0;
+}
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vsXi_n.inc
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vsXi_n.inc
@@ -68,7 +68,24 @@ void FNNAME (INSN_NAME) (void)
   TEST_VSXI_N(INSN_NAME, q, poly, p, 8, 16, 3);
   TEST_VSXI_N(INSN_NAME, q, poly, p, 16, 8, 12);
 
-  CHECK_RESULTS (TEST_MSG, "");
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected, "");
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected, "");
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected, "");
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected, "");
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected, "");
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected, "");
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected, "");
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected, "");
+  CHECK(TEST_MSG, poly, 8, 8, PRIx8, expected, "");
+  CHECK(TEST_MSG, poly, 16, 4, PRIx16, expected, "");
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected, "");
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected, "");
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected, "");
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected, "");
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected, "");
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected, "");
+  CHECK(TEST_MSG, poly, 8, 16, PRIx8, expected, "");
+  CHECK(TEST_MSG, poly, 16, 8, PRIx16, expected, "");
 
 #ifdef EXTRA_TESTS
   EXTRA_TESTS();
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vset_lane.c
@@ -0,0 +1,112 @@
+#include <arm_neon.h>
+#include "arm-neon-ref.h"
+#include "compute-ref-data.h"
+
+/* Expected results.  */
+VECT_VAR_DECL(expected,int,8,8) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
+				       0xf4, 0xf5, 0xf6, 0x11 };
+VECT_VAR_DECL(expected,int,16,4) [] = { 0xfff0, 0xfff1, 0xfff2, 0x22 };
+VECT_VAR_DECL(expected,int,32,2) [] = { 0xfffffff0, 0x33 };
+VECT_VAR_DECL(expected,int,64,1) [] = { 0x44 };
+VECT_VAR_DECL(expected,uint,8,8) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
+					0xf4, 0xf5, 0x55, 0xf7 };
+VECT_VAR_DECL(expected,uint,16,4) [] = { 0xfff0, 0xfff1, 0x66, 0xfff3 };
+VECT_VAR_DECL(expected,uint,32,2) [] = { 0xfffffff0, 0x77 };
+VECT_VAR_DECL(expected,uint,64,1) [] = { 0x88 };
+VECT_VAR_DECL(expected,poly,8,8) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
+					0xf4, 0xf5, 0x55, 0xf7 };
+VECT_VAR_DECL(expected,poly,16,4) [] = { 0xfff0, 0xfff1, 0x66, 0xfff3 };
+VECT_VAR_DECL(expected,hfloat,16,4) [] = { 0xcc00, 0xcb80, 0x4840, 0xca80 };
+VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0xc1800000, 0x4204cccd };
+VECT_VAR_DECL(expected,int,8,16) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
+					0xf4, 0xf5, 0xf6, 0xf7,
+					0xf8, 0xf9, 0xfa, 0xfb,
+					0xfc, 0xfd, 0xfe, 0x99 };
+VECT_VAR_DECL(expected,int,16,8) [] = { 0xfff0, 0xfff1, 0xfff2, 0xfff3,
+					0xfff4, 0xaa, 0xfff6, 0xfff7 };
+VECT_VAR_DECL(expected,int,32,4) [] = { 0xfffffff0, 0xfffffff1,
+					0xfffffff2, 0xbb };
+VECT_VAR_DECL(expected,int,64,2) [] = { 0xfffffffffffffff0, 0xcc };
+VECT_VAR_DECL(expected,uint,8,16) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
+					 0xf4, 0xf5, 0xf6, 0xf7,
+					 0xf8, 0xf9, 0xfa, 0xfb,
+					 0xfc, 0xfd, 0xdd, 0xff };
+VECT_VAR_DECL(expected,uint,16,8) [] = { 0xfff0, 0xfff1, 0xfff2, 0xfff3,
+					 0xfff4, 0xfff5, 0xee, 0xfff7 };
+VECT_VAR_DECL(expected,uint,32,4) [] = { 0xfffffff0, 0xfffffff1,
+					 0xff, 0xfffffff3 };
+VECT_VAR_DECL(expected,uint,64,2) [] = { 0xfffffffffffffff0, 0x11 };
+VECT_VAR_DECL(expected,poly,8,16) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
+					 0xf4, 0xf5, 0xf6, 0xf7,
+					 0xf8, 0xf9, 0xfa, 0xfb,
+					 0xfc, 0xfd, 0xdd, 0xff };
+VECT_VAR_DECL(expected,poly,16,8) [] = { 0xfff0, 0xfff1, 0xfff2, 0xfff3,
+					 0xfff4, 0xfff5, 0xee, 0xfff7 };
+VECT_VAR_DECL(expected,hfloat,16,8) [] = { 0xcc00, 0xcb80, 0xcb00, 0xca80,
+					   0xca00, 0x4480, 0xc900, 0xc880 };
+VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0xc1800000, 0xc1700000,
+					   0xc1600000, 0x41333333 };
+
+#define TEST_MSG "VSET_LANE/VSET_LANEQ"
+void exec_vset_lane (void)
+{
+  /* vec=vset_lane(val, vec, lane), then store the result.  */
+#define TEST_VSET_LANE(Q, T1, T2, W, N, V, L)				\
+  VECT_VAR(vector, T1, W, N) =						\
+    vset##Q##_lane_##T2##W(V,						\
+			   VECT_VAR(vector, T1, W, N),			\
+			   L);						\
+  vst1##Q##_##T2##W(VECT_VAR(result, T1, W, N), VECT_VAR(vector, T1, W, N))
+
+  DECL_VARIABLE_ALL_VARIANTS(vector);
+
+  clean_results ();
+
+  /* Initialize input "vector" from "buffer".  */
+  TEST_MACRO_ALL_VARIANTS_2_5(VLOAD, vector, buffer);
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+  VLOAD(vector, buffer, , float, f, 16, 4);
+  VLOAD(vector, buffer, q, float, f, 16, 8);
+#endif
+  VLOAD(vector, buffer, , float, f, 32, 2);
+  VLOAD(vector, buffer, q, float, f, 32, 4);
+
+  /* Choose value and lane arbitrarily.  */
+  TEST_VSET_LANE(, int, s, 8, 8, 0x11, 7);
+  TEST_VSET_LANE(, int, s, 16, 4, 0x22, 3);
+  TEST_VSET_LANE(, int, s, 32, 2, 0x33, 1);
+  TEST_VSET_LANE(, int, s, 64, 1, 0x44, 0);
+  TEST_VSET_LANE(, uint, u, 8, 8, 0x55, 6);
+  TEST_VSET_LANE(, uint, u, 16, 4, 0x66, 2);
+  TEST_VSET_LANE(, uint, u, 32, 2, 0x77, 1);
+  TEST_VSET_LANE(, uint, u, 64, 1, 0x88, 0);
+  TEST_VSET_LANE(, poly, p, 8, 8, 0x55, 6);
+  TEST_VSET_LANE(, poly, p, 16, 4, 0x66, 2);
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+  TEST_VSET_LANE(, float, f, 16, 4, 8.5f, 2);
+#endif
+  TEST_VSET_LANE(, float, f, 32, 2, 33.2f, 1);
+
+  TEST_VSET_LANE(q, int, s, 8, 16, 0x99, 15);
+  TEST_VSET_LANE(q, int, s, 16, 8, 0xAA, 5);
+  TEST_VSET_LANE(q, int, s, 32, 4, 0xBB, 3);
+  TEST_VSET_LANE(q, int, s, 64, 2, 0xCC, 1);
+  TEST_VSET_LANE(q, uint, u, 8, 16, 0xDD, 14);
+  TEST_VSET_LANE(q, uint, u, 16, 8, 0xEE, 6);
+  TEST_VSET_LANE(q, uint, u, 32, 4, 0xFF, 2);
+  TEST_VSET_LANE(q, uint, u, 64, 2, 0x11, 1);
+  TEST_VSET_LANE(q, poly, p, 8, 16, 0xDD, 14);
+  TEST_VSET_LANE(q, poly, p, 16, 8, 0xEE, 6);
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+  TEST_VSET_LANE(q, float, f, 16, 8, 4.5f, 5);
+#endif
+  TEST_VSET_LANE(q, float, f, 32, 4, 11.2f, 3);
+
+  CHECK_RESULTS(TEST_MSG, "");
+}
+
+int main (void)
+{
+  exec_vset_lane ();
+  return 0;
+}
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vshl.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vshl.c
@@ -13,11 +13,6 @@ VECT_VAR_DECL(expected,uint,8,8) [] = { 0xe0, 0xe2, 0xe4, 0xe6,
 VECT_VAR_DECL(expected,uint,16,4) [] = { 0xff80, 0xff88, 0xff90, 0xff98 };
 VECT_VAR_DECL(expected,uint,32,2) [] = { 0xfffff000, 0xfffff100 };
 VECT_VAR_DECL(expected,uint,64,1) [] = { 0xffffffffffffff80 };
-VECT_VAR_DECL(expected,poly,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,4) [] = { 0x3333, 0x3333,
-					 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0x33333333, 0x33333333 };
 VECT_VAR_DECL(expected,int,8,16) [] = { 0x0, 0x20, 0x40, 0x60,
 					0x80, 0xa0, 0xc0, 0xe0,
 					0x0, 0x20, 0x40, 0x60,
@@ -36,14 +31,6 @@ VECT_VAR_DECL(expected,uint,16,8) [] = { 0x0, 0x1000, 0x2000, 0x3000,
 VECT_VAR_DECL(expected,uint,32,4) [] = { 0x0, 0x40000000,
 					 0x80000000, 0xc0000000 };
 VECT_VAR_DECL(expected,uint,64,2) [] = { 0x0, 0x8000000000000000 };
-VECT_VAR_DECL(expected,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0x33333333, 0x33333333,
-					   0x33333333, 0x33333333 };
 
 /* Expected results with large shift amount.  */
 VECT_VAR_DECL(expected_large_shift,int,8,8) [] = { 0x0, 0x0, 0x0, 0x0,
@@ -56,11 +43,6 @@ VECT_VAR_DECL(expected_large_shift,uint,8,8) [] = { 0x0, 0x0, 0x0, 0x0,
 VECT_VAR_DECL(expected_large_shift,uint,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
 VECT_VAR_DECL(expected_large_shift,uint,32,2) [] = { 0x0, 0x0 };
 VECT_VAR_DECL(expected_large_shift,uint,64,1) [] = { 0x0 };
-VECT_VAR_DECL(expected_large_shift,poly,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-						    0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected_large_shift,poly,16,4) [] = { 0x3333, 0x3333,
-						     0x3333, 0x3333 };
-VECT_VAR_DECL(expected_large_shift,hfloat,32,2) [] = { 0x33333333, 0x33333333 };
 VECT_VAR_DECL(expected_large_shift,int,8,16) [] = { 0x0, 0x0, 0x0, 0x0,
 						    0x0, 0x0, 0x0, 0x0,
 						    0x0, 0x0, 0x0, 0x0,
@@ -77,16 +59,6 @@ VECT_VAR_DECL(expected_large_shift,uint,16,8) [] = { 0x0, 0x0, 0x0, 0x0,
 						     0x0, 0x0, 0x0, 0x0 };
 VECT_VAR_DECL(expected_large_shift,uint,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
 VECT_VAR_DECL(expected_large_shift,uint,64,2) [] = { 0x0, 0x0 };
-VECT_VAR_DECL(expected_large_shift,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-						     0x33, 0x33, 0x33, 0x33,
-						     0x33, 0x33, 0x33, 0x33,
-						     0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected_large_shift,poly,16,8) [] = { 0x3333, 0x3333,
-						     0x3333, 0x3333,
-						     0x3333, 0x3333,
-						     0x3333, 0x3333 };
-VECT_VAR_DECL(expected_large_shift,hfloat,32,4) [] = { 0x33333333, 0x33333333,
-						       0x33333333, 0x33333333 };
 
 
 /* Expected results with negative shift amount.  */
@@ -103,12 +75,6 @@ VECT_VAR_DECL(expected_negative_shift,uint,16,4) [] = { 0x7ff8, 0x7ff8,
 VECT_VAR_DECL(expected_negative_shift,uint,32,2) [] = { 0x3ffffffc,
 							0x3ffffffc };
 VECT_VAR_DECL(expected_negative_shift,uint,64,1) [] = { 0xfffffffffffffff };
-VECT_VAR_DECL(expected_negative_shift,poly,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-						       0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected_negative_shift,poly,16,4) [] = { 0x3333, 0x3333,
-							0x3333, 0x3333 };
-VECT_VAR_DECL(expected_negative_shift,hfloat,32,2) [] = { 0x33333333,
-							  0x33333333 };
 VECT_VAR_DECL(expected_negative_shift,int,8,16) [] = { 0xfc, 0xfc, 0xfc, 0xfc,
 						       0xfd, 0xfd, 0xfd, 0xfd,
 						       0xfe, 0xfe, 0xfe, 0xfe,
@@ -133,18 +99,6 @@ VECT_VAR_DECL(expected_negative_shift,uint,32,4) [] = { 0x1ffffffe, 0x1ffffffe,
 							0x1ffffffe, 0x1ffffffe };
 VECT_VAR_DECL(expected_negative_shift,uint,64,2) [] = { 0x7ffffffffffffff,
 							0x7ffffffffffffff };
-VECT_VAR_DECL(expected_negative_shift,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-							0x33, 0x33, 0x33, 0x33,
-							0x33, 0x33, 0x33, 0x33,
-							0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected_negative_shift,poly,16,8) [] = { 0x3333, 0x3333,
-							0x3333, 0x3333,
-							0x3333, 0x3333,
-							0x3333, 0x3333 };
-VECT_VAR_DECL(expected_negative_shift,hfloat,32,4) [] = { 0x33333333,
-							  0x33333333,
-							  0x33333333,
-							  0x33333333 };
 
 
 #ifndef INSN_NAME
@@ -187,7 +141,22 @@ void FNNAME (INSN_NAME) (void)
   /* Execute the tests.  */
   TEST_MACRO_ALL_VARIANTS_1_5(TEST_VSHL, int);
 
-  CHECK_RESULTS (TEST_MSG, "");
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected, "");
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected, "");
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected, "");
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected, "");
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected, "");
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected, "");
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected, "");
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected, "");
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected, "");
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected, "");
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected, "");
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected, "");
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected, "");
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected, "");
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected, "");
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected, "");
 
 
   /* Test large shift amount (larger or equal to the type width.  */
@@ -203,7 +172,23 @@ void FNNAME (INSN_NAME) (void)
   /* Execute the tests.  */
   TEST_MACRO_ALL_VARIANTS_1_5(TEST_VSHL, int);
 
-  CHECK_RESULTS_NAMED (TEST_MSG, expected_large_shift, "(large shift amount)");
+#define COMMENT1 "(large shift amount)"
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_large_shift, COMMENT1);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_large_shift, COMMENT1);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_large_shift, COMMENT1);
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected_large_shift, COMMENT1);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_large_shift, COMMENT1);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_large_shift, COMMENT1);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_large_shift, COMMENT1);
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected_large_shift, COMMENT1);
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected_large_shift, COMMENT1);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_large_shift, COMMENT1);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_large_shift, COMMENT1);
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected_large_shift, COMMENT1);
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected_large_shift, COMMENT1);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_large_shift, COMMENT1);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_large_shift, COMMENT1);
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected_large_shift, COMMENT1);
 
 
   /* Test negative shift amount. */
@@ -219,7 +204,23 @@ void FNNAME (INSN_NAME) (void)
   /* Execute the tests.  */
   TEST_MACRO_ALL_VARIANTS_1_5(TEST_VSHL, int);
 
-  CHECK_RESULTS_NAMED (TEST_MSG, expected_negative_shift, "(negative shift amount)");
+#define COMMENT2 "(negative shift amount)"
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_negative_shift, COMMENT2);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_negative_shift, COMMENT2);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_negative_shift, COMMENT2);
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected_negative_shift, COMMENT2);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_negative_shift, COMMENT2);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_negative_shift, COMMENT2);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_negative_shift, COMMENT2);
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected_negative_shift, COMMENT2);
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected_negative_shift, COMMENT2);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_negative_shift, COMMENT2);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_negative_shift, COMMENT2);
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected_negative_shift, COMMENT2);
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected_negative_shift, COMMENT2);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_negative_shift, COMMENT2);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_negative_shift, COMMENT2);
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected_negative_shift, COMMENT2);
 }
 
 int main (void)
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vshl_n.c
@@ -0,0 +1,96 @@
+#include <arm_neon.h>
+#include "arm-neon-ref.h"
+#include "compute-ref-data.h"
+
+/* Expected results.  */
+VECT_VAR_DECL(expected,int,8,8) [] = { 0xe0, 0xe2, 0xe4, 0xe6,
+				       0xe8, 0xea, 0xec, 0xee };
+VECT_VAR_DECL(expected,int,16,4) [] = { 0xffe0, 0xffe2, 0xffe4, 0xffe6 };
+VECT_VAR_DECL(expected,int,32,2) [] = { 0xffffff80, 0xffffff88 };
+VECT_VAR_DECL(expected,int,64,1) [] = { 0xffffffffffffffc0 };
+VECT_VAR_DECL(expected,uint,8,8) [] = { 0xc0, 0xc4, 0xc8, 0xcc,
+					0xd0, 0xd4, 0xd8, 0xdc };
+VECT_VAR_DECL(expected,uint,16,4) [] = { 0xff00, 0xff10, 0xff20, 0xff30 };
+VECT_VAR_DECL(expected,uint,32,2) [] = { 0xffffff80, 0xffffff88 };
+VECT_VAR_DECL(expected,uint,64,1) [] = { 0xffffffffffffffe0 };
+VECT_VAR_DECL(expected,int,8,16) [] = { 0x0, 0x20, 0x40, 0x60,
+					0x80, 0xa0, 0xc0, 0xe0,
+					0x0, 0x20, 0x40, 0x60,
+					0x80, 0xa0, 0xc0, 0xe0 };
+VECT_VAR_DECL(expected,int,16,8) [] = { 0xffe0, 0xffe2, 0xffe4, 0xffe6,
+					0xffe8, 0xffea, 0xffec, 0xffee };
+VECT_VAR_DECL(expected,int,32,4) [] = { 0xffffffc0, 0xffffffc4,
+					0xffffffc8, 0xffffffcc };
+VECT_VAR_DECL(expected,int,64,2) [] = { 0xffffffffffffffc0, 0xffffffffffffffc4 };
+VECT_VAR_DECL(expected,uint,8,16) [] = { 0xc0, 0xc4, 0xc8, 0xcc,
+					 0xd0, 0xd4, 0xd8, 0xdc,
+					 0xe0, 0xe4, 0xe8, 0xec,
+					 0xf0, 0xf4, 0xf8, 0xfc };
+VECT_VAR_DECL(expected,uint,16,8) [] = { 0xff80, 0xff88, 0xff90, 0xff98,
+					 0xffa0, 0xffa8, 0xffb0, 0xffb8 };
+VECT_VAR_DECL(expected,uint,32,4) [] = { 0xffffffc0, 0xffffffc4,
+					 0xffffffc8, 0xffffffcc };
+VECT_VAR_DECL(expected,uint,64,2) [] = { 0xffffffffffffffe0,
+					 0xffffffffffffffe2 };
+
+#define TEST_MSG "VSHL_N"
+void exec_vshl_n (void)
+{
+  /* Basic test: v2=vshl_n(v1,v), then store the result.  */
+#define TEST_VSHL_N(Q, T1, T2, W, N, V)					\
+  VECT_VAR(vector_res, T1, W, N) =					\
+    vshl##Q##_n_##T2##W(VECT_VAR(vector, T1, W, N),			\
+			V);						\
+  vst1##Q##_##T2##W(VECT_VAR(result, T1, W, N), VECT_VAR(vector_res, T1, W, N))
+
+  DECL_VARIABLE_ALL_VARIANTS(vector);
+  DECL_VARIABLE_ALL_VARIANTS(vector_res);
+
+  clean_results ();
+
+  /* Initialize input "vector" from "buffer".  */
+  TEST_MACRO_ALL_VARIANTS_2_5(VLOAD, vector, buffer);
+
+  /* Choose shift amount arbitrarily.  */
+  TEST_VSHL_N(, int, s, 8, 8, 1);
+  TEST_VSHL_N(, int, s, 16, 4, 1);
+  TEST_VSHL_N(, int, s, 32, 2, 3);
+  TEST_VSHL_N(, int, s, 64, 1, 2);
+  TEST_VSHL_N(, uint, u, 8, 8, 2);
+  TEST_VSHL_N(, uint, u, 16, 4, 4);
+  TEST_VSHL_N(, uint, u, 32, 2, 3);
+  TEST_VSHL_N(, uint, u, 64, 1, 1);
+
+  TEST_VSHL_N(q, int, s, 8, 16, 5);
+  TEST_VSHL_N(q, int, s, 16, 8, 1);
+  TEST_VSHL_N(q, int, s, 32, 4, 2);
+  TEST_VSHL_N(q, int, s, 64, 2, 2);
+  TEST_VSHL_N(q, uint, u, 8, 16, 2);
+  TEST_VSHL_N(q, uint, u, 16, 8, 3);
+  TEST_VSHL_N(q, uint, u, 32, 4, 2);
+  TEST_VSHL_N(q, uint, u, 64, 2, 1);
+
+#define CMT ""
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected, CMT);
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected, CMT);
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected, CMT);
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected, CMT);
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected, CMT);
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected, CMT);
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected, CMT);
+}
+
+int main (void)
+{
+  exec_vshl_n ();
+  return 0;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vshll_n.c
@@ -0,0 +1,56 @@
+#include <arm_neon.h>
+#include "arm-neon-ref.h"
+#include "compute-ref-data.h"
+
+/* Expected results.  */
+VECT_VAR_DECL(expected,int,16,8) [] = { 0xffe0, 0xffe2, 0xffe4, 0xffe6,
+					0xffe8, 0xffea, 0xffec, 0xffee };
+VECT_VAR_DECL(expected,int,32,4) [] = { 0xffffffe0, 0xffffffe2,
+					0xffffffe4, 0xffffffe6 };
+VECT_VAR_DECL(expected,int,64,2) [] = { 0xffffffffffffff80, 0xffffffffffffff88 };
+VECT_VAR_DECL(expected,uint,16,8) [] = { 0x3c0, 0x3c4, 0x3c8, 0x3cc,
+					 0x3d0, 0x3d4, 0x3d8, 0x3dc };
+VECT_VAR_DECL(expected,uint,32,4) [] = { 0xfff00, 0xfff10, 0xfff20, 0xfff30 };
+VECT_VAR_DECL(expected,uint,64,2) [] = { 0x7ffffff80, 0x7ffffff88 };
+
+#define TEST_MSG "VSHLL_N"
+void exec_vshll_n (void)
+{
+  /* Basic test: v2=vshll_n(v1,v), then store the result.  */
+#define TEST_VSHLL_N(T1, T2, W, W2, N, V)				\
+  VECT_VAR(vector_res, T1, W2, N) =					\
+    vshll##_n_##T2##W(VECT_VAR(vector, T1, W, N),			\
+		      V);						\
+  vst1q##_##T2##W2(VECT_VAR(result, T1, W2, N), VECT_VAR(vector_res, T1, W2, N))
+
+  DECL_VARIABLE_ALL_VARIANTS(vector);
+  DECL_VARIABLE_ALL_VARIANTS(vector_res);
+
+  clean_results ();
+
+  /* Initialize input "vector" from "buffer".  */
+  TEST_MACRO_ALL_VARIANTS_2_5(VLOAD, vector, buffer);
+
+  /* Choose shift amount arbitrarily.  */
+  TEST_VSHLL_N(int, s, 8, 16, 8, 1);
+  TEST_VSHLL_N(int, s, 16, 32, 4, 1);
+  TEST_VSHLL_N(int, s, 32, 64, 2, 3);
+  TEST_VSHLL_N(uint, u, 8, 16, 8, 2);
+  TEST_VSHLL_N(uint, u, 16, 32, 4, 4);
+  TEST_VSHLL_N(uint, u, 32, 64, 2, 3);
+
+#undef CMT
+#define CMT ""
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected, CMT);
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected, CMT);
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected, CMT);
+}
+
+int main (void)
+{
+  exec_vshll_n ();
+  return 0;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vshr_n.c
@@ -0,0 +1,95 @@
+#include <arm_neon.h>
+#include "arm-neon-ref.h"
+#include "compute-ref-data.h"
+
+/* Expected results.  */
+VECT_VAR_DECL(expected,int,8,8) [] = { 0xf8, 0xf8, 0xf9, 0xf9,
+				       0xfa, 0xfa, 0xfb, 0xfb };
+VECT_VAR_DECL(expected,int,16,4) [] = { 0xffff, 0xffff, 0xffff, 0xffff };
+VECT_VAR_DECL(expected,int,32,2) [] = { 0xfffffffc, 0xfffffffc };
+VECT_VAR_DECL(expected,int,64,1) [] = { 0xffffffffffffffff };
+VECT_VAR_DECL(expected,uint,8,8) [] = { 0x3c, 0x3c, 0x3c, 0x3c,
+					0x3d, 0x3d, 0x3d, 0x3d };
+VECT_VAR_DECL(expected,uint,16,4) [] = { 0x1ffe, 0x1ffe, 0x1ffe, 0x1ffe };
+VECT_VAR_DECL(expected,uint,32,2) [] = { 0x7ffffff, 0x7ffffff };
+VECT_VAR_DECL(expected,uint,64,1) [] = { 0x7fffffff };
+VECT_VAR_DECL(expected,int,8,16) [] = { 0xf8, 0xf8, 0xf9, 0xf9,
+					0xfa, 0xfa, 0xfb, 0xfb,
+					0xfc, 0xfc, 0xfd, 0xfd,
+					0xfe, 0xfe, 0xff, 0xff };
+VECT_VAR_DECL(expected,int,16,8) [] = { 0xffff, 0xffff, 0xffff, 0xffff,
+					0xffff, 0xffff, 0xffff, 0xffff };
+VECT_VAR_DECL(expected,int,32,4) [] = { 0xfffffffc, 0xfffffffc,
+					0xfffffffc, 0xfffffffc };
+VECT_VAR_DECL(expected,int,64,2) [] = { 0xffffffffffffffff, 0xffffffffffffffff };
+VECT_VAR_DECL(expected,uint,8,16) [] = { 0x3c, 0x3c, 0x3c, 0x3c,
+					 0x3d, 0x3d, 0x3d, 0x3d,
+					 0x3e, 0x3e, 0x3e, 0x3e,
+					 0x3f, 0x3f, 0x3f, 0x3f };
+VECT_VAR_DECL(expected,uint,16,8) [] = { 0x1ffe, 0x1ffe, 0x1ffe, 0x1ffe,
+					 0x1ffe, 0x1ffe, 0x1ffe, 0x1ffe };
+VECT_VAR_DECL(expected,uint,32,4) [] = { 0x7ffffff, 0x7ffffff,
+					 0x7ffffff, 0x7ffffff };
+VECT_VAR_DECL(expected,uint,64,2) [] = { 0x7fffffff, 0x7fffffff };
+
+#define TEST_MSG "VSHR_N"
+void exec_vshr_n (void)
+{
+  /* Basic test: y=vshr_n(x,v), then store the result.  */
+#define TEST_VSHR_N(Q, T1, T2, W, N, V)					\
+  VECT_VAR(vector_res, T1, W, N) =					\
+    vshr##Q##_n_##T2##W(VECT_VAR(vector, T1, W, N),			\
+			V);						\
+  vst1##Q##_##T2##W(VECT_VAR(result, T1, W, N), VECT_VAR(vector_res, T1, W, N))
+
+  DECL_VARIABLE_ALL_VARIANTS(vector);
+  DECL_VARIABLE_ALL_VARIANTS(vector_res);
+
+  clean_results ();
+
+  /* Initialize input "vector" from "buffer".  */
+  TEST_MACRO_ALL_VARIANTS_2_5(VLOAD, vector, buffer);
+
+  /* Choose shift amount arbitrarily.  */
+  TEST_VSHR_N(, int, s, 8, 8, 1);
+  TEST_VSHR_N(, int, s, 16, 4, 12);
+  TEST_VSHR_N(, int, s, 32, 2, 2);
+  TEST_VSHR_N(, int, s, 64, 1, 32);
+  TEST_VSHR_N(, uint, u, 8, 8, 2);
+  TEST_VSHR_N(, uint, u, 16, 4, 3);
+  TEST_VSHR_N(, uint, u, 32, 2, 5);
+  TEST_VSHR_N(, uint, u, 64, 1, 33);
+
+  TEST_VSHR_N(q, int, s, 8, 16, 1);
+  TEST_VSHR_N(q, int, s, 16, 8, 12);
+  TEST_VSHR_N(q, int, s, 32, 4, 2);
+  TEST_VSHR_N(q, int, s, 64, 2, 32);
+  TEST_VSHR_N(q, uint, u, 8, 16, 2);
+  TEST_VSHR_N(q, uint, u, 16, 8, 3);
+  TEST_VSHR_N(q, uint, u, 32, 4, 5);
+  TEST_VSHR_N(q, uint, u, 64, 2, 33);
+
+#define CMT ""
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected, CMT);
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected, CMT);
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected, CMT);
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected, CMT);
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected, CMT);
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected, CMT);
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected, CMT);
+}
+
+int main (void)
+{
+  exec_vshr_n ();
+  return 0;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vshrn_n.c
@@ -0,0 +1,70 @@
+#include <arm_neon.h>
+#include "arm-neon-ref.h"
+#include "compute-ref-data.h"
+
+/* Expected results.  */
+VECT_VAR_DECL(expected,int,8,8) [] = { 0xf8, 0xf8, 0xf9, 0xf9,
+				       0xfa, 0xfa, 0xfb, 0xfb };
+VECT_VAR_DECL(expected,int,16,4) [] = { 0xfff8, 0xfff8, 0xfff9, 0xfff9 };
+VECT_VAR_DECL(expected,int,32,2) [] = { 0xfffffffc, 0xfffffffc };
+VECT_VAR_DECL(expected,uint,8,8) [] = { 0xfc, 0xfc, 0xfc, 0xfc,
+					0xfd, 0xfd, 0xfd, 0xfd };
+VECT_VAR_DECL(expected,uint,16,4) [] = { 0xfffe, 0xfffe, 0xfffe, 0xfffe };
+VECT_VAR_DECL(expected,uint,32,2) [] = { 0xfffffffe, 0xfffffffe };
+
+#define TEST_MSG "VSHRN_N"
+void exec_vshrn_n (void)
+{
+  /* Basic test: y=vshrn_n(x,v), then store the result.  */
+#define TEST_VSHRN_N(T1, T2, W, W2, N, V)				\
+  VECT_VAR(vector_res, T1, W2, N) =					\
+    vshrn_n_##T2##W(VECT_VAR(vector, T1, W, N),				\
+		    V);							\
+  vst1_##T2##W2(VECT_VAR(result, T1, W2, N), VECT_VAR(vector_res, T1, W2, N))
+
+  /* vector is twice as large as vector_res.  */
+  DECL_VARIABLE(vector, int, 16, 8);
+  DECL_VARIABLE(vector, int, 32, 4);
+  DECL_VARIABLE(vector, int, 64, 2);
+  DECL_VARIABLE(vector, uint, 16, 8);
+  DECL_VARIABLE(vector, uint, 32, 4);
+  DECL_VARIABLE(vector, uint, 64, 2);
+
+  DECL_VARIABLE(vector_res, int, 8, 8);
+  DECL_VARIABLE(vector_res, int, 16, 4);
+  DECL_VARIABLE(vector_res, int, 32, 2);
+  DECL_VARIABLE(vector_res, uint, 8, 8);
+  DECL_VARIABLE(vector_res, uint, 16, 4);
+  DECL_VARIABLE(vector_res, uint, 32, 2);
+
+  clean_results ();
+
+  VLOAD(vector, buffer, q, int, s, 16, 8);
+  VLOAD(vector, buffer, q, int, s, 32, 4);
+  VLOAD(vector, buffer, q, int, s, 64, 2);
+  VLOAD(vector, buffer, q, uint, u, 16, 8);
+  VLOAD(vector, buffer, q, uint, u, 32, 4);
+  VLOAD(vector, buffer, q, uint, u, 64, 2);
+
+  /* Choose shift amount arbitrarily.  */
+  TEST_VSHRN_N(int, s, 16, 8, 8, 1);
+  TEST_VSHRN_N(int, s, 32, 16, 4, 1);
+  TEST_VSHRN_N(int, s, 64, 32, 2, 2);
+  TEST_VSHRN_N(uint, u, 16, 8, 8, 2);
+  TEST_VSHRN_N(uint, u, 32, 16, 4, 3);
+  TEST_VSHRN_N(uint, u, 64, 32, 2, 3);
+
+#define CMT ""
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected, CMT);
+}
+
+int main (void)
+{
+  exec_vshrn_n ();
+  return 0;
+}
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vshuffle.inc
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vshuffle.inc
@@ -120,15 +120,40 @@ void FNNAME (INSN_NAME) (void)
   TEST_EXTRA_CHUNK(poly, 16, 8, 1);		\
   TEST_EXTRA_CHUNK(float, 32, 4, 1)
 
+  /* vshuffle support all vector types except [u]int64x1 and
+     [u]int64x2.  */
+#define CHECK_RESULTS_VSHUFFLE(test_name,EXPECTED,comment)		\
+  {									\
+    CHECK(test_name, int, 8, 8, PRIx8, EXPECTED, comment);		\
+    CHECK(test_name, int, 16, 4, PRIx16, EXPECTED, comment);		\
+    CHECK(test_name, int, 32, 2, PRIx32, EXPECTED, comment);		\
+    CHECK(test_name, uint, 8, 8, PRIx8, EXPECTED, comment);		\
+    CHECK(test_name, uint, 16, 4, PRIx16, EXPECTED, comment);		\
+    CHECK(test_name, uint, 32, 2, PRIx32, EXPECTED, comment);		\
+    CHECK(test_name, poly, 8, 8, PRIx8, EXPECTED, comment);		\
+    CHECK(test_name, poly, 16, 4, PRIx16, EXPECTED, comment);		\
+    CHECK_FP(test_name, float, 32, 2, PRIx32, EXPECTED, comment);	\
+									\
+    CHECK(test_name, int, 8, 16, PRIx8, EXPECTED, comment);		\
+    CHECK(test_name, int, 16, 8, PRIx16, EXPECTED, comment);		\
+    CHECK(test_name, int, 32, 4, PRIx32, EXPECTED, comment);		\
+    CHECK(test_name, uint, 8, 16, PRIx8, EXPECTED, comment);		\
+    CHECK(test_name, uint, 16, 8, PRIx16, EXPECTED, comment);		\
+    CHECK(test_name, uint, 32, 4, PRIx32, EXPECTED, comment);		\
+    CHECK(test_name, poly, 8, 16, PRIx8, EXPECTED, comment);		\
+    CHECK(test_name, poly, 16, 8, PRIx16, EXPECTED, comment);		\
+    CHECK_FP(test_name, float, 32, 4, PRIx32, EXPECTED, comment);	\
+  }									\
+
   clean_results ();
 
   /* Execute the tests.  */
   TEST_ALL_VSHUFFLE(INSN_NAME);
 
-  CHECK_RESULTS_NAMED (TEST_MSG, expected0, "(chunk 0)");
+  CHECK_RESULTS_VSHUFFLE (TEST_MSG, expected0, "(chunk 0)");
 
   TEST_ALL_EXTRA_CHUNKS();
-  CHECK_RESULTS_NAMED (TEST_MSG, expected1, "(chunk 1)");
+  CHECK_RESULTS_VSHUFFLE (TEST_MSG, expected1, "(chunk 1)");
 }
 
 int main (void)
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vsli_n.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vsli_n.c
@@ -23,7 +23,6 @@ VECT_VAR_DECL(expected,uint,64,1) [] = { 0x10 };
 VECT_VAR_DECL(expected,poly,8,8) [] = { 0x50, 0x51, 0x52, 0x53,
 					0x50, 0x51, 0x52, 0x53 };
 VECT_VAR_DECL(expected,poly,16,4) [] = { 0x7bf0, 0x7bf1, 0x7bf2, 0x7bf3 };
-VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0x33333333, 0x33333333 };
 VECT_VAR_DECL(expected,int,8,16) [] = { 0xd0, 0xd1, 0xd2, 0xd3,
 					0xd4, 0xd5, 0xd6, 0xd7,
 					0xd8, 0xd9, 0xda, 0xdb,
@@ -48,8 +47,6 @@ VECT_VAR_DECL(expected,poly,8,16) [] = { 0x60, 0x61, 0x62, 0x63,
 					 0x64, 0x65, 0x66, 0x67 };
 VECT_VAR_DECL(expected,poly,16,8) [] = { 0x3ff0, 0x3ff1, 0x3ff2, 0x3ff3,
 					 0x3ff4, 0x3ff5, 0x3ff6, 0x3ff7 };
-VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0x33333333, 0x33333333,
-					   0x33333333, 0x33333333 };
 
 /* Expected results with max shift amount.  */
 VECT_VAR_DECL(expected_max_shift,int,8,8) [] = { 0x70, 0x71, 0x72, 0x73,
@@ -68,7 +65,6 @@ VECT_VAR_DECL(expected_max_shift,poly,8,8) [] = { 0x70, 0x71, 0x72, 0x73,
 						  0x74, 0x75, 0x76, 0x77 };
 VECT_VAR_DECL(expected_max_shift,poly,16,4) [] = { 0x7ff0, 0x7ff1,
 						   0x7ff2, 0x7ff3 };
-VECT_VAR_DECL(expected_max_shift,hfloat,32,2) [] = { 0x33333333, 0x33333333 };
 VECT_VAR_DECL(expected_max_shift,int,8,16) [] = { 0x70, 0x71, 0x72, 0x73,
 						  0x74, 0x75, 0x76, 0x77,
 						  0x78, 0x79, 0x7a, 0x7b,
@@ -95,8 +91,6 @@ VECT_VAR_DECL(expected_max_shift,poly,8,16) [] = { 0x70, 0x71, 0x72, 0x73,
 						   0x7c, 0x7d, 0x7e, 0x7f };
 VECT_VAR_DECL(expected_max_shift,poly,16,8) [] = { 0xfff0, 0xfff1, 0xfff2, 0xfff3,
 						   0xfff4, 0xfff5, 0xfff6, 0xfff7 };
-VECT_VAR_DECL(expected_max_shift,hfloat,32,4) [] = { 0x33333333, 0x33333333,
-						     0x33333333, 0x33333333 };
 
 #include "vsXi_n.inc"
 
@@ -158,5 +152,23 @@ void vsli_extra(void)
   TEST_VSXI_N(INSN_NAME, q, poly, p, 8, 16, 7);
   TEST_VSXI_N(INSN_NAME, q, poly, p, 16, 8, 15);
 
-  CHECK_RESULTS_NAMED (TEST_MSG, expected_max_shift, "(max shift amount)");
+#define COMMENT "(max shift amount)"
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_max_shift, COMMENT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_max_shift, COMMENT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_max_shift, COMMENT);
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected_max_shift, COMMENT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_max_shift, COMMENT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_max_shift, COMMENT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_max_shift, COMMENT);
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected_max_shift, COMMENT);
+  CHECK(TEST_MSG, poly, 8, 8, PRIx8, expected_max_shift, COMMENT);
+  CHECK(TEST_MSG, poly, 16, 4, PRIx16, expected_max_shift, COMMENT);
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected_max_shift, COMMENT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_max_shift, COMMENT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_max_shift, COMMENT);
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected_max_shift, COMMENT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_max_shift, COMMENT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_max_shift, COMMENT);
+  CHECK(TEST_MSG, poly, 8, 16, PRIx8, expected_max_shift, COMMENT);
+  CHECK(TEST_MSG, poly, 16, 8, PRIx16, expected_max_shift, COMMENT);
 }
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vsra_n.c
@@ -0,0 +1,117 @@
+#include <arm_neon.h>
+#include "arm-neon-ref.h"
+#include "compute-ref-data.h"
+
+/* Expected results.  */
+VECT_VAR_DECL(expected,int,8,8) [] = { 0xf8, 0xf9, 0xfa, 0xfb,
+				       0xfc, 0xfd, 0xfe, 0xff };
+VECT_VAR_DECL(expected,int,16,4) [] = { 0xfff0, 0xfff1, 0xfff2, 0xfff3 };
+VECT_VAR_DECL(expected,int,32,2) [] = { 0xfffffffc, 0xfffffffd };
+VECT_VAR_DECL(expected,int,64,1) [] = { 0xfffffffffffffff0 };
+VECT_VAR_DECL(expected,uint,8,8) [] = { 0x5, 0x6, 0x7, 0x8,
+					0x9, 0xa, 0xb, 0xc };
+VECT_VAR_DECL(expected,uint,16,4) [] = { 0xfffc, 0xfffd, 0xfffe, 0xffff };
+VECT_VAR_DECL(expected,uint,32,2) [] = { 0xfffffff3, 0xfffffff4 };
+VECT_VAR_DECL(expected,uint,64,1) [] = { 0xfffffffffffffff0 };
+VECT_VAR_DECL(expected,int,8,16) [] = { 0xf8, 0xf9, 0xfa, 0xfb,
+					0xfc, 0xfd, 0xfe, 0xff,
+					0x0, 0x1, 0x2, 0x3,
+					0x4, 0x5, 0x6, 0x7 };
+VECT_VAR_DECL(expected,int,16,8) [] = { 0xfff0, 0xfff1, 0xfff2, 0xfff3,
+					0xfff4, 0xfff5, 0xfff6, 0xfff7 };
+VECT_VAR_DECL(expected,int,32,4) [] = { 0xfffffffc, 0xfffffffd,
+					0xfffffffe, 0xffffffff };
+VECT_VAR_DECL(expected,int,64,2) [] = { 0xfffffffffffffff0,
+					0xfffffffffffffff1 };
+VECT_VAR_DECL(expected,uint,8,16) [] = { 0x5, 0x6, 0x7, 0x8,
+					 0x9, 0xa, 0xb, 0xc,
+					 0xd, 0xe, 0xf, 0x10,
+					 0x11, 0x12, 0x13, 0x14 };
+VECT_VAR_DECL(expected,uint,16,8) [] = { 0xfffc, 0xfffd, 0xfffe, 0xffff,
+					 0x0, 0x1, 0x2, 0x3 };
+VECT_VAR_DECL(expected,uint,32,4) [] = { 0xfffffff3, 0xfffffff4,
+					 0xfffffff5, 0xfffffff6 };
+VECT_VAR_DECL(expected,uint,64,2) [] = { 0xfffffffffffffff0,
+					 0xfffffffffffffff1 };
+
+#define TEST_MSG "VSRA_N"
+void exec_vsra_n (void)
+{
+  /* Basic test: y=vsra_n(x,v), then store the result.  */
+#define TEST_VSRA_N(Q, T1, T2, W, N, V)					\
+  VECT_VAR(vector_res, T1, W, N) =					\
+    vsra##Q##_n_##T2##W(VECT_VAR(vector, T1, W, N),			\
+			VECT_VAR(vector2, T1, W, N),			\
+			V);						\
+  vst1##Q##_##T2##W(VECT_VAR(result, T1, W, N), VECT_VAR(vector_res, T1, W, N))
+
+  DECL_VARIABLE_ALL_VARIANTS(vector);
+  DECL_VARIABLE_ALL_VARIANTS(vector2);
+  DECL_VARIABLE_ALL_VARIANTS(vector_res);
+
+  clean_results ();
+
+  /* Initialize input "vector" from "buffer".  */
+  TEST_MACRO_ALL_VARIANTS_2_5(VLOAD, vector, buffer);
+
+  /* Choose arbitrary initialization values.  */
+  VDUP(vector2, , int, s, 8, 8, 0x11);
+  VDUP(vector2, , int, s, 16, 4, 0x22);
+  VDUP(vector2, , int, s, 32, 2, 0x33);
+  VDUP(vector2, , int, s, 64, 1, 0x44);
+  VDUP(vector2, , uint, u, 8, 8, 0x55);
+  VDUP(vector2, , uint, u, 16, 4, 0x66);
+  VDUP(vector2, , uint, u, 32, 2, 0x77);
+  VDUP(vector2, , uint, u, 64, 1, 0x88);
+
+  VDUP(vector2, q, int, s, 8, 16, 0x11);
+  VDUP(vector2, q, int, s, 16, 8, 0x22);
+  VDUP(vector2, q, int, s, 32, 4, 0x33);
+  VDUP(vector2, q, int, s, 64, 2, 0x44);
+  VDUP(vector2, q, uint, u, 8, 16, 0x55);
+  VDUP(vector2, q, uint, u, 16, 8, 0x66);
+  VDUP(vector2, q, uint, u, 32, 4, 0x77);
+  VDUP(vector2, q, uint, u, 64, 2, 0x88);
+
+  /* Choose shift amount arbitrarily.  */
+  TEST_VSRA_N(, int, s, 8, 8, 1);
+  TEST_VSRA_N(, int, s, 16, 4, 12);
+  TEST_VSRA_N(, int, s, 32, 2, 2);
+  TEST_VSRA_N(, int, s, 64, 1, 32);
+  TEST_VSRA_N(, uint, u, 8, 8, 2);
+  TEST_VSRA_N(, uint, u, 16, 4, 3);
+  TEST_VSRA_N(, uint, u, 32, 2, 5);
+  TEST_VSRA_N(, uint, u, 64, 1, 33);
+
+  TEST_VSRA_N(q, int, s, 8, 16, 1);
+  TEST_VSRA_N(q, int, s, 16, 8, 12);
+  TEST_VSRA_N(q, int, s, 32, 4, 2);
+  TEST_VSRA_N(q, int, s, 64, 2, 32);
+  TEST_VSRA_N(q, uint, u, 8, 16, 2);
+  TEST_VSRA_N(q, uint, u, 16, 8, 3);
+  TEST_VSRA_N(q, uint, u, 32, 4, 5);
+  TEST_VSRA_N(q, uint, u, 64, 2, 33);
+
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected, "");
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected, "");
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected, "");
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected, "");
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected, "");
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected, "");
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected, "");
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected, "");
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected, "");
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected, "");
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected, "");
+  CHECK(TEST_MSG, int, 64, 2, PRIx64, expected, "");
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected, "");
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected, "");
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected, "");
+  CHECK(TEST_MSG, uint, 64, 2, PRIx64, expected, "");
+}
+
+int main (void)
+{
+  exec_vsra_n ();
+  return 0;
+}
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vsri_n.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vsri_n.c
@@ -23,7 +23,6 @@ VECT_VAR_DECL(expected,uint,64,1) [] = { 0xe000000000000000 };
 VECT_VAR_DECL(expected,poly,8,8) [] = { 0xc5, 0xc5, 0xc5, 0xc5,
 					0xc5, 0xc5, 0xc5, 0xc5 };
 VECT_VAR_DECL(expected,poly,16,4) [] = { 0xffc0, 0xffc0, 0xffc0, 0xffc0 };
-VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0x33333333, 0x33333333 };
 VECT_VAR_DECL(expected,int,8,16) [] = { 0xf7, 0xf7, 0xf7, 0xf7,
 					0xf7, 0xf7, 0xf7, 0xf7,
 					0xff, 0xff, 0xff, 0xff,
@@ -50,8 +49,6 @@ VECT_VAR_DECL(expected,poly,8,16) [] = { 0xe1, 0xe1, 0xe1, 0xe1,
 					 0xe1, 0xe1, 0xe1, 0xe1 };
 VECT_VAR_DECL(expected,poly,16,8) [] = { 0xfff0, 0xfff0, 0xfff0, 0xfff0,
 					 0xfff0, 0xfff0, 0xfff0, 0xfff0 };
-VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0x33333333, 0x33333333,
-					   0x33333333, 0x33333333 };
 
 /* Expected results with max shift amount.  */
 VECT_VAR_DECL(expected_max_shift,int,8,8) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
@@ -70,7 +67,6 @@ VECT_VAR_DECL(expected_max_shift,poly,8,8) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
 						  0xf4, 0xf5, 0xf6, 0xf7 };
 VECT_VAR_DECL(expected_max_shift,poly,16,4) [] = { 0xfff0, 0xfff1,
 						   0xfff2, 0xfff3 };
-VECT_VAR_DECL(expected_max_shift,hfloat,32,2) [] = { 0x33333333, 0x33333333 };
 VECT_VAR_DECL(expected_max_shift,int,8,16) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
 						  0xf4, 0xf5, 0xf6, 0xf7,
 						  0xf8, 0xf9, 0xfa, 0xfb,
@@ -97,8 +93,6 @@ VECT_VAR_DECL(expected_max_shift,poly,8,16) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
 						   0xfc, 0xfd, 0xfe, 0xff };
 VECT_VAR_DECL(expected_max_shift,poly,16,8) [] = { 0xfff0, 0xfff1, 0xfff2, 0xfff3,
 						   0xfff4, 0xfff5, 0xfff6, 0xfff7 };
-VECT_VAR_DECL(expected_max_shift,hfloat,32,4) [] = { 0x33333333, 0x33333333,
-						     0x33333333, 0x33333333 };
 
 #include "vsXi_n.inc"
 
@@ -160,5 +154,23 @@ void vsri_extra(void)
   TEST_VSXI_N(INSN_NAME, q, poly, p, 8, 16, 8);
   TEST_VSXI_N(INSN_NAME, q, poly, p, 16, 8, 16);
 
-  CHECK_RESULTS_NAMED (TEST_MSG, expected_max_shift, "(max shift amount)");
+#define COMMENT "(max shift amount)"
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_max_shift, COMMENT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_max_shift, COMMENT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_max_shift, COMMENT);
+  CHECK(TEST_MSG, int, 64, 1, PRIx64, expected_max_shift, COMMENT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_max_shift, COMMENT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_max_shift, COMMENT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_max_shift, COMMENT);
+  CHECK(TEST_MSG, uint, 64, 1, PRIx64, expected_max_shift, COMMENT);
+  CHECK(TEST_MSG, poly, 8, 8, PRIx8, expected_max_shift, COMMENT);
+  CHECK(TEST_MSG, poly, 16, 4, PRIx16, expected_max_shift, COMMENT);
+  CHECK(TEST_MSG, int, 8, 16, PRIx8, expected_max_shift, COMMENT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_max_shift, COMMENT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_max_shift, COMMENT);
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected_max_shift, COMMENT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_max_shift, COMMENT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_max_shift, COMMENT);
+  CHECK(TEST_MSG, poly, 8, 16, PRIx8, expected_max_shift, COMMENT);
+  CHECK(TEST_MSG, poly, 16, 8, PRIx16, expected_max_shift, COMMENT);
 }
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst1_lane.c
@@ -0,0 +1,102 @@
+#include <arm_neon.h>
+#include "arm-neon-ref.h"
+#include "compute-ref-data.h"
+
+/* Expected results.  */
+VECT_VAR_DECL(expected,int,8,8) [] = { 0xf7, 0x33, 0x33, 0x33,
+				       0x33, 0x33, 0x33, 0x33 };
+VECT_VAR_DECL(expected,int,16,4) [] = { 0xfff3, 0x3333, 0x3333, 0x3333 };
+VECT_VAR_DECL(expected,int,32,2) [] = { 0xfffffff1, 0x33333333 };
+VECT_VAR_DECL(expected,int,64,1) [] = { 0xfffffffffffffff0 };
+VECT_VAR_DECL(expected,uint,8,8) [] = { 0xf6, 0x33, 0x33, 0x33,
+					0x33, 0x33, 0x33, 0x33 };
+VECT_VAR_DECL(expected,uint,16,4) [] = { 0xfff2, 0x3333, 0x3333, 0x3333 };
+VECT_VAR_DECL(expected,uint,32,2) [] = { 0xfffffff0, 0x33333333 };
+VECT_VAR_DECL(expected,uint,64,1) [] = { 0xfffffffffffffff0 };
+VECT_VAR_DECL(expected,poly,8,8) [] = { 0xf6, 0x33, 0x33, 0x33,
+					0x33, 0x33, 0x33, 0x33 };
+VECT_VAR_DECL(expected,poly,16,4) [] = { 0xfff2, 0x3333, 0x3333, 0x3333 };
+VECT_VAR_DECL(expected,hfloat,16,4) [] = { 0xcb80, 0x3333, 0x3333, 0x3333 };
+VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0xc1700000, 0x33333333 };
+VECT_VAR_DECL(expected,int,8,16) [] = { 0xff, 0x33, 0x33, 0x33,
+					0x33, 0x33, 0x33, 0x33,
+					0x33, 0x33, 0x33, 0x33,
+					0x33, 0x33, 0x33, 0x33 };
+VECT_VAR_DECL(expected,int,16,8) [] = { 0xfff5, 0x3333, 0x3333, 0x3333,
+					0x3333, 0x3333, 0x3333, 0x3333 };
+VECT_VAR_DECL(expected,int,32,4) [] = { 0xfffffff1, 0x33333333,
+					0x33333333, 0x33333333 };
+VECT_VAR_DECL(expected,int,64,2) [] = { 0xfffffffffffffff1, 0x3333333333333333 };
+VECT_VAR_DECL(expected,uint,8,16) [] = { 0xfa, 0x33, 0x33, 0x33,
+					 0x33, 0x33, 0x33, 0x33,
+					 0x33, 0x33, 0x33, 0x33,
+					 0x33, 0x33, 0x33, 0x33 };
+VECT_VAR_DECL(expected,uint,16,8) [] = { 0xfff4, 0x3333, 0x3333, 0x3333,
+					 0x3333, 0x3333, 0x3333, 0x3333 };
+VECT_VAR_DECL(expected,uint,32,4) [] = { 0xfffffff3, 0x33333333,
+					 0x33333333, 0x33333333 };
+VECT_VAR_DECL(expected,uint,64,2) [] = { 0xfffffffffffffff0,
+					 0x3333333333333333 };
+VECT_VAR_DECL(expected,poly,8,16) [] = { 0xfa, 0x33, 0x33, 0x33,
+					 0x33, 0x33, 0x33, 0x33,
+					 0x33, 0x33, 0x33, 0x33,
+					 0x33, 0x33, 0x33, 0x33 };
+VECT_VAR_DECL(expected,poly,16,8) [] = { 0xfff4, 0x3333, 0x3333, 0x3333,
+					 0x3333, 0x3333, 0x3333, 0x3333 };
+VECT_VAR_DECL(expected,hfloat,16,8) [] = { 0xc900, 0x3333, 0x3333, 0x3333,
+					   0x3333, 0x3333, 0x3333, 0x3333 };
+VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0xc1700000, 0x33333333,
+					   0x33333333, 0x33333333 };
+
+#define TEST_MSG "VST1_LANE/VST1_LANEQ"
+void exec_vst1_lane (void)
+{
+#define TEST_VST1_LANE(Q, T1, T2, W, N, L)		\
+  VECT_VAR(vector, T1, W, N) =				\
+    vld1##Q##_##T2##W(VECT_VAR(buffer, T1, W, N));	\
+  vst1##Q##_lane_##T2##W(VECT_VAR(result, T1, W, N),	\
+			 VECT_VAR(vector, T1, W, N), L)
+
+  DECL_VARIABLE_ALL_VARIANTS(vector);
+
+  clean_results ();
+
+  /* Choose lane arbitrarily.  */
+  TEST_VST1_LANE(, int, s, 8, 8, 7);
+  TEST_VST1_LANE(, int, s, 16, 4, 3);
+  TEST_VST1_LANE(, int, s, 32, 2, 1);
+  TEST_VST1_LANE(, int, s, 64, 1, 0);
+  TEST_VST1_LANE(, uint, u, 8, 8, 6);
+  TEST_VST1_LANE(, uint, u, 16, 4, 2);
+  TEST_VST1_LANE(, uint, u, 32, 2, 0);
+  TEST_VST1_LANE(, uint, u, 64, 1, 0);
+  TEST_VST1_LANE(, poly, p, 8, 8, 6);
+  TEST_VST1_LANE(, poly, p, 16, 4, 2);
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+  TEST_VST1_LANE(, float, f, 16, 4, 1);
+#endif
+  TEST_VST1_LANE(, float, f, 32, 2, 1);
+
+  TEST_VST1_LANE(q, int, s, 8, 16, 15);
+  TEST_VST1_LANE(q, int, s, 16, 8, 5);
+  TEST_VST1_LANE(q, int, s, 32, 4, 1);
+  TEST_VST1_LANE(q, int, s, 64, 2, 1);
+  TEST_VST1_LANE(q, uint, u, 8, 16, 10);
+  TEST_VST1_LANE(q, uint, u, 16, 8, 4);
+  TEST_VST1_LANE(q, uint, u, 32, 4, 3);
+  TEST_VST1_LANE(q, uint, u, 64, 2, 0);
+  TEST_VST1_LANE(q, poly, p, 8, 16, 10);
+  TEST_VST1_LANE(q, poly, p, 16, 8, 4);
+#if defined (__ARM_FP16_FORMAT_IEEE) || defined (__ARM_FP16_FORMAT_ALTERNATIVE)
+  TEST_VST1_LANE(q, float, f, 16, 8, 6);
+#endif
+  TEST_VST1_LANE(q, float, f, 32, 4, 1);
+
+  CHECK_RESULTS(TEST_MSG, "");
+}
+
+int main (void)
+{
+  exec_vst1_lane ();
+  return 0;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst2_lane_f16_indices_1.c
@@ -0,0 +1,15 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+void
+f_vst2_lane_f16 (float16_t * p, float16x4x2_t v)
+{
+  /* { dg-error "lane 4 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  vst2_lane_f16 (p, v, 4);
+  /* { dg-error "lane -1 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  vst2_lane_f16 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst2_lane_f32_indices_1.c
@@ -0,0 +1,15 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+void
+f_vst2_lane_f32 (float32_t * p, float32x2x2_t v)
+{
+  /* { dg-error "lane 2 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  vst2_lane_f32 (p, v, 2);
+  /* { dg-error "lane -1 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  vst2_lane_f32 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst2_lane_f64_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+/* { dg-skip-if "" { arm*-*-* } } */
+
+void
+f_vst2_lane_f64 (float64_t * p, float64x1x2_t v)
+{
+  /* { dg-error "lane 1 out of range 0 - 0" "" { xfail arm*-*-* } 0 } */
+  vst2_lane_f64 (p, v, 1);
+  /* { dg-error "lane -1 out of range 0 - 0" "" { xfail arm*-*-* } 0 } */
+  vst2_lane_f64 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst2_lane_p8_indices_1.c
@@ -0,0 +1,15 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+void
+f_vst2_lane_p8 (poly8_t * p, poly8x8x2_t v)
+{
+  /* { dg-error "lane 8 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  vst2_lane_p8 (p, v, 8);
+  /* { dg-error "lane -1 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  vst2_lane_p8 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst2_lane_s16_indices_1.c
@@ -0,0 +1,15 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+void
+f_vst2_lane_s16 (int16_t * p, int16x4x2_t v)
+{
+  /* { dg-error "lane 4 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  vst2_lane_s16 (p, v, 4);
+  /* { dg-error "lane -1 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  vst2_lane_s16 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst2_lane_s32_indices_1.c
@@ -0,0 +1,15 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+void
+f_vst2_lane_s32 (int32_t * p, int32x2x2_t v)
+{
+  /* { dg-error "lane 2 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  vst2_lane_s32 (p, v, 2);
+  /* { dg-error "lane -1 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  vst2_lane_s32 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst2_lane_s64_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+/* { dg-skip-if "" { arm*-*-* } } */
+
+void
+f_vst2_lane_s64 (int64_t * p, int64x1x2_t v)
+{
+  /* { dg-error "lane 1 out of range 0 - 0" "" { xfail arm*-*-* } 0 } */
+  vst2_lane_s64 (p, v, 1);
+  /* { dg-error "lane -1 out of range 0 - 0" "" { xfail arm*-*-* } 0 } */
+  vst2_lane_s64 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst2_lane_s8_indices_1.c
@@ -0,0 +1,15 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+void
+f_vst2_lane_s8 (int8_t * p, int8x8x2_t v)
+{
+  /* { dg-error "lane 8 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  vst2_lane_s8 (p, v, 8);
+  /* { dg-error "lane -1 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  vst2_lane_s8 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst2_lane_u16_indices_1.c
@@ -0,0 +1,15 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+void
+f_vst2_lane_u16 (uint16_t * p, uint16x4x2_t v)
+{
+  /* { dg-error "lane 4 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  vst2_lane_u16 (p, v, 4);
+  /* { dg-error "lane -1 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  vst2_lane_u16 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst2_lane_u32_indices_1.c
@@ -0,0 +1,15 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+void
+f_vst2_lane_u32 (uint32_t * p, uint32x2x2_t v)
+{
+  /* { dg-error "lane 2 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  vst2_lane_u32 (p, v, 2);
+  /* { dg-error "lane -1 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  vst2_lane_u32 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst2_lane_u64_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+/* { dg-skip-if "" { arm*-*-* } } */
+
+void
+f_vst2_lane_u64 (uint64_t * p, uint64x1x2_t v)
+{
+  /* { dg-error "lane 1 out of range 0 - 0" "" { xfail arm*-*-* } 0 } */
+  vst2_lane_u64 (p, v, 1);
+  /* { dg-error "lane -1 out of range 0 - 0" "" { xfail arm*-*-* } 0 } */
+  vst2_lane_u64 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst2_lane_u8_indices_1.c
@@ -0,0 +1,15 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+void
+f_vst2_lane_u8 (uint8_t * p, uint8x8x2_t v)
+{
+  /* { dg-error "lane 8 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  vst2_lane_u8 (p, v, 8);
+  /* { dg-error "lane -1 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  vst2_lane_u8 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst2q_lane_f16_indices_1.c
@@ -0,0 +1,15 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+void
+f_vst2q_lane_f16 (float16_t * p, float16x8x2_t v)
+{
+  /* { dg-error "lane 8 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  vst2q_lane_f16 (p, v, 8);
+  /* { dg-error "lane -1 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  vst2q_lane_f16 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst2q_lane_f32_indices_1.c
@@ -0,0 +1,15 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+void
+f_vst2q_lane_f32 (float32_t * p, float32x4x2_t v)
+{
+  /* { dg-error "lane 4 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  vst2q_lane_f32 (p, v, 4);
+  /* { dg-error "lane -1 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  vst2q_lane_f32 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst2q_lane_f64_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+/* { dg-skip-if "" { arm*-*-* } } */
+
+void
+f_vst2q_lane_f64 (float64_t * p, float64x2x2_t v)
+{
+  /* { dg-error "lane 2 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  vst2q_lane_f64 (p, v, 2);
+  /* { dg-error "lane -1 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  vst2q_lane_f64 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst2q_lane_p8_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+/* { dg-skip-if "" { arm*-*-* } } */
+
+void
+f_vst2q_lane_p8 (poly8_t * p, poly8x16x2_t v)
+{
+  /* { dg-error "lane 16 out of range 0 - 15" "" { xfail arm*-*-* } 0 } */
+  vst2q_lane_p8 (p, v, 16);
+  /* { dg-error "lane -1 out of range 0 - 15" "" { xfail arm*-*-* } 0 } */
+  vst2q_lane_p8 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst2q_lane_s16_indices_1.c
@@ -0,0 +1,15 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+void
+f_vst2q_lane_s16 (int16_t * p, int16x8x2_t v)
+{
+  /* { dg-error "lane 8 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  vst2q_lane_s16 (p, v, 8);
+  /* { dg-error "lane -1 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  vst2q_lane_s16 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst2q_lane_s32_indices_1.c
@@ -0,0 +1,15 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+void
+f_vst2q_lane_s32 (int32_t * p, int32x4x2_t v)
+{
+  /* { dg-error "lane 4 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  vst2q_lane_s32 (p, v, 4);
+  /* { dg-error "lane -1 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  vst2q_lane_s32 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst2q_lane_s64_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+/* { dg-skip-if "" { arm*-*-* } } */
+
+void
+f_vst2q_lane_s64 (int64_t * p, int64x2x2_t v)
+{
+  /* { dg-error "lane 2 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  vst2q_lane_s64 (p, v, 2);
+  /* { dg-error "lane -1 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  vst2q_lane_s64 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst2q_lane_s8_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+/* { dg-skip-if "" { arm*-*-* } } */
+
+void
+f_vst2q_lane_s8 (int8_t * p, int8x16x2_t v)
+{
+  /* { dg-error "lane 16 out of range 0 - 15" "" { xfail arm*-*-* } 0 } */
+  vst2q_lane_s8 (p, v, 16);
+  /* { dg-error "lane -1 out of range 0 - 15" "" { xfail arm*-*-* } 0 } */
+  vst2q_lane_s8 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst2q_lane_u16_indices_1.c
@@ -0,0 +1,15 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+void
+f_vst2q_lane_u16 (uint16_t * p, uint16x8x2_t v)
+{
+  /* { dg-error "lane 8 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  vst2q_lane_u16 (p, v, 8);
+  /* { dg-error "lane -1 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  vst2q_lane_u16 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst2q_lane_u32_indices_1.c
@@ -0,0 +1,15 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+void
+f_vst2q_lane_u32 (uint32_t * p, uint32x4x2_t v)
+{
+  /* { dg-error "lane 4 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  vst2q_lane_u32 (p, v, 4);
+  /* { dg-error "lane -1 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  vst2q_lane_u32 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst2q_lane_u64_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+/* { dg-skip-if "" { arm*-*-* } } */
+
+void
+f_vst2q_lane_u64 (uint64_t * p, uint64x2x2_t v)
+{
+  /* { dg-error "lane 2 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  vst2q_lane_u64 (p, v, 2);
+  /* { dg-error "lane -1 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  vst2q_lane_u64 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst2q_lane_u8_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+/* { dg-skip-if "" { arm*-*-* } } */
+
+void
+f_vst2q_lane_u8 (uint8_t * p, uint8x16x2_t v)
+{
+  /* { dg-error "lane 16 out of range 0 - 15" "" { xfail arm*-*-* } 0 } */
+  vst2q_lane_u8 (p, v, 16);
+  /* { dg-error "lane -1 out of range 0 - 15" "" { xfail arm*-*-* } 0 } */
+  vst2q_lane_u8 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst3_lane_f16_indices_1.c
@@ -0,0 +1,15 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+void
+f_vst3_lane_f16 (float16_t * p, float16x4x3_t v)
+{
+  /* { dg-error "lane 4 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  vst3_lane_f16 (p, v, 4);
+  /* { dg-error "lane -1 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  vst3_lane_f16 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst3_lane_f32_indices_1.c
@@ -0,0 +1,15 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+void
+f_vst3_lane_f32 (float32_t * p, float32x2x3_t v)
+{
+  /* { dg-error "lane 2 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  vst3_lane_f32 (p, v, 2);
+  /* { dg-error "lane -1 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  vst3_lane_f32 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst3_lane_f64_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+/* { dg-skip-if "" { arm*-*-* } } */
+
+void
+f_vst3_lane_f64 (float64_t * p, float64x1x3_t v)
+{
+  /* { dg-error "lane 1 out of range 0 - 0" "" { xfail arm*-*-* } 0 } */
+  vst3_lane_f64 (p, v, 1);
+  /* { dg-error "lane -1 out of range 0 - 0" "" { xfail arm*-*-* } 0 } */
+  vst3_lane_f64 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst3_lane_p8_indices_1.c
@@ -0,0 +1,15 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+void
+f_vst3_lane_p8 (poly8_t * p, poly8x8x3_t v)
+{
+  /* { dg-error "lane 8 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  vst3_lane_p8 (p, v, 8);
+  /* { dg-error "lane -1 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  vst3_lane_p8 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst3_lane_s16_indices_1.c
@@ -0,0 +1,15 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+void
+f_vst3_lane_s16 (int16_t * p, int16x4x3_t v)
+{
+  /* { dg-error "lane 4 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  vst3_lane_s16 (p, v, 4);
+  /* { dg-error "lane -1 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  vst3_lane_s16 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst3_lane_s32_indices_1.c
@@ -0,0 +1,15 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+void
+f_vst3_lane_s32 (int32_t * p, int32x2x3_t v)
+{
+  /* { dg-error "lane 2 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  vst3_lane_s32 (p, v, 2);
+  /* { dg-error "lane -1 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  vst3_lane_s32 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst3_lane_s64_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+/* { dg-skip-if "" { arm*-*-* } } */
+
+void
+f_vst3_lane_s64 (int64_t * p, int64x1x3_t v)
+{
+  /* { dg-error "lane 1 out of range 0 - 0" "" { xfail arm*-*-* } 0 } */
+  vst3_lane_s64 (p, v, 1);
+  /* { dg-error "lane -1 out of range 0 - 0" "" { xfail arm*-*-* } 0 } */
+  vst3_lane_s64 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst3_lane_s8_indices_1.c
@@ -0,0 +1,15 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+void
+f_vst3_lane_s8 (int8_t * p, int8x8x3_t v)
+{
+  /* { dg-error "lane 8 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  vst3_lane_s8 (p, v, 8);
+  /* { dg-error "lane -1 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  vst3_lane_s8 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst3_lane_u16_indices_1.c
@@ -0,0 +1,15 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+void
+f_vst3_lane_u16 (uint16_t * p, uint16x4x3_t v)
+{
+  /* { dg-error "lane 4 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  vst3_lane_u16 (p, v, 4);
+  /* { dg-error "lane -1 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  vst3_lane_u16 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst3_lane_u32_indices_1.c
@@ -0,0 +1,15 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+void
+f_vst3_lane_u32 (uint32_t * p, uint32x2x3_t v)
+{
+  /* { dg-error "lane 2 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  vst3_lane_u32 (p, v, 2);
+  /* { dg-error "lane -1 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  vst3_lane_u32 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst3_lane_u64_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+/* { dg-skip-if "" { arm*-*-* } } */
+
+void
+f_vst3_lane_u64 (uint64_t * p, uint64x1x3_t v)
+{
+  /* { dg-error "lane 1 out of range 0 - 0" "" { xfail arm*-*-* } 0 } */
+  vst3_lane_u64 (p, v, 1);
+  /* { dg-error "lane -1 out of range 0 - 0" "" { xfail arm*-*-* } 0 } */
+  vst3_lane_u64 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst3_lane_u8_indices_1.c
@@ -0,0 +1,15 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+void
+f_vst3_lane_u8 (uint8_t * p, uint8x8x3_t v)
+{
+  /* { dg-error "lane 8 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  vst3_lane_u8 (p, v, 8);
+  /* { dg-error "lane -1 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  vst3_lane_u8 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst3q_lane_f16_indices_1.c
@@ -0,0 +1,15 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+void
+f_vst3q_lane_f16 (float16_t * p, float16x8x3_t v)
+{
+  /* { dg-error "lane 8 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  vst3q_lane_f16 (p, v, 8);
+  /* { dg-error "lane -1 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  vst3q_lane_f16 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst3q_lane_f32_indices_1.c
@@ -0,0 +1,15 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+void
+f_vst3q_lane_f32 (float32_t * p, float32x4x3_t v)
+{
+  /* { dg-error "lane 4 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  vst3q_lane_f32 (p, v, 4);
+  /* { dg-error "lane -1 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  vst3q_lane_f32 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst3q_lane_f64_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+/* { dg-skip-if "" { arm*-*-* } } */
+
+void
+f_vst3q_lane_f64 (float64_t * p, float64x2x3_t v)
+{
+  /* { dg-error "lane 2 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  vst3q_lane_f64 (p, v, 2);
+  /* { dg-error "lane -1 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  vst3q_lane_f64 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst3q_lane_p8_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+/* { dg-skip-if "" { arm*-*-* } } */
+
+void
+f_vst3q_lane_p8 (poly8_t * p, poly8x16x3_t v)
+{
+  /* { dg-error "lane 16 out of range 0 - 15" "" { xfail arm*-*-* } 0 } */
+  vst3q_lane_p8 (p, v, 16);
+  /* { dg-error "lane -1 out of range 0 - 15" "" { xfail arm*-*-* } 0 } */
+  vst3q_lane_p8 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst3q_lane_s16_indices_1.c
@@ -0,0 +1,15 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+void
+f_vst3q_lane_s16 (int16_t * p, int16x8x3_t v)
+{
+  /* { dg-error "lane 8 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  vst3q_lane_s16 (p, v, 8);
+  /* { dg-error "lane -1 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  vst3q_lane_s16 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst3q_lane_s32_indices_1.c
@@ -0,0 +1,15 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+void
+f_vst3q_lane_s32 (int32_t * p, int32x4x3_t v)
+{
+  /* { dg-error "lane 4 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  vst3q_lane_s32 (p, v, 4);
+  /* { dg-error "lane -1 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  vst3q_lane_s32 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst3q_lane_s64_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+/* { dg-skip-if "" { arm*-*-* } } */
+
+void
+f_vst3q_lane_s64 (int64_t * p, int64x2x3_t v)
+{
+  /* { dg-error "lane 2 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  vst3q_lane_s64 (p, v, 2);
+  /* { dg-error "lane -1 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  vst3q_lane_s64 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst3q_lane_s8_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+/* { dg-skip-if "" { arm*-*-* } } */
+
+void
+f_vst3q_lane_s8 (int8_t * p, int8x16x3_t v)
+{
+  /* { dg-error "lane 16 out of range 0 - 15" "" { xfail arm*-*-* } 0 } */
+  vst3q_lane_s8 (p, v, 16);
+  /* { dg-error "lane -1 out of range 0 - 15" "" { xfail arm*-*-* } 0 } */
+  vst3q_lane_s8 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst3q_lane_u16_indices_1.c
@@ -0,0 +1,15 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+void
+f_vst3q_lane_u16 (uint16_t * p, uint16x8x3_t v)
+{
+  /* { dg-error "lane 8 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  vst3q_lane_u16 (p, v, 8);
+  /* { dg-error "lane -1 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  vst3q_lane_u16 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst3q_lane_u32_indices_1.c
@@ -0,0 +1,15 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+void
+f_vst3q_lane_u32 (uint32_t * p, uint32x4x3_t v)
+{
+  /* { dg-error "lane 4 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  vst3q_lane_u32 (p, v, 4);
+  /* { dg-error "lane -1 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  vst3q_lane_u32 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst3q_lane_u64_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+/* { dg-skip-if "" { arm*-*-* } } */
+
+void
+f_vst3q_lane_u64 (uint64_t * p, uint64x2x3_t v)
+{
+  /* { dg-error "lane 2 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  vst3q_lane_u64 (p, v, 2);
+  /* { dg-error "lane -1 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  vst3q_lane_u64 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst3q_lane_u8_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+/* { dg-skip-if "" { arm*-*-* } } */
+
+void
+f_vst3q_lane_u8 (uint8_t * p, uint8x16x3_t v)
+{
+  /* { dg-error "lane 16 out of range 0 - 15" "" { xfail arm*-*-* } 0 } */
+  vst3q_lane_u8 (p, v, 16);
+  /* { dg-error "lane -1 out of range 0 - 15" "" { xfail arm*-*-* } 0 } */
+  vst3q_lane_u8 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst4_lane_f16_indices_1.c
@@ -0,0 +1,15 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+void
+f_vst4_lane_f16 (float16_t * p, float16x4x4_t v)
+{
+  /* { dg-error "lane 4 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  vst4_lane_f16 (p, v, 4);
+  /* { dg-error "lane -1 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  vst4_lane_f16 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst4_lane_f32_indices_1.c
@@ -0,0 +1,15 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+void
+f_vst4_lane_f32 (float32_t * p, float32x2x4_t v)
+{
+  /* { dg-error "lane 2 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  vst4_lane_f32 (p, v, 2);
+  /* { dg-error "lane -1 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  vst4_lane_f32 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst4_lane_f64_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+/* { dg-skip-if "" { arm*-*-* } } */
+
+void
+f_vst4_lane_f64 (float64_t * p, float64x1x4_t v)
+{
+  /* { dg-error "lane 1 out of range 0 - 0" "" { xfail arm*-*-* } 0 } */
+  vst4_lane_f64 (p, v, 1);
+  /* { dg-error "lane -1 out of range 0 - 0" "" { xfail arm*-*-* } 0 } */
+  vst4_lane_f64 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst4_lane_p8_indices_1.c
@@ -0,0 +1,15 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+void
+f_vst4_lane_p8 (poly8_t * p, poly8x8x4_t v)
+{
+  /* { dg-error "lane 8 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  vst4_lane_p8 (p, v, 8);
+  /* { dg-error "lane -1 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  vst4_lane_p8 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst4_lane_s16_indices_1.c
@@ -0,0 +1,15 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+void
+f_vst4_lane_s16 (int16_t * p, int16x4x4_t v)
+{
+  /* { dg-error "lane 4 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  vst4_lane_s16 (p, v, 4);
+  /* { dg-error "lane -1 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  vst4_lane_s16 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst4_lane_s32_indices_1.c
@@ -0,0 +1,15 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+void
+f_vst4_lane_s32 (int32_t * p, int32x2x4_t v)
+{
+  /* { dg-error "lane 2 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  vst4_lane_s32 (p, v, 2);
+  /* { dg-error "lane -1 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  vst4_lane_s32 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst4_lane_s64_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+/* { dg-skip-if "" { arm*-*-* } } */
+
+void
+f_vst4_lane_s64 (int64_t * p, int64x1x4_t v)
+{
+  /* { dg-error "lane 1 out of range 0 - 0" "" { xfail arm*-*-* } 0 } */
+  vst4_lane_s64 (p, v, 1);
+  /* { dg-error "lane -1 out of range 0 - 0" "" { xfail arm*-*-* } 0 } */
+  vst4_lane_s64 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst4_lane_s8_indices_1.c
@@ -0,0 +1,15 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+void
+f_vst4_lane_s8 (int8_t * p, int8x8x4_t v)
+{
+  /* { dg-error "lane 8 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  vst4_lane_s8 (p, v, 8);
+  /* { dg-error "lane -1 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  vst4_lane_s8 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst4_lane_u16_indices_1.c
@@ -0,0 +1,15 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+void
+f_vst4_lane_u16 (uint16_t * p, uint16x4x4_t v)
+{
+  /* { dg-error "lane 4 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  vst4_lane_u16 (p, v, 4);
+  /* { dg-error "lane -1 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  vst4_lane_u16 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst4_lane_u32_indices_1.c
@@ -0,0 +1,15 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+void
+f_vst4_lane_u32 (uint32_t * p, uint32x2x4_t v)
+{
+  /* { dg-error "lane 2 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  vst4_lane_u32 (p, v, 2);
+  /* { dg-error "lane -1 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  vst4_lane_u32 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst4_lane_u64_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+/* { dg-skip-if "" { arm*-*-* } } */
+
+void
+f_vst4_lane_u64 (uint64_t * p, uint64x1x4_t v)
+{
+  /* { dg-error "lane 1 out of range 0 - 0" "" { xfail arm*-*-* } 0 } */
+  vst4_lane_u64 (p, v, 1);
+  /* { dg-error "lane -1 out of range 0 - 0" "" { xfail arm*-*-* } 0 } */
+  vst4_lane_u64 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst4_lane_u8_indices_1.c
@@ -0,0 +1,15 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+void
+f_vst4_lane_u8 (uint8_t * p, uint8x8x4_t v)
+{
+  /* { dg-error "lane 8 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  vst4_lane_u8 (p, v, 8);
+  /* { dg-error "lane -1 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  vst4_lane_u8 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst4q_lane_f16_indices_1.c
@@ -0,0 +1,15 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+void
+f_vst4q_lane_f16 (float16_t * p, float16x8x4_t v)
+{
+  /* { dg-error "lane 8 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  vst4q_lane_f16 (p, v, 8);
+  /* { dg-error "lane -1 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  vst4q_lane_f16 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst4q_lane_f32_indices_1.c
@@ -0,0 +1,15 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+void
+f_vst4q_lane_f32 (float32_t * p, float32x4x4_t v)
+{
+  /* { dg-error "lane 4 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  vst4q_lane_f32 (p, v, 4);
+  /* { dg-error "lane -1 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  vst4q_lane_f32 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst4q_lane_f64_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+/* { dg-skip-if "" { arm*-*-* } } */
+
+void
+f_vst4q_lane_f64 (float64_t * p, float64x2x4_t v)
+{
+  /* { dg-error "lane 2 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  vst4q_lane_f64 (p, v, 2);
+  /* { dg-error "lane -1 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  vst4q_lane_f64 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst4q_lane_p8_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+/* { dg-skip-if "" { arm*-*-* } } */
+
+void
+f_vst4q_lane_p8 (poly8_t * p, poly8x16x4_t v)
+{
+  /* { dg-error "lane 16 out of range 0 - 15" "" { xfail arm*-*-* } 0 } */
+  vst4q_lane_p8 (p, v, 16);
+  /* { dg-error "lane -1 out of range 0 - 15" "" { xfail arm*-*-* } 0 } */
+  vst4q_lane_p8 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst4q_lane_s16_indices_1.c
@@ -0,0 +1,15 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+void
+f_vst4q_lane_s16 (int16_t * p, int16x8x4_t v)
+{
+  /* { dg-error "lane 8 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  vst4q_lane_s16 (p, v, 8);
+  /* { dg-error "lane -1 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  vst4q_lane_s16 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst4q_lane_s32_indices_1.c
@@ -0,0 +1,15 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+void
+f_vst4q_lane_s32 (int32_t * p, int32x4x4_t v)
+{
+  /* { dg-error "lane 4 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  vst4q_lane_s32 (p, v, 4);
+  /* { dg-error "lane -1 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  vst4q_lane_s32 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst4q_lane_s64_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+/* { dg-skip-if "" { arm*-*-* } } */
+
+void
+f_vst4q_lane_s64 (int64_t * p, int64x2x4_t v)
+{
+  /* { dg-error "lane 2 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  vst4q_lane_s64 (p, v, 2);
+  /* { dg-error "lane -1 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  vst4q_lane_s64 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst4q_lane_s8_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+/* { dg-skip-if "" { arm*-*-* } } */
+
+void
+f_vst4q_lane_s8 (int8_t * p, int8x16x4_t v)
+{
+  /* { dg-error "lane 16 out of range 0 - 15" "" { xfail arm*-*-* } 0 } */
+  vst4q_lane_s8 (p, v, 16);
+  /* { dg-error "lane -1 out of range 0 - 15" "" { xfail arm*-*-* } 0 } */
+  vst4q_lane_s8 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst4q_lane_u16_indices_1.c
@@ -0,0 +1,15 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+void
+f_vst4q_lane_u16 (uint16_t * p, uint16x8x4_t v)
+{
+  /* { dg-error "lane 8 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  vst4q_lane_u16 (p, v, 8);
+  /* { dg-error "lane -1 out of range 0 - 7" "" { xfail arm*-*-* } 0 } */
+  vst4q_lane_u16 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst4q_lane_u32_indices_1.c
@@ -0,0 +1,15 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+
+void
+f_vst4q_lane_u32 (uint32_t * p, uint32x4x4_t v)
+{
+  /* { dg-error "lane 4 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  vst4q_lane_u32 (p, v, 4);
+  /* { dg-error "lane -1 out of range 0 - 3" "" { xfail arm*-*-* } 0 } */
+  vst4q_lane_u32 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst4q_lane_u64_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+/* { dg-skip-if "" { arm*-*-* } } */
+
+void
+f_vst4q_lane_u64 (uint64_t * p, uint64x2x4_t v)
+{
+  /* { dg-error "lane 2 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  vst4q_lane_u64 (p, v, 2);
+  /* { dg-error "lane -1 out of range 0 - 1" "" { xfail arm*-*-* } 0 } */
+  vst4q_lane_u64 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst4q_lane_u8_indices_1.c
@@ -0,0 +1,16 @@
+#include <arm_neon.h>
+
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+/* { dg-excess-errors "" { xfail arm*-*-* } } */
+/* { dg-skip-if "" { arm*-*-* } } */
+
+void
+f_vst4q_lane_u8 (uint8_t * p, uint8x16x4_t v)
+{
+  /* { dg-error "lane 16 out of range 0 - 15" "" { xfail arm*-*-* } 0 } */
+  vst4q_lane_u8 (p, v, 16);
+  /* { dg-error "lane -1 out of range 0 - 15" "" { xfail arm*-*-* } 0 } */
+  vst4q_lane_u8 (p, v, -1);
+  return;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vstX_lane.c
@@ -0,0 +1,578 @@
+#include <arm_neon.h>
+#include "arm-neon-ref.h"
+#include "compute-ref-data.h"
+
+/* Expected results for vst2, chunk 0.  */
+VECT_VAR_DECL(expected_st2_0,int,8,8) [] = { 0xf0, 0xf1, 0x0, 0x0,
+					     0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st2_0,int,16,4) [] = { 0xfff0, 0xfff1, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st2_0,int,32,2) [] = { 0xfffffff0, 0xfffffff1 };
+VECT_VAR_DECL(expected_st2_0,uint,8,8) [] = { 0xf0, 0xf1, 0x0, 0x0,
+					      0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st2_0,uint,16,4) [] = { 0xfff0, 0xfff1, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st2_0,uint,32,2) [] = { 0xfffffff0, 0xfffffff1 };
+VECT_VAR_DECL(expected_st2_0,poly,8,8) [] = { 0xf0, 0xf1, 0x0, 0x0,
+					      0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st2_0,poly,16,4) [] = { 0xfff0, 0xfff1, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st2_0,hfloat,32,2) [] = { 0xc1800000, 0xc1700000 };
+VECT_VAR_DECL(expected_st2_0,int,16,8) [] = { 0xfff0, 0xfff1, 0x0, 0x0,
+					      0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st2_0,int,32,4) [] = { 0xfffffff0, 0xfffffff1, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st2_0,uint,16,8) [] = { 0xfff0, 0xfff1, 0x0, 0x0,
+					       0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st2_0,uint,32,4) [] = { 0xfffffff0, 0xfffffff1,
+					       0x0, 0x0 };
+VECT_VAR_DECL(expected_st2_0,poly,16,8) [] = { 0xfff0, 0xfff1, 0x0, 0x0,
+					       0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st2_0,hfloat,32,4) [] = { 0xc1800000, 0xc1700000,
+						 0x0, 0x0 };
+
+/* Expected results for vst2, chunk 1.  */
+VECT_VAR_DECL(expected_st2_1,int,8,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					     0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st2_1,int,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st2_1,int,32,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_st2_1,uint,8,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					      0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st2_1,uint,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st2_1,uint,32,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_st2_1,poly,8,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					      0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st2_1,poly,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st2_1,hfloat,32,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_st2_1,int,16,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					      0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st2_1,int,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st2_1,uint,16,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					       0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st2_1,uint,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st2_1,poly,16,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					       0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st2_1,hfloat,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+
+/* Expected results for vst3, chunk 0.  */
+VECT_VAR_DECL(expected_st3_0,int,8,8) [] = { 0xf0, 0xf1, 0xf2, 0x0,
+					     0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st3_0,int,16,4) [] = { 0xfff0, 0xfff1, 0xfff2, 0x0 };
+VECT_VAR_DECL(expected_st3_0,int,32,2) [] = { 0xfffffff0, 0xfffffff1 };
+VECT_VAR_DECL(expected_st3_0,uint,8,8) [] = { 0xf0, 0xf1, 0xf2, 0x0,
+					      0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st3_0,uint,16,4) [] = { 0xfff0, 0xfff1, 0xfff2, 0x0 };
+VECT_VAR_DECL(expected_st3_0,uint,32,2) [] = { 0xfffffff0, 0xfffffff1 };
+VECT_VAR_DECL(expected_st3_0,poly,8,8) [] = { 0xf0, 0xf1, 0xf2, 0x0,
+					      0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st3_0,poly,16,4) [] = { 0xfff0, 0xfff1, 0xfff2, 0x0 };
+VECT_VAR_DECL(expected_st3_0,hfloat,32,2) [] = { 0xc1800000, 0xc1700000 };
+VECT_VAR_DECL(expected_st3_0,int,16,8) [] = { 0xfff0, 0xfff1, 0xfff2, 0x0,
+					      0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st3_0,int,32,4) [] = { 0xfffffff0, 0xfffffff1,
+					      0xfffffff2, 0x0 };
+VECT_VAR_DECL(expected_st3_0,uint,16,8) [] = { 0xfff0, 0xfff1, 0xfff2, 0x0,
+					       0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st3_0,uint,32,4) [] = { 0xfffffff0, 0xfffffff1,
+					       0xfffffff2, 0x0 };
+VECT_VAR_DECL(expected_st3_0,poly,16,8) [] = { 0xfff0, 0xfff1, 0xfff2, 0x0,
+					       0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st3_0,hfloat,32,4) [] = { 0xc1800000, 0xc1700000,
+						 0xc1600000, 0x0 };
+
+/* Expected results for vst3, chunk 1.  */
+VECT_VAR_DECL(expected_st3_1,int,8,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					     0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st3_1,int,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st3_1,int,32,2) [] = { 0xfffffff2, 0x0 };
+VECT_VAR_DECL(expected_st3_1,uint,8,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					      0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st3_1,uint,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st3_1,uint,32,2) [] = { 0xfffffff2, 0x0 };
+VECT_VAR_DECL(expected_st3_1,poly,8,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					      0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st3_1,poly,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st3_1,hfloat,32,2) [] = { 0xc1600000, 0x0 };
+VECT_VAR_DECL(expected_st3_1,int,16,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					      0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st3_1,int,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st3_1,uint,16,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					       0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st3_1,uint,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st3_1,poly,16,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					       0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st3_1,hfloat,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+
+/* Expected results for vst3, chunk 2.  */
+VECT_VAR_DECL(expected_st3_2,int,8,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					     0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st3_2,int,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st3_2,int,32,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_st3_2,uint,8,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					      0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st3_2,uint,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st3_2,uint,32,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_st3_2,poly,8,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					      0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st3_2,poly,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st3_2,hfloat,32,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_st3_2,int,16,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					      0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st3_2,int,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st3_2,uint,16,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					       0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st3_2,uint,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st3_2,poly,16,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					       0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st3_2,hfloat,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+
+/* Expected results for vst4, chunk 0.  */
+VECT_VAR_DECL(expected_st4_0,int,8,8) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
+					     0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st4_0,int,16,4) [] = { 0xfff0, 0xfff1, 0xfff2, 0xfff3 };
+VECT_VAR_DECL(expected_st4_0,int,32,2) [] = { 0xfffffff0, 0xfffffff1 };
+VECT_VAR_DECL(expected_st4_0,uint,8,8) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
+					      0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st4_0,uint,16,4) [] = { 0xfff0, 0xfff1, 0xfff2, 0xfff3 };
+VECT_VAR_DECL(expected_st4_0,uint,32,2) [] = { 0xfffffff0, 0xfffffff1 };
+VECT_VAR_DECL(expected_st4_0,poly,8,8) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
+					      0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st4_0,poly,16,4) [] = { 0xfff0, 0xfff1, 0xfff2, 0xfff3 };
+VECT_VAR_DECL(expected_st4_0,hfloat,32,2) [] = { 0xc1800000, 0xc1700000 };
+VECT_VAR_DECL(expected_st4_0,int,16,8) [] = { 0xfff0, 0xfff1, 0xfff2, 0xfff3,
+					      0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st4_0,int,32,4) [] = { 0xfffffff0, 0xfffffff1,
+					      0xfffffff2, 0xfffffff3 };
+VECT_VAR_DECL(expected_st4_0,uint,16,8) [] = { 0xfff0, 0xfff1, 0xfff2, 0xfff3,
+					       0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st4_0,uint,32,4) [] = { 0xfffffff0, 0xfffffff1,
+					       0xfffffff2, 0xfffffff3 };
+VECT_VAR_DECL(expected_st4_0,poly,16,8) [] = { 0xfff0, 0xfff1, 0xfff2, 0xfff3,
+					       0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st4_0,hfloat,32,4) [] = { 0xc1800000, 0xc1700000,
+						 0xc1600000, 0xc1500000 };
+
+/* Expected results for vst4, chunk 1.  */
+VECT_VAR_DECL(expected_st4_1,int,8,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					     0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st4_1,int,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st4_1,int,32,2) [] = { 0xfffffff2, 0xfffffff3 };
+VECT_VAR_DECL(expected_st4_1,uint,8,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					      0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st4_1,uint,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st4_1,uint,32,2) [] = { 0xfffffff2, 0xfffffff3 };
+VECT_VAR_DECL(expected_st4_1,poly,8,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					      0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st4_1,poly,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st4_1,hfloat,32,2) [] = { 0xc1600000, 0xc1500000 };
+VECT_VAR_DECL(expected_st4_1,int,16,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					      0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st4_1,int,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st4_1,uint,16,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					       0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st4_1,uint,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st4_1,poly,16,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					       0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st4_1,hfloat,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+
+/* Expected results for vst4, chunk 2.  */
+VECT_VAR_DECL(expected_st4_2,int,8,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					     0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st4_2,int,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st4_2,int,32,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_st4_2,uint,8,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					      0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st4_2,uint,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st4_2,uint,32,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_st4_2,poly,8,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					      0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st4_2,poly,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st4_2,hfloat,32,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_st4_2,int,16,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					      0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st4_2,int,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st4_2,uint,16,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					       0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st4_2,uint,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st4_2,poly,16,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					       0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st4_2,hfloat,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+
+/* Expected results for vst4, chunk 3.  */
+VECT_VAR_DECL(expected_st4_3,int,8,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					     0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st4_3,int,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st4_3,int,32,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_st4_3,uint,8,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					      0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st4_3,uint,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st4_3,uint,32,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_st4_3,poly,8,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					      0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st4_3,poly,16,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st4_3,hfloat,32,2) [] = { 0x0, 0x0 };
+VECT_VAR_DECL(expected_st4_3,int,16,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					      0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st4_3,int,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st4_3,uint,16,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					       0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st4_3,uint,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st4_3,poly,16,8) [] = { 0x0, 0x0, 0x0, 0x0,
+					       0x0, 0x0, 0x0, 0x0 };
+VECT_VAR_DECL(expected_st4_3,hfloat,32,4) [] = { 0x0, 0x0, 0x0, 0x0 };
+
+/* Declare additional input buffers as needed.  */
+/* Input buffers for vld2_lane.  */
+VECT_VAR_DECL_INIT(buffer_vld2_lane, int, 8, 2);
+VECT_VAR_DECL_INIT(buffer_vld2_lane, int, 16, 2);
+VECT_VAR_DECL_INIT(buffer_vld2_lane, int, 32, 2);
+VECT_VAR_DECL_INIT(buffer_vld2_lane, int, 64, 2);
+VECT_VAR_DECL_INIT(buffer_vld2_lane, uint, 8, 2);
+VECT_VAR_DECL_INIT(buffer_vld2_lane, uint, 16, 2);
+VECT_VAR_DECL_INIT(buffer_vld2_lane, uint, 32, 2);
+VECT_VAR_DECL_INIT(buffer_vld2_lane, uint, 64, 2);
+VECT_VAR_DECL_INIT(buffer_vld2_lane, poly, 8, 2);
+VECT_VAR_DECL_INIT(buffer_vld2_lane, poly, 16, 2);
+VECT_VAR_DECL_INIT(buffer_vld2_lane, float, 32, 2);
+
+/* Input buffers for vld3_lane.  */
+VECT_VAR_DECL_INIT(buffer_vld3_lane, int, 8, 3);
+VECT_VAR_DECL_INIT(buffer_vld3_lane, int, 16, 3);
+VECT_VAR_DECL_INIT(buffer_vld3_lane, int, 32, 3);
+VECT_VAR_DECL_INIT(buffer_vld3_lane, int, 64, 3);
+VECT_VAR_DECL_INIT(buffer_vld3_lane, uint, 8, 3);
+VECT_VAR_DECL_INIT(buffer_vld3_lane, uint, 16, 3);
+VECT_VAR_DECL_INIT(buffer_vld3_lane, uint, 32, 3);
+VECT_VAR_DECL_INIT(buffer_vld3_lane, uint, 64, 3);
+VECT_VAR_DECL_INIT(buffer_vld3_lane, poly, 8, 3);
+VECT_VAR_DECL_INIT(buffer_vld3_lane, poly, 16, 3);
+VECT_VAR_DECL_INIT(buffer_vld3_lane, float, 32, 3);
+
+/* Input buffers for vld4_lane.  */
+VECT_VAR_DECL_INIT(buffer_vld4_lane, int, 8, 4);
+VECT_VAR_DECL_INIT(buffer_vld4_lane, int, 16, 4);
+VECT_VAR_DECL_INIT(buffer_vld4_lane, int, 32, 4);
+VECT_VAR_DECL_INIT(buffer_vld4_lane, int, 64, 4);
+VECT_VAR_DECL_INIT(buffer_vld4_lane, uint, 8, 4);
+VECT_VAR_DECL_INIT(buffer_vld4_lane, uint, 16, 4);
+VECT_VAR_DECL_INIT(buffer_vld4_lane, uint, 32, 4);
+VECT_VAR_DECL_INIT(buffer_vld4_lane, uint, 64, 4);
+VECT_VAR_DECL_INIT(buffer_vld4_lane, poly, 8, 4);
+VECT_VAR_DECL_INIT(buffer_vld4_lane, poly, 16, 4);
+VECT_VAR_DECL_INIT(buffer_vld4_lane, float, 32, 4);
+
+void exec_vstX_lane (void)
+{
+  /* In this case, input variables are arrays of vectors.  */
+#define DECL_VSTX_LANE(T1, W, N, X)					\
+  VECT_ARRAY_TYPE(T1, W, N, X) VECT_ARRAY_VAR(vector, T1, W, N, X);	\
+  VECT_ARRAY_TYPE(T1, W, N, X) VECT_ARRAY_VAR(vector_src, T1, W, N, X);	\
+  VECT_VAR_DECL(result_bis_##X, T1, W, N)[X * N]
+
+  /* We need to use a temporary result buffer (result_bis), because
+     the one used for other tests is not large enough. A subset of the
+     result data is moved from result_bis to result, and it is this
+     subset which is used to check the actual behaviour. The next
+     macro enables to move another chunk of data from result_bis to
+     result.  */
+  /* We also use another extra input buffer (buffer_src), which we
+     fill with 0xAA, and which it used to load a vector from which we
+     read a given lane.  */
+#define TEST_VSTX_LANE(Q, T1, T2, W, N, X, L)				 \
+  memset (VECT_VAR(buffer_src, T1, W, N), 0xAA,				 \
+	  sizeof(VECT_VAR(buffer_src, T1, W, N)));			 \
+  memset (VECT_VAR(result_bis_##X, T1, W, N), 0,			 \
+	  sizeof(VECT_VAR(result_bis_##X, T1, W, N)));			 \
+									 \
+  VECT_ARRAY_VAR(vector_src, T1, W, N, X) =				 \
+    vld##X##Q##_##T2##W(VECT_VAR(buffer_src, T1, W, N));		 \
+									 \
+  VECT_ARRAY_VAR(vector, T1, W, N, X) =					 \
+    /* Use dedicated init buffer, of size X.  */			 \
+    vld##X##Q##_lane_##T2##W(VECT_VAR(buffer_vld##X##_lane, T1, W, X),	 \
+			     VECT_ARRAY_VAR(vector_src, T1, W, N, X),	 \
+			     L);					 \
+  vst##X##Q##_lane_##T2##W(VECT_VAR(result_bis_##X, T1, W, N),		 \
+			   VECT_ARRAY_VAR(vector, T1, W, N, X),		 \
+			   L);						 \
+  memcpy(VECT_VAR(result, T1, W, N), VECT_VAR(result_bis_##X, T1, W, N), \
+	 sizeof(VECT_VAR(result, T1, W, N)));
+
+  /* Overwrite "result" with the contents of "result_bis"[Y].  */
+#define TEST_EXTRA_CHUNK(T1, W, N, X, Y)		\
+  memcpy(VECT_VAR(result, T1, W, N),			\
+	 &(VECT_VAR(result_bis_##X, T1, W, N)[Y*N]),	\
+	 sizeof(VECT_VAR(result, T1, W, N)));
+
+  /* We need all variants in 64 bits, but there is no 64x2 variant,
+     nor 128 bits vectors of int8/uint8/poly8.  */
+#define DECL_ALL_VSTX_LANE(X)			\
+  DECL_VSTX_LANE(int, 8, 8, X);			\
+  DECL_VSTX_LANE(int, 16, 4, X);		\
+  DECL_VSTX_LANE(int, 32, 2, X);		\
+  DECL_VSTX_LANE(uint, 8, 8, X);		\
+  DECL_VSTX_LANE(uint, 16, 4, X);		\
+  DECL_VSTX_LANE(uint, 32, 2, X);		\
+  DECL_VSTX_LANE(poly, 8, 8, X);		\
+  DECL_VSTX_LANE(poly, 16, 4, X);		\
+  DECL_VSTX_LANE(float, 32, 2, X);		\
+  DECL_VSTX_LANE(int, 16, 8, X);		\
+  DECL_VSTX_LANE(int, 32, 4, X);		\
+  DECL_VSTX_LANE(uint, 16, 8, X);		\
+  DECL_VSTX_LANE(uint, 32, 4, X);		\
+  DECL_VSTX_LANE(poly, 16, 8, X);		\
+  DECL_VSTX_LANE(float, 32, 4, X)
+
+#define DUMMY_ARRAY(V, T, W, N, L) VECT_VAR_DECL(V,T,W,N)[N*L]
+
+  /* Use the same lanes regardless of the size of the array (X), for
+     simplicity.  */
+#define TEST_ALL_VSTX_LANE(X)			\
+  TEST_VSTX_LANE(, int, s, 8, 8, X, 7);		\
+  TEST_VSTX_LANE(, int, s, 16, 4, X, 2);	\
+  TEST_VSTX_LANE(, int, s, 32, 2, X, 0);	\
+  TEST_VSTX_LANE(, float, f, 32, 2, X, 0);	\
+  TEST_VSTX_LANE(, uint, u, 8, 8, X, 4);	\
+  TEST_VSTX_LANE(, uint, u, 16, 4, X, 3);	\
+  TEST_VSTX_LANE(, uint, u, 32, 2, X, 1);	\
+  TEST_VSTX_LANE(, poly, p, 8, 8, X, 4);	\
+  TEST_VSTX_LANE(, poly, p, 16, 4, X, 3);	\
+  TEST_VSTX_LANE(q, int, s, 16, 8, X, 6);	\
+  TEST_VSTX_LANE(q, int, s, 32, 4, X, 2);	\
+  TEST_VSTX_LANE(q, uint, u, 16, 8, X, 5);	\
+  TEST_VSTX_LANE(q, uint, u, 32, 4, X, 0);	\
+  TEST_VSTX_LANE(q, poly, p, 16, 8, X, 5);	\
+  TEST_VSTX_LANE(q, float, f, 32, 4, X, 2)
+
+#define TEST_ALL_EXTRA_CHUNKS(X, Y)		\
+  TEST_EXTRA_CHUNK(int, 8, 8, X, Y);		\
+  TEST_EXTRA_CHUNK(int, 16, 4, X, Y);		\
+  TEST_EXTRA_CHUNK(int, 32, 2, X, Y);		\
+  TEST_EXTRA_CHUNK(uint, 8, 8, X, Y);		\
+  TEST_EXTRA_CHUNK(uint, 16, 4, X, Y);		\
+  TEST_EXTRA_CHUNK(uint, 32, 2, X, Y);		\
+  TEST_EXTRA_CHUNK(poly, 8, 8, X, Y);		\
+  TEST_EXTRA_CHUNK(poly, 16, 4, X, Y);		\
+  TEST_EXTRA_CHUNK(float, 32, 2, X, Y);		\
+  TEST_EXTRA_CHUNK(int, 16, 8, X, Y);		\
+  TEST_EXTRA_CHUNK(int, 32, 4, X, Y);		\
+  TEST_EXTRA_CHUNK(uint, 16, 8, X, Y);		\
+  TEST_EXTRA_CHUNK(uint, 32, 4, X, Y);		\
+  TEST_EXTRA_CHUNK(poly, 16, 8, X, Y);		\
+  TEST_EXTRA_CHUNK(float, 32, 4, X, Y)
+
+  /* Declare the temporary buffers / variables.  */
+  DECL_ALL_VSTX_LANE(2);
+  DECL_ALL_VSTX_LANE(3);
+  DECL_ALL_VSTX_LANE(4);
+
+  /* Define dummy input arrays, large enough for x4 vectors.  */
+  DUMMY_ARRAY(buffer_src, int, 8, 8, 4);
+  DUMMY_ARRAY(buffer_src, int, 16, 4, 4);
+  DUMMY_ARRAY(buffer_src, int, 32, 2, 4);
+  DUMMY_ARRAY(buffer_src, uint, 8, 8, 4);
+  DUMMY_ARRAY(buffer_src, uint, 16, 4, 4);
+  DUMMY_ARRAY(buffer_src, uint, 32, 2, 4);
+  DUMMY_ARRAY(buffer_src, poly, 8, 8, 4);
+  DUMMY_ARRAY(buffer_src, poly, 16, 4, 4);
+  DUMMY_ARRAY(buffer_src, float, 32, 2, 4);
+  DUMMY_ARRAY(buffer_src, int, 16, 8, 4);
+  DUMMY_ARRAY(buffer_src, int, 32, 4, 4);
+  DUMMY_ARRAY(buffer_src, uint, 16, 8, 4);
+  DUMMY_ARRAY(buffer_src, uint, 32, 4, 4);
+  DUMMY_ARRAY(buffer_src, poly, 16, 8, 4);
+  DUMMY_ARRAY(buffer_src, float, 32, 4, 4);
+
+  /* Check vst2_lane/vst2q_lane.  */
+  clean_results ();
+#define TEST_MSG "VST2_LANE/VST2Q_LANE"
+  TEST_ALL_VSTX_LANE(2);
+
+#define CMT " (chunk 0)"
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_st2_0, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_st2_0, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_st2_0, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_st2_0, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_st2_0, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_st2_0, CMT);
+  CHECK(TEST_MSG, poly, 8, 8, PRIx8, expected_st2_0, CMT);
+  CHECK(TEST_MSG, poly, 16, 4, PRIx16, expected_st2_0, CMT);
+  CHECK_FP(TEST_MSG, float, 32, 2, PRIx32, expected_st2_0, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_st2_0, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_st2_0, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_st2_0, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_st2_0, CMT);
+  CHECK(TEST_MSG, poly, 16, 8, PRIx16, expected_st2_0, CMT);
+  CHECK_FP(TEST_MSG, float, 32, 4, PRIx32, expected_st2_0, CMT);
+
+  TEST_ALL_EXTRA_CHUNKS(2, 1);
+#undef CMT
+#define CMT " chunk 1"
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_st2_1, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_st2_1, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_st2_1, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_st2_1, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_st2_1, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_st2_1, CMT);
+  CHECK(TEST_MSG, poly, 8, 8, PRIx8, expected_st2_1, CMT);
+  CHECK(TEST_MSG, poly, 16, 4, PRIx16, expected_st2_1, CMT);
+  CHECK_FP(TEST_MSG, float, 32, 2, PRIx32, expected_st2_1, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_st2_1, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_st2_1, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_st2_1, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_st2_1, CMT);
+  CHECK(TEST_MSG, poly, 16, 8, PRIx16, expected_st2_1, CMT);
+  CHECK_FP(TEST_MSG, float, 32, 4, PRIx32, expected_st2_1, CMT);
+
+
+  /* Check vst3_lane/vst3q_lane.  */
+  clean_results ();
+#undef TEST_MSG
+#define TEST_MSG "VST3_LANE/VST3Q_LANE"
+  TEST_ALL_VSTX_LANE(3);
+
+#undef CMT
+#define CMT " (chunk 0)"
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_st3_0, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_st3_0, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_st3_0, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_st3_0, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_st3_0, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_st3_0, CMT);
+  CHECK(TEST_MSG, poly, 8, 8, PRIx8, expected_st3_0, CMT);
+  CHECK(TEST_MSG, poly, 16, 4, PRIx16, expected_st3_0, CMT);
+  CHECK_FP(TEST_MSG, float, 32, 2, PRIx32, expected_st3_0, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_st3_0, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_st3_0, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_st3_0, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_st3_0, CMT);
+  CHECK(TEST_MSG, poly, 16, 8, PRIx16, expected_st3_0, CMT);
+  CHECK_FP(TEST_MSG, float, 32, 4, PRIx32, expected_st3_0, CMT);
+
+  TEST_ALL_EXTRA_CHUNKS(3, 1);
+
+#undef CMT
+#define CMT " (chunk 1)"
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_st3_1, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_st3_1, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_st3_1, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_st3_1, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_st3_1, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_st3_1, CMT);
+  CHECK(TEST_MSG, poly, 8, 8, PRIx8, expected_st3_1, CMT);
+  CHECK(TEST_MSG, poly, 16, 4, PRIx16, expected_st3_1, CMT);
+  CHECK_FP(TEST_MSG, float, 32, 2, PRIx32, expected_st3_1, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_st3_1, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_st3_1, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_st3_1, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_st3_1, CMT);
+  CHECK(TEST_MSG, poly, 16, 8, PRIx16, expected_st3_1, CMT);
+  CHECK_FP(TEST_MSG, float, 32, 4, PRIx32, expected_st3_1, CMT);
+
+  TEST_ALL_EXTRA_CHUNKS(3, 2);
+
+#undef CMT
+#define CMT " (chunk 2)"
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_st3_2, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_st3_2, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_st3_2, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_st3_2, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_st3_2, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_st3_2, CMT);
+  CHECK(TEST_MSG, poly, 8, 8, PRIx8, expected_st3_2, CMT);
+  CHECK(TEST_MSG, poly, 16, 4, PRIx16, expected_st3_2, CMT);
+  CHECK_FP(TEST_MSG, float, 32, 2, PRIx32, expected_st3_2, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_st3_2, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_st3_2, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_st3_2, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_st3_2, CMT);
+  CHECK(TEST_MSG, poly, 16, 8, PRIx16, expected_st3_2, CMT);
+  CHECK_FP(TEST_MSG, float, 32, 4, PRIx32, expected_st3_2, CMT);
+
+
+  /* Check vst4_lane/vst4q_lane.  */
+  clean_results ();
+#undef TEST_MSG
+#define TEST_MSG "VST4_LANE/VST4Q_LANE"
+  TEST_ALL_VSTX_LANE(4);
+
+#undef CMT
+#define CMT " (chunk 0)"
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_st4_0, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_st4_0, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_st4_0, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_st4_0, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_st4_0, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_st4_0, CMT);
+  CHECK(TEST_MSG, poly, 8, 8, PRIx8, expected_st4_0, CMT);
+  CHECK(TEST_MSG, poly, 16, 4, PRIx16, expected_st4_0, CMT);
+  CHECK_FP(TEST_MSG, float, 32, 2, PRIx32, expected_st4_0, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_st4_0, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_st4_0, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_st4_0, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_st4_0, CMT);
+  CHECK(TEST_MSG, poly, 16, 8, PRIx16, expected_st4_0, CMT);
+  CHECK_FP(TEST_MSG, float, 32, 4, PRIx32, expected_st4_0, CMT);
+
+  TEST_ALL_EXTRA_CHUNKS(4, 1);
+
+#undef CMT
+#define CMT " (chunk 1)"
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_st4_1, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_st4_1, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_st4_1, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_st4_1, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_st4_1, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_st4_1, CMT);
+  CHECK(TEST_MSG, poly, 8, 8, PRIx8, expected_st4_1, CMT);
+  CHECK(TEST_MSG, poly, 16, 4, PRIx16, expected_st4_1, CMT);
+  CHECK_FP(TEST_MSG, float, 32, 2, PRIx32, expected_st4_1, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_st4_1, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_st4_1, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_st4_1, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_st4_1, CMT);
+  CHECK(TEST_MSG, poly, 16, 8, PRIx16, expected_st4_1, CMT);
+  CHECK_FP(TEST_MSG, float, 32, 4, PRIx32, expected_st4_1, CMT);
+
+  TEST_ALL_EXTRA_CHUNKS(4, 2);
+
+#undef CMT
+#define CMT " (chunk 2)"
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_st4_2, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_st4_2, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_st4_2, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_st4_2, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_st4_2, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_st4_2, CMT);
+  CHECK(TEST_MSG, poly, 8, 8, PRIx8, expected_st4_2, CMT);
+  CHECK(TEST_MSG, poly, 16, 4, PRIx16, expected_st4_2, CMT);
+  CHECK_FP(TEST_MSG, float, 32, 2, PRIx32, expected_st4_2, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_st4_2, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_st4_2, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_st4_2, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_st4_2, CMT);
+  CHECK(TEST_MSG, poly, 16, 8, PRIx16, expected_st4_2, CMT);
+  CHECK_FP(TEST_MSG, float, 32, 4, PRIx32, expected_st4_2, CMT);
+
+  TEST_ALL_EXTRA_CHUNKS(4, 3);
+
+#undef CMT
+#define CMT " (chunk 3)"
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_st4_3, CMT);
+  CHECK(TEST_MSG, int, 16, 4, PRIx16, expected_st4_3, CMT);
+  CHECK(TEST_MSG, int, 32, 2, PRIx32, expected_st4_3, CMT);
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_st4_3, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_st4_3, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_st4_3, CMT);
+  CHECK(TEST_MSG, poly, 8, 8, PRIx8, expected_st4_3, CMT);
+  CHECK(TEST_MSG, poly, 16, 4, PRIx16, expected_st4_3, CMT);
+  CHECK_FP(TEST_MSG, float, 32, 2, PRIx32, expected_st4_3, CMT);
+  CHECK(TEST_MSG, int, 16, 8, PRIx16, expected_st4_3, CMT);
+  CHECK(TEST_MSG, int, 32, 4, PRIx32, expected_st4_3, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_st4_3, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_st4_3, CMT);
+  CHECK(TEST_MSG, poly, 16, 8, PRIx16, expected_st4_3, CMT);
+  CHECK_FP(TEST_MSG, float, 32, 4, PRIx32, expected_st4_3, CMT);
+}
+
+int main (void)
+{
+  exec_vstX_lane ();
+  return 0;
+}
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vsub.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vsub.c
@@ -18,10 +18,6 @@ VECT_VAR_DECL(expected,uint,8,8) [] = { 0xdc, 0xdd, 0xde, 0xdf,
 VECT_VAR_DECL(expected,uint,16,4) [] = { 0xffd2, 0xffd3, 0xffd4, 0xffd5 };
 VECT_VAR_DECL(expected,uint,32,2) [] = { 0xffffffc8, 0xffffffc9 };
 VECT_VAR_DECL(expected,uint,64,1) [] = { 0xffffffffffffffee };
-VECT_VAR_DECL(expected,poly,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0x33333333, 0x33333333 };
 VECT_VAR_DECL(expected,int,8,16) [] = { 0xfa, 0xfb, 0xfc, 0xfd,
 					0xfe, 0xff, 0x0, 0x1,
 					0x2, 0x3, 0x4, 0x5,
@@ -41,14 +37,6 @@ VECT_VAR_DECL(expected,uint,32,4) [] = { 0xffffffb9, 0xffffffba,
 					 0xffffffbb, 0xffffffbc };
 VECT_VAR_DECL(expected,uint,64,2) [] = { 0xffffffffffffffed,
 					 0xffffffffffffffee };
-VECT_VAR_DECL(expected,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0x33333333, 0x33333333,
-					  0x33333333, 0x33333333 };
 
 /* Expected results for float32 variants. Needs to be separated since
    the generic test function does not test floating-point
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vsubl.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vsubl.c
@@ -6,43 +6,13 @@
 #define TEST_MSG "VSUBL"
 
 /* Expected results.  */
-VECT_VAR_DECL(expected,int,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-				       0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,int,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,int,32,2) [] = { 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,int,64,1) [] = { 0x3333333333333333 };
-VECT_VAR_DECL(expected,uint,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,uint,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,uint,32,2) [] = { 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,uint,64,1) [] = { 0x3333333333333333 };
-VECT_VAR_DECL(expected,poly,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,int,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
 VECT_VAR_DECL(expected,int,16,8) [] = { 0xfffd, 0xfffe, 0xffff, 0x0,
 					0x1, 0x2, 0x3, 0x4 };
 VECT_VAR_DECL(expected,int,32,4) [] = { 0xfffffffe, 0xffffffff, 0x0, 0x1 };
 VECT_VAR_DECL(expected,int,64,2) [] = { 0x0, 0x1 };
-VECT_VAR_DECL(expected,uint,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
 VECT_VAR_DECL(expected,uint,16,8) [] = { 0xfffd, 0xfffe, 0xffff, 0x0,
 					 0x1, 0x2, 0x3, 0x4 };
 VECT_VAR_DECL(expected,uint,32,4) [] = { 0xffffffff, 0x0, 0x1, 0x2 };
 VECT_VAR_DECL(expected,uint,64,2) [] = { 0x0, 0x1 };
-VECT_VAR_DECL(expected,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0x33333333, 0x33333333,
-					   0x33333333, 0x33333333 };
 
 #include "vXXXl.inc"
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vsubw.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vsubw.c
@@ -6,45 +6,15 @@
 #define TEST_MSG "VSUBW"
 
 /* Expected results.  */
-VECT_VAR_DECL(expected,int,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-				       0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,int,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,int,32,2) [] = { 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,int,64,1) [] = { 0x3333333333333333 };
-VECT_VAR_DECL(expected,uint,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,uint,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,uint,32,2) [] = { 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,uint,64,1) [] = { 0x3333333333333333 };
-VECT_VAR_DECL(expected,poly,8,8) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,4) [] = { 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0x33333333, 0x33333333 };
-VECT_VAR_DECL(expected,int,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33,
-					0x33, 0x33, 0x33, 0x33 };
 VECT_VAR_DECL(expected,int,16,8) [] = { 0xfffd, 0xfffe, 0xffff, 0x0,
 					0x1, 0x2, 0x3, 0x4 };
 VECT_VAR_DECL(expected,int,32,4) [] = { 0xfffffffe, 0xffffffff, 0x0, 0x1 };
 VECT_VAR_DECL(expected,int,64,2) [] = { 0x0, 0x1 };
-VECT_VAR_DECL(expected,uint,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
 VECT_VAR_DECL(expected,uint,16,8) [] = { 0xfefd, 0xfefe, 0xfeff, 0xff00,
 					 0xff01, 0xff02, 0xff03, 0xff04 };
 VECT_VAR_DECL(expected,uint,32,4) [] = { 0xfffeffff, 0xffff0000,
 					 0xffff0001, 0xffff0002 };
 VECT_VAR_DECL(expected,uint,64,2) [] = { 0xffffffff00000000,
 					 0xffffffff00000001 };
-VECT_VAR_DECL(expected,poly,8,16) [] = { 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33,
-					 0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected,poly,16,8) [] = { 0x3333, 0x3333, 0x3333, 0x3333,
-					 0x3333, 0x3333, 0x3333, 0x3333 };
-VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0x33333333, 0x33333333,
-					   0x33333333, 0x33333333 };
 
 #include "vXXXw.inc"
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vtbX.c
@@ -0,0 +1,289 @@
+#include <arm_neon.h>
+#include "arm-neon-ref.h"
+#include "compute-ref-data.h"
+
+/* Expected results for vtbl1.  */
+VECT_VAR_DECL(expected_vtbl1,int,8,8) [] = { 0x0, 0xf2, 0xf2, 0xf2,
+					     0x0, 0x0, 0xf2, 0xf2 };
+VECT_VAR_DECL(expected_vtbl1,uint,8,8) [] = { 0x0, 0xf3, 0xf3, 0xf3,
+					      0x0, 0x0, 0xf3, 0xf3 };
+VECT_VAR_DECL(expected_vtbl1,poly,8,8) [] = { 0x0, 0xf3, 0xf3, 0xf3,
+					      0x0, 0x0, 0xf3, 0xf3 };
+
+/* Expected results for vtbl2.  */
+VECT_VAR_DECL(expected_vtbl2,int,8,8) [] = { 0xf6, 0xf3, 0xf3, 0xf3,
+					     0x0, 0x0, 0xf3, 0xf3 };
+VECT_VAR_DECL(expected_vtbl2,uint,8,8) [] = { 0xf6, 0xf5, 0xf5, 0xf5,
+					      0x0, 0x0, 0xf5, 0xf5 };
+VECT_VAR_DECL(expected_vtbl2,poly,8,8) [] = { 0xf6, 0xf5, 0xf5, 0xf5,
+					      0x0, 0x0, 0xf5, 0xf5 };
+
+/* Expected results for vtbl3.  */
+VECT_VAR_DECL(expected_vtbl3,int,8,8) [] = { 0xf8, 0xf4, 0xf4, 0xf4,
+					     0xff, 0x0, 0xf4, 0xf4 };
+VECT_VAR_DECL(expected_vtbl3,uint,8,8) [] = { 0xf8, 0xf7, 0xf7, 0xf7,
+					      0xff, 0x0, 0xf7, 0xf7 };
+VECT_VAR_DECL(expected_vtbl3,poly,8,8) [] = { 0xf8, 0xf7, 0xf7, 0xf7,
+					      0xff, 0x0, 0xf7, 0xf7 };
+
+/* Expected results for vtbl4.  */
+VECT_VAR_DECL(expected_vtbl4,int,8,8) [] = { 0xfa, 0xf5, 0xf5, 0xf5,
+					    0x3, 0x0, 0xf5, 0xf5 };
+VECT_VAR_DECL(expected_vtbl4,uint,8,8) [] = { 0xfa, 0xf9, 0xf9, 0xf9,
+					     0x3, 0x0, 0xf9, 0xf9 };
+VECT_VAR_DECL(expected_vtbl4,poly,8,8) [] = { 0xfa, 0xf9, 0xf9, 0xf9,
+					     0x3, 0x0, 0xf9, 0xf9 };
+
+/* Expected results for vtbx1.  */
+VECT_VAR_DECL(expected_vtbx1,int,8,8) [] = { 0x33, 0xf2, 0xf2, 0xf2,
+					    0x33, 0x33, 0xf2, 0xf2 };
+VECT_VAR_DECL(expected_vtbx1,uint,8,8) [] = { 0xcc, 0xf3, 0xf3, 0xf3,
+					     0xcc, 0xcc, 0xf3, 0xf3 };
+VECT_VAR_DECL(expected_vtbx1,poly,8,8) [] = { 0xcc, 0xf3, 0xf3, 0xf3,
+					     0xcc, 0xcc, 0xf3, 0xf3 };
+
+/* Expected results for vtbx2.  */
+VECT_VAR_DECL(expected_vtbx2,int,8,8) [] = { 0xf6, 0xf3, 0xf3, 0xf3,
+					    0x33, 0x33, 0xf3, 0xf3 };
+VECT_VAR_DECL(expected_vtbx2,uint,8,8) [] = { 0xf6, 0xf5, 0xf5, 0xf5,
+					     0xcc, 0xcc, 0xf5, 0xf5 };
+VECT_VAR_DECL(expected_vtbx2,poly,8,8) [] = { 0xf6, 0xf5, 0xf5, 0xf5,
+					     0xcc, 0xcc, 0xf5, 0xf5 };
+
+/* Expected results for vtbx3.  */
+VECT_VAR_DECL(expected_vtbx3,int,8,8) [] = { 0xf8, 0xf4, 0xf4, 0xf4,
+					    0xff, 0x33, 0xf4, 0xf4 };
+VECT_VAR_DECL(expected_vtbx3,uint,8,8) [] = { 0xf8, 0xf7, 0xf7, 0xf7,
+					     0xff, 0xcc, 0xf7, 0xf7 };
+VECT_VAR_DECL(expected_vtbx3,poly,8,8) [] = { 0xf8, 0xf7, 0xf7, 0xf7,
+					     0xff, 0xcc, 0xf7, 0xf7 };
+
+/* Expected results for vtbx4.  */
+VECT_VAR_DECL(expected_vtbx4,int,8,8) [] = { 0xfa, 0xf5, 0xf5, 0xf5,
+					     0x3, 0x33, 0xf5, 0xf5 };
+VECT_VAR_DECL(expected_vtbx4,uint,8,8) [] = { 0xfa, 0xf9, 0xf9, 0xf9,
+					      0x3, 0xcc, 0xf9, 0xf9 };
+VECT_VAR_DECL(expected_vtbx4,poly,8,8) [] = { 0xfa, 0xf9, 0xf9, 0xf9,
+					      0x3, 0xcc, 0xf9, 0xf9 };
+
+void exec_vtbX (void)
+{
+  int i;
+
+  /* In this case, input variables are arrays of vectors.  */
+#define DECL_VTBX(T1, W, N, X)						\
+  VECT_ARRAY_TYPE(T1, W, N, X) VECT_ARRAY_VAR(table_vector, T1, W, N, X)
+
+  /* The vtbl1 variant is different from vtbl{2,3,4} because it takes a
+     vector as 1st param, instead of an array of vectors.  */
+#define TEST_VTBL1(T1, T2, T3, W, N)			\
+  VECT_VAR(table_vector, T1, W, N) =			\
+    vld1##_##T2##W((T1##W##_t *)lookup_table);		\
+							\
+  VECT_VAR(vector_res, T1, W, N) =			\
+    vtbl1_##T2##W(VECT_VAR(table_vector, T1, W, N),	\
+		  VECT_VAR(vector, T3, W, N));		\
+  vst1_##T2##W(VECT_VAR(result, T1, W, N),		\
+	       VECT_VAR(vector_res, T1, W, N));
+
+#define TEST_VTBLX(T1, T2, T3, W, N, X)					\
+  VECT_ARRAY_VAR(table_vector, T1, W, N, X) =				\
+    vld##X##_##T2##W((T1##W##_t *)lookup_table);			\
+									\
+  VECT_VAR(vector_res, T1, W, N) =					\
+    vtbl##X##_##T2##W(VECT_ARRAY_VAR(table_vector, T1, W, N, X),	\
+		      VECT_VAR(vector, T3, W, N));			\
+  vst1_##T2##W(VECT_VAR(result, T1, W, N),				\
+	       VECT_VAR(vector_res, T1, W, N));
+
+  /* We need to define a lookup table.  */
+  uint8_t lookup_table[32];
+
+  DECL_VARIABLE(vector, int, 8, 8);
+  DECL_VARIABLE(vector, uint, 8, 8);
+  DECL_VARIABLE(vector, poly, 8, 8);
+  DECL_VARIABLE(vector_res, int, 8, 8);
+  DECL_VARIABLE(vector_res, uint, 8, 8);
+  DECL_VARIABLE(vector_res, poly, 8, 8);
+
+  /* For vtbl1.  */
+  DECL_VARIABLE(table_vector, int, 8, 8);
+  DECL_VARIABLE(table_vector, uint, 8, 8);
+  DECL_VARIABLE(table_vector, poly, 8, 8);
+
+  /* For vtbx*.  */
+  DECL_VARIABLE(default_vector, int, 8, 8);
+  DECL_VARIABLE(default_vector, uint, 8, 8);
+  DECL_VARIABLE(default_vector, poly, 8, 8);
+
+  /* We need only 8 bits variants.  */
+#define DECL_ALL_VTBLX(X)			\
+  DECL_VTBX(int, 8, 8, X);			\
+  DECL_VTBX(uint, 8, 8, X);			\
+  DECL_VTBX(poly, 8, 8, X)
+
+#define TEST_ALL_VTBL1()			\
+  TEST_VTBL1(int, s, int, 8, 8);		\
+  TEST_VTBL1(uint, u, uint, 8, 8);		\
+  TEST_VTBL1(poly, p, uint, 8, 8)
+
+#define TEST_ALL_VTBLX(X)			\
+  TEST_VTBLX(int, s, int, 8, 8, X);		\
+  TEST_VTBLX(uint, u, uint, 8, 8, X);		\
+  TEST_VTBLX(poly, p, uint, 8, 8, X)
+
+  /* Declare the temporary buffers / variables.  */
+  DECL_ALL_VTBLX(2);
+  DECL_ALL_VTBLX(3);
+  DECL_ALL_VTBLX(4);
+
+  /* Fill the lookup table.  */
+  for (i=0; i<32; i++) {
+    lookup_table[i] = i-15;
+  }
+
+  /* Choose init value arbitrarily, will be used as table index.  */
+  VDUP(vector, , int, s, 8, 8, 1);
+  VDUP(vector, , uint, u, 8, 8, 2);
+  VDUP(vector, , poly, p, 8, 8, 2);
+
+  /* To ensure coverage, add some indexes larger than 8,16 and 32
+     except: lane 0 (by 6), lane 1 (by 8) and lane 2 (by 9).  */
+  VSET_LANE(vector, , int, s, 8, 8, 0, 10);
+  VSET_LANE(vector, , int, s, 8, 8, 4, 20);
+  VSET_LANE(vector, , int, s, 8, 8, 5, 40);
+  VSET_LANE(vector, , uint, u, 8, 8, 0, 10);
+  VSET_LANE(vector, , uint, u, 8, 8, 4, 20);
+  VSET_LANE(vector, , uint, u, 8, 8, 5, 40);
+  VSET_LANE(vector, , poly, p, 8, 8, 0, 10);
+  VSET_LANE(vector, , poly, p, 8, 8, 4, 20);
+  VSET_LANE(vector, , poly, p, 8, 8, 5, 40);
+
+
+  /* Check vtbl1.  */
+  clean_results ();
+#define TEST_MSG "VTBL1"
+  TEST_ALL_VTBL1();
+
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_vtbl1, "");
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_vtbl1, "");
+  CHECK(TEST_MSG, poly, 8, 8, PRIx8, expected_vtbl1, "");
+
+  /* Check vtbl2.  */
+  clean_results ();
+#undef TEST_MSG
+#define TEST_MSG "VTBL2"
+  TEST_ALL_VTBLX(2);
+
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_vtbl2, "");
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_vtbl2, "");
+  CHECK(TEST_MSG, poly, 8, 8, PRIx8, expected_vtbl2, "");
+
+  /* Check vtbl3.  */
+  clean_results ();
+#undef TEST_MSG
+#define TEST_MSG "VTBL3"
+  TEST_ALL_VTBLX(3);
+
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_vtbl3, "");
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_vtbl3, "");
+  CHECK(TEST_MSG, poly, 8, 8, PRIx8, expected_vtbl3, "");
+
+  /* Check vtbl4.  */
+  clean_results ();
+#undef TEST_MSG
+#define TEST_MSG "VTBL4"
+  TEST_ALL_VTBLX(4);
+
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_vtbl4, "");
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_vtbl4, "");
+  CHECK(TEST_MSG, poly, 8, 8, PRIx8, expected_vtbl4, "");
+
+
+  /* Now test VTBX.  */
+
+  /* The vtbx1 variant is different from vtbx{2,3,4} because it takes a
+     vector as 1st param, instead of an array of vectors.  */
+#define TEST_VTBX1(T1, T2, T3, W, N)			\
+  VECT_VAR(table_vector, T1, W, N) =			\
+    vld1##_##T2##W((T1##W##_t *)lookup_table);		\
+							\
+  VECT_VAR(vector_res, T1, W, N) =			\
+    vtbx1_##T2##W(VECT_VAR(default_vector, T1, W, N),	\
+		  VECT_VAR(table_vector, T1, W, N),	\
+		  VECT_VAR(vector, T3, W, N));		\
+  vst1_##T2##W(VECT_VAR(result, T1, W, N),		\
+	       VECT_VAR(vector_res, T1, W, N));
+
+#define TEST_VTBXX(T1, T2, T3, W, N, X)					\
+  VECT_ARRAY_VAR(table_vector, T1, W, N, X) =				\
+    vld##X##_##T2##W((T1##W##_t *)lookup_table);			\
+									\
+  VECT_VAR(vector_res, T1, W, N) =					\
+    vtbx##X##_##T2##W(VECT_VAR(default_vector, T1, W, N),		\
+		      VECT_ARRAY_VAR(table_vector, T1, W, N, X),	\
+		      VECT_VAR(vector, T3, W, N));			\
+  vst1_##T2##W(VECT_VAR(result, T1, W, N),				\
+	       VECT_VAR(vector_res, T1, W, N));
+
+#define TEST_ALL_VTBX1()			\
+  TEST_VTBX1(int, s, int, 8, 8);		\
+  TEST_VTBX1(uint, u, uint, 8, 8);		\
+  TEST_VTBX1(poly, p, uint, 8, 8)
+
+#define TEST_ALL_VTBXX(X)			\
+  TEST_VTBXX(int, s, int, 8, 8, X);		\
+  TEST_VTBXX(uint, u, uint, 8, 8, X);		\
+  TEST_VTBXX(poly, p, uint, 8, 8, X)
+
+  /* Choose init value arbitrarily, will be used as default value.  */
+  VDUP(default_vector, , int, s, 8, 8, 0x33);
+  VDUP(default_vector, , uint, u, 8, 8, 0xCC);
+  VDUP(default_vector, , poly, p, 8, 8, 0xCC);
+
+  /* Check vtbx1.  */
+  clean_results ();
+#undef TEST_MSG
+#define TEST_MSG "VTBX1"
+  TEST_ALL_VTBX1();
+
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_vtbx1, "");
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_vtbx1, "");
+  CHECK(TEST_MSG, poly, 8, 8, PRIx8, expected_vtbx1, "");
+
+  /* Check vtbx2.  */
+  clean_results ();
+#undef TEST_MSG
+#define TEST_MSG "VTBX2"
+  TEST_ALL_VTBXX(2);
+
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_vtbx2, "");
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_vtbx2, "");
+  CHECK(TEST_MSG, poly, 8, 8, PRIx8, expected_vtbx2, "");
+
+  /* Check vtbx3.  */
+  clean_results ();
+#undef TEST_MSG
+#define TEST_MSG "VTBX3"
+  TEST_ALL_VTBXX(3);
+
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_vtbx3, "");
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_vtbx3, "");
+  CHECK(TEST_MSG, poly, 8, 8, PRIx8, expected_vtbx3, "");
+
+  /* Check vtbx4.  */
+  clean_results ();
+#undef TEST_MSG
+#define TEST_MSG "VTBX4"
+  TEST_ALL_VTBXX(4);
+
+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_vtbx4, "");
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_vtbx4, "");
+  CHECK(TEST_MSG, poly, 8, 8, PRIx8, expected_vtbx4, "");
+}
+
+int main (void)
+{
+  exec_vtbX ();
+  return 0;
+}
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vtrn.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vtrn.c
@@ -8,12 +8,10 @@ VECT_VAR_DECL(expected0,int,8,8) [] = { 0xf0, 0xf1, 0x11, 0x11,
 					0xf2, 0xf3, 0x11, 0x11 };
 VECT_VAR_DECL(expected0,int,16,4) [] = { 0xfff0, 0xfff1, 0x22, 0x22 };
 VECT_VAR_DECL(expected0,int,32,2) [] = { 0xfffffff0, 0xfffffff1 };
-VECT_VAR_DECL(expected0,int,64,1) [] = { 0x3333333333333333 };
 VECT_VAR_DECL(expected0,uint,8,8) [] = { 0xf0, 0xf1, 0x55, 0x55,
 					 0xf2, 0xf3, 0x55, 0x55 };
 VECT_VAR_DECL(expected0,uint,16,4) [] = { 0xfff0, 0xfff1, 0x66, 0x66 };
 VECT_VAR_DECL(expected0,uint,32,2) [] = { 0xfffffff0, 0xfffffff1 };
-VECT_VAR_DECL(expected0,uint,64,1) [] = { 0x3333333333333333 };
 VECT_VAR_DECL(expected0,poly,8,8) [] = { 0xf0, 0xf1, 0x55, 0x55,
 					 0xf2, 0xf3, 0x55, 0x55 };
 VECT_VAR_DECL(expected0,poly,16,4) [] = { 0xfff0, 0xfff1, 0x66, 0x66 };
@@ -25,8 +23,6 @@ VECT_VAR_DECL(expected0,int,8,16) [] = { 0xf0, 0xf1, 0x11, 0x11,
 VECT_VAR_DECL(expected0,int,16,8) [] = { 0xfff0, 0xfff1, 0x22, 0x22,
 					 0xfff2, 0xfff3, 0x22, 0x22 };
 VECT_VAR_DECL(expected0,int,32,4) [] = { 0xfffffff0, 0xfffffff1, 0x33, 0x33 };
-VECT_VAR_DECL(expected0,int,64,2) [] = { 0x3333333333333333,
-					 0x3333333333333333 };
 VECT_VAR_DECL(expected0,uint,8,16) [] = { 0xf0, 0xf1, 0x55, 0x55,
 					  0xf2, 0xf3, 0x55, 0x55,
 					  0xf4, 0xf5, 0x55, 0x55,
@@ -34,8 +30,6 @@ VECT_VAR_DECL(expected0,uint,8,16) [] = { 0xf0, 0xf1, 0x55, 0x55,
 VECT_VAR_DECL(expected0,uint,16,8) [] = { 0xfff0, 0xfff1, 0x66, 0x66,
 					  0xfff2, 0xfff3, 0x66, 0x66 };
 VECT_VAR_DECL(expected0,uint,32,4) [] = { 0xfffffff0, 0xfffffff1, 0x77, 0x77 };
-VECT_VAR_DECL(expected0,uint,64,2) [] = { 0x3333333333333333,
-					  0x3333333333333333 };
 VECT_VAR_DECL(expected0,poly,8,16) [] = { 0xf0, 0xf1, 0x55, 0x55,
 					  0xf2, 0xf3, 0x55, 0x55,
 					  0xf4, 0xf5, 0x55, 0x55,
@@ -50,12 +44,10 @@ VECT_VAR_DECL(expected1,int,8,8) [] = { 0xf4, 0xf5, 0x11, 0x11,
 					0xf6, 0xf7, 0x11, 0x11 };
 VECT_VAR_DECL(expected1,int,16,4) [] = { 0xfff2, 0xfff3, 0x22, 0x22 };
 VECT_VAR_DECL(expected1,int,32,2) [] = { 0x33, 0x33 };
-VECT_VAR_DECL(expected1,int,64,1) [] = { 0x3333333333333333 };
 VECT_VAR_DECL(expected1,uint,8,8) [] = { 0xf4, 0xf5, 0x55, 0x55,
 					 0xf6, 0xf7, 0x55, 0x55 };
 VECT_VAR_DECL(expected1,uint,16,4) [] = { 0xfff2, 0xfff3, 0x66, 0x66 };
 VECT_VAR_DECL(expected1,uint,32,2) [] = { 0x77, 0x77 };
-VECT_VAR_DECL(expected1,uint,64,1) [] = { 0x3333333333333333 };
 VECT_VAR_DECL(expected1,poly,8,8) [] = { 0xf4, 0xf5, 0x55, 0x55,
 					 0xf6, 0xf7, 0x55, 0x55 };
 VECT_VAR_DECL(expected1,poly,16,4) [] = { 0xfff2, 0xfff3, 0x66, 0x66 };
@@ -67,8 +59,6 @@ VECT_VAR_DECL(expected1,int,8,16) [] = { 0xf8, 0xf9, 0x11, 0x11,
 VECT_VAR_DECL(expected1,int,16,8) [] = { 0xfff4, 0xfff5, 0x22, 0x22,
 					 0xfff6, 0xfff7, 0x22, 0x22 };
 VECT_VAR_DECL(expected1,int,32,4) [] = { 0xfffffff2, 0xfffffff3, 0x33, 0x33 };
-VECT_VAR_DECL(expected1,int,64,2) [] = { 0x3333333333333333,
-					 0x3333333333333333 };
 VECT_VAR_DECL(expected1,uint,8,16) [] = { 0xf8, 0xf9, 0x55, 0x55,
 					  0xfa, 0xfb, 0x55, 0x55,
 					  0xfc, 0xfd, 0x55, 0x55,
@@ -76,8 +66,6 @@ VECT_VAR_DECL(expected1,uint,8,16) [] = { 0xf8, 0xf9, 0x55, 0x55,
 VECT_VAR_DECL(expected1,uint,16,8) [] = { 0xfff4, 0xfff5, 0x66, 0x66,
 					  0xfff6, 0xfff7, 0x66, 0x66 };
 VECT_VAR_DECL(expected1,uint,32,4) [] = { 0xfffffff2, 0xfffffff3, 0x77, 0x77 };
-VECT_VAR_DECL(expected1,uint,64,2) [] = { 0x3333333333333333,
-					  0x3333333333333333 };
 VECT_VAR_DECL(expected1,poly,8,16) [] = { 0xf8, 0xf9, 0x55, 0x55,
 					  0xfa, 0xfb, 0x55, 0x55,
 					  0xfc, 0xfd, 0x55, 0x55,
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vtst.c
@@ -0,0 +1,120 @@
+#include <arm_neon.h>
+#include "arm-neon-ref.h"
+#include "compute-ref-data.h"
+
+/* Expected results with signed input.  */
+VECT_VAR_DECL(expected_signed,uint,8,8) [] = { 0x0, 0xff, 0xff, 0xff,
+					       0xff, 0xff, 0xff, 0xff };
+VECT_VAR_DECL(expected_signed,uint,16,4) [] = { 0x0, 0xffff, 0x0, 0xffff };
+VECT_VAR_DECL(expected_signed,uint,32,2) [] = { 0x0, 0xffffffff };
+VECT_VAR_DECL(expected_signed,uint,8,16) [] = { 0x0, 0xff, 0xff, 0xff,
+						0xff, 0xff, 0xff, 0xff,
+						0xff, 0xff, 0xff, 0xff,
+						0xff, 0xff, 0xff, 0xff };
+VECT_VAR_DECL(expected_signed,uint,16,8) [] = { 0x0, 0xffff, 0x0, 0xffff,
+						0xffff, 0xffff, 0xffff, 0xffff };
+VECT_VAR_DECL(expected_signed,uint,32,4) [] = { 0x0, 0xffffffff,
+						0x0, 0xffffffff };
+
+/* Expected results with unsigned input.  */
+VECT_VAR_DECL(expected_unsigned,uint,8,8) [] = { 0x0, 0xff, 0xff, 0xff,
+						 0xff, 0xff, 0xff, 0xff };
+VECT_VAR_DECL(expected_unsigned,uint,16,4) [] = { 0x0, 0xffff, 0x0, 0xffff };
+VECT_VAR_DECL(expected_unsigned,uint,32,2) [] = { 0x0, 0xffffffff };
+VECT_VAR_DECL(expected_unsigned,uint,8,16) [] = { 0x0, 0xff, 0xff, 0xff,
+						  0xff, 0xff, 0xff, 0xff,
+						  0xff, 0xff, 0xff, 0xff,
+						  0xff, 0xff, 0xff, 0xff };
+VECT_VAR_DECL(expected_unsigned,uint,16,8) [] = { 0x0, 0xffff,
+						  0x0, 0xffff,
+						  0xffff, 0xffff,
+						  0xffff, 0xffff };
+VECT_VAR_DECL(expected_unsigned,uint,32,4) [] = { 0x0, 0xffffffff,
+						  0x0, 0xffffffff };
+
+#ifndef INSN_NAME
+#define INSN_NAME vtst
+#define TEST_MSG "VTST/VTSTQ"
+#endif
+
+/* We can't use the standard ref_v_binary_op.c template because vtst
+   has no 64 bits variant, and outputs are always of uint type.  */
+#define FNNAME1(NAME) void exec_ ## NAME (void)
+#define FNNAME(NAME) FNNAME1(NAME)
+
+FNNAME (INSN_NAME)
+{
+  /* Basic test: y=OP(x,x), then store the result.  */
+#define TEST_BINARY_OP1(INSN, Q, T1, T2, W, N)		\
+  VECT_VAR(vector_res, uint, W, N) =			\
+    INSN##Q##_##T2##W(VECT_VAR(vector, T1, W, N),	\
+		      VECT_VAR(vector2, T1, W, N));	\
+  vst1##Q##_u##W(VECT_VAR(result, uint, W, N),		\
+		 VECT_VAR(vector_res, uint, W, N))
+
+#define TEST_BINARY_OP(INSN, Q, T1, T2, W, N)	\
+  TEST_BINARY_OP1(INSN, Q, T1, T2, W, N)	\
+
+  DECL_VARIABLE_ALL_VARIANTS(vector);
+  DECL_VARIABLE_ALL_VARIANTS(vector2);
+  DECL_VARIABLE_UNSIGNED_VARIANTS(vector_res);
+
+
+  clean_results ();
+
+  /* Initialize input "vector" from "buffer".  */
+  TEST_MACRO_ALL_VARIANTS_2_5(VLOAD, vector, buffer);
+
+  /* Choose init value arbitrarily, will be used as comparison
+     value.  */
+  VDUP(vector2, , int, s, 8, 8, 15);
+  VDUP(vector2, , int, s, 16, 4, 5);
+  VDUP(vector2, , int, s, 32, 2, 1);
+  VDUP(vector2, , uint, u, 8, 8, 15);
+  VDUP(vector2, , uint, u, 16, 4, 5);
+  VDUP(vector2, , uint, u, 32, 2, 1);
+  VDUP(vector2, q, int, s, 8, 16, 15);
+  VDUP(vector2, q, int, s, 16, 8, 5);
+  VDUP(vector2, q, int, s, 32, 4, 1);
+  VDUP(vector2, q, uint, u, 8, 16, 15);
+  VDUP(vector2, q, uint, u, 16, 8, 5);
+  VDUP(vector2, q, uint, u, 32, 4, 1);
+
+#define TEST_MACRO_NO64BIT_VARIANT_1_5(MACRO, VAR, T1, T2)	\
+  MACRO(VAR, , T1, T2, 8, 8);					\
+  MACRO(VAR, , T1, T2, 16, 4);					\
+  MACRO(VAR, , T1, T2, 32, 2);					\
+  MACRO(VAR, q, T1, T2, 8, 16);					\
+  MACRO(VAR, q, T1, T2, 16, 8);					\
+  MACRO(VAR, q, T1, T2, 32, 4)
+
+  /* Split the test, as both signed and unsigned variants output their
+     result in an unsigned form (thus the same output variable is used
+     in these tests).  */
+  TEST_MACRO_NO64BIT_VARIANT_1_5(TEST_BINARY_OP, INSN_NAME, int, s);
+
+#define CMT " (signed input)"
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_signed, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_signed, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_signed, CMT);
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected_signed, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_signed, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_signed, CMT);
+
+  TEST_MACRO_NO64BIT_VARIANT_1_5(TEST_BINARY_OP, INSN_NAME, uint, u);
+
+#undef CMT
+#define CMT " (unsigned input)"
+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_unsigned, CMT);
+  CHECK(TEST_MSG, uint, 16, 4, PRIx16, expected_unsigned, CMT);
+  CHECK(TEST_MSG, uint, 32, 2, PRIx32, expected_unsigned, CMT);
+  CHECK(TEST_MSG, uint, 8, 16, PRIx8, expected_unsigned, CMT);
+  CHECK(TEST_MSG, uint, 16, 8, PRIx16, expected_unsigned, CMT);
+  CHECK(TEST_MSG, uint, 32, 4, PRIx32, expected_unsigned, CMT);
+}
+
+int main (void)
+{
+  exec_vtst ();
+  return 0;
+}
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vuzp.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vuzp.c
@@ -9,14 +9,12 @@ VECT_VAR_DECL(expected0,int,8,8) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
 VECT_VAR_DECL(expected0,int,16,4) [] = { 0xfff0, 0xfff1,
 					 0xfff2, 0xfff3 };
 VECT_VAR_DECL(expected0,int,32,2) [] = { 0xfffffff0, 0xfffffff1 };
-VECT_VAR_DECL(expected0,int,64,1) [] = { 0x3333333333333333 };
 VECT_VAR_DECL(expected0,uint,8,8) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
 					 0xf4, 0xf5, 0xf6, 0xf7 };
 VECT_VAR_DECL(expected0,uint,16,4) [] = { 0xfff0, 0xfff1,
 					  0xfff2, 0xfff3 };
 VECT_VAR_DECL(expected0,uint,32,2) [] = { 0xfffffff0,
 					  0xfffffff1 };
-VECT_VAR_DECL(expected0,uint,64,1) [] = { 0x3333333333333333 };
 VECT_VAR_DECL(expected0,poly,8,8) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
 					 0xf4, 0xf5, 0xf6, 0xf7 };
 VECT_VAR_DECL(expected0,poly,16,4) [] = { 0xfff0, 0xfff1,
@@ -32,8 +30,6 @@ VECT_VAR_DECL(expected0,int,16,8) [] = { 0xfff0, 0xfff1,
 					 0xfff6, 0xfff7 };
 VECT_VAR_DECL(expected0,int,32,4) [] = { 0xfffffff0, 0xfffffff1,
 					 0xfffffff2, 0xfffffff3 };
-VECT_VAR_DECL(expected0,int,64,2) [] = { 0x3333333333333333,
-					 0x3333333333333333 };
 VECT_VAR_DECL(expected0,uint,8,16) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
 					  0xf4, 0xf5, 0xf6, 0xf7,
 					  0xf8, 0xf9, 0xfa, 0xfb,
@@ -44,8 +40,6 @@ VECT_VAR_DECL(expected0,uint,16,8) [] = { 0xfff0, 0xfff1,
 					  0xfff6, 0xfff7 };
 VECT_VAR_DECL(expected0,uint,32,4) [] = { 0xfffffff0, 0xfffffff1,
 					  0xfffffff2, 0xfffffff3 };
-VECT_VAR_DECL(expected0,uint,64,2) [] = { 0x3333333333333333,
-					  0x3333333333333333 };
 VECT_VAR_DECL(expected0,poly,8,16) [] = { 0xf0, 0xf1, 0xf2, 0xf3,
 					  0xf4, 0xf5, 0xf6, 0xf7,
 					  0xf8, 0xf9, 0xfa, 0xfb,
@@ -62,12 +56,10 @@ VECT_VAR_DECL(expected1,int,8,8) [] = { 0x11, 0x11, 0x11, 0x11,
 					0x11, 0x11, 0x11, 0x11 };
 VECT_VAR_DECL(expected1,int,16,4) [] = { 0x22, 0x22, 0x22, 0x22 };
 VECT_VAR_DECL(expected1,int,32,2) [] = { 0x33, 0x33 };
-VECT_VAR_DECL(expected1,int,64,1) [] = { 0x3333333333333333 };
 VECT_VAR_DECL(expected1,uint,8,8) [] = { 0x55, 0x55, 0x55, 0x55,
 					 0x55, 0x55, 0x55, 0x55 };
 VECT_VAR_DECL(expected1,uint,16,4) [] = { 0x66, 0x66, 0x66, 0x66 };
 VECT_VAR_DECL(expected1,uint,32,2) [] = { 0x77, 0x77 };
-VECT_VAR_DECL(expected1,uint,64,1) [] = { 0x3333333333333333 };
 VECT_VAR_DECL(expected1,poly,8,8) [] = { 0x55, 0x55, 0x55, 0x55,
 					 0x55, 0x55, 0x55, 0x55 };
 VECT_VAR_DECL(expected1,poly,16,4) [] = { 0x66, 0x66, 0x66, 0x66 };
@@ -79,8 +71,6 @@ VECT_VAR_DECL(expected1,int,8,16) [] = { 0x11, 0x11, 0x11, 0x11,
 VECT_VAR_DECL(expected1,int,16,8) [] = { 0x22, 0x22, 0x22, 0x22,
 					 0x22, 0x22, 0x22, 0x22 };
 VECT_VAR_DECL(expected1,int,32,4) [] = { 0x33, 0x33, 0x33, 0x33 };
-VECT_VAR_DECL(expected1,int,64,2) [] = { 0x3333333333333333,
-					 0x3333333333333333 };
 VECT_VAR_DECL(expected1,uint,8,16) [] = { 0x55, 0x55, 0x55, 0x55,
 					  0x55, 0x55, 0x55, 0x55,
 					  0x55, 0x55, 0x55, 0x55,
@@ -88,8 +78,6 @@ VECT_VAR_DECL(expected1,uint,8,16) [] = { 0x55, 0x55, 0x55, 0x55,
 VECT_VAR_DECL(expected1,uint,16,8) [] = { 0x66, 0x66, 0x66, 0x66,
 					  0x66, 0x66, 0x66, 0x66 };
 VECT_VAR_DECL(expected1,uint,32,4) [] = { 0x77, 0x77, 0x77, 0x77 };
-VECT_VAR_DECL(expected1,uint,64,2) [] = { 0x3333333333333333,
-					  0x3333333333333333 };
 VECT_VAR_DECL(expected1,poly,8,16) [] = { 0x55, 0x55, 0x55, 0x55,
 					  0x55, 0x55, 0x55, 0x55,
 					  0x55, 0x55, 0x55, 0x55,
--- a/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vzip.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vzip.c
@@ -9,13 +9,11 @@ VECT_VAR_DECL(expected0,int,8,8) [] = { 0xf0, 0xf4, 0x11, 0x11,
 VECT_VAR_DECL(expected0,int,16,4) [] = { 0xfff0, 0xfff2,
 					 0x22, 0x22 };
 VECT_VAR_DECL(expected0,int,32,2) [] = { 0xfffffff0, 0xfffffff1 };
-VECT_VAR_DECL(expected0,int,64,1) [] = { 0x3333333333333333 };
 VECT_VAR_DECL(expected0,uint,8,8) [] = { 0xf0, 0xf4, 0x55, 0x55,
 					 0xf1, 0xf5, 0x55, 0x55 };
 VECT_VAR_DECL(expected0,uint,16,4) [] = { 0xfff0, 0xfff2,
 					  0x66, 0x66 };
 VECT_VAR_DECL(expected0,uint,32,2) [] = { 0xfffffff0, 0xfffffff1 };
-VECT_VAR_DECL(expected0,uint,64,1) [] = { 0x3333333333333333 };
 VECT_VAR_DECL(expected0,poly,8,8) [] = { 0xf0, 0xf4, 0x55, 0x55,
 					 0xf1, 0xf5, 0x55, 0x55 };
 VECT_VAR_DECL(expected0,poly,16,4) [] = { 0xfff0, 0xfff2,
@@ -29,8 +27,6 @@ VECT_VAR_DECL(expected0,int,16,8) [] = { 0xfff0, 0xfff4, 0x22, 0x22,
 					 0xfff1, 0xfff5, 0x22, 0x22 };
 VECT_VAR_DECL(expected0,int,32,4) [] = { 0xfffffff0, 0xfffffff2,
 					 0x33, 0x33 };
-VECT_VAR_DECL(expected0,int,64,2) [] = { 0x3333333333333333,
-					 0x3333333333333333 };
 VECT_VAR_DECL(expected0,uint,8,16) [] = { 0xf0, 0xf8, 0x55, 0x55,
 					  0xf1, 0xf9, 0x55, 0x55,
 					  0xf2, 0xfa, 0x55, 0x55,
@@ -39,8 +35,6 @@ VECT_VAR_DECL(expected0,uint,16,8) [] = { 0xfff0, 0xfff4, 0x66, 0x66,
 					  0xfff1, 0xfff5, 0x66, 0x66 };
 VECT_VAR_DECL(expected0,uint,32,4) [] = { 0xfffffff0, 0xfffffff2,
 					  0x77, 0x77 };
-VECT_VAR_DECL(expected0,uint,64,2) [] = { 0x3333333333333333,
-					  0x3333333333333333 };
 VECT_VAR_DECL(expected0,poly,8,16) [] = { 0xf0, 0xf8, 0x55, 0x55,
 					  0xf1, 0xf9, 0x55, 0x55,
 					  0xf2, 0xfa, 0x55, 0x55,
@@ -56,13 +50,11 @@ VECT_VAR_DECL(expected1,int,8,8) [] = { 0xf2, 0xf6, 0x11, 0x11,
 VECT_VAR_DECL(expected1,int,16,4) [] = { 0xfff1, 0xfff3,
 					 0x22, 0x22 };
 VECT_VAR_DECL(expected1,int,32,2) [] = { 0x33, 0x33 };
-VECT_VAR_DECL(expected1,int,64,1) [] = { 0x3333333333333333 };
 VECT_VAR_DECL(expected1,uint,8,8) [] = { 0xf2, 0xf6, 0x55, 0x55,
 					 0xf3, 0xf7, 0x55, 0x55 };
 VECT_VAR_DECL(expected1,uint,16,4) [] = { 0xfff1, 0xfff3,
 					  0x66, 0x66 };
 VECT_VAR_DECL(expected1,uint,32,2) [] = { 0x77, 0x77 };
-VECT_VAR_DECL(expected1,uint,64,1) [] = { 0x3333333333333333 };
 VECT_VAR_DECL(expected1,poly,8,8) [] = { 0xf2, 0xf6, 0x55, 0x55,
 					 0xf3, 0xf7, 0x55, 0x55 };
 VECT_VAR_DECL(expected1,poly,16,4) [] = { 0xfff1, 0xfff3,
@@ -76,8 +68,6 @@ VECT_VAR_DECL(expected1,int,16,8) [] = { 0xfff2, 0xfff6, 0x22, 0x22,
 					 0xfff3, 0xfff7, 0x22, 0x22 };
 VECT_VAR_DECL(expected1,int,32,4) [] = { 0xfffffff1, 0xfffffff3,
 					 0x33, 0x33 };
-VECT_VAR_DECL(expected1,int,64,2) [] = { 0x3333333333333333,
-					 0x3333333333333333 };
 VECT_VAR_DECL(expected1,uint,8,16) [] = { 0xf4, 0xfc, 0x55, 0x55,
 					  0xf5, 0xfd, 0x55, 0x55,
 					  0xf6, 0xfe, 0x55, 0x55,
@@ -86,8 +76,6 @@ VECT_VAR_DECL(expected1,uint,16,8) [] = { 0xfff2, 0xfff6, 0x66, 0x66,
 					  0xfff3, 0xfff7, 0x66, 0x66 };
 VECT_VAR_DECL(expected1,uint,32,4) [] = { 0xfffffff1, 0xfffffff3,
 					  0x77, 0x77 };
-VECT_VAR_DECL(expected1,uint,64,2) [] = { 0x3333333333333333,
-					  0x3333333333333333 };
 VECT_VAR_DECL(expected1,poly,8,16) [] = { 0xf4, 0xfc, 0x55, 0x55,
 					  0xf5, 0xfd, 0x55, 0x55,
 					  0xf6, 0xfe, 0x55, 0x55,
--- a/src/gcc/testsuite/gcc.target/aarch64/aes_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/aes_1.c
@@ -37,4 +37,3 @@ test_vaesimcq_u8 (uint8x16_t data)
 /* { dg-final { scan-assembler-times "aesimc\\tv\[0-9\]+\.16b, v\[0-9\]+\.16b" 1 } } */
 
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/ands_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/ands_1.c
@@ -12,7 +12,7 @@ ands_si_test1 (int a, int b, int c)
   if (d == 0)
     return a + c;
   else
-    return b + d + c;
+    return d;
 }
 
 int
@@ -24,7 +24,7 @@ ands_si_test2 (int a, int b, int c)
   if (d == 0)
     return a + c;
   else
-    return b + d + c;
+    return d;
 }
 
 int
@@ -36,7 +36,7 @@ ands_si_test3 (int a, int b, int c)
   if (d == 0)
     return a + c;
   else
-    return b + d + c;
+    return d;
 }
 
 typedef long long s64;
@@ -50,7 +50,7 @@ ands_di_test1 (s64 a, s64 b, s64 c)
   if (d == 0)
     return a + c;
   else
-    return b + d + c;
+    return d;
 }
 
 s64
@@ -62,7 +62,7 @@ ands_di_test2 (s64 a, s64 b, s64 c)
   if (d == 0)
     return a + c;
   else
-    return b + d + c;
+    return d;
 }
 
 s64
@@ -74,7 +74,7 @@ ands_di_test3 (s64 a, s64 b, s64 c)
   if (d == 0)
     return a + c;
   else
-    return b + d + c;
+    return d;
 }
 
 int
@@ -84,7 +84,7 @@ main ()
   s64 y;
 
   x = ands_si_test1 (29, 4, 5);
-  if (x != 13)
+  if (x != (29 & 4))
     abort ();
 
   x = ands_si_test1 (5, 2, 20);
@@ -92,7 +92,7 @@ main ()
     abort ();
 
   x = ands_si_test2 (29, 4, 5);
-  if (x != 38)
+  if (x != (29 & 0xff))
     abort ();
 
   x = ands_si_test2 (1024, 2, 20);
@@ -100,7 +100,7 @@ main ()
     abort ();
 
   x = ands_si_test3 (35, 4, 5);
-  if (x != 41)
+  if (x != (35 & (4 << 3)))
     abort ();
 
   x = ands_si_test3 (5, 2, 20);
@@ -111,7 +111,7 @@ main ()
                      0x320000004ll,
                      0x505050505ll);
 
-  if (y != ((0x130000029ll & 0x320000004ll) + 0x320000004ll + 0x505050505ll))
+  if (y != ((0x130000029ll & 0x320000004ll)))
     abort ();
 
   y = ands_di_test1 (0x5000500050005ll,
@@ -123,7 +123,7 @@ main ()
   y = ands_di_test2 (0x130000029ll,
                      0x320000004ll,
                      0x505050505ll);
-  if (y != ((0x130000029ll & 0xff) + 0x320000004ll + 0x505050505ll))
+  if (y != ((0x130000029ll & 0xff)))
     abort ();
 
   y = ands_di_test2 (0x130002900ll,
@@ -135,8 +135,7 @@ main ()
   y = ands_di_test3 (0x130000029ll,
                      0x064000008ll,
                      0x505050505ll);
-  if (y != ((0x130000029ll & (0x064000008ll << 3))
-	    + 0x064000008ll + 0x505050505ll))
+  if (y != ((0x130000029ll & (0x064000008ll << 3))))
     abort ();
 
   y = ands_di_test3 (0x130002900ll,
@@ -148,4 +147,3 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/ands_2.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/ands_2.c
@@ -154,4 +154,3 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/arm_align_max_pwr.c
@@ -0,0 +1,23 @@
+/* { dg-do compile } */
+/* { dg-options "-O1" } */
+
+#define align (1ul << __ARM_ALIGN_MAX_PWR)
+static int x __attribute__ ((aligned (align)));
+static int y __attribute__ ((aligned (align)));
+
+extern void foo (int *x, int *y);
+extern int bar (int x, int y);
+
+int
+dummy ()
+{
+  int result;
+
+  foo (&x, &y);
+  result = bar (x, y);
+
+  return result;
+}
+
+/* { dg-final { scan-assembler-times "zero\t4" 2 } } */
+/* { dg-final { scan-assembler "zero\t268435452" } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/arm_align_max_stack_pwr.c
@@ -0,0 +1,20 @@
+/* { dg-do compile } */
+/* { dg-options "-O1" } */
+
+#define align (1ul << __ARM_ALIGN_MAX_STACK_PWR)
+extern void foo (int *x);
+extern int bar (int x);
+
+int
+dummy ()
+{
+  int x __attribute__ ((aligned (align)));
+  int result;
+
+  foo (&x);
+  result = bar (x);
+
+  return result;
+}
+
+/* { dg-final { scan-assembler "and\tx\[0-9\]+, x\[0-9\]+, -65536" } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/arm_neon-nosimd-error.c
+++ b/src//dev/null
@@ -1,11 +0,0 @@
-/* { dg-do compile } */
-/* { dg-options "-mgeneral-regs-only" } */
-/* { dg-excess-errors "You must enable" } */
-
-#include "arm_neon.h"
-
-int
-foo ()
-{
-  return 0;
-}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/ashltidisi.c
@@ -0,0 +1,49 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -save-temps" } */
+
+extern void abort (void);
+
+#define GEN_TEST_CASE(x, y, z)\
+__uint128_t __attribute__ ((noinline))\
+ushift_##x##_##z (unsigned y data)\
+{\
+  return (__uint128_t) data << x;\
+}\
+__int128_t __attribute__ ((noinline)) \
+shift_##x##_##z (y data) \
+{\
+  return (__int128_t) data << x;\
+}
+
+GEN_TEST_CASE (53, int, i)
+GEN_TEST_CASE (3, long long, ll)
+GEN_TEST_CASE (13, long long, ll)
+GEN_TEST_CASE (53, long long, ll)
+
+int
+main (int argc, char **argv)
+{
+
+#define SHIFT_CHECK(x, y, z, p) \
+	if (ushift_##y##_##p (x)\
+	    != ((__uint128_t) (unsigned z) x << y)) \
+	  abort ();\
+	if (shift_##y##_##p (x)\
+	    != ((__uint128_t) (signed z) x << y)) \
+	  abort ();
+
+  SHIFT_CHECK (0x12345678, 53, int, i)
+  SHIFT_CHECK (0xcafecafe, 53, int, i)
+
+  SHIFT_CHECK (0x1234567890abcdefLL, 3, long long, ll)
+  SHIFT_CHECK (0x1234567890abcdefLL, 13, long long, ll)
+  SHIFT_CHECK (0x1234567890abcdefLL, 53, long long, ll)
+  SHIFT_CHECK (0xcafecafedeaddeadLL, 3, long long, ll)
+  SHIFT_CHECK (0xcafecafedeaddeadLL, 13, long long, ll)
+  SHIFT_CHECK (0xcafecafedeaddeadLL, 53, long long, ll)
+
+  return 0;
+}
+
+/* { dg-final { scan-assembler-times "asr" 4 } } */
+/* { dg-final { scan-assembler-not "extr\t" } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/atomic-comp-swap-release-acquire.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/atomic-comp-swap-release-acquire.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -fno-ipa-icf" } */
+/* { dg-options "-march=armv8-a+nolse -O2 -fno-ipa-icf" } */
 
 #include "atomic-comp-swap-release-acquire.x"
 
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/atomic-inst-cas.c
@@ -0,0 +1,61 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -march=armv8-a+lse -fno-ipa-icf" } */
+
+/* Test ARMv8.1-A CAS instruction.  */
+
+#include "atomic-inst-ops.inc"
+
+#define TEST TEST_TWO
+
+#define CAS_ATOMIC(FN, TY, MODEL1, MODEL2)				\
+  int FNNAME (FN, TY) (TY* val, TY* foo, TY* bar)			\
+  {									\
+    int model_s = MODEL1;						\
+    int model_f = MODEL2;						\
+    /* The success memory ordering must be at least as strong as	\
+       the failure memory ordering.  */					\
+    if (model_s < model_f)						\
+      return 0;								\
+    /* Ignore invalid memory orderings.  */				\
+    if (model_f == __ATOMIC_RELEASE || model_f == __ATOMIC_ACQ_REL)	\
+      return 0;								\
+    return __atomic_compare_exchange_n (val, foo, bar, 0, model_s, model_f); \
+  }
+
+#define CAS_ATOMIC_NORETURN(FN, TY, MODEL1, MODEL2)			\
+  void FNNAME (FN, TY) (TY* val, TY* foo, TY* bar)			\
+  {									\
+    int model_s = MODEL1;						\
+    int model_f = MODEL2;						\
+    /* The success memory ordering must be at least as strong as	\
+       the failure memory ordering.  */					\
+    if (model_s < model_f)						\
+      return;								\
+    /* Ignore invalid memory orderings.  */				\
+    if (model_f == __ATOMIC_RELEASE || model_f == __ATOMIC_ACQ_REL)	\
+      return;								\
+    __atomic_compare_exchange_n (val, foo, bar, 0, model_s, model_f);	\
+  }
+
+TEST (cas_atomic, CAS_ATOMIC)
+TEST (cas_atomic_noreturn, CAS_ATOMIC_NORETURN)
+
+
+/* { dg-final { scan-assembler-times "casb\t" 4} } */
+/* { dg-final { scan-assembler-times "casab\t" 20} } */
+/* { dg-final { scan-assembler-times "caslb\t" 4} } */
+/* { dg-final { scan-assembler-times "casalb\t" 36} } */
+
+/* { dg-final { scan-assembler-times "cash\t" 4} } */
+/* { dg-final { scan-assembler-times "casah\t" 20} } */
+/* { dg-final { scan-assembler-times "caslh\t" 4} } */
+/* { dg-final { scan-assembler-times "casalh\t" 36} } */
+
+/* { dg-final { scan-assembler-times "cas\t" 8} } */
+/* { dg-final { scan-assembler-times "casa\t" 40} } */
+/* { dg-final { scan-assembler-times "casl\t" 8} } */
+/* { dg-final { scan-assembler-times "casal\t" 72} } */
+
+/* { dg-final { scan-assembler-not "ldaxr\t" } } */
+/* { dg-final { scan-assembler-not "stlxr\t" } } */
+/* { dg-final { scan-assembler-not "dmb" } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/atomic-inst-ldadd.c
@@ -0,0 +1,87 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -march=armv8-a+lse -fno-ipa-icf" } */
+
+/* Test ARMv8.1-A Load-ADD instruction.  */
+
+#include "atomic-inst-ops.inc"
+
+#define TEST TEST_ONE
+
+#define LOAD_ADD(FN, TY, MODEL)						\
+  TY FNNAME (FN, TY) (TY* val, TY* foo)					\
+  {									\
+    return __atomic_fetch_add (val, foo, MODEL);			\
+  }
+
+#define LOAD_ADD_NORETURN(FN, TY, MODEL)				\
+  void FNNAME (FN, TY) (TY* val, TY* foo)				\
+  {									\
+    __atomic_fetch_add (val, foo, MODEL);				\
+  }
+
+#define LOAD_SUB(FN, TY, MODEL)						\
+  TY FNNAME (FN, TY) (TY* val, TY* foo)					\
+  {									\
+    return __atomic_fetch_sub (val, foo, MODEL);			\
+  }
+
+#define LOAD_SUB_NORETURN(FN, TY, MODEL)				\
+  void FNNAME (FN, TY) (TY* val, TY* foo)				\
+  {									\
+    __atomic_fetch_sub (val, foo, MODEL);				\
+  }
+
+#define ADD_LOAD(FN, TY, MODEL)						\
+  TY FNNAME (FN, TY) (TY* val, TY* foo)					\
+  {									\
+    return __atomic_add_fetch (val, foo, MODEL);			\
+  }
+
+#define ADD_LOAD_NORETURN(FN, TY, MODEL)				\
+  void FNNAME (FN, TY) (TY* val, TY* foo)				\
+  {									\
+    __atomic_add_fetch (val, foo, MODEL);				\
+  }
+
+#define SUB_LOAD(FN, TY, MODEL)						\
+  TY FNNAME (FN, TY) (TY* val, TY* foo)					\
+  {									\
+    return __atomic_sub_fetch (val, foo, MODEL);			\
+  }
+
+#define SUB_LOAD_NORETURN(FN, TY, MODEL)				\
+  void FNNAME (FN, TY) (TY* val, TY* foo)				\
+  {									\
+    __atomic_sub_fetch (val, foo, MODEL);				\
+  }
+
+TEST (load_add, LOAD_ADD)
+TEST (load_add_notreturn, LOAD_ADD_NORETURN)
+
+TEST (load_sub, LOAD_SUB)
+TEST (load_sub_notreturn, LOAD_SUB_NORETURN)
+
+TEST (add_load, ADD_LOAD)
+TEST (add_load_notreturn, ADD_LOAD_NORETURN)
+
+TEST (sub_load, SUB_LOAD)
+TEST (sub_load_notreturn, SUB_LOAD_NORETURN)
+
+/* { dg-final { scan-assembler-times "ldaddb\t" 16} } */
+/* { dg-final { scan-assembler-times "ldaddab\t" 32} } */
+/* { dg-final { scan-assembler-times "ldaddlb\t" 16} } */
+/* { dg-final { scan-assembler-times "ldaddalb\t" 32} } */
+
+/* { dg-final { scan-assembler-times "ldaddh\t" 16} } */
+/* { dg-final { scan-assembler-times "ldaddah\t" 32} } */
+/* { dg-final { scan-assembler-times "ldaddlh\t" 16} } */
+/* { dg-final { scan-assembler-times "ldaddalh\t" 32} } */
+
+/* { dg-final { scan-assembler-times "ldadd\t" 32} } */
+/* { dg-final { scan-assembler-times "ldadda\t" 64} } */
+/* { dg-final { scan-assembler-times "ldaddl\t" 32} } */
+/* { dg-final { scan-assembler-times "ldaddal\t" 64} } */
+
+/* { dg-final { scan-assembler-not "ldaxr\t" } } */
+/* { dg-final { scan-assembler-not "stlxr\t" } } */
+/* { dg-final { scan-assembler-not "dmb" } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/atomic-inst-ldlogic.c
@@ -0,0 +1,155 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -march=armv8-a+lse -fno-ipa-icf" } */
+
+/* Test ARMv8.1-A LD<logic-op> instruction.  */
+
+#include "atomic-inst-ops.inc"
+
+#define TEST TEST_ONE
+
+#define LOAD_OR(FN, TY, MODEL)						\
+  TY FNNAME (FN, TY) (TY* val, TY* foo)					\
+  {									\
+    return __atomic_fetch_or (val, foo, MODEL);				\
+  }
+
+#define LOAD_OR_NORETURN(FN, TY, MODEL)					\
+  void FNNAME (FN, TY) (TY* val, TY* foo)				\
+  {									\
+    __atomic_fetch_or (val, foo, MODEL);				\
+  }
+
+#define LOAD_AND(FN, TY, MODEL)						\
+  TY FNNAME (FN, TY) (TY* val, TY* foo)					\
+  {									\
+    return __atomic_fetch_and (val, foo, MODEL);			\
+  }
+
+#define LOAD_AND_NORETURN(FN, TY, MODEL)				\
+  void FNNAME (FN, TY) (TY* val, TY* foo)				\
+  {									\
+    __atomic_fetch_and (val, foo, MODEL);				\
+  }
+
+#define LOAD_XOR(FN, TY, MODEL)						\
+  TY FNNAME (FN, TY) (TY* val, TY* foo)					\
+  {									\
+    return __atomic_fetch_xor (val, foo, MODEL);			\
+  }
+
+#define LOAD_XOR_NORETURN(FN, TY, MODEL)				\
+  void FNNAME (FN, TY) (TY* val, TY* foo)				\
+  {									\
+    __atomic_fetch_xor (val, foo, MODEL);				\
+  }
+
+#define OR_LOAD(FN, TY, MODEL)						\
+  TY FNNAME (FN, TY) (TY* val, TY* foo)					\
+  {									\
+    return __atomic_or_fetch (val, foo, MODEL);				\
+  }
+
+#define OR_LOAD_NORETURN(FN, TY, MODEL)					\
+  void FNNAME (FN, TY) (TY* val, TY* foo)				\
+  {									\
+    __atomic_or_fetch (val, foo, MODEL);				\
+  }
+
+#define AND_LOAD(FN, TY, MODEL)						\
+  TY FNNAME (FN, TY) (TY* val, TY* foo)					\
+  {									\
+    return __atomic_and_fetch (val, foo, MODEL);			\
+  }
+
+#define AND_LOAD_NORETURN(FN, TY, MODEL)				\
+  void FNNAME (FN, TY) (TY* val, TY* foo)				\
+  {									\
+    __atomic_and_fetch (val, foo, MODEL);				\
+  }
+
+#define XOR_LOAD(FN, TY, MODEL)						\
+  TY FNNAME (FN, TY) (TY* val, TY* foo)					\
+  {									\
+    return __atomic_xor_fetch (val, foo, MODEL);			\
+  }
+
+#define XOR_LOAD_NORETURN(FN, TY, MODEL)				\
+  void FNNAME (FN, TY) (TY* val, TY* foo)				\
+  {									\
+    __atomic_xor_fetch (val, foo, MODEL);				\
+  }
+
+
+TEST (load_or, LOAD_OR)
+TEST (load_or_notreturn, LOAD_OR_NORETURN)
+
+TEST (load_and, LOAD_AND)
+TEST (load_and_notreturn, LOAD_AND_NORETURN)
+
+TEST (load_xor, LOAD_XOR)
+TEST (load_xor_notreturn, LOAD_XOR_NORETURN)
+
+TEST (or_load, OR_LOAD)
+TEST (or_load_notreturn, OR_LOAD_NORETURN)
+
+TEST (and_load, AND_LOAD)
+TEST (and_load_notreturn, AND_LOAD_NORETURN)
+
+TEST (xor_load, XOR_LOAD)
+TEST (xor_load_notreturn, XOR_LOAD_NORETURN)
+
+
+/* Load-OR.  */
+
+/* { dg-final { scan-assembler-times "ldsetb\t" 8} } */
+/* { dg-final { scan-assembler-times "ldsetab\t" 16} } */
+/* { dg-final { scan-assembler-times "ldsetlb\t" 8} } */
+/* { dg-final { scan-assembler-times "ldsetalb\t" 16} } */
+
+/* { dg-final { scan-assembler-times "ldseth\t" 8} } */
+/* { dg-final { scan-assembler-times "ldsetah\t" 16} } */
+/* { dg-final { scan-assembler-times "ldsetlh\t" 8} } */
+/* { dg-final { scan-assembler-times "ldsetalh\t" 16} } */
+
+/* { dg-final { scan-assembler-times "ldset\t" 16} } */
+/* { dg-final { scan-assembler-times "ldseta\t" 32} } */
+/* { dg-final { scan-assembler-times "ldsetl\t" 16} } */
+/* { dg-final { scan-assembler-times "ldsetal\t" 32} } */
+
+/* Load-AND.  */
+
+/* { dg-final { scan-assembler-times "ldclrb\t" 8} } */
+/* { dg-final { scan-assembler-times "ldclrab\t" 16} } */
+/* { dg-final { scan-assembler-times "ldclrlb\t" 8} } */
+/* { dg-final { scan-assembler-times "ldclralb\t" 16} } */
+
+/* { dg-final { scan-assembler-times "ldclrh\t" 8} } */
+/* { dg-final { scan-assembler-times "ldclrah\t" 16} } */
+/* { dg-final { scan-assembler-times "ldclrlh\t" 8} } */
+/* { dg-final { scan-assembler-times "ldclralh\t" 16} } */
+
+/* { dg-final { scan-assembler-times "ldclr\t" 16} */
+/* { dg-final { scan-assembler-times "ldclra\t" 32} } */
+/* { dg-final { scan-assembler-times "ldclrl\t" 16} } */
+/* { dg-final { scan-assembler-times "ldclral\t" 32} } */
+
+/* Load-XOR.  */
+
+/* { dg-final { scan-assembler-times "ldeorb\t" 8} } */
+/* { dg-final { scan-assembler-times "ldeorab\t" 16} } */
+/* { dg-final { scan-assembler-times "ldeorlb\t" 8} } */
+/* { dg-final { scan-assembler-times "ldeoralb\t" 16} } */
+
+/* { dg-final { scan-assembler-times "ldeorh\t" 8} } */
+/* { dg-final { scan-assembler-times "ldeorah\t" 16} } */
+/* { dg-final { scan-assembler-times "ldeorlh\t" 8} } */
+/* { dg-final { scan-assembler-times "ldeoralh\t" 16} } */
+
+/* { dg-final { scan-assembler-times "ldeor\t" 16} */
+/* { dg-final { scan-assembler-times "ldeora\t" 32} } */
+/* { dg-final { scan-assembler-times "ldeorl\t" 16} } */
+/* { dg-final { scan-assembler-times "ldeoral\t" 32} } */
+
+/* { dg-final { scan-assembler-not "ldaxr\t" } } */
+/* { dg-final { scan-assembler-not "stlxr\t" } } */
+/* { dg-final { scan-assembler-not "dmb" } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/atomic-inst-ops.inc
@@ -0,0 +1,66 @@
+/* Support code for atomic instruction tests.  */
+
+/* Define types names without spaces.  */
+typedef unsigned char uchar;
+typedef unsigned short ushort;
+typedef unsigned int uint;
+typedef long long longlong;
+typedef unsigned long long ulonglong;
+typedef __int128_t int128;
+typedef __uint128_t uint128;
+
+#define FNNAME(NAME,TY) NAME
+
+/* Expand one-model functions.  */
+#define TEST_M1(NAME, FN, TY, MODEL, DUMMY)	\
+  FN (test_##NAME##_##TY, TY, MODEL)
+
+/* Expand two-model functions.  */
+#define TEST_M2(NAME, FN, TY, MODEL1, MODEL2)	\
+  FN (test_##NAME##_##TY, TY, MODEL1, MODEL2)
+
+/* Typest to test.  */
+#define TEST_TY(NAME, FN, N, MODEL1, MODEL2)		\
+  TEST_M##N (NAME, FN, char, MODEL1, MODEL2)		\
+  TEST_M##N (NAME, FN, uchar, MODEL1, MODEL2)		\
+  TEST_M##N (NAME, FN, short, MODEL1, MODEL2)		\
+  TEST_M##N (NAME, FN, ushort, MODEL1, MODEL2)		\
+  TEST_M##N (NAME, FN, int, MODEL1, MODEL2)		\
+  TEST_M##N (NAME, FN, uint, MODEL1, MODEL2)		\
+  TEST_M##N (NAME, FN, longlong, MODEL1, MODEL2)	\
+  TEST_M##N (NAME, FN, ulonglong, MODEL1, MODEL2)	\
+  TEST_M##N (NAME, FN, int128, MODEL1, MODEL2)		\
+  TEST_M##N (NAME, FN, uint128, MODEL1, MODEL2)
+
+/* Models to test.  */
+#define TEST_MODEL(NAME, FN, N)					\
+  TEST_TY (NAME##_relaxed, FN, N, __ATOMIC_RELAXED, DUMMY)	\
+  TEST_TY (NAME##_consume, FN, N, __ATOMIC_CONSUME, DUMMY)	\
+  TEST_TY (NAME##_acquire, FN, N, __ATOMIC_ACQUIRE, DUMMY)	\
+  TEST_TY (NAME##_release, FN, N, __ATOMIC_RELEASE, DUMMY)	\
+  TEST_TY (NAME##_acq_rel, FN, N, __ATOMIC_ACQ_REL, DUMMY)	\
+  TEST_TY (NAME##_seq_cst, FN, N, __ATOMIC_SEQ_CST, DUMMY)	\
+
+/* Cross-product of models to test.  */
+#define TEST_MODEL_M1(NAME, FN, N, M)			\
+  TEST_TY (NAME##_relaxed, FN, N, M, __ATOMIC_RELAXED)	\
+  TEST_TY (NAME##_consume, FN, N, M, __ATOMIC_CONSUME)	\
+  TEST_TY (NAME##_acquire, FN, N, M, __ATOMIC_ACQUIRE)	\
+  TEST_TY (NAME##_release, FN, N, M, __ATOMIC_RELEASE)	\
+  TEST_TY (NAME##_acq_rel, FN, N, M, __ATOMIC_ACQ_REL)	\
+  TEST_TY (NAME##_seq_cst, FN, N, M, __ATOMIC_SEQ_CST)	\
+
+#define TEST_MODEL_M2(NAME, FN)					\
+  TEST_MODEL_M1 (NAME##_relaxed, FN, 2, __ATOMIC_RELAXED)	\
+  TEST_MODEL_M1 (NAME##_consume, FN, 2, __ATOMIC_CONSUME)	\
+  TEST_MODEL_M1 (NAME##_acquire, FN, 2, __ATOMIC_ACQUIRE)	\
+  TEST_MODEL_M1 (NAME##_release, FN, 2, __ATOMIC_RELEASE)	\
+  TEST_MODEL_M1 (NAME##_acq_rel, FN, 2, __ATOMIC_ACQ_REL)	\
+  TEST_MODEL_M1 (NAME##_seq_cst, FN, 2, __ATOMIC_SEQ_CST)	\
+
+/* Expand functions for a cross-product of memory models and types.  */
+#define TEST_TWO(NAME, FN) TEST_MODEL_M2 (NAME, FN)
+
+/* Expand functions for a set of memory models and types.  */
+#define TEST_ONE(NAME, FN) TEST_MODEL (NAME, FN, 1)
+
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/atomic-inst-swp.c
@@ -0,0 +1,44 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -march=armv8-a+lse -fno-ipa-icf" } */
+
+/* Test ARMv8.1-A SWP instruction.  */
+
+#include "atomic-inst-ops.inc"
+
+#define TEST TEST_ONE
+
+#define SWAP_ATOMIC(FN, TY, MODEL)					\
+  TY FNNAME (FN, TY) (TY* val, TY foo)					\
+  {									\
+    return __atomic_exchange_n (val, foo, MODEL);			\
+  }
+
+#define SWAP_ATOMIC_NORETURN(FN, TY, MODEL)				\
+  void FNNAME (FN, TY) (TY* val, TY* foo, TY* bar)			\
+  {									\
+    __atomic_exchange (val, foo, bar, MODEL);				\
+  }
+
+
+TEST (swap_atomic, SWAP_ATOMIC)
+TEST (swap_atomic_noreturn, SWAP_ATOMIC_NORETURN)
+
+
+/* { dg-final { scan-assembler-times "swpb\t" 4} } */
+/* { dg-final { scan-assembler-times "swpab\t" 8} } */
+/* { dg-final { scan-assembler-times "swplb\t" 4} } */
+/* { dg-final { scan-assembler-times "swpalb\t" 8} } */
+
+/* { dg-final { scan-assembler-times "swph\t" 4} } */
+/* { dg-final { scan-assembler-times "swpah\t" 8} } */
+/* { dg-final { scan-assembler-times "swplh\t" 4} } */
+/* { dg-final { scan-assembler-times "swpalh\t" 8} } */
+
+/* { dg-final { scan-assembler-times "swp\t" 8} } */
+/* { dg-final { scan-assembler-times "swpa\t" 16} } */
+/* { dg-final { scan-assembler-times "swpl\t" 8} } */
+/* { dg-final { scan-assembler-times "swpal\t" 16} } */
+
+/* { dg-final { scan-assembler-not "ldaxr\t" } } */
+/* { dg-final { scan-assembler-not "stlxr\t" } } */
+/* { dg-final { scan-assembler-not "dmb" } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/atomic-op-acq_rel.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/atomic-op-acq_rel.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O2" } */
+/* { dg-options "-march=armv8-a+nolse -O2" } */
 
 #include "atomic-op-acq_rel.x"
 
--- a/src/gcc/testsuite/gcc.target/aarch64/atomic-op-acquire.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/atomic-op-acquire.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O2" } */
+/* { dg-options "-march=armv8-a+nolse -O2" } */
 
 #include "atomic-op-acquire.x"
 
--- a/src/gcc/testsuite/gcc.target/aarch64/atomic-op-char.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/atomic-op-char.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O2" } */
+/* { dg-options "-march=armv8-a+nolse -O2" } */
 
 #include "atomic-op-char.x"
 
--- a/src/gcc/testsuite/gcc.target/aarch64/atomic-op-consume.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/atomic-op-consume.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O2" } */
+/* { dg-options "-march=armv8-a+nolse -O2" } */
 
 #include "atomic-op-consume.x"
 
--- a/src/gcc/testsuite/gcc.target/aarch64/atomic-op-imm.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/atomic-op-imm.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O2" } */
+/* { dg-options "-march=armv8-a+nolse -O2" } */
 
 int v = 0;
 
--- a/src/gcc/testsuite/gcc.target/aarch64/atomic-op-int.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/atomic-op-int.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O2" } */
+/* { dg-options "-march=armv8-a+nolse -O2" } */
 
 #include "atomic-op-int.x"
 
--- a/src/gcc/testsuite/gcc.target/aarch64/atomic-op-long.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/atomic-op-long.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O2" } */
+/* { dg-options "-march=armv8-a+nolse -O2" } */
 
 long v = 0;
 
--- a/src/gcc/testsuite/gcc.target/aarch64/atomic-op-relaxed.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/atomic-op-relaxed.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O2" } */
+/* { dg-options "-march=armv8-a+nolse -O2" } */
 
 #include "atomic-op-relaxed.x"
 
--- a/src/gcc/testsuite/gcc.target/aarch64/atomic-op-release.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/atomic-op-release.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O2" } */
+/* { dg-options "-march=armv8-a+nolse -O2" } */
 
 #include "atomic-op-release.x"
 
--- a/src/gcc/testsuite/gcc.target/aarch64/atomic-op-seq_cst.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/atomic-op-seq_cst.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O2" } */
+/* { dg-options "-march=armv8-a+nolse -O2" } */
 
 #include "atomic-op-seq_cst.x"
 
--- a/src/gcc/testsuite/gcc.target/aarch64/atomic-op-short.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/atomic-op-short.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O2" } */
+/* { dg-options "-march=armv8-a+nolse -O2" } */
 
 #include "atomic-op-short.x"
 
--- a/src/gcc/testsuite/gcc.target/aarch64/bfxil_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/bfxil_1.c
@@ -37,4 +37,3 @@ main (void)
   return 0;
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/bfxil_2.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/bfxil_2.c
@@ -39,4 +39,3 @@ main (void)
   return 0;
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/bics_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/bics_1.c
@@ -12,7 +12,7 @@ bics_si_test1 (int a, int b, int c)
   if (d == 0)
     return a + c;
   else
-    return b + d + c;
+    return d;
 }
 
 int
@@ -24,7 +24,7 @@ bics_si_test2 (int a, int b, int c)
   if (d == 0)
     return a + c;
   else
-    return b + d + c;
+    return d;
 }
 
 typedef long long s64;
@@ -38,7 +38,7 @@ bics_di_test1 (s64 a, s64 b, s64 c)
   if (d == 0)
     return a + c;
   else
-    return b + d + c;
+    return d;
 }
 
 s64
@@ -50,7 +50,7 @@ bics_di_test2 (s64 a, s64 b, s64 c)
   if (d == 0)
     return a + c;
   else
-    return b + d + c;
+    return d;
 }
 
 int
@@ -60,7 +60,7 @@ main ()
   s64 y;
 
   x = bics_si_test1 (29, ~4, 5);
-  if (x != ((29 & 4) + ~4 + 5))
+  if (x != (29 & 4))
     abort ();
 
   x = bics_si_test1 (5, ~2, 20);
@@ -68,7 +68,7 @@ main ()
     abort ();
 
   x = bics_si_test2 (35, ~4, 5);
-  if (x != ((35 & ~(~4 << 3)) + ~4 + 5))
+  if (x != (35 & ~(~4 << 3)))
     abort ();
 
   x = bics_si_test2 (96, ~2, 20);
@@ -79,7 +79,7 @@ main ()
                      ~0x320000004ll,
                      0x505050505ll);
 
-  if (y != ((0x130000029ll & 0x320000004ll) + ~0x320000004ll + 0x505050505ll))
+  if (y != (0x130000029ll & 0x320000004ll))
     abort ();
 
   y = bics_di_test1 (0x5000500050005ll,
@@ -91,8 +91,7 @@ main ()
   y = bics_di_test2 (0x130000029ll,
                      ~0x064000008ll,
                      0x505050505ll);
-  if (y != ((0x130000029ll & ~(~0x064000008ll << 3))
-	    + ~0x064000008ll + 0x505050505ll))
+  if (y != (0x130000029ll & ~(~0x064000008ll << 3)))
     abort ();
 
   y = bics_di_test2 (0x130002900ll,
@@ -103,5 +102,3 @@ main ()
 
   return 0;
 }
-
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/bics_2.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/bics_2.c
@@ -108,4 +108,3 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/bics_3.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/bics_3.c
@@ -66,4 +66,3 @@ main (void)
 /* { dg-final { scan-assembler-times "bics\txzr, x\[0-9\]+, x\[0-9\]+" 2 } } */
 /* { dg-final { scan-assembler-times "bics\txzr, x\[0-9\]+, x\[0-9\]+, lsl 2" 1 } } */
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/bics_4.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/bics_4.c
@@ -84,4 +84,3 @@ main ()
 
 /* { dg-final { scan-assembler-times "bics\twzr, w\[0-9\]+, w\[0-9\]+" 2 } } */
 /* { dg-final { scan-assembler-times "bics\txzr, x\[0-9\]+, x\[0-9\]+" 2 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/c-output-template-4.c
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-O0" } */
+
+void
+test (void)
+{
+    __asm__ ("@ %c0" : : "S" (&test + 4));
+}
+
+/* { dg-final { scan-assembler "@ test\\+4" } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/cinc_common_1.c
@@ -0,0 +1,64 @@
+/* { dg-do run } */
+/* { dg-options "-save-temps -O2 -fno-inline" } */
+
+extern void abort (void);
+
+int
+foosi (int x)
+{
+  return x > 100 ? x - 2 : x - 1;
+}
+
+int
+barsi (int x)
+{
+  return x > 100 ? x + 4 : x + 3;
+}
+
+long
+foodi (long x)
+{
+  return x > 100 ? x - 2 : x - 1;
+}
+
+long
+bardi (long x)
+{
+  return x > 100 ? x + 4 : x + 3;
+}
+
+/* { dg-final { scan-assembler-times "cs?inc\tw\[0-9\]*" 2 } } */
+/* { dg-final { scan-assembler-times "cs?inc\tx\[0-9\]*" 2 } } */
+
+int
+main (void)
+{
+  if (foosi (105) != 103)
+    abort ();
+
+  if (foosi (95) != 94)
+    abort ();
+
+  if (barsi (105) != 109)
+    abort ();
+
+  if (barsi (95) != 98)
+    abort ();
+
+  if (foodi (105) != 103)
+    abort ();
+
+  if (foodi (95) != 94)
+    abort ();
+
+  if (bardi (105) != 109)
+    abort ();
+
+  if (bardi (95) != 98)
+    abort ();
+
+  return 0;
+}
+
+/* { dg-final { scan-assembler-not "csel\tx\[0-9\]*.*" } } */
+/* { dg-final { scan-assembler-not "csel\tw\[0-9\]*.*" } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/cmn-neg.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/cmn-neg.c
@@ -30,4 +30,3 @@ main (void)
   return 0;
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/cmn-neg2.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/cmn-neg2.c
@@ -31,4 +31,3 @@ main (void)
 }
 /* { dg-final { scan-assembler-not "cmn\t" } } */
 
-/* { dg-final { cleanup-saved-temps } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/combine_bfi_1.c
@@ -0,0 +1,34 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-rtl-combine" } */
+
+int
+f1 (int x, int y)
+{
+  return (x & ~0x0ffff00) | ((y << 8) & 0x0ffff00);
+}
+
+int
+f2 (int x, int y)
+{
+  return (x & ~0x0ff000) | ((y & 0x0ff) << 12);
+}
+
+int
+f3 (int x, int y)
+{
+  return (x & ~0xffff) | (y & 0xffff);
+}
+
+int
+f4 (int x, int y)
+{
+  return (x & ~0xff) | (y & 0xff);
+}
+
+long
+f5 (long x, long y)
+{
+  return (x & ~0xffffffffull) | (y & 0xffffffff);
+}
+
+/* { dg-final { scan-rtl-dump-times "\\*aarch64_bfi" 5 "combine" } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/copysign_1.c
@@ -0,0 +1,81 @@
+/* { dg-do run } */
+/* { dg-options "-O2 --save-temps" } */
+
+double fabs (double);
+
+double
+check (double x, double y)
+{
+  return __builtin_copysign (x, y);
+}
+
+double
+check1 (double x)
+{
+  return __builtin_copysign (x, 1.0);
+}
+
+double
+check2 (double x)
+{
+  return __builtin_copysign (1.0, x);
+}
+
+double
+check3 (double x)
+{
+  return -__builtin_copysign (x, 1.0);
+}
+
+double
+check4 (double x, double y)
+{
+  return x * __builtin_copysign (x, y);
+}
+
+double
+check5 (double x, double y)
+{
+  return __builtin_copysign (-x, -y);
+}
+
+int
+main (int argc, char** argv)
+{
+  double x = 2.0;
+  double y = -5.0;
+  double epsilon = 0.00001;
+
+  double expected = -2.0;
+
+  if (fabs (check (x, y) - expected) >= epsilon)
+    __builtin_abort ();
+
+  expected = 2.0;
+
+  if (fabs (check1 (x) - expected) >= epsilon)
+    __builtin_abort ();
+
+  expected = 1.0;
+
+  if (fabs (check2 (x) - expected) >= epsilon)
+    __builtin_abort ();
+
+  expected = -2.0;
+
+  if (fabs (check3 (x) - expected) >= epsilon)
+    __builtin_abort ();
+
+  expected = -4.0;
+
+  if (fabs (check4 (x, y) - expected) >= epsilon)
+    __builtin_abort ();
+
+  expected = 2.0;
+
+  if (fabs (check5 (x, y) - expected) >= epsilon)
+    __builtin_abort ();
+}
+
+/* { dg-final { scan-assembler-not "copysign\tw" } } */
+
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/copysign_2.c
@@ -0,0 +1,81 @@
+/* { dg-do run } */
+/* { dg-options "-O2 --save-temps" } */
+
+float fabsf (float);
+
+float
+check (float x, float y)
+{
+  return __builtin_copysignf (x, y);
+}
+
+float
+check1 (float x)
+{
+  return __builtin_copysignf (x, 1.0);
+}
+
+float
+check2 (float x)
+{
+  return __builtin_copysignf (1.0, x);
+}
+
+float
+check3 (float x)
+{
+  return -__builtin_copysignf (x, 1.0);
+}
+
+float
+check4 (float x, float y)
+{
+  return x * __builtin_copysignf (x, y);
+}
+
+float
+check5 (float x, float y)
+{
+  return __builtin_copysignf (-x, -y);
+}
+
+int
+main (int argc, char** argv)
+{
+  float x = 2.0f;
+  float y = -5.0f;
+  float epsilon = 0.00001f;
+
+  float expected = -2.0f;
+
+  if (fabsf (check (x, y) - expected) >= epsilon)
+    __builtin_abort ();
+
+  expected = 2.0f;
+
+  if (fabsf (check1 (x) - expected) >= epsilon)
+    __builtin_abort ();
+
+  expected = 1.0f;
+
+  if (fabsf (check2 (x) - expected) >= epsilon)
+    __builtin_abort ();
+
+  expected = -2.0f;
+
+  if (fabsf (check3 (x) - expected) >= epsilon)
+    __builtin_abort ();
+
+  expected = -4.0f;
+
+  if (fabsf (check4 (x, y) - expected) >= epsilon)
+    __builtin_abort ();
+
+  expected = 2.0f;
+
+  if (fabsf (check5 (x, y) - expected) >= epsilon)
+    __builtin_abort ();
+}
+
+/* { dg-final { scan-assembler-not "copysign\tw" } } */
+
--- a/src/gcc/testsuite/gcc.target/aarch64/cpu-diagnostics-3.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/cpu-diagnostics-3.c
@@ -1,4 +1,4 @@
-/* { dg-error "unknown" "" {target "aarch64*-*-*" } } */
+/* { dg-error "invalid feature" "" {target "aarch64*-*-*" } } */
 /* { dg-options "-O2 -mcpu=cortex-a53+dummy" } */
 
 void f ()
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/csel_bfx_1.c
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-options "-save-temps -O2" } */
+
+int
+foo (int a, int b)
+{
+  return ((a & (1 << 25)) ? 5 : 4);
+}
+
+/* { dg-final { scan-assembler "ubfx\t\[xw\]\[0-9\]*.*" } } */
+/* { dg-final { scan-assembler-not "csel\tw\[0-9\]*.*" } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/csel_imms_inc_1.c
@@ -0,0 +1,42 @@
+/* { dg-do run } */
+/* { dg-options "-save-temps -O2 -fno-inline" } */
+
+extern void abort (void);
+
+int
+fooinc (int x)
+{
+  if (x)
+    return 1025;
+  else
+    return 1026;
+}
+
+int
+fooinc2 (int x)
+{
+  if (x)
+    return 1026;
+  else
+    return 1025;
+}
+
+int
+main (void)
+{
+  if (fooinc (0) != 1026)
+    abort ();
+
+  if (fooinc (1) != 1025)
+    abort ();
+
+  if (fooinc2 (0) != 1025)
+    abort ();
+
+  if (fooinc2 (1) != 1026)
+    abort ();
+
+  return 0;
+}
+
+/* { dg-final { scan-assembler-not "csel\tw\[0-9\]*.*" } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/csneg-1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/csneg-1.c
@@ -56,3 +56,15 @@ int test_csneg_cmp(int x)
     x = -x;
   return x;
 }
+
+unsigned long long
+test_csneg_uxtw (unsigned int a,
+		 unsigned int b,
+		 unsigned int c)
+{
+  /* { dg-final { scan-assembler "csneg\tw\[0-9\]*.*ne" } } */
+  /* { dg-final { scan-assembler-not "uxtw\tw\[0-9\]*.*" } } */
+  unsigned int val;
+  val = a ? b: -c;
+  return val;
+}
--- a/src/gcc/testsuite/gcc.target/aarch64/cvtf_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/cvtf_1.c
@@ -92,4 +92,3 @@ int main ()
   return 0;
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/extr.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/extr.c
@@ -31,4 +31,3 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/f16_movs_1.c
@@ -0,0 +1,26 @@
+/* { dg-do run } */
+/* { dg-options "-fno-inline -O2" } */
+
+#include <arm_neon.h>
+
+__fp16
+func2 (__fp16 a, __fp16 b)
+{
+  return b;
+}
+
+int
+main (int argc, char **argv)
+{
+  __fp16 array[16];
+  int i;
+
+  for (i = 0; i < sizeof (array) / sizeof (array[0]); i++)
+    array[i] = i;
+
+  array[0] = func2 (array[1], array[2]);
+
+  __builtin_printf ("%f\n", array[0]); /* { dg-output "2.0" } */
+
+  return 0;
+}
--- a/src/gcc/testsuite/gcc.target/aarch64/fabd.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/fabd.c
@@ -35,4 +35,3 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/fmla_intrinsic_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/fmla_intrinsic_1.c
@@ -112,5 +112,4 @@ main (int argc, char **argv)
    vfmaq_laneq_f64.  */
 /* { dg-final { scan-assembler-times "fmla\\tv\[0-9\]+\.2d, v\[0-9\]+\.2d, v\[0-9\]+\.2d\\\[\[0-9\]+\\\]" 3 } } */
 
-/* { dg-final { cleanup-saved-temps } } */
 
--- a/src/gcc/testsuite/gcc.target/aarch64/fmls_intrinsic_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/fmls_intrinsic_1.c
@@ -113,5 +113,4 @@ main (int argc, char **argv)
    vfmsq_laneq_f64.  */
 /* { dg-final { scan-assembler-times "fmls\\tv\[0-9\]+\.2d, v\[0-9\]+\.2d, v\[0-9\]+\.2d\\\[\[0-9\]+\\\]" 3 } } */
 
-/* { dg-final { cleanup-saved-temps } } */
 
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/fmovd-zero-mem.c
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+void
+foo (double *output)
+{
+  *output = 0.0;
+}
+
+/* { dg-final { scan-assembler "str\\txzr, \\\[x0\\\]" } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/fmovd-zero-reg.c
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+void bar (double);
+void
+foo (void)
+{
+  bar (0.0);
+}
+
+/* { dg-final { scan-assembler "fmov\\td0, xzr" } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/fmovd-zero.c
+++ b/src//dev/null
@@ -1,10 +0,0 @@
-/* { dg-do compile } */
-/* { dg-options "-O2" } */
-
-void
-foo (double *output)
-{
-  *output = 0.0;
-}
-
-/* { dg-final { scan-assembler "fmov\\td\[0-9\]+, xzr" } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/fmovf-zero-mem.c
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+void
+foo (float *output)
+{
+  *output = 0.0;
+}
+
+/* { dg-final { scan-assembler "str\\twzr, \\\[x0\\\]" } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/fmovf-zero-reg.c
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+void bar (float);
+void
+foo (void)
+{
+  bar (0.0);
+}
+
+/* { dg-final { scan-assembler "fmov\\ts0, wzr" } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/fmovf-zero.c
+++ b/src//dev/null
@@ -1,10 +0,0 @@
-/* { dg-do compile } */
-/* { dg-options "-O2" } */
-
-void
-foo (float *output)
-{
-  *output = 0.0;
-}
-
-/* { dg-final { scan-assembler "fmov\\ts\[0-9\]+, wzr" } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/fmovld-zero-mem.c
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+void
+foo (long double *output)
+{
+  *output = 0.0;
+}
+
+/* { dg-final { scan-assembler "stp\\txzr, xzr, \\\[x0\\\]" } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/fmovld-zero-reg.c
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+void bar (long double);
+void
+foo (void)
+{
+  bar (0.0);
+}
+
+/* { dg-final { scan-assembler "movi\\tv0\.2d, #0" } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/fmul_intrinsic_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/fmul_intrinsic_1.c
@@ -112,5 +112,4 @@ main (int argc, char **argv)
    vmulq_laneq_f64.  */
 /* { dg-final { scan-assembler-times "fmul\\tv\[0-9\]+\.2d, v\[0-9\]+\.2d, v\[0-9\]+\.d\\\[\[0-9\]+\\\]" 3 } } */
 
-/* { dg-final { cleanup-saved-temps } } */
 
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/fp16/f16_convs_1.c
@@ -0,0 +1,34 @@
+/* { dg-do run } */
+/* { dg-options "-O2" } */
+/* { dg-additional-options "-mfp16-format=ieee" {target "arm*-*-*"} } */
+
+extern void abort (void);
+
+#define EPSILON 0.0001
+
+int
+main (int argc, char **argv)
+{
+  float f1 = 3.14159f;
+  float f2 = 2.718f;
+  /* This 'assembler' statement should be portable between ARM and AArch64.  */
+  asm volatile ("" : : : "memory");
+  __fp16 in1 = f1;
+  __fp16 in2 = f2;
+
+  /* Do the addition on __fp16's (implicitly converts both operands to
+     float32, adds, converts back to f16, then we convert back to f32).  */
+  __fp16 res1 = in1 + in2;
+  asm volatile ("" : : : "memory");
+  float f_res_1 = res1;
+
+  /* Do the addition on float32's (we convert both operands to f32, and add,
+     as above, but skip the final conversion f32 -> f16 -> f32).  */
+  float f1a = in1;
+  float f2a = in2;
+  float f_res_2 = f1a + f2a;
+
+  if (__builtin_fabs (f_res_2 - f_res_1) > EPSILON)
+    abort ();
+  return 0;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/fp16/f16_convs_2.c
@@ -0,0 +1,33 @@
+/* { dg-do run } */
+/* { dg-options "-O2" } */
+/* { dg-additional-options "-mfp16-format=ieee" {target "arm*-*-*"} } */
+
+extern void abort (void);
+
+#define EPSILON 0.0001
+
+int
+main (int argc, char **argv)
+{
+  int i1 = 3;
+  int i2 = 2;
+  /*  This 'assembler' should be portable across ARM and AArch64.  */
+  asm volatile ("" : : : "memory");
+
+  __fp16 in1 = i1;
+  __fp16 in2 = i2;
+
+  /* Do the addition on __fp16's (implicitly converts both operands to
+     float32, adds, converts back to f16, then we convert to int).  */
+  __fp16 res1 = in1 + in2;
+  asm volatile ("" : : : "memory");
+  int result1 = res1;
+
+  /* Do the addition on int's (we convert both operands directly to int, add,
+     and we're done).  */
+  int result2 = ((int) in1) + ((int) in2);
+
+  if (__builtin_abs (result2 - result1) > EPSILON)
+    abort ();
+  return 0;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/fp16/fp16.exp
@@ -0,0 +1,43 @@
+# Tests of 16-bit floating point (__fp16), for both ARM and AArch64.
+# Copyright (C) 2015 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+# GCC testsuite that uses the `dg.exp' driver.
+
+# Exit immediately if this isn't an ARM or AArch64 target.
+if {![istarget arm*-*-*]
+    && ![istarget aarch64*-*-*]} then {
+  return
+}
+
+# Load support procs.
+load_lib gcc-dg.exp
+
+# If a testcase doesn't have special options, use these.
+global DEFAULT_CFLAGS
+if ![info exists DEFAULT_CFLAGS] then {
+    set DEFAULT_CFLAGS " -ansi -pedantic-errors"
+}
+
+# Initialize `dg'.
+dg-init
+
+# Main loop.
+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.\[cC\]]] \
+	"" $DEFAULT_CFLAGS
+
+# All done.
+dg-finish
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/fpcr_fpsr_1.c
@@ -0,0 +1,26 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+void
+f1 (int *x)
+{
+  __builtin_aarch64_set_fpsr (*x);
+}
+
+void
+f2 (int *x)
+{
+  __builtin_aarch64_set_fpcr (*x);
+}
+
+void
+f3 (int *x)
+{
+  *x = __builtin_aarch64_get_fpsr ();
+}
+
+void
+f4 (int *x)
+{
+  *x = __builtin_aarch64_get_fpcr ();
+}
--- a/src/gcc/testsuite/gcc.target/aarch64/insv_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/insv_1.c
@@ -82,4 +82,3 @@ main (int argc, char** argv)
   return 0;
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/insv_2.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/insv_2.c
@@ -82,4 +82,3 @@ main (int argc, char** argv)
   return 0;
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/ldp_vec_64_1.c
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+/* { dg-options "-Ofast" } */
+
+typedef int int32x2_t __attribute__ ((__vector_size__ ((8))));
+
+void
+foo (int32x2_t *foo, int32x2_t *bar)
+{
+  int i = 0;
+  int32x2_t val = { 3, 2 };
+
+  for (i = 0; i < 1024; i+=2)
+    foo[i] = bar[i] + bar[i + 1];
+}
+
+/* { dg-final { scan-assembler "ldp\td\[0-9\]+, d\[0-9\]" } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/legitimize_stack_var_before_reload_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/legitimize_stack_var_before_reload_1.c
@@ -18,4 +18,3 @@ test15 (void)
 
 /* { dg-final { scan-rtl-dump "\\(mem\[^\\n\]*\\(plus\[^\\n\]*virtual-stack-vars" "expand" } } */
 
-/* { dg-final { cleanup-rtl-dump "expand" } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/lr_free_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/lr_free_1.c
@@ -35,4 +35,3 @@ main (int argc, char **argv)
 /* { dg-final { scan-assembler "ldr\tw30, \\\[sp, \[0-9\]+\\\]" } } */
 /* { dg-final { scan-assembler-times "ldr\tx30, \\\[sp\\\], \[0-9\]+" 2 } } */
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/lr_free_2.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/lr_free_2.c
@@ -25,5 +25,3 @@ main (int argc, char **argv)
   return 0;
 }
 
-/* { dg-final { cleanup-saved-temps } } */
-/* { dg-final { cleanup-rtl-dump "ira" } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/mgeneral-regs_1.c
@@ -0,0 +1,10 @@
+/* { dg-options "-mgeneral-regs-only" } */
+
+typedef int int32x2_t __attribute__ ((__vector_size__ ((8))));
+
+/* { dg-error "'-mgeneral-regs-only' is incompatible with vector return type" "" {target "aarch64*-*-*"} 7 } */
+/* { dg-error "'-mgeneral-regs-only' is incompatible with vector argument" "" {target "aarch64*-*-*"} 7 } */
+int32x2_t test (int32x2_t a, int32x2_t b)
+{
+  return a + b;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/mgeneral-regs_2.c
@@ -0,0 +1,15 @@
+/* { dg-options "-mgeneral-regs-only" } */
+
+#include <stdarg.h>
+
+typedef int int32x2_t __attribute__ ((__vector_size__ ((8))));
+
+int
+test (int i, ...)
+{
+  va_list argp;
+  va_start (argp, i);
+  int32x2_t x = (int32x2_t) {0, 1};
+  x += va_arg (argp, int32x2_t); /* { dg-error "'-mgeneral-regs-only' is incompatible with vector varargs" } */
+  return x[0] + x[1];
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/mgeneral-regs_3.c
@@ -0,0 +1,11 @@
+/* { dg-options "-mgeneral-regs-only -O2" } */
+
+extern void abort (void);
+
+int
+test (int i, ...)
+{
+  float f = (float) i; /* { dg-error "'-mgeneral-regs-only' is incompatible with floating-point code" } */
+  if (f != f) abort ();
+  return 2;
+}
--- a/src/gcc/testsuite/gcc.target/aarch64/mla_intrinsic_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/mla_intrinsic_1.c
@@ -80,5 +80,4 @@ main (int argc, char **argv)
 
 /* { dg-final { scan-assembler-times "mla\\tv\[0-9\]+\.4s, v\[0-9\]+\.4s, v\[0-9\]+\.4s\\\[\[0-9\]+\\\]" 4 } } */
 /* { dg-final { scan-assembler-times "mla\\tv\[0-9\]+\.8h, v\[0-9\]+\.8h, v\[0-9\]+\.8h\\\[\[0-9\]+\\\]" 4 } } */
-/* { dg-final { cleanup-saved-temps } } */
 
--- a/src/gcc/testsuite/gcc.target/aarch64/mls_intrinsic_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/mls_intrinsic_1.c
@@ -85,5 +85,4 @@ main (int argc, char **argv)
 
 /* { dg-final { scan-assembler-times "mls\\tv\[0-9\]+\.4s, v\[0-9\]+\.4s, v\[0-9\]+\.4s\\\[\[0-9\]+\\\]" 4 } } */
 /* { dg-final { scan-assembler-times "mls\\tv\[0-9\]+\.8h, v\[0-9\]+\.8h, v\[0-9\]+\.8h\\\[\[0-9\]+\\\]" 4 } } */
-/* { dg-final { cleanup-saved-temps } } */
 
--- a/src/gcc/testsuite/gcc.target/aarch64/movk.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/movk.c
@@ -28,4 +28,3 @@ main (void)
   return 0;
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/mul_intrinsic_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/mul_intrinsic_1.c
@@ -79,5 +79,4 @@ main (int argc, char **argv)
 
 /* { dg-final { scan-assembler-times "mul\\tv\[0-9\]+\.4s, v\[0-9\]+\.4s, v\[0-9\]+\.s\\\[\[0-9\]+\\\]" 4 } } */
 /* { dg-final { scan-assembler-times "mul\\tv\[0-9\]+\.8h, v\[0-9\]+\.8h, v\[0-9\]+\.h\\\[\[0-9\]+\\\]" 4 } } */
-/* { dg-final { cleanup-saved-temps } } */
 
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/mult-synth_1.c
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -mcpu=cortex-a57 -save-temps" } */
+
+int
+foo (int x)
+{
+  return x * 100;
+}
+
+/* { dg-final { scan-assembler-times "mul\tw\[0-9\]+, w\[0-9\]+, w\[0-9\]+" 1 } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/mult-synth_2.c
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -mcpu=cortex-a57 -save-temps" } */
+
+int
+foo (int x)
+{
+  return x * 25;
+}
+
+/* { dg-final { scan-assembler-times "mul\tw\[0-9\]+, w\[0-9\]+, w\[0-9\]+" 1 } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/mult-synth_3.c
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -mcpu=cortex-a57 -save-temps" } */
+
+int
+foo (int x)
+{
+  return x * 11;
+}
+
+/* { dg-final { scan-assembler-times "mul\tw\[0-9\]+, w\[0-9\]+, w\[0-9\]+" 1 } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/mult-synth_4.c
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -mcpu=cortex-a57 -save-temps" } */
+
+long
+foo (int x, int y)
+{
+   return (long)x * 6L;
+}
+
+/* { dg-final { scan-assembler-times "smull\tx\[0-9\]+, w\[0-9\]+, w\[0-9\]+" 1 } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/mult-synth_5.c
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -mcpu=cortex-a57 -save-temps" } */
+
+int
+foo (int x)
+{
+  return x * 10;
+}
+
+/* { dg-final { scan-assembler-not "\tw1" } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/mult-synth_6.c
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -mcpu=cortex-a57 -save-temps" } */
+
+int
+foo (int x)
+{
+  return x * 20;
+}
+
+/* { dg-final { scan-assembler-not "\tw1" } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/neg_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/neg_1.c
@@ -64,4 +64,3 @@ main (void)
   return 0;
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/neg_abs_1.c
@@ -0,0 +1,17 @@
+/* { dg-do compile } */
+/* { dg-options "-save-temps -O2" } */
+
+int
+f1 (int x)
+{
+  return x < 0 ? x : -x;
+}
+
+long long
+f2 (long long x)
+{
+  return x < 0 ? x : -x;
+}
+
+/* { dg-final { scan-assembler-not "\tneg\tw\[0-9\]*.*" } } */
+/* { dg-final { scan-assembler-not "\tneg\tx\[0-9\]*.*" } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/ngc.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/ngc.c
@@ -63,4 +63,3 @@ main ()
 
 /* { dg-final { scan-assembler-times "ngc\tw\[0-9\]+, w\[0-9\]+" 2 } } */
 /* { dg-final { scan-assembler-times "ngc\tx\[0-9\]+, x\[0-9\]+" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/nofp_1.c
@@ -0,0 +1,19 @@
+/* { dg-skip-if "conflicting -march" { *-*-* } { "-march=*" } { "-march=*+nofp" } } */
+/* If there are multiple -march's, the latest wins; skip the test either way.
+   -march overrides -mcpu, so there is no possibility of conflict.  */
+
+/* { dg-options "-march=armv8-a+nofp" } */
+
+#include <stdarg.h>
+
+typedef int int32x2_t __attribute__ ((__vector_size__ ((8))));
+
+int test (int i, ...);
+
+int
+main (int argc, char **argv)
+{
+  int32x2_t a = (int32x2_t) {0, 1};
+  int32x2_t b = (int32x2_t) {2, 3};
+  return test (2, a, b); /* { dg-error "'\\+nofp' feature modifier is incompatible with vector argument" } */
+}
--- a/src/gcc/testsuite/gcc.target/aarch64/pmull_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/pmull_1.c
@@ -20,4 +20,3 @@ test_vmull_high_p64 (poly64x2_t a, poly64x2_t b)
 
 /* { dg-final { scan-assembler-times "pmull2\\tv" 1 } } */
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/pr60580_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/pr60580_1.c
@@ -42,4 +42,3 @@ func3 (void)
 
 /* { dg-final { scan-assembler-times "stp\tx29, x30, \\\[sp, -\[0-9\]+\\\]!" 1 } } */
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/pr64304.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/pr64304.c
@@ -15,4 +15,3 @@ set_bit (unsigned int bit, unsigned char value)
   /* { dg-final { scan-assembler "and\tw\[0-9\]+, w\[0-9\]+, 7" } } */
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/pr65491_1.c
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+typedef long double a __attribute__((vector_size (16)));
+
+a
+sum (a first, a second)
+{
+  return first + second;
+}
+
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/pr66776.c
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 --save-temps" } */
+
+unsigned long long
+foo (unsigned int a, unsigned int b, unsigned int c)
+{
+  return a ? b : c;
+}
+
+/* { dg-final { scan-assembler-not "uxtw" } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/pragma_cpp_predefs_1.c
@@ -0,0 +1,255 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -march=armv8-a+crypto" } */
+
+/* Test that pragma option pushing and popping works.
+   Also that CPP predefines redefinitions on #pragma works.  */
+
+#pragma GCC push_options
+#pragma GCC target ("arch=armv8-a+nofp+nosimd")
+#ifdef __ARM_FEATURE_FMA
+#error "__ARM_FEATURE_FMA is defined but should not be!"
+#endif
+
+#ifdef __ARM_FP
+#error "__ARM_FP is defined but should not be!"
+#endif
+
+#pragma GCC push_options
+#pragma GCC target ("arch=armv8-a+fp+nosimd")
+#ifndef __ARM_FP
+#error "__ARM_FP is not defined but should be!"
+#endif
+
+#ifdef __ARM_NEON
+#error "__ARM_NEON is defined but should not be!"
+#endif
+
+#pragma GCC push_options
+#pragma GCC target ("arch=armv8-a+fp+simd")
+
+#ifndef __ARM_NEON
+#error "__ARM_NEON is not defined but should be!"
+#endif
+
+#ifdef __ARM_FEATURE_CRYPTO
+#error "__ARM_FEATURE_CRYPTO is defined but should not be!"
+#endif
+
+#pragma GCC push_options
+#pragma GCC target ("arch=armv8-a+fp+simd+crypto")
+
+#ifndef __ARM_FEATURE_CRYPTO
+#error "__ARM_FEATURE_CRYPTO is not defined but should be!"
+#endif
+
+#pragma GCC pop_options
+
+#ifndef __ARM_NEON
+#error "__ARM_NEON is not defined but should be!"
+#endif
+
+#ifdef __ARM_FEATURE_CRYPTO
+#error "__ARM_FEATURE_CRYPTO is defined but should not be!"
+#endif
+
+
+#pragma GCC pop_options
+
+#ifndef __ARM_FP
+#error "__ARM_FP is not defined but should be!"
+#endif
+
+#ifdef __ARM_NEON
+#error "__ARM_NEON is defined but should not be!"
+#endif
+
+#pragma GCC pop_options
+
+#ifdef __ARM_FP
+#error "__ARM_FP is defined but should not be!"
+#endif
+
+#ifdef __ARM_NEON
+#error "__ARM_NEON is defined but should not be!"
+#endif
+
+/* And again, but using cpu=.  */
+
+#pragma GCC push_options
+#pragma GCC target ("cpu=cortex-a53+nofp+nosimd")
+#ifdef __ARM_FEATURE_FMA
+#error "__ARM_FEATURE_FMA is defined but should not be!"
+#endif
+
+#ifdef __ARM_FP
+#error "__ARM_FP is defined but should not be!"
+#endif
+
+#pragma GCC push_options
+#pragma GCC target ("cpu=cortex-a53+fp+nosimd")
+#ifndef __ARM_FP
+#error "__ARM_FP is not defined but should be!"
+#endif
+
+#ifdef __ARM_NEON
+#error "__ARM_NEON is defined but should not be!"
+#endif
+
+#pragma GCC push_options
+#pragma GCC target ("cpu=cortex-a53+fp+simd+nocrypto")
+
+#ifndef __ARM_NEON
+#error "__ARM_NEON is not defined but should be!"
+#endif
+
+#ifdef __ARM_FEATURE_CRYPTO
+#error "__ARM_FEATURE_CRYPTO is defined but should not be!"
+#endif
+
+#pragma GCC push_options
+#pragma GCC target ("cpu=cortex-a53+fp+simd+crypto")
+
+#ifndef __ARM_FEATURE_CRYPTO
+#error "__ARM_FEATURE_CRYPTO is not defined but should be!"
+#endif
+
+
+#pragma GCC pop_options
+
+#ifndef __ARM_NEON
+#error "__ARM_NEON is not defined but should be!"
+#endif
+
+#ifdef __ARM_FEATURE_CRYPTO
+#error "__ARM_FEATURE_CRYPTO is defined but should not be!"
+#endif
+
+
+#pragma GCC pop_options
+
+#ifndef __ARM_FP
+#error "__ARM_FP is not defined but should be!"
+#endif
+
+#ifdef __ARM_NEON
+#error "__ARM_NEON is defined but should not be!"
+#endif
+
+#pragma GCC pop_options
+
+#ifdef __ARM_FP
+#error "__ARM_FP is defined but should not be!"
+#endif
+
+#ifdef __ARM_NEON
+#error "__ARM_NEON is defined but should not be!"
+#endif
+
+/* And again, but using just the ISA extensions.  */
+
+#pragma GCC push_options
+#pragma GCC target ("+nofp")
+#ifdef __ARM_FEATURE_FMA
+#error "__ARM_FEATURE_FMA is defined but should not be!"
+#endif
+
+#ifdef __ARM_FP
+#error "__ARM_FP is defined but should not be!"
+#endif
+
+#pragma GCC push_options
+#pragma GCC target ("+fp+nosimd")
+#ifndef __ARM_FP
+#error "__ARM_FP is not defined but should be!"
+#endif
+
+#ifdef __ARM_NEON
+#error "__ARM_NEON is defined but should not be!"
+#endif
+
+#pragma GCC push_options
+#pragma GCC target ("+fp+simd+nocrypto")
+
+#ifndef __ARM_NEON
+#error "__ARM_NEON is not defined but should be!"
+#endif
+
+#ifdef __ARM_FEATURE_CRYPTO
+#error "__ARM_FEATURE_CRYPTO is defined but should not be!"
+#endif
+
+#pragma GCC push_options
+#pragma GCC target ("+fp+simd+crypto")
+
+#ifndef __ARM_FEATURE_CRYPTO
+#error "__ARM_FEATURE_CRYPTO is not defined but should be!"
+#endif
+
+#pragma GCC pop_options
+
+#ifndef __ARM_NEON
+#error "__ARM_NEON is not defined but should be!"
+#endif
+
+#ifdef __ARM_FEATURE_CRYPTO
+#error "__ARM_FEATURE_CRYPTO is defined but should not be!"
+#endif
+
+
+#pragma GCC pop_options
+
+#ifndef __ARM_FP
+#error "__ARM_FP is not defined but should be!"
+#endif
+
+#ifdef __ARM_NEON
+#error "__ARM_NEON is defined but should not be!"
+#endif
+
+#pragma GCC pop_options
+
+#ifdef __ARM_FP
+#error "__ARM_FP is defined but should not be!"
+#endif
+
+#ifdef __ARM_NEON
+#error "__ARM_NEON is defined but should not be!"
+#endif
+
+/* Make sure that general-regs-only works too.  */
+#pragma GCC push_options
+#pragma GCC target ("general-regs-only")
+#ifdef __ARM_FEATURE_FMA
+#error "__ARM_FEATURE_FMA is defined but should not be!"
+#endif
+
+#ifdef __ARM_FP
+#error "__ARM_FP is defined but should not be!"
+#endif
+
+#ifdef __ARM_NEON
+#error "__ARM_NEON is defined but should not be!"
+#endif
+
+#ifdef __ARM_FEATURE_CRYPTO
+#error "__ARM_FEATURE_CRYPTO is defined but should not be!"
+#endif
+
+#pragma GCC pop_options
+
+/* Also check that crc re-defines work.  */
+#pragma GCC target ("+nocrc")
+#ifdef __ARM_FEATURE_CRC32
+#error "__ARM_FEATURE_CRC32 is defined but should not be!"
+#endif
+
+#pragma GCC target ("+crc")
+#ifndef __ARM_FEATURE_CRC32
+#error "__ARM_FEATURE_CRC32 is not defined but should be!"
+#endif
+
+int
+foo (int a)
+{
+  return a;
+}
--- a/src/gcc/testsuite/gcc.target/aarch64/ror.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/ror.c
@@ -31,4 +31,3 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/sbc.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/sbc.c
@@ -38,4 +38,3 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/scalar-vca.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/scalar-vca.c
@@ -69,4 +69,3 @@ main (int argc, char **argv)
   return 0;
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/scalar_shift_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/scalar_shift_1.c
@@ -258,4 +258,3 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/sha1_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/sha1_1.c
@@ -52,4 +52,3 @@ test_vsha1su1q_u32 (uint32x4_t tw0_3, uint32x4_t w12_15)
 
 /* { dg-final { scan-assembler-times "sha1su1\\tv" 1 } } */
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/sha256_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/sha256_1.c
@@ -37,4 +37,3 @@ test_vsha256su1q_u32 (uint32x4_t tw0_3, uint32x4_t w8_11, uint32x4_t w12_15)
 /* { dg-final { scan-assembler-times "sha256su1\\tv" 1 } } */
 
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/shrink_wrap_symbol_ref_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/shrink_wrap_symbol_ref_1.c
@@ -25,4 +25,3 @@ assemble_string (const char *p, int size)
 }
 
 /* { dg-final { scan-rtl-dump "Performing shrink-wrapping" "pro_and_epilogue"  } } */
-/* { dg-final { cleanup-rtl-dump "pro_and_epilogue" } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/ext_f32_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/ext_f32_1.c
@@ -7,4 +7,3 @@
 #include "ext_f32.x"
 
 /* { dg-final { scan-assembler-times "ext\[ \t\]+\[vV\]\[0-9\]+\.8\[bB\], ?\[vV\]\[0-9\]+\.8\[bB\], ?\[vV\]\[0-9\]+\.8\[bB\], ?#\[0-9\]+\(?:.4)?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/ext_f64_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/ext_f64_1.c
@@ -22,4 +22,3 @@ main (int argc, char **argv)
 
 /* Do not scan-assembler.  An EXT instruction could be emitted, but would merely
    return its first argument, so it is legitimate to optimize it out.  */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/ext_p16_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/ext_p16_1.c
@@ -7,4 +7,3 @@
 #include "ext_p16.x"
 
 /* { dg-final { scan-assembler-times "ext\[ \t\]+\[vV\]\[0-9\]+\.8\[bB\], ?\[vV\]\[0-9\]+\.8\[bB\], ?\[vV\]\[0-9\]+\.8\[bB\], ?#\[0-9\]+\(?:.2\)?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 3 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/ext_p8_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/ext_p8_1.c
@@ -7,4 +7,3 @@
 #include "ext_p8.x"
 
 /* { dg-final { scan-assembler-times "ext\[ \t\]+\[vV\]\[0-9\]+\.8\[bB\], ?\[vV\]\[0-9\]+\.8\[bB\], ?\[vV\]\[0-9\]+\.8\[bB\], ?#?\[0-9\]+\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 7 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/ext_s16_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/ext_s16_1.c
@@ -7,4 +7,3 @@
 #include "ext_s16.x"
 
 /* { dg-final { scan-assembler-times "ext\[ \t\]+\[vV\]\[0-9\]+\.8\[bB\], ?\[vV\]\[0-9\]+\.8\[bB\], ?\[vV\]\[0-9\]+\.8\[bB\], ?#\[0-9\]+\(?:.2\)?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 3 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/ext_s32_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/ext_s32_1.c
@@ -7,4 +7,3 @@
 #include "ext_s32.x"
 
 /* { dg-final { scan-assembler-times "ext\[ \t\]+\[vV\]\[0-9\]+\.8\[bB\], ?\[vV\]\[0-9\]+\.8\[bB\], ?\[vV\]\[0-9\]+\.8\[bB\], ?#\[0-9\]+\(?:.4)?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/ext_s64_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/ext_s64_1.c
@@ -23,4 +23,3 @@ main (int argc, char **argv)
 
 /* Do not scan-assembler.  An EXT instruction could be emitted, but would merely
    return its first argument, so it is legitimate to optimize it out.  */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/ext_s8_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/ext_s8_1.c
@@ -7,4 +7,3 @@
 #include "ext_s8.x"
 
 /* { dg-final { scan-assembler-times "ext\[ \t\]+\[vV\]\[0-9\]+\.8\[bB\], ?\[vV\]\[0-9\]+\.8\[bB\], ?\[vV\]\[0-9\]+\.8\[bB\], ?#?\[0-9\]+\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 7 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/ext_u16_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/ext_u16_1.c
@@ -7,4 +7,3 @@
 #include "ext_u16.x"
 
 /* { dg-final { scan-assembler-times "ext\[ \t\]+\[vV\]\[0-9\]+\.8\[bB\], ?\[vV\]\[0-9\]+\.8\[bB\], ?\[vV\]\[0-9\]+\.8\[bB\], ?#\[0-9\]+\(?:.2\)?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 3 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/ext_u32_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/ext_u32_1.c
@@ -7,4 +7,3 @@
 #include "ext_u32.x"
 
 /* { dg-final { scan-assembler-times "ext\[ \t\]+\[vV\]\[0-9\]+\.8\[bB\], ?\[vV\]\[0-9\]+\.8\[bB\], ?\[vV\]\[0-9\]+\.8\[bB\], ?#\[0-9\]+\(?:.4)?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/ext_u64_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/ext_u64_1.c
@@ -23,4 +23,3 @@ main (int argc, char **argv)
 
 /* Do not scan-assembler.  An EXT instruction could be emitted, but would merely
    return its first argument, so it is legitimate to optimize it out.  */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/ext_u8_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/ext_u8_1.c
@@ -7,4 +7,3 @@
 #include "ext_u8.x"
 
 /* { dg-final { scan-assembler-times "ext\[ \t\]+\[vV\]\[0-9\]+\.8\[bB\], ?\[vV\]\[0-9\]+\.8\[bB\], ?\[vV\]\[0-9\]+\.8\[bB\], ?#?\[0-9\]+\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 7 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/extq_f32_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/extq_f32_1.c
@@ -7,4 +7,3 @@
 #include "extq_f32.x"
 
 /* { dg-final { scan-assembler-times "ext\[ \t\]+\[vV\]\[0-9\]+\.16\[bB\], ?\[vV\]\[0-9\]+\.16\[bB\], ?\[vV\]\[0-9\]+\.16\[bB\], ?#\[0-9\]+\(?:.4)?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 3 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/extq_f64_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/extq_f64_1.c
@@ -33,4 +33,3 @@ main (int argc, char **argv)
 }
 
 /* { dg-final { scan-assembler-times "ext\[ \t\]+\[vV\]\[0-9\]+\.16\[bB\], ?\[vV\]\[0-9\]+\.16\[bB\], ?\[vV\]\[0-9\]+\.16\[bB\], ?#\[0-9\]+\(?:.8\)?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/extq_p16_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/extq_p16_1.c
@@ -7,4 +7,3 @@
 #include "extq_p16.x"
 
 /* { dg-final { scan-assembler-times "ext\[ \t\]+\[vV\]\[0-9\]+\.16\[bB\], ?\[vV\]\[0-9\]+\.16\[bB\], ?\[vV\]\[0-9\]+\.16\[bB\], ?#\[0-9\]+\(?:.2\)?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 7 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/extq_p8_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/extq_p8_1.c
@@ -7,4 +7,3 @@
 #include "extq_p8.x"
 
 /* { dg-final { scan-assembler-times "ext\[ \t\]+\[vV\]\[0-9\]+\.16\[bB\], ?\[vV\]\[0-9\]+\.16\[bB\], ?\[vV\]\[0-9\]+\.16\[bB\], ?#?\[0-9\]+\(?:.2\)?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 15 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/extq_s16_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/extq_s16_1.c
@@ -7,4 +7,3 @@
 #include "extq_s16.x"
 
 /* { dg-final { scan-assembler-times "ext\[ \t\]+\[vV\]\[0-9\]+\.16\[bB\], ?\[vV\]\[0-9\]+\.16\[bB\], ?\[vV\]\[0-9\]+\.16\[bB\], ?#\[0-9\]+\(?:.2\)?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 7 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/extq_s32_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/extq_s32_1.c
@@ -7,4 +7,3 @@
 #include "extq_s32.x"
 
 /* { dg-final { scan-assembler-times "ext\[ \t\]+\[vV\]\[0-9\]+\.16\[bB\], ?\[vV\]\[0-9\]+\.16\[bB\], ?\[vV\]\[0-9\]+\.16\[bB\], ?#\[0-9\]+\(?:.4)?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 3 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/extq_s64_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/extq_s64_1.c
@@ -7,4 +7,3 @@
 #include "extq_s64.x"
 
 /* { dg-final { scan-assembler-times "ext\[ \t\]+\[vV\]\[0-9\]+\.16\[bB\], ?\[vV\]\[0-9\]+\.16\[bB\], ?\[vV\]\[0-9\]+\.16\[bB\], ?#\[0-9\]+\(?:.8\)?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/extq_s8_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/extq_s8_1.c
@@ -7,4 +7,3 @@
 #include "extq_s8.x"
 
 /* { dg-final { scan-assembler-times "ext\[ \t\]+\[vV\]\[0-9\]+\.16\[bB\], ?\[vV\]\[0-9\]+\.16\[bB\], ?\[vV\]\[0-9\]+\.16\[bB\], ?#?\[0-9\]+\(?:.2\)?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 15 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/extq_u16_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/extq_u16_1.c
@@ -7,4 +7,3 @@
 #include "extq_u16.x"
 
 /* { dg-final { scan-assembler-times "ext\[ \t\]+\[vV\]\[0-9\]+\.16\[bB\], ?\[vV\]\[0-9\]+\.16\[bB\], ?\[vV\]\[0-9\]+\.16\[bB\], ?#\[0-9\]+\(?:.2\)?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 7 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/extq_u32_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/extq_u32_1.c
@@ -7,4 +7,3 @@
 #include "extq_u32.x"
 
 /* { dg-final { scan-assembler-times "ext\[ \t\]+\[vV\]\[0-9\]+\.16\[bB\], ?\[vV\]\[0-9\]+\.16\[bB\], ?\[vV\]\[0-9\]+\.16\[bB\], ?#\[0-9\]+\(?:.4)?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 3 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/extq_u64_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/extq_u64_1.c
@@ -7,4 +7,3 @@
 #include "extq_u64.x"
 
 /* { dg-final { scan-assembler-times "ext\[ \t\]+\[vV\]\[0-9\]+\.16\[bB\], ?\[vV\]\[0-9\]+\.16\[bB\], ?\[vV\]\[0-9\]+\.16\[bB\], ?#\[0-9\]+\(?:.8\)?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/extq_u8_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/extq_u8_1.c
@@ -7,4 +7,3 @@
 #include "extq_u8.x"
 
 /* { dg-final { scan-assembler-times "ext\[ \t\]+\[vV\]\[0-9\]+\.16\[bB\], ?\[vV\]\[0-9\]+\.16\[bB\], ?\[vV\]\[0-9\]+\.16\[bB\], ?#?\[0-9\]+\(?:.2\)?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 15 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vcage_f64.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vcage_f64.c
@@ -35,4 +35,3 @@ main (void)
 }
 
 /* { dg-final { scan-assembler "facge\[ \t\]+\[dD\]\[0-9\]+, ?\[dD\]\[0-9\]+, ?\[dD\]\[0-9\]+\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vcagt_f64.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vcagt_f64.c
@@ -35,4 +35,3 @@ main (void)
 }
 
 /* { dg-final { scan-assembler "facgt\[ \t\]+\[dD\]\[0-9\]+, ?\[dD\]\[0-9\]+, ?\[dD\]\[0-9\]+\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vcale_f64.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vcale_f64.c
@@ -35,4 +35,3 @@ main (void)
 }
 
 /* { dg-final { scan-assembler "facge\[ \t\]+\[dD\]\[0-9\]+, ?\[dD\]\[0-9\]+, ?\[dD\]\[0-9\]+\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vcaled_f64.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vcaled_f64.c
@@ -33,4 +33,3 @@ main (void)
 }
 
 /* { dg-final { scan-assembler "facge\[ \t\]+\[dD\]\[0-9\]+, ?\[dD\]\[0-9\]+, ?\[dD\]\[0-9\]+\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vcales_f32.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vcales_f32.c
@@ -33,4 +33,3 @@ main (void)
 }
 
 /* { dg-final { scan-assembler "facge\[ \t\]+\[sS\]\[0-9\]+, ?\[sS\]\[0-9\]+, ?\[sS\]\[0-9\]+\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vcalt_f64.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vcalt_f64.c
@@ -35,4 +35,3 @@ main (void)
 }
 
 /* { dg-final { scan-assembler "facgt\[ \t\]+\[dD\]\[0-9\]+, ?\[dD\]\[0-9\]+, ?\[dD\]\[0-9\]+\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vcaltd_f64.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vcaltd_f64.c
@@ -33,4 +33,3 @@ main (void)
 }
 
 /* { dg-final { scan-assembler "facgt\[ \t\]+\[dD\]\[0-9\]+, ?\[dD\]\[0-9\]+, ?\[dD\]\[0-9\]+\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vcalts_f32.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vcalts_f32.c
@@ -33,4 +33,3 @@ main (void)
 }
 
 /* { dg-final { scan-assembler "facgt\[ \t\]+\[sS\]\[0-9\]+, ?\[sS\]\[0-9\]+, ?\[sS\]\[0-9\]+\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vfma_f64.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vfma_f64.c
@@ -42,4 +42,3 @@ main (void)
 }
 
 /* { dg-final { scan-assembler-times "fmadd\[ \t\]+\[dD\]\[0-9\]+, ?\[dD\]\[0-9\]+, ?\[dD\]\[0-9\]+, ?\[dD\]\[0-9\]+\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vfms_f64.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vfms_f64.c
@@ -42,4 +42,3 @@ main (void)
 }
 
 /* { dg-final { scan-assembler-times "fmsub\[ \t\]+\[dD\]\[0-9\]+, ?\[dD\]\[0-9\]+, ?\[dD\]\[0-9\]+, ?\[dD\]\[0-9\]+\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vmul_f64_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vmul_f64_1.c
@@ -27,4 +27,3 @@ main (void)
 }
 
 /* { dg-final { scan-assembler "fmul\[ \t\]+\[dD\]\[0-9\]+, ?\[dD\]\[0-9\]+, ?\[dD\]\[0-9\]+\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vpaddd_f64.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vpaddd_f64.c
@@ -24,4 +24,3 @@ main (void)
 }
 
 /* { dg-final { scan-assembler "faddp\[ \t\]+\[dD\]\[0-9\]+, v\[0-9\].2d+\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vpaddd_s64.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vpaddd_s64.c
@@ -24,4 +24,3 @@ main (void)
 }
 
 /* { dg-final { scan-assembler "addp\[ \t\]+\[dD\]\[0-9\]+, v\[0-9\].2d+\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vpaddd_u64.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vpaddd_u64.c
@@ -24,4 +24,3 @@ main (void)
 }
 
 /* { dg-final { scan-assembler "addp\[ \t\]+\[dD\]\[0-9\]+, v\[0-9\].2d+\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmlal_high_lane_s16.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmlal_high_lane_s16.c
@@ -12,4 +12,3 @@ t_vqdmlal_high_lane_s16 (int32x4_t a, int16x8_t b, int16x4_t c)
 }
 
 /* { dg-final { scan-assembler-times "sqdmlal2\[ \t\]+\[vV\]\[0-9\]+\.4\[sS\], ?\[vV\]\[0-9\]+\.8\[hH\], ?\[vV\]\[0-9\]+\.\[hH\]\\\[0\\\]\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmlal_high_lane_s32.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmlal_high_lane_s32.c
@@ -12,4 +12,3 @@ t_vqdmlal_high_lane_s32 (int64x2_t a, int32x4_t b, int32x2_t c)
 }
 
 /* { dg-final { scan-assembler-times "sqdmlal2\[ \t\]+\[vV\]\[0-9\]+\.2\[dD\], ?\[vV\]\[0-9\]+\.4\[sS\], ?\[vV\]\[0-9\]+\.\[sS\]\\\[0\\\]\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmlal_high_laneq_s16.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmlal_high_laneq_s16.c
@@ -12,4 +12,3 @@ t_vqdmlal_high_laneq_s16 (int32x4_t a, int16x8_t b, int16x8_t c)
 }
 
 /* { dg-final { scan-assembler-times "sqdmlal2\[ \t\]+\[vV\]\[0-9\]+\.4\[sS\], ?\[vV\]\[0-9\]+\.8\[hH\], ?\[vV\]\[0-9\]+\.\[hH\]\\\[0\\\]\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmlal_high_laneq_s32.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmlal_high_laneq_s32.c
@@ -12,4 +12,3 @@ t_vqdmlal_high_laneq_s32 (int64x2_t a, int32x4_t b, int32x4_t c)
 }
 
 /* { dg-final { scan-assembler-times "sqdmlal2\[ \t\]+\[vV\]\[0-9\]+\.2\[dD\], ?\[vV\]\[0-9\]+\.4\[sS\], ?\[vV\]\[0-9\]+\.\[sS\]\\\[0\\\]\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmlal_lane_s16.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmlal_lane_s16.c
@@ -12,4 +12,3 @@ t_vqdmlal_lane_s16 (int32x4_t a, int16x4_t b, int16x4_t c)
 }
 
 /* { dg-final { scan-assembler-times "sqdmlal\[ \t\]+\[vV\]\[0-9\]+\.4\[sS\], ?\[vV\]\[0-9\]+\.4\[hH\], ?\[vV\]\[0-9\]+\.\[hH\]\\\[0\\\]\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmlal_lane_s32.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmlal_lane_s32.c
@@ -12,4 +12,3 @@ t_vqdmlal_lane_s32 (int64x2_t a, int32x2_t b, int32x2_t c)
 }
 
 /* { dg-final { scan-assembler-times "sqdmlal\[ \t\]+\[vV\]\[0-9\]+\.2\[dD\], ?\[vV\]\[0-9\]+\.2\[sS\], ?\[vV\]\[0-9\]+\.\[sS\]\\\[0\\\]\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmlal_laneq_s16.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmlal_laneq_s16.c
@@ -12,4 +12,3 @@ t_vqdmlal_laneq_s16 (int32x4_t a, int16x4_t b, int16x8_t c)
 }
 
 /* { dg-final { scan-assembler-times "sqdmlal\[ \t\]+\[vV\]\[0-9\]+\.4\[sS\], ?\[vV\]\[0-9\]+\.4\[hH\], ?\[vV\]\[0-9\]+\.\[hH\]\\\[0\\\]\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmlal_laneq_s32.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmlal_laneq_s32.c
@@ -12,4 +12,3 @@ t_vqdmlal_laneq_s32 (int64x2_t a, int32x2_t b, int32x4_t c)
 }
 
 /* { dg-final { scan-assembler-times "sqdmlal\[ \t\]+\[vV\]\[0-9\]+\.2\[dD\], ?\[vV\]\[0-9\]+\.2\[sS\], ?\[vV\]\[0-9\]+\.\[sS\]\\\[0\\\]\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmlalh_lane_s16.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmlalh_lane_s16.c
@@ -12,4 +12,3 @@ t_vqdmlalh_lane_s16 (int32_t a, int16_t b, int16x4_t c)
 }
 
 /* { dg-final { scan-assembler-times "sqdmlal\[ \t\]+\[sS\]\[0-9\]+, ?\[hH\]\[0-9\]+, ?\[vV\]\[0-9\]+\.\[hH\]\\\[0\\\]\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmlalh_laneq_s16_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmlalh_laneq_s16_1.c
@@ -32,4 +32,3 @@ main (void)
 
 
 /* { dg-final { scan-assembler-times "sqdmlal\[ \t\]+\[sS\]\[0-9\]+, ?\[hH\]\[0-9\]+, ?\[vV\]\[0-9\]+\.\[hH\]\\\[7\\\]\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmlals_lane_s32.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmlals_lane_s32.c
@@ -12,4 +12,3 @@ t_vqdmlals_lane_s32 (int64_t a, int32_t b, int32x2_t c)
 }
 
 /* { dg-final { scan-assembler-times "sqdmlal\[ \t\]+\[dD\]\[0-9\]+, ?\[sS\]\[0-9\]+, ?\[vV\]\[0-9\]+\.\[sS\]\\\[0\\\]\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmlals_laneq_s32_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmlals_laneq_s32_1.c
@@ -32,4 +32,3 @@ main (void)
 
 
 /* { dg-final { scan-assembler-times "sqdmlal\[ \t\]+\[dD\]\[0-9\]+, ?\[sS\]\[0-9\]+, ?\[vV\]\[0-9\]+\.\[sS\]\\\[3\\\]\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmlsl_high_lane_s16.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmlsl_high_lane_s16.c
@@ -12,4 +12,3 @@ t_vqdmlsl_high_lane_s16 (int32x4_t a, int16x8_t b, int16x4_t c)
 }
 
 /* { dg-final { scan-assembler-times "sqdmlsl2\[ \t\]+\[vV\]\[0-9\]+\.4\[sS\], ?\[vV\]\[0-9\]+\.8\[hH\], ?\[vV\]\[0-9\]+\.\[hH\]\\\[0\\\]\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmlsl_high_lane_s32.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmlsl_high_lane_s32.c
@@ -12,4 +12,3 @@ t_vqdmlsl_high_lane_s32 (int64x2_t a, int32x4_t b, int32x2_t c)
 }
 
 /* { dg-final { scan-assembler-times "sqdmlsl2\[ \t\]+\[vV\]\[0-9\]+\.2\[dD\], ?\[vV\]\[0-9\]+\.4\[sS\], ?\[vV\]\[0-9\]+\.\[sS\]\\\[0\\\]\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmlsl_high_laneq_s16.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmlsl_high_laneq_s16.c
@@ -12,4 +12,3 @@ t_vqdmlsl_high_laneq_s16 (int32x4_t a, int16x8_t b, int16x8_t c)
 }
 
 /* { dg-final { scan-assembler-times "sqdmlsl2\[ \t\]+\[vV\]\[0-9\]+\.4\[sS\], ?\[vV\]\[0-9\]+\.8\[hH\], ?\[vV\]\[0-9\]+\.\[hH\]\\\[0\\\]\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmlsl_high_laneq_s32.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmlsl_high_laneq_s32.c
@@ -12,4 +12,3 @@ t_vqdmlsl_high_laneq_s32 (int64x2_t a, int32x4_t b, int32x4_t c)
 }
 
 /* { dg-final { scan-assembler-times "sqdmlsl2\[ \t\]+\[vV\]\[0-9\]+\.2\[dD\], ?\[vV\]\[0-9\]+\.4\[sS\], ?\[vV\]\[0-9\]+\.\[sS\]\\\[0\\\]\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmlsl_lane_s16.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmlsl_lane_s16.c
@@ -12,4 +12,3 @@ t_vqdmlsl_lane_s16 (int32x4_t a, int16x4_t b, int16x4_t c)
 }
 
 /* { dg-final { scan-assembler-times "sqdmlsl\[ \t\]+\[vV\]\[0-9\]+\.4\[sS\], ?\[vV\]\[0-9\]+\.4\[hH\], ?\[vV\]\[0-9\]+\.\[hH\]\\\[0\\\]\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmlsl_lane_s32.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmlsl_lane_s32.c
@@ -12,4 +12,3 @@ t_vqdmlsl_lane_s32 (int64x2_t a, int32x2_t b, int32x2_t c)
 }
 
 /* { dg-final { scan-assembler-times "sqdmlsl\[ \t\]+\[vV\]\[0-9\]+\.2\[dD\], ?\[vV\]\[0-9\]+\.2\[sS\], ?\[vV\]\[0-9\]+\.\[sS\]\\\[0\\\]\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmlsl_laneq_s32.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmlsl_laneq_s32.c
@@ -12,4 +12,3 @@ t_vqdmlsl_lane_s32 (int64x2_t a, int32x2_t b, int32x4_t c)
 }
 
 /* { dg-final { scan-assembler-times "sqdmlsl\[ \t\]+\[vV\]\[0-9\]+\.2\[dD\], ?\[vV\]\[0-9\]+\.2\[sS\], ?\[vV\]\[0-9\]+\.\[sS\]\\\[0\\\]\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmlslh_lane_s16.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmlslh_lane_s16.c
@@ -12,4 +12,3 @@ t_vqdmlslh_lane_s16 (int32_t a, int16_t b, int16x4_t c)
 }
 
 /* { dg-final { scan-assembler-times "sqdmlsl\[ \t\]+\[sS\]\[0-9\]+, ?\[hH\]\[0-9\]+, ?\[vV\]\[0-9\]+\.\[hH\]\\\[0\\\]\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmlslh_laneq_s16_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmlslh_laneq_s16_1.c
@@ -32,4 +32,3 @@ main (void)
 
 
 /* { dg-final { scan-assembler-times "sqdmlsl\[ \t\]+\[sS\]\[0-9\]+, ?\[hH\]\[0-9\]+, ?\[vV\]\[0-9\]+\.\[hH\]\\\[4\\\]\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmlsls_lane_s32.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmlsls_lane_s32.c
@@ -12,4 +12,3 @@ t_vqdmlsls_lane_s32 (int64_t a, int32_t b, int32x2_t c)
 }
 
 /* { dg-final { scan-assembler-times "sqdmlsl\[ \t\]+\[dD\]\[0-9\]+, ?\[sS\]\[0-9\]+, ?\[vV\]\[0-9\]+\.\[sS\]\\\[0\\\]\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmlsls_laneq_s32_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmlsls_laneq_s32_1.c
@@ -32,4 +32,3 @@ main (void)
 }
 
 /* { dg-final { scan-assembler-times "sqdmlsl\[ \t\]+\[dD\]\[0-9\]+, ?\[sS\]\[0-9\]+, ?\[vV\]\[0-9\]+\.\[sS\]\\\[3\\\]\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmulh_laneq_s16.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmulh_laneq_s16.c
@@ -12,4 +12,3 @@ t_vqdmulh_laneq_s16 (int16x4_t a, int16x8_t b)
 }
 
 /* { dg-final { scan-assembler-times "sqdmulh\[ \t\]+\[vV\]\[0-9\]+\.4\[hH\], ?\[vV\]\[0-9\]+\.4\[hH\], ?\[vV\]\[0-9\]+\.\[hH\]\\\[0\\\]\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmulh_laneq_s32.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmulh_laneq_s32.c
@@ -12,4 +12,3 @@ t_vqdmulh_laneq_s32 (int32x2_t a, int32x4_t b)
 }
 
 /* { dg-final { scan-assembler-times "sqdmulh\[ \t\]+\[vV\]\[0-9\]+\.2\[sS\], ?\[vV\]\[0-9\]+\.2\[sS\], ?\[vV\]\[0-9\]+\.\[sS\]\\\[0\\\]\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmulhh_lane_s16.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmulhh_lane_s16.c
@@ -33,4 +33,3 @@ main (void)
 
 
 /* { dg-final { scan-assembler-times "sqdmulh\[ \t\]+\[hH\]\[0-9\]+, ?\[hH\]\[0-9\]+, ?\[vV\]\[0-9\]+\.\[hH\]\\\[2\\\]\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmulhh_laneq_s16_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmulhh_laneq_s16_1.c
@@ -30,4 +30,3 @@ main (void)
 
 
 /* { dg-final { scan-assembler-times "sqdmulh\[ \t\]+\[hH\]\[0-9\]+, ?\[hH\]\[0-9\]+, ?\[vV\]\[0-9\]+\.\[hH\]\\\[7\\\]\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmulhq_laneq_s16.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmulhq_laneq_s16.c
@@ -12,4 +12,3 @@ t_vqdmulhq_laneq_s16 (int16x8_t a, int16x8_t b)
 }
 
 /* { dg-final { scan-assembler-times "sqdmulh\[ \t\]+\[vV\]\[0-9\]+\.8\[hH\], ?\[vV\]\[0-9\]+\.8\[hH\], ?\[vV\]\[0-9\]+\.\[hH\]\\\[0\\\]\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmulhq_laneq_s32.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmulhq_laneq_s32.c
@@ -12,4 +12,3 @@ t_vqdmulhq_laneq_s32 (int32x4_t a, int32x4_t b)
 }
 
 /* { dg-final { scan-assembler-times "sqdmulh\[ \t\]+\[vV\]\[0-9\]+\.4\[sS\], ?\[vV\]\[0-9\]+\.4\[sS\], ?\[vV\]\[0-9\]+\.\[sS\]\\\[0\\\]\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmulhs_lane_s32.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmulhs_lane_s32.c
@@ -31,4 +31,3 @@ main (void)
   return 0;
 }
 /* { dg-final { scan-assembler-times "sqdmulh\[ \t\]+\[sS\]\[0-9\]+, ?\[sS\]\[0-9\]+, ?\[vV\]\[0-9\]+\.\[sS\]\\\[0\\\]\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmulhs_laneq_s32_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmulhs_laneq_s32_1.c
@@ -30,4 +30,3 @@ main (void)
 
 
 /* { dg-final { scan-assembler-times "sqdmulh\[ \t\]+\[sS\]\[0-9\]+, ?\[sS\]\[0-9\]+, ?\[vV\]\[0-9\]+\.\[sS\]\\\[3\\\]\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmull_high_lane_s16.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmull_high_lane_s16.c
@@ -12,4 +12,3 @@ t_vqdmull_high_lane_s16 (int16x8_t a, int16x4_t b)
 }
 
 /* { dg-final { scan-assembler-times "sqdmull2\[ \t\]+\[vV\]\[0-9\]+\.4\[sS\], ?\[vV\]\[0-9\]+\.8\[hH\], ?\[vV\]\[0-9\]+\.\[hH\]\\\[0\\\]\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmull_high_lane_s32.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmull_high_lane_s32.c
@@ -12,4 +12,3 @@ t_vqdmull_high_lane_s32 (int32x4_t a, int32x2_t b)
 }
 
 /* { dg-final { scan-assembler-times "sqdmull2\[ \t\]+\[vV\]\[0-9\]+\.2\[dD\], ?\[vV\]\[0-9\]+\.4\[sS\], ?\[vV\]\[0-9\]+\.\[sS\]\\\[0\\\]\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmull_high_laneq_s16.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmull_high_laneq_s16.c
@@ -12,4 +12,3 @@ t_vqdmull_high_laneq_s16 (int16x8_t a, int16x8_t b)
 }
 
 /* { dg-final { scan-assembler-times "sqdmull2\[ \t\]+\[vV\]\[0-9\]+\.4\[sS\], ?\[vV\]\[0-9\]+\.8\[hH\], ?\[vV\]\[0-9\]+\.\[hH\]\\\[0\\\]\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmull_high_laneq_s32.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmull_high_laneq_s32.c
@@ -12,4 +12,3 @@ t_vqdmull_high_laneq_s32 (int32x4_t a, int32x4_t b)
 }
 
 /* { dg-final { scan-assembler-times "sqdmull2\[ \t\]+\[vV\]\[0-9\]+\.2\[dD\], ?\[vV\]\[0-9\]+\.4\[sS\], ?\[vV\]\[0-9\]+\.\[sS\]\\\[0\\\]\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmull_lane_s16.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmull_lane_s16.c
@@ -12,4 +12,3 @@ t_vqdmull_lane_s16 (int16x4_t a, int16x4_t b)
 }
 
 /* { dg-final { scan-assembler-times "sqdmull\[ \t\]+\[vV\]\[0-9\]+\.4\[sS\], ?\[vV\]\[0-9\]+\.4\[hH\], ?\[vV\]\[0-9\]+\.\[hH\]\\\[0\\\]\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmull_lane_s32.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmull_lane_s32.c
@@ -12,4 +12,3 @@ t_vqdmull_lane_s32 (int32x2_t a, int32x2_t b)
 }
 
 /* { dg-final { scan-assembler-times "sqdmull\[ \t\]+\[vV\]\[0-9\]+\.2\[dD\], ?\[vV\]\[0-9\]+\.2\[sS\], ?\[vV\]\[0-9\]+\.\[sS\]\\\[0\\\]\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmull_laneq_s16.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmull_laneq_s16.c
@@ -12,4 +12,3 @@ t_vqdmull_laneq_s16 (int16x4_t a, int16x8_t b)
 }
 
 /* { dg-final { scan-assembler-times "sqdmull\[ \t\]+\[vV\]\[0-9\]+\.4\[sS\], ?\[vV\]\[0-9\]+\.4\[hH\], ?\[vV\]\[0-9\]+\.\[hH\]\\\[0\\\]\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmull_laneq_s32.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmull_laneq_s32.c
@@ -12,4 +12,3 @@ t_vqdmull_laneq_s32 (int32x2_t a, int32x4_t b)
 }
 
 /* { dg-final { scan-assembler-times "sqdmull\[ \t\]+\[vV\]\[0-9\]+\.2\[dD\], ?\[vV\]\[0-9\]+\.2\[sS\], ?\[vV\]\[0-9\]+\.\[sS\]\\\[0\\\]\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmullh_lane_s16.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmullh_lane_s16.c
@@ -12,4 +12,3 @@ t_vqdmullh_lane_s16 (int16_t a, int16x4_t b)
 }
 
 /* { dg-final { scan-assembler-times "sqdmull\[ \t\]+\[sS\]\[0-9\]+, ?\[hH\]\[0-9\]+, ?\[vV\]\[0-9\]+\.\[hH\]\\\[0\\\]\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmullh_laneq_s16.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmullh_laneq_s16.c
@@ -12,4 +12,3 @@ t_vqdmullh_laneq_s16 (int16_t a, int16x8_t b)
 }
 
 /* { dg-final { scan-assembler-times "sqdmull\[ \t\]+\[sS\]\[0-9\]+, ?\[hH\]\[0-9\]+, ?\[vV\]\[0-9\]+\.\[hH\]\\\[0\\\]\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmulls_lane_s32.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmulls_lane_s32.c
@@ -12,4 +12,3 @@ t_vqdmulls_lane_s32 (int32_t a, int32x2_t b)
 }
 
 /* { dg-final { scan-assembler-times "sqdmull\[ \t\]+\[dD\]\[0-9\]+, ?\[sS\]\[0-9\]+, ?\[vV\]\[0-9\]+\.\[sS\]\\\[0\\\]\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmulls_laneq_s32.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vqdmulls_laneq_s32.c
@@ -12,4 +12,3 @@ t_vqdmulls_laneq_s32 (int32_t a, int32x4_t b)
 }
 
 /* { dg-final { scan-assembler-times "sqdmull\[ \t\]+\[dD\]\[0-9\]+, ?\[sS\]\[0-9\]+, ?\[vV\]\[0-9\]+\.\[sS\]\\\[0\\\]\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vqrdmulh_laneq_s16.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vqrdmulh_laneq_s16.c
@@ -12,4 +12,3 @@ t_vqrdmulh_laneq_s16 (int16x4_t a, int16x8_t b)
 }
 
 /* { dg-final { scan-assembler-times "sqrdmulh\[ \t\]+\[vV\]\[0-9\]+\.4\[hH\], ?\[vV\]\[0-9\]+\.4\[hH\], ?\[vV\]\[0-9\]+\.\[hH\]\\\[0\\\]\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vqrdmulh_laneq_s32.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vqrdmulh_laneq_s32.c
@@ -12,4 +12,3 @@ t_vqrdmulh_laneq_s32 (int32x2_t a, int32x4_t b)
 }
 
 /* { dg-final { scan-assembler-times "sqrdmulh\[ \t\]+\[vV\]\[0-9\]+\.2\[sS\], ?\[vV\]\[0-9\]+\.2\[sS\], ?\[vV\]\[0-9\]+\.\[sS\]\\\[0\\\]\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vqrdmulhh_lane_s16.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vqrdmulhh_lane_s16.c
@@ -32,4 +32,3 @@ main (void)
 }
 
 /* { dg-final { scan-assembler-times "sqrdmulh\[ \t\]+\[hH\]\[0-9\]+, ?\[hH\]\[0-9\]+, ?\[vV\]\[0-9\]+\.\[hH\]\\\[3\\\]\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vqrdmulhh_laneq_s16_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vqrdmulhh_laneq_s16_1.c
@@ -30,4 +30,3 @@ main (void)
 
 
 /* { dg-final { scan-assembler-times "sqrdmulh\[ \t\]+\[hH\]\[0-9\]+, ?\[hH\]\[0-9\]+, ?\[vV\]\[0-9\]+\.\[hH\]\\\[7\\\]\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vqrdmulhq_laneq_s16.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vqrdmulhq_laneq_s16.c
@@ -12,4 +12,3 @@ t_vqrdmulhq_laneq_s16 (int16x8_t a, int16x8_t b)
 }
 
 /* { dg-final { scan-assembler-times "sqrdmulh\[ \t\]+\[vV\]\[0-9\]+\.8\[hH\], ?\[vV\]\[0-9\]+\.8\[hH\], ?\[vV\]\[0-9\]+\.\[hH\]\\\[0\\\]\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vqrdmulhq_laneq_s32.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vqrdmulhq_laneq_s32.c
@@ -12,4 +12,3 @@ t_vqrdmulhq_laneq_s32 (int32x4_t a, int32x4_t b)
 }
 
 /* { dg-final { scan-assembler-times "sqrdmulh\[ \t\]+\[vV\]\[0-9\]+\.4\[sS\], ?\[vV\]\[0-9\]+\.4\[sS\], ?\[vV\]\[0-9\]+\.\[sS\]\\\[0\\\]\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vqrdmulhs_lane_s32.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vqrdmulhs_lane_s32.c
@@ -32,4 +32,3 @@ main (void)
 }
 
 /* { dg-final { scan-assembler-times "sqrdmulh\[ \t\]+\[sS\]\[0-9\]+, ?\[sS\]\[0-9\]+, ?\[vV\]\[0-9\]+\.\[sS\]\\\[1\\\]\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vqrdmulhs_laneq_s32_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vqrdmulhs_laneq_s32_1.c
@@ -29,4 +29,3 @@ main (void)
 }
 
 /* { dg-final { scan-assembler-times "sqrdmulh\[ \t\]+\[sS\]\[0-9\]+, ?\[sS\]\[0-9\]+, ?\[vV\]\[0-9\]+\.\[sS\]\\\[3\\\]\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vrbit_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vrbit_1.c
@@ -53,4 +53,3 @@ main (int argc, char **argv)
 /* { dg-final { scan-assembler-times "rbit\[ \t\]+\[vV\]\[0-9\]+\.8\[bB\], ?\[vV\]\[0-9\]+\.8\[bB\]" 3 } } */
 /* { dg-final { scan-assembler-times "rbit\[ \t\]+\[vV\]\[0-9\]+\.16\[bB\], ?\[vV\]\[0-9\]+\.16\[bB\]" 3 } } */
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vrev16p8_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vrev16p8_1.c
@@ -7,4 +7,3 @@
 #include "vrev16p8.x"
 
 /* { dg-final { scan-assembler-times "rev16\[ \t\]+v\[0-9\]+.8b, ?v\[0-9\]+.8b!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vrev16qp8_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vrev16qp8_1.c
@@ -7,4 +7,3 @@
 #include "vrev16qp8.x"
 
 /* { dg-final { scan-assembler-times "rev16\[ \t\]+v\[0-9\]+.16b, ?v\[0-9\]+.16b!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vrev16qs8_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vrev16qs8_1.c
@@ -7,4 +7,3 @@
 #include "vrev16qs8.x"
 
 /* { dg-final { scan-assembler-times "rev16\[ \t\]+v\[0-9\]+.16b, ?v\[0-9\]+.16b!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vrev16qu8_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vrev16qu8_1.c
@@ -7,4 +7,3 @@
 #include "vrev16qu8.x"
 
 /* { dg-final { scan-assembler-times "rev16\[ \t\]+v\[0-9\]+.16b, ?v\[0-9\]+.16b!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vrev16s8_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vrev16s8_1.c
@@ -7,4 +7,3 @@
 #include "vrev16s8.x"
 
 /* { dg-final { scan-assembler-times "rev16\[ \t\]+v\[0-9\]+.8b, ?v\[0-9\]+.8b!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vrev16u8_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vrev16u8_1.c
@@ -7,4 +7,3 @@
 #include "vrev16u8.x"
 
 /* { dg-final { scan-assembler-times "rev16\[ \t\]+v\[0-9\]+.8b, ?v\[0-9\]+.8b!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vrev32p16_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vrev32p16_1.c
@@ -7,4 +7,3 @@
 #include "vrev32p16.x"
 
 /* { dg-final { scan-assembler-times "rev32\[ \t\]+v\[0-9\]+.4h, ?v\[0-9\]+.4h!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vrev32p8_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vrev32p8_1.c
@@ -7,4 +7,3 @@
 #include "vrev32p8.x"
 
 /* { dg-final { scan-assembler-times "rev32\[ \t\]+v\[0-9\]+.8b, ?v\[0-9\]+.8b!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vrev32qp16_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vrev32qp16_1.c
@@ -7,4 +7,3 @@
 #include "vrev32qp16.x"
 
 /* { dg-final { scan-assembler-times "rev32\[ \t\]+v\[0-9\]+.8h, ?v\[0-9\]+.8h!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vrev32qp8_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vrev32qp8_1.c
@@ -7,4 +7,3 @@
 #include "vrev32qp8.x"
 
 /* { dg-final { scan-assembler-times "rev32\[ \t\]+v\[0-9\]+.16b, ?v\[0-9\]+.16b!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vrev32qs16_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vrev32qs16_1.c
@@ -7,4 +7,3 @@
 #include "vrev32qs16.x"
 
 /* { dg-final { scan-assembler-times "rev32\[ \t\]+v\[0-9\]+.8h, ?v\[0-9\]+.8h!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vrev32qs8_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vrev32qs8_1.c
@@ -7,4 +7,3 @@
 #include "vrev32qs8.x"
 
 /* { dg-final { scan-assembler-times "rev32\[ \t\]+v\[0-9\]+.16b, ?v\[0-9\]+.16b!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vrev32qu16_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vrev32qu16_1.c
@@ -7,4 +7,3 @@
 #include "vrev32qu16.x"
 
 /* { dg-final { scan-assembler-times "rev32\[ \t\]+v\[0-9\]+.8h, ?v\[0-9\]+.8h!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vrev32qu8_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vrev32qu8_1.c
@@ -7,4 +7,3 @@
 #include "vrev32qu8.x"
 
 /* { dg-final { scan-assembler-times "rev32\[ \t\]+v\[0-9\]+.16b, ?v\[0-9\]+.16b!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vrev32s16_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vrev32s16_1.c
@@ -7,4 +7,3 @@
 #include "vrev32s16.x"
 
 /* { dg-final { scan-assembler-times "rev32\[ \t\]+v\[0-9\]+.4h, ?v\[0-9\]+.4h!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vrev32s8_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vrev32s8_1.c
@@ -7,4 +7,3 @@
 #include "vrev32s8.x"
 
 /* { dg-final { scan-assembler-times "rev32\[ \t\]+v\[0-9\]+.8b, ?v\[0-9\]+.8b!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vrev32u16_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vrev32u16_1.c
@@ -7,4 +7,3 @@
 #include "vrev32u16.x"
 
 /* { dg-final { scan-assembler-times "rev32\[ \t\]+v\[0-9\]+.4h, ?v\[0-9\]+.4h!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vrev32u8_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vrev32u8_1.c
@@ -7,4 +7,3 @@
 #include "vrev32u8.x"
 
 /* { dg-final { scan-assembler-times "rev32\[ \t\]+v\[0-9\]+.8b, ?v\[0-9\]+.8b!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vrev64f32_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vrev64f32_1.c
@@ -7,4 +7,3 @@
 #include "vrev64f32.x"
 
 /* { dg-final { scan-assembler-times "rev64\[ \t\]+v\[0-9\]+.2s, ?v\[0-9\]+.2s!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vrev64p16_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vrev64p16_1.c
@@ -7,4 +7,3 @@
 #include "vrev64p16.x"
 
 /* { dg-final { scan-assembler-times "rev64\[ \t\]+v\[0-9\]+.4h, ?v\[0-9\]+.4h!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vrev64p8_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vrev64p8_1.c
@@ -7,4 +7,3 @@
 #include "vrev64p8.x"
 
 /* { dg-final { scan-assembler-times "rev64\[ \t\]+v\[0-9\]+.8b, ?v\[0-9\]+.8b!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vrev64qf32_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vrev64qf32_1.c
@@ -7,4 +7,3 @@
 #include "vrev64qf32.x"
 
 /* { dg-final { scan-assembler-times "rev64\[ \t\]+v\[0-9\]+.4s, ?v\[0-9\]+.4s!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vrev64qp16_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vrev64qp16_1.c
@@ -7,4 +7,3 @@
 #include "vrev64qp16.x"
 
 /* { dg-final { scan-assembler-times "rev64\[ \t\]+v\[0-9\]+.8h, ?v\[0-9\]+.8h!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vrev64qp8_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vrev64qp8_1.c
@@ -7,4 +7,3 @@
 #include "vrev64qp8.x"
 
 /* { dg-final { scan-assembler-times "rev64\[ \t\]+v\[0-9\]+.16b, ?v\[0-9\]+.16b!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vrev64qs16_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vrev64qs16_1.c
@@ -7,4 +7,3 @@
 #include "vrev64qs16.x"
 
 /* { dg-final { scan-assembler-times "rev64\[ \t\]+v\[0-9\]+.8h, ?v\[0-9\]+.8h!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vrev64qs32_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vrev64qs32_1.c
@@ -7,4 +7,3 @@
 #include "vrev64qs32.x"
 
 /* { dg-final { scan-assembler-times "rev64\[ \t\]+v\[0-9\]+.4s, ?v\[0-9\]+.4s!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vrev64qs8_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vrev64qs8_1.c
@@ -7,4 +7,3 @@
 #include "vrev64qs8.x"
 
 /* { dg-final { scan-assembler-times "rev64\[ \t\]+v\[0-9\]+.16b, ?v\[0-9\]+.16b!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vrev64qu16_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vrev64qu16_1.c
@@ -7,4 +7,3 @@
 #include "vrev64qu16.x"
 
 /* { dg-final { scan-assembler-times "rev64\[ \t\]+v\[0-9\]+.8h, ?v\[0-9\]+.8h!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vrev64qu32_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vrev64qu32_1.c
@@ -7,4 +7,3 @@
 #include "vrev64qu32.x"
 
 /* { dg-final { scan-assembler-times "rev64\[ \t\]+v\[0-9\]+.4s, ?v\[0-9\]+.4s!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vrev64qu8_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vrev64qu8_1.c
@@ -7,4 +7,3 @@
 #include "vrev64qu8.x"
 
 /* { dg-final { scan-assembler-times "rev64\[ \t\]+v\[0-9\]+.16b, ?v\[0-9\]+.16b!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vrev64s16_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vrev64s16_1.c
@@ -7,4 +7,3 @@
 #include "vrev64s16.x"
 
 /* { dg-final { scan-assembler-times "rev64\[ \t\]+v\[0-9\]+.4h, ?v\[0-9\]+.4h!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vrev64s32_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vrev64s32_1.c
@@ -7,4 +7,3 @@
 #include "vrev64s32.x"
 
 /* { dg-final { scan-assembler-times "rev64\[ \t\]+v\[0-9\]+.2s, ?v\[0-9\]+.2s!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vrev64s8_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vrev64s8_1.c
@@ -7,4 +7,3 @@
 #include "vrev64s8.x"
 
 /* { dg-final { scan-assembler-times "rev64\[ \t\]+v\[0-9\]+.8b, ?v\[0-9\]+.8b!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vrev64u16_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vrev64u16_1.c
@@ -7,4 +7,3 @@
 #include "vrev64u16.x"
 
 /* { dg-final { scan-assembler-times "rev64\[ \t\]+v\[0-9\]+.4h, ?v\[0-9\]+.4h!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vrev64u32_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vrev64u32_1.c
@@ -7,4 +7,3 @@
 #include "vrev64u32.x"
 
 /* { dg-final { scan-assembler-times "rev64\[ \t\]+v\[0-9\]+.2s, ?v\[0-9\]+.2s!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vrev64u8_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vrev64u8_1.c
@@ -7,4 +7,3 @@
 #include "vrev64u8.x"
 
 /* { dg-final { scan-assembler-times "rev64\[ \t\]+v\[0-9\]+.8b, ?v\[0-9\]+.8b!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vsqrt_f64_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vsqrt_f64_1.c
@@ -22,4 +22,3 @@ main (void)
 }
 
 /* { dg-final { scan-assembler "fsqrt\[ \t\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vtrnf32_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vtrnf32_1.c
@@ -8,4 +8,3 @@
 
 /* { dg-final { scan-assembler-times "zip1\[ \t\]+v\[0-9\]+\.2s, ?v\[0-9\]+\.2s, ?v\[0-9\]+\.2s!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
 /* { dg-final { scan-assembler-times "zip2\[ \t\]+v\[0-9\]+\.2s, ?v\[0-9\]+\.2s, ?v\[0-9\]+\.2s!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vtrnp16_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vtrnp16_1.c
@@ -8,4 +8,3 @@
 
 /* { dg-final { scan-assembler-times "trn1\[ \t\]+v\[0-9\]+\.4h, ?v\[0-9\]+\.4h, ?v\[0-9\]+\.4h!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
 /* { dg-final { scan-assembler-times "trn2\[ \t\]+v\[0-9\]+\.4h, ?v\[0-9\]+\.4h, ?v\[0-9\]+\.4h!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vtrnp8_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vtrnp8_1.c
@@ -8,4 +8,3 @@
 
 /* { dg-final { scan-assembler-times "trn1\[ \t\]+v\[0-9\]+\.8b, ?v\[0-9\]+\.8b, ?v\[0-9\]+\.8b!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
 /* { dg-final { scan-assembler-times "trn2\[ \t\]+v\[0-9\]+\.8b, ?v\[0-9\]+\.8b, ?v\[0-9\]+\.8b!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vtrnqf32_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vtrnqf32_1.c
@@ -8,4 +8,3 @@
 
 /* { dg-final { scan-assembler-times "trn1\[ \t\]+v\[0-9\]+\.4s, ?v\[0-9\]+\.4s, ?v\[0-9\]+\.4s!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
 /* { dg-final { scan-assembler-times "trn2\[ \t\]+v\[0-9\]+\.4s, ?v\[0-9\]+\.4s, ?v\[0-9\]+\.4s!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vtrnqp16_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vtrnqp16_1.c
@@ -8,4 +8,3 @@
 
 /* { dg-final { scan-assembler-times "trn1\[ \t\]+v\[0-9\]+\.8h, ?v\[0-9\]+\.8h, ?v\[0-9\]+\.8h!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
 /* { dg-final { scan-assembler-times "trn2\[ \t\]+v\[0-9\]+\.8h, ?v\[0-9\]+\.8h, ?v\[0-9\]+\.8h!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vtrnqp8_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vtrnqp8_1.c
@@ -8,4 +8,3 @@
 
 /* { dg-final { scan-assembler-times "trn1\[ \t\]+v\[0-9\]+\.16b, ?v\[0-9\]+\.16b, ?v\[0-9\]+\.16b!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
 /* { dg-final { scan-assembler-times "trn2\[ \t\]+v\[0-9\]+\.16b, ?v\[0-9\]+\.16b, ?v\[0-9\]+\.16b!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vtrnqs16_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vtrnqs16_1.c
@@ -8,4 +8,3 @@
 
 /* { dg-final { scan-assembler-times "trn1\[ \t\]+v\[0-9\]+\.8h, ?v\[0-9\]+\.8h, ?v\[0-9\]+\.8h!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
 /* { dg-final { scan-assembler-times "trn2\[ \t\]+v\[0-9\]+\.8h, ?v\[0-9\]+\.8h, ?v\[0-9\]+\.8h!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vtrnqs32_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vtrnqs32_1.c
@@ -8,4 +8,3 @@
 
 /* { dg-final { scan-assembler-times "trn1\[ \t\]+v\[0-9\]+\.4s, ?v\[0-9\]+\.4s, ?v\[0-9\]+\.4s!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
 /* { dg-final { scan-assembler-times "trn2\[ \t\]+v\[0-9\]+\.4s, ?v\[0-9\]+\.4s, ?v\[0-9\]+\.4s!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vtrnqs8_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vtrnqs8_1.c
@@ -8,4 +8,3 @@
 
 /* { dg-final { scan-assembler-times "trn1\[ \t\]+v\[0-9\]+\.16b, ?v\[0-9\]+\.16b, ?v\[0-9\]+\.16b!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
 /* { dg-final { scan-assembler-times "trn2\[ \t\]+v\[0-9\]+\.16b, ?v\[0-9\]+\.16b, ?v\[0-9\]+\.16b!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vtrnqu16_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vtrnqu16_1.c
@@ -8,4 +8,3 @@
 
 /* { dg-final { scan-assembler-times "trn1\[ \t\]+v\[0-9\]+\.8h, ?v\[0-9\]+\.8h, ?v\[0-9\]+\.8h!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
 /* { dg-final { scan-assembler-times "trn2\[ \t\]+v\[0-9\]+\.8h, ?v\[0-9\]+\.8h, ?v\[0-9\]+\.8h!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vtrnqu32_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vtrnqu32_1.c
@@ -8,4 +8,3 @@
 
 /* { dg-final { scan-assembler-times "trn1\[ \t\]+v\[0-9\]+\.4s, ?v\[0-9\]+\.4s, ?v\[0-9\]+\.4s!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
 /* { dg-final { scan-assembler-times "trn2\[ \t\]+v\[0-9\]+\.4s, ?v\[0-9\]+\.4s, ?v\[0-9\]+\.4s!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vtrnqu8_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vtrnqu8_1.c
@@ -8,4 +8,3 @@
 
 /* { dg-final { scan-assembler-times "trn1\[ \t\]+v\[0-9\]+\.16b, ?v\[0-9\]+\.16b, ?v\[0-9\]+\.16b!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
 /* { dg-final { scan-assembler-times "trn2\[ \t\]+v\[0-9\]+\.16b, ?v\[0-9\]+\.16b, ?v\[0-9\]+\.16b!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vtrns16_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vtrns16_1.c
@@ -8,4 +8,3 @@
 
 /* { dg-final { scan-assembler-times "trn1\[ \t\]+v\[0-9\]+\.4h, ?v\[0-9\]+\.4h, ?v\[0-9\]+\.4h!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
 /* { dg-final { scan-assembler-times "trn2\[ \t\]+v\[0-9\]+\.4h, ?v\[0-9\]+\.4h, ?v\[0-9\]+\.4h!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vtrns32_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vtrns32_1.c
@@ -8,4 +8,3 @@
 
 /* { dg-final { scan-assembler-times "zip1\[ \t\]+v\[0-9\]+\.2s, ?v\[0-9\]+\.2s, ?v\[0-9\]+\.2s!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
 /* { dg-final { scan-assembler-times "zip2\[ \t\]+v\[0-9\]+\.2s, ?v\[0-9\]+\.2s, ?v\[0-9\]+\.2s!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vtrns8_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vtrns8_1.c
@@ -8,4 +8,3 @@
 
 /* { dg-final { scan-assembler-times "trn1\[ \t\]+v\[0-9\]+\.8b, ?v\[0-9\]+\.8b, ?v\[0-9\]+\.8b!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
 /* { dg-final { scan-assembler-times "trn2\[ \t\]+v\[0-9\]+\.8b, ?v\[0-9\]+\.8b, ?v\[0-9\]+\.8b!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vtrnu16_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vtrnu16_1.c
@@ -8,4 +8,3 @@
 
 /* { dg-final { scan-assembler-times "trn1\[ \t\]+v\[0-9\]+\.4h, ?v\[0-9\]+\.4h, ?v\[0-9\]+\.4h!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
 /* { dg-final { scan-assembler-times "trn2\[ \t\]+v\[0-9\]+\.4h, ?v\[0-9\]+\.4h, ?v\[0-9\]+\.4h!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vtrnu32_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vtrnu32_1.c
@@ -8,4 +8,3 @@
 
 /* { dg-final { scan-assembler-times "zip1\[ \t\]+v\[0-9\]+\.2s, ?v\[0-9\]+\.2s, ?v\[0-9\]+\.2s!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
 /* { dg-final { scan-assembler-times "zip2\[ \t\]+v\[0-9\]+\.2s, ?v\[0-9\]+\.2s, ?v\[0-9\]+\.2s!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vtrnu8_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vtrnu8_1.c
@@ -8,4 +8,3 @@
 
 /* { dg-final { scan-assembler-times "trn1\[ \t\]+v\[0-9\]+\.8b, ?v\[0-9\]+\.8b, ?v\[0-9\]+\.8b!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
 /* { dg-final { scan-assembler-times "trn2\[ \t\]+v\[0-9\]+\.8b, ?v\[0-9\]+\.8b, ?v\[0-9\]+\.8b!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vuzpf32_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vuzpf32_1.c
@@ -8,4 +8,3 @@
 
 /* { dg-final { scan-assembler-times "zip1\[ \t\]+v\[0-9\]+\.2s, ?v\[0-9\]+\.2s, ?v\[0-9\]+\.2s!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
 /* { dg-final { scan-assembler-times "zip2\[ \t\]+v\[0-9\]+\.2s, ?v\[0-9\]+\.2s, ?v\[0-9\]+\.2s!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vuzpp16_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vuzpp16_1.c
@@ -8,4 +8,3 @@
 
 /* { dg-final { scan-assembler-times "uzp1\[ \t\]+v\[0-9\]+\.4h, ?v\[0-9\]+\.4h, ?v\[0-9\]+\.4h!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
 /* { dg-final { scan-assembler-times "uzp2\[ \t\]+v\[0-9\]+\.4h, ?v\[0-9\]+\.4h, ?v\[0-9\]+\.4h!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vuzpp8_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vuzpp8_1.c
@@ -8,4 +8,3 @@
 
 /* { dg-final { scan-assembler-times "uzp1\[ \t\]+v\[0-9\]+\.8b, ?v\[0-9\]+\.8b, ?v\[0-9\]+\.8b!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
 /* { dg-final { scan-assembler-times "uzp2\[ \t\]+v\[0-9\]+\.8b, ?v\[0-9\]+\.8b, ?v\[0-9\]+\.8b!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vuzpqf32_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vuzpqf32_1.c
@@ -8,4 +8,3 @@
 
 /* { dg-final { scan-assembler-times "uzp1\[ \t\]+v\[0-9\]+\.4s, ?v\[0-9\]+\.4s, ?v\[0-9\]+\.4s!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
 /* { dg-final { scan-assembler-times "uzp2\[ \t\]+v\[0-9\]+\.4s, ?v\[0-9\]+\.4s, ?v\[0-9\]+\.4s!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vuzpqp16_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vuzpqp16_1.c
@@ -8,4 +8,3 @@
 
 /* { dg-final { scan-assembler-times "uzp1\[ \t\]+v\[0-9\]+\.8h, ?v\[0-9\]+\.8h, ?v\[0-9\]+\.8h!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
 /* { dg-final { scan-assembler-times "uzp2\[ \t\]+v\[0-9\]+\.8h, ?v\[0-9\]+\.8h, ?v\[0-9\]+\.8h!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vuzpqp8_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vuzpqp8_1.c
@@ -8,4 +8,3 @@
 
 /* { dg-final { scan-assembler-times "uzp1\[ \t\]+v\[0-9\]+\.16b, ?v\[0-9\]+\.16b, ?v\[0-9\]+\.16b!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
 /* { dg-final { scan-assembler-times "uzp2\[ \t\]+v\[0-9\]+\.16b, ?v\[0-9\]+\.16b, ?v\[0-9\]+\.16b!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vuzpqs16_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vuzpqs16_1.c
@@ -8,4 +8,3 @@
 
 /* { dg-final { scan-assembler-times "uzp1\[ \t\]+v\[0-9\]+\.8h, ?v\[0-9\]+\.8h, ?v\[0-9\]+\.8h!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
 /* { dg-final { scan-assembler-times "uzp2\[ \t\]+v\[0-9\]+\.8h, ?v\[0-9\]+\.8h, ?v\[0-9\]+\.8h!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vuzpqs32_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vuzpqs32_1.c
@@ -8,4 +8,3 @@
 
 /* { dg-final { scan-assembler-times "uzp1\[ \t\]+v\[0-9\]+\.4s, ?v\[0-9\]+\.4s, ?v\[0-9\]+\.4s!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
 /* { dg-final { scan-assembler-times "uzp2\[ \t\]+v\[0-9\]+\.4s, ?v\[0-9\]+\.4s, ?v\[0-9\]+\.4s!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vuzpqs8_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vuzpqs8_1.c
@@ -8,4 +8,3 @@
 
 /* { dg-final { scan-assembler-times "uzp1\[ \t\]+v\[0-9\]+\.16b, ?v\[0-9\]+\.16b, ?v\[0-9\]+\.16b!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
 /* { dg-final { scan-assembler-times "uzp2\[ \t\]+v\[0-9\]+\.16b, ?v\[0-9\]+\.16b, ?v\[0-9\]+\.16b!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vuzpqu16_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vuzpqu16_1.c
@@ -8,4 +8,3 @@
 
 /* { dg-final { scan-assembler-times "uzp1\[ \t\]+v\[0-9\]+\.8h, ?v\[0-9\]+\.8h, ?v\[0-9\]+\.8h!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
 /* { dg-final { scan-assembler-times "uzp2\[ \t\]+v\[0-9\]+\.8h, ?v\[0-9\]+\.8h, ?v\[0-9\]+\.8h!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vuzpqu32_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vuzpqu32_1.c
@@ -8,4 +8,3 @@
 
 /* { dg-final { scan-assembler-times "uzp1\[ \t\]+v\[0-9\]+\.4s, ?v\[0-9\]+\.4s, ?v\[0-9\]+\.4s!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
 /* { dg-final { scan-assembler-times "uzp2\[ \t\]+v\[0-9\]+\.4s, ?v\[0-9\]+\.4s, ?v\[0-9\]+\.4s!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vuzpqu8_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vuzpqu8_1.c
@@ -8,4 +8,3 @@
 
 /* { dg-final { scan-assembler-times "uzp1\[ \t\]+v\[0-9\]+\.16b, ?v\[0-9\]+\.16b, ?v\[0-9\]+\.16b!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
 /* { dg-final { scan-assembler-times "uzp2\[ \t\]+v\[0-9\]+\.16b, ?v\[0-9\]+\.16b, ?v\[0-9\]+\.16b!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vuzps16_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vuzps16_1.c
@@ -8,4 +8,3 @@
 
 /* { dg-final { scan-assembler-times "uzp1\[ \t\]+v\[0-9\]+\.4h, ?v\[0-9\]+\.4h, ?v\[0-9\]+\.4h!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
 /* { dg-final { scan-assembler-times "uzp2\[ \t\]+v\[0-9\]+\.4h, ?v\[0-9\]+\.4h, ?v\[0-9\]+\.4h!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vuzps32_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vuzps32_1.c
@@ -8,4 +8,3 @@
 
 /* { dg-final { scan-assembler-times "zip1\[ \t\]+v\[0-9\]+\.2s, ?v\[0-9\]+\.2s, ?v\[0-9\]+\.2s!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
 /* { dg-final { scan-assembler-times "zip2\[ \t\]+v\[0-9\]+\.2s, ?v\[0-9\]+\.2s, ?v\[0-9\]+\.2s!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vuzps8_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vuzps8_1.c
@@ -8,4 +8,3 @@
 
 /* { dg-final { scan-assembler-times "uzp1\[ \t\]+v\[0-9\]+\.8b, ?v\[0-9\]+\.8b, ?v\[0-9\]+\.8b!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
 /* { dg-final { scan-assembler-times "uzp2\[ \t\]+v\[0-9\]+\.8b, ?v\[0-9\]+\.8b, ?v\[0-9\]+\.8b!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vuzpu16_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vuzpu16_1.c
@@ -8,4 +8,3 @@
 
 /* { dg-final { scan-assembler-times "uzp1\[ \t\]+v\[0-9\]+\.4h, ?v\[0-9\]+\.4h, ?v\[0-9\]+\.4h!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
 /* { dg-final { scan-assembler-times "uzp2\[ \t\]+v\[0-9\]+\.4h, ?v\[0-9\]+\.4h, ?v\[0-9\]+\.4h!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vuzpu32_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vuzpu32_1.c
@@ -8,4 +8,3 @@
 
 /* { dg-final { scan-assembler-times "zip1\[ \t\]+v\[0-9\]+\.2s, ?v\[0-9\]+\.2s, ?v\[0-9\]+\.2s!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
 /* { dg-final { scan-assembler-times "zip2\[ \t\]+v\[0-9\]+\.2s, ?v\[0-9\]+\.2s, ?v\[0-9\]+\.2s!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vuzpu8_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vuzpu8_1.c
@@ -8,4 +8,3 @@
 
 /* { dg-final { scan-assembler-times "uzp1\[ \t\]+v\[0-9\]+\.8b, ?v\[0-9\]+\.8b, ?v\[0-9\]+\.8b!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
 /* { dg-final { scan-assembler-times "uzp2\[ \t\]+v\[0-9\]+\.8b, ?v\[0-9\]+\.8b, ?v\[0-9\]+\.8b!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vzipf32_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vzipf32_1.c
@@ -8,4 +8,3 @@
 
 /* { dg-final { scan-assembler-times "zip1\[ \t\]+v\[0-9\]+\.2s, ?v\[0-9\]+\.2s, ?v\[0-9\]+\.2s!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
 /* { dg-final { scan-assembler-times "zip2\[ \t\]+v\[0-9\]+\.2s, ?v\[0-9\]+\.2s, ?v\[0-9\]+\.2s!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vzipp16_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vzipp16_1.c
@@ -8,4 +8,3 @@
 
 /* { dg-final { scan-assembler-times "zip1\[ \t\]+v\[0-9\]+\.4h, ?v\[0-9\]+\.4h, ?v\[0-9\]+\.4h!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
 /* { dg-final { scan-assembler-times "zip2\[ \t\]+v\[0-9\]+\.4h, ?v\[0-9\]+\.4h, ?v\[0-9\]+\.4h!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vzipp8_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vzipp8_1.c
@@ -8,4 +8,3 @@
 
 /* { dg-final { scan-assembler-times "zip1\[ \t\]+v\[0-9\]+\.8b, ?v\[0-9\]+\.8b, ?v\[0-9\]+\.8b!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
 /* { dg-final { scan-assembler-times "zip2\[ \t\]+v\[0-9\]+\.8b, ?v\[0-9\]+\.8b, ?v\[0-9\]+\.8b!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vzipqf32_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vzipqf32_1.c
@@ -8,4 +8,3 @@
 
 /* { dg-final { scan-assembler-times "zip1\[ \t\]+v\[0-9\]+\.4s, ?v\[0-9\]+\.4s, ?v\[0-9\]+\.4s!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
 /* { dg-final { scan-assembler-times "zip2\[ \t\]+v\[0-9\]+\.4s, ?v\[0-9\]+\.4s, ?v\[0-9\]+\.4s!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vzipqp16_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vzipqp16_1.c
@@ -8,4 +8,3 @@
 
 /* { dg-final { scan-assembler-times "zip1\[ \t\]+v\[0-9\]+\.8h, ?v\[0-9\]+\.8h, ?v\[0-9\]+\.8h!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
 /* { dg-final { scan-assembler-times "zip2\[ \t\]+v\[0-9\]+\.8h, ?v\[0-9\]+\.8h, ?v\[0-9\]+\.8h!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vzipqp8_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vzipqp8_1.c
@@ -8,4 +8,3 @@
 
 /* { dg-final { scan-assembler-times "zip1\[ \t\]+v\[0-9\]+\.16b, ?v\[0-9\]+\.16b, ?v\[0-9\]+\.16b!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
 /* { dg-final { scan-assembler-times "zip2\[ \t\]+v\[0-9\]+\.16b, ?v\[0-9\]+\.16b, ?v\[0-9\]+\.16b!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vzipqs16_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vzipqs16_1.c
@@ -8,4 +8,3 @@
 
 /* { dg-final { scan-assembler-times "zip1\[ \t\]+v\[0-9\]+\.8h, ?v\[0-9\]+\.8h, ?v\[0-9\]+\.8h!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
 /* { dg-final { scan-assembler-times "zip2\[ \t\]+v\[0-9\]+\.8h, ?v\[0-9\]+\.8h, ?v\[0-9\]+\.8h!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vzipqs32_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vzipqs32_1.c
@@ -8,4 +8,3 @@
 
 /* { dg-final { scan-assembler-times "zip1\[ \t\]+v\[0-9\]+\.4s, ?v\[0-9\]+\.4s, ?v\[0-9\]+\.4s!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
 /* { dg-final { scan-assembler-times "zip2\[ \t\]+v\[0-9\]+\.4s, ?v\[0-9\]+\.4s, ?v\[0-9\]+\.4s!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vzipqs8_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vzipqs8_1.c
@@ -8,4 +8,3 @@
 
 /* { dg-final { scan-assembler-times "zip1\[ \t\]+v\[0-9\]+\.16b, ?v\[0-9\]+\.16b, ?v\[0-9\]+\.16b!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
 /* { dg-final { scan-assembler-times "zip2\[ \t\]+v\[0-9\]+\.16b, ?v\[0-9\]+\.16b, ?v\[0-9\]+\.16b!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vzipqu16_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vzipqu16_1.c
@@ -8,4 +8,3 @@
 
 /* { dg-final { scan-assembler-times "zip1\[ \t\]+v\[0-9\]+\.8h, ?v\[0-9\]+\.8h, ?v\[0-9\]+\.8h!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
 /* { dg-final { scan-assembler-times "zip2\[ \t\]+v\[0-9\]+\.8h, ?v\[0-9\]+\.8h, ?v\[0-9\]+\.8h!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vzipqu32_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vzipqu32_1.c
@@ -8,4 +8,3 @@
 
 /* { dg-final { scan-assembler-times "zip1\[ \t\]+v\[0-9\]+\.4s, ?v\[0-9\]+\.4s, ?v\[0-9\]+\.4s!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
 /* { dg-final { scan-assembler-times "zip2\[ \t\]+v\[0-9\]+\.4s, ?v\[0-9\]+\.4s, ?v\[0-9\]+\.4s!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vzipqu8_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vzipqu8_1.c
@@ -8,4 +8,3 @@
 
 /* { dg-final { scan-assembler-times "zip1\[ \t\]+v\[0-9\]+\.16b, ?v\[0-9\]+\.16b, ?v\[0-9\]+\.16b!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
 /* { dg-final { scan-assembler-times "zip2\[ \t\]+v\[0-9\]+\.16b, ?v\[0-9\]+\.16b, ?v\[0-9\]+\.16b!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vzips16_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vzips16_1.c
@@ -8,4 +8,3 @@
 
 /* { dg-final { scan-assembler-times "zip1\[ \t\]+v\[0-9\]+\.4h, ?v\[0-9\]+\.4h, ?v\[0-9\]+\.4h!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
 /* { dg-final { scan-assembler-times "zip2\[ \t\]+v\[0-9\]+\.4h, ?v\[0-9\]+\.4h, ?v\[0-9\]+\.4h!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vzips32_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vzips32_1.c
@@ -8,4 +8,3 @@
 
 /* { dg-final { scan-assembler-times "zip1\[ \t\]+v\[0-9\]+\.2s, ?v\[0-9\]+\.2s, ?v\[0-9\]+\.2s!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
 /* { dg-final { scan-assembler-times "zip2\[ \t\]+v\[0-9\]+\.2s, ?v\[0-9\]+\.2s, ?v\[0-9\]+\.2s!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vzips8_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vzips8_1.c
@@ -8,4 +8,3 @@
 
 /* { dg-final { scan-assembler-times "zip1\[ \t\]+v\[0-9\]+\.8b, ?v\[0-9\]+\.8b, ?v\[0-9\]+\.8b!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
 /* { dg-final { scan-assembler-times "zip2\[ \t\]+v\[0-9\]+\.8b, ?v\[0-9\]+\.8b, ?v\[0-9\]+\.8b!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vzipu16_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vzipu16_1.c
@@ -8,4 +8,3 @@
 
 /* { dg-final { scan-assembler-times "zip1\[ \t\]+v\[0-9\]+\.4h, ?v\[0-9\]+\.4h, ?v\[0-9\]+\.4h!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
 /* { dg-final { scan-assembler-times "zip2\[ \t\]+v\[0-9\]+\.4h, ?v\[0-9\]+\.4h, ?v\[0-9\]+\.4h!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vzipu32_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vzipu32_1.c
@@ -8,4 +8,3 @@
 
 /* { dg-final { scan-assembler-times "zip1\[ \t\]+v\[0-9\]+\.2s, ?v\[0-9\]+\.2s, ?v\[0-9\]+\.2s!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
 /* { dg-final { scan-assembler-times "zip2\[ \t\]+v\[0-9\]+\.2s, ?v\[0-9\]+\.2s, ?v\[0-9\]+\.2s!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/simd/vzipu8_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/simd/vzipu8_1.c
@@ -8,4 +8,3 @@
 
 /* { dg-final { scan-assembler-times "zip1\[ \t\]+v\[0-9\]+\.8b, ?v\[0-9\]+\.8b, ?v\[0-9\]+\.8b!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
 /* { dg-final { scan-assembler-times "zip2\[ \t\]+v\[0-9\]+\.8b, ?v\[0-9\]+\.8b, ?v\[0-9\]+\.8b!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/singleton_intrinsics_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/singleton_intrinsics_1.c
@@ -235,8 +235,8 @@ test_vrshl_u64 (uint64x1_t a, int64x1_t b)
   return vrshl_u64 (a, b);
 }
 
-/* For int64x1_t, sshr...#63 is output instead of the equivalent cmlt...#0.  */
-/* { dg-final { scan-assembler-times "\\tsshr\\td\[0-9\]+" 2 } } */
+/* For int64x1_t, sshr...#63 is equivalent to cmlt...#0.  */
+/* { dg-final { scan-assembler-times "\\t(?:sshr|cmlt)\\td\[0-9\]+" 2 } } */
 
 int64x1_t
 test_vshr_n_s64 (int64x1_t a)
@@ -400,5 +400,4 @@ test_vsri_n_u64 (uint64x1_t a, uint64x1_t b)
   return vsri_n_u64 (a, b, 9);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
 
--- a/src/gcc/testsuite/gcc.target/aarch64/sshr64_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/sshr64_1.c
@@ -112,4 +112,3 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/stp_vec_64_1.c
@@ -0,0 +1,20 @@
+/* { dg-do compile } */
+/* { dg-options "-Ofast" } */
+
+
+typedef int int32x2_t __attribute__ ((__vector_size__ ((8))));
+
+void
+bar (int32x2_t *foo)
+{
+  int i = 0;
+  int32x2_t val = { 3, 2 };
+
+  for (i = 0; i < 256; i+=2)
+    {
+      foo[i] = val;
+      foo[i+1] = val;
+    }
+}
+
+/* { dg-final { scan-assembler "stp\td\[0-9\]+, d\[0-9\]" } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/subs1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/subs1.c
@@ -12,7 +12,7 @@ subs_si_test1 (int a, int b, int c)
   if (d == 0)
     return a + c;
   else
-    return b + d + c;
+    return d;
 }
 
 int
@@ -24,7 +24,7 @@ subs_si_test2 (int a, int b, int c)
   if (d == 0)
     return a + c;
   else
-    return b + d + c;
+    return d;
 }
 
 int
@@ -36,7 +36,7 @@ subs_si_test3 (int a, int b, int c)
   if (d == 0)
     return a + c;
   else
-    return b + d + c;
+    return d;
 }
 
 typedef long long s64;
@@ -50,7 +50,7 @@ subs_di_test1 (s64 a, s64 b, s64 c)
   if (d == 0)
     return a + c;
   else
-    return b + d + c;
+    return d;
 }
 
 s64
@@ -62,7 +62,7 @@ subs_di_test2 (s64 a, s64 b, s64 c)
   if (d == 0)
     return a + c;
   else
-    return b + d + c;
+    return d;
 }
 
 s64
@@ -74,7 +74,7 @@ subs_di_test3 (s64 a, s64 b, s64 c)
   if (d == 0)
     return a + c;
   else
-    return b + d + c;
+    return d;
 }
 
 int main ()
@@ -83,67 +83,66 @@ int main ()
   s64 y;
 
   x = subs_si_test1 (29, 4, 5);
-  if (x != 33)
+  if (x != 24)
     abort ();
 
-  x = subs_si_test1 (5, 2, 20);
-  if (x != 7)
+  x = subs_si_test1 (20, 2, 20);
+  if (x != 40)
     abort ();
 
-  x = subs_si_test2 (29, 4, 5);
-  if (x != -217)
-    abort ();
+   x = subs_si_test2 (0xff, 4, 5);
+   if (x != (0xff + 5))
+     abort ();
 
-  x = subs_si_test2 (1024, 2, 20);
-  if (x != 791)
-    abort ();
+   x = subs_si_test2 (1024, 2, 20);
+   if (x != (1024 - 0xff))
+     abort ();
 
   x = subs_si_test3 (35, 4, 5);
-  if (x != 12)
+  if (x != 35 - (4 << 3))
     abort ();
 
-  x = subs_si_test3 (5, 2, 20);
-  if (x != 11)
+  x = subs_si_test3 (5 << 3, 5, 20);
+  if (x != (20 + (5 << 3)))
     abort ();
 
   y = subs_di_test1 (0x130000029ll,
 		     0x320000004ll,
 		     0x505050505ll);
 
-  if (y != 0x45000002d)
+  if (y != (0x130000029ll - 0x505050505ll))
     abort ();
 
   y = subs_di_test1 (0x5000500050005ll,
 		     0x2111211121112ll,
-		     0x0000000002020ll);
-  if (y != 0x7111711171117)
+		     0x5000500050005ll);
+  if (y != (0x5000500050005ll + 0x5000500050005ll))
     abort ();
 
   y = subs_di_test2 (0x130000029ll,
 		     0x320000004ll,
 		     0x505050505ll);
-  if (y != 0x955050433)
+  if (y != (0x130000029ll - 0xff))
     abort ();
 
-  y = subs_di_test2 (0x130002900ll,
+  y = subs_di_test2 (0xff,
 		     0x320000004ll,
 		     0x505050505ll);
-  if (y != 0x955052d0a)
+  if (y != (0xff + 0x505050505ll))
     abort ();
 
   y = subs_di_test3 (0x130000029ll,
 		     0x064000008ll,
 		     0x505050505ll);
-  if (y != 0x3790504f6)
+  if (y != (0x130000029ll - (0x064000008ll << 3)))
     abort ();
 
-  y = subs_di_test3 (0x130002900ll,
-		     0x088000008ll,
+  y = subs_di_test3 (0x130002900ll << 3,
+		     0x130002900ll,
 		     0x505050505ll);
-  if (y != 0x27d052dcd)
+  if (y != (0x505050505ll + (0x130002900ll << 3)))
     abort ();
 
   return 0;
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/subs2.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/subs2.c
@@ -152,4 +152,3 @@ int main ()
   return 0;
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/subs3.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/subs3.c
@@ -12,7 +12,7 @@ subs_ext (s64 a, int b, int c)
   if (d == 0)
     return a + c;
   else
-    return b + d + c;
+    return d;
 }
 
 int
@@ -23,7 +23,7 @@ subs_shift_ext (s64 a, int b, int c)
   if (d == 0)
     return a + c;
   else
-    return b + d + c;
+    return d;
 }
 
 int main ()
@@ -32,27 +32,27 @@ int main ()
   s64 y;
 
   x = subs_ext (0x13000002ll, 41, 15);
-  if (x != 318767121)
+  if (x != (int)(0x13000002ll - 41))
     abort ();
 
-  x = subs_ext (0x50505050ll, 29, 4);
-  if (x != 1347440724)
+  x = subs_ext (0x50505050ll, 0x50505050ll, 4);
+  if (x != (int)(0x50505050ll + 4))
     abort ();
 
   x = subs_ext (0x12121212121ll, 2, 14);
-  if (x != 555819311)
+  if (x != (int)(0x12121212121ll - 2))
     abort ();
 
   x = subs_shift_ext (0x123456789ll, 4, 12);
-  if (x != 591751033)
+  if (x != (int)(0x123456789ll - (4 << 3)))
     abort ();
 
-  x = subs_shift_ext (0x02020202ll, 9, 8);
-  if (x != 33685963)
+  x = subs_shift_ext (0x02020202ll << 3, 0x02020202ll, 8);
+  if (x != (int)(8 + (0x02020202ll << 3)))
     abort ();
 
   x = subs_shift_ext (0x987987987987ll, 23, 41);
-  if (x != -2020050673)
+  if (x != (int)(0x987987987987ll - (23 << 3)))
     abort ();
 
   return 0;
--- a/src/gcc/testsuite/gcc.target/aarch64/symbol-range-tiny.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/symbol-range-tiny.c
@@ -10,4 +10,3 @@ foo()
 }
 
 /* { dg-final { scan-assembler-not "adr\tx\[0-9\]+, fixed_regs\\\+" } } */
-/* { dg-final {cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/symbol-range.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/symbol-range.c
@@ -10,4 +10,3 @@ foo()
 }
 
 /* { dg-final { scan-assembler-not "adrp\tx\[0-9\]+, fixed_regs\\\+" } } */
-/* { dg-final {cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/sync-comp-swap.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/sync-comp-swap.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -fno-ipa-icf" } */
+/* { dg-options "-march=armv8-a+nolse -O2 -fno-ipa-icf" } */
 
 #include "sync-comp-swap.x"
 
--- a/src/gcc/testsuite/gcc.target/aarch64/sync-op-acquire.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/sync-op-acquire.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O2" } */
+/* { dg-options "-march=armv8-a+nolse -O2" } */
 
 #include "sync-op-acquire.x"
 
--- a/src/gcc/testsuite/gcc.target/aarch64/sync-op-full.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/sync-op-full.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O2" } */
+/* { dg-options "-march=armv8-a+nolse -O2" } */
 
 #include "sync-op-full.x"
 
--- a/src/gcc/testsuite/gcc.target/aarch64/sync-op-release.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/sync-op-release.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O2" } */
+/* { dg-options "-march=armv8-a+nolse -O2" } */
 
 #include "sync-op-release.x"
 
--- a/src/gcc/testsuite/gcc.target/aarch64/table-intrinsics.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/table-intrinsics.c
@@ -435,5 +435,5 @@ qtbxq_testp8_4 (poly8x16_t r, poly8x16x4_t tab, uint8x16_t idx)
   return vqtbx4q_p8 (r, tab, idx);
 }
 
-/* { dg-final { scan-assembler-times "tbl v" 42} }  */
-/* { dg-final { scan-assembler-times "tbx v" 30} }  */
+/* { dg-final { scan-assembler-times "tbl\[ |\t\]*v" 42} }  */
+/* { dg-final { scan-assembler-times "tbx\[ |\t\]*v" 30} }  */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/target_attr_1.c
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -mcpu=thunderx -save-temps" } */
+
+/* Test that cpu attribute overrides the command-line -mcpu.  */
+
+__attribute__ ((target ("cpu=cortex-a72.cortex-a53")))
+int
+foo (int a)
+{
+  return a + 1;
+}
+
+/* { dg-final { scan-assembler "//.tune cortex-a72.cortex-a53" } } */
+/* { dg-final { scan-assembler-not "thunderx" } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/target_attr_10.c
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -march=armv8-a+simd" } */
+
+/* Using a SIMD intrinsic from a function tagged with nosimd should fail
+   due to inlining rules.  */
+
+#include "arm_neon.h"
+
+__attribute__ ((target ("+nosimd")))
+uint8x16_t
+foo (uint8x16_t a, uint8x16_t b, uint8x16_t c)
+{
+  return vbslq_u8 (a, b, c); /* { dg-error "called from here" } */
+}
+
+/* { dg-error "inlining failed in call to always_inline" "" { target *-*-* } 0 } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/target_attr_11.c
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+
+/* Reject the negated form of non-negatable attributes.  */
+
+__attribute__ ((target ("no-general-regs-only")))
+int
+foo (int a)
+{
+  return a + 1;
+}
+
+/* { dg-error "does not allow a negated form" "" { target *-*-* } 0 } */
+/* { dg-error "is invalid" "" { target *-*-* } 0 } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/target_attr_12.c
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+
+/* Reject arguments to attributes that do not accept any.  */
+
+__attribute__ ((target ("general-regs-only=+crc")))
+int
+foo (int a)
+{
+  return a + 1;
+}
+
+/* { dg-error "does not accept an argument" "" { target *-*-* } 0 } */
+/* { dg-error "is invalid" "" { target *-*-* } 0 } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/target_attr_13.c
@@ -0,0 +1,16 @@
+/* { dg-do assemble } */
+/* { dg-options "-O2 -march=armv8-a+crc+crypto" } */
+
+#include "arm_acle.h"
+
+/* Make sure that 'crypto' is not required to compile an intrinsic
+   from arm_acle.h in a non-crypto function.  Tests that arm_acle.h
+   properly clears the architectural features in its initial target
+   pragma.  */
+
+__attribute__ ((target ("+crc+nocrypto")))
+int
+foo (uint32_t a, uint8_t b)
+{
+  return __crc32b (a, b);
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/target_attr_14.c
@@ -0,0 +1,20 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -save-temps" } */
+
+/* Inlining non-strict-align functions into strict-align
+   functions is allowed.  */
+
+int
+bar (int a)
+{
+  return a - 6;
+}
+
+__attribute__ ((target ("strict-align")))
+int
+bam (int a)
+{
+  return a - bar (a);
+}
+
+/* { dg-final { scan-assembler-not "bl.*bar" } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/target_attr_15.c
@@ -0,0 +1,15 @@
+/* { dg-do assemble } */
+/* { dg-options "-march=armv8-a+crypto -save-temps" } */
+
+/* Check that "+nothing" clears the ISA flags.  */
+
+__attribute__ ((target ("+nothing")))
+int
+foo (int a)
+{
+  return a + 1;
+}
+
+/* { dg-final { scan-assembler-not "\\+fp" } } */
+/* { dg-final { scan-assembler-not "\\+crypto" } } */
+/* { dg-final { scan-assembler-not "\\+simd" } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/target_attr_2.c
@@ -0,0 +1,39 @@
+/* { dg-do assemble } */
+/* { dg-options "-O2 -mcpu=cortex-a57 -ftree-vectorize -fdump-tree-vect-all" } */
+
+/* The various ways to turn off simd availability should
+   turn off vectorization.  */
+
+__attribute__ ((target ("+nosimd")))
+int
+baz (int *a)
+{
+  for (int i = 0; i < 1024; i++)
+    a[i] += 5;
+}
+
+__attribute__ ((target ("arch=armv8-a+nosimd")))
+int
+baz2 (int *a)
+{
+  for (int i = 0; i < 1024; i++)
+    a[i] += 5;
+}
+
+__attribute__ ((target ("cpu=cortex-a53+nosimd")))
+int
+baz3 (int *a)
+{
+  for (int i = 0; i < 1024; i++)
+    a[i] += 5;
+}
+
+__attribute__ ((target ("general-regs-only")))
+int
+baz4 (int *a)
+{
+  for (int i = 0; i < 1024; i++)
+    a[i] += 5;
+}
+
+/* { dg-final { scan-tree-dump-not "vectorized 1 loops" "vect" } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/target_attr_3.c
@@ -0,0 +1,34 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -mno-fix-cortex-a53-835769 -save-temps" } */
+
+/* Check that the attribute overrides the command line option
+   and the fix is applied once.  */
+
+__attribute__ ((target ("fix-cortex-a53-835769")))
+unsigned long
+test (unsigned long a, double b, unsigned long c,
+      unsigned long d, unsigned long *e)
+{
+  double result;
+  volatile unsigned long tmp = *e;
+  __asm__ __volatile ("// %0, %1"
+			: "=w" (result)
+			: "0" (b)
+			:    /* No clobbers.  */);
+  return c * d + d;
+}
+
+unsigned long
+test2 (unsigned long a, double b, unsigned long c,
+       unsigned long d, unsigned long *e)
+{
+  double result;
+  volatile unsigned long tmp = *e;
+  __asm__ __volatile ("// %0, %1"
+			: "=w" (result)
+			: "0" (b)
+			:   /* No clobbers.  */);
+  return c * d + d;
+}
+
+/* { dg-final { scan-assembler-times "between mem op and" 1 } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/target_attr_4.c
@@ -0,0 +1,30 @@
+/* { dg-do assemble } */
+/* { dg-options "-O2 -march=armv8-a+nocrc -save-temps" } */
+
+#include "arm_acle.h"
+
+/* Check that enabling an ISA feature using an attribute in a file
+   compiled without that attribute works.  */
+
+__attribute__ ((target ("+crc")))
+uint32_t
+foo (uint32_t a, uint8_t b)
+{
+  return __crc32b (a, b);
+}
+
+__attribute__ ((target ("arch=armv8-a+crc")))
+uint32_t
+fooarch (uint32_t a, uint8_t b)
+{
+  return __crc32b (a, b);
+}
+
+__attribute__ ((target ("cpu=cortex-a53+crc")))
+uint32_t
+foocpu (uint32_t a, uint8_t b)
+{
+  return __crc32b (a, b);
+}
+
+/* { dg-final { scan-assembler-times "crc32b\tw..?, w..?, w..?\n" 3 } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/target_attr_5.c
@@ -0,0 +1,20 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -save-temps" } */
+
+/* Make sure that bar is inlined into bam.  */
+
+__attribute__ ((target ("arch=armv8-a+nocrc")))
+int
+bar (int a)
+{
+  return a - 6;
+}
+
+__attribute__ ((target ("cpu=cortex-a53+nocrc")))
+int
+bam (int a)
+{
+  return a - bar (a);
+}
+
+/* { dg-final { scan-assembler-not "bl.*bar" } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/target_attr_6.c
@@ -0,0 +1,20 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -save-temps" } */
+
+/* Inlining strict-align functions into non-strict align
+   functions is not allowed.  */
+
+__attribute__ ((target ("strict-align")))
+int
+bar (int a)
+{
+  return a - 6;
+}
+
+int
+bam (int a)
+{
+  return a - bar (a);
+}
+
+/* { dg-final { scan-assembler "bl.*bar" } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/target_attr_7.c
@@ -0,0 +1,24 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -mcpu=thunderx -save-temps" } */
+
+/* Make sure that #pragma overrides command line option and
+   target attribute overrides the pragma.  */
+
+#pragma GCC target ("cpu=xgene1")
+
+int
+bar (int a)
+{
+  return a - 6;
+}
+
+__attribute__ ((target ("tune=cortex-a53")))
+int
+bam (int a)
+{
+  return a - bar (a);
+}
+
+/* { dg-final { scan-assembler-times "//.tune xgene1" 1 } } */
+/* { dg-final { scan-assembler-times "//.tune cortex-a53" 1 } } */
+/* { dg-final { scan-assembler-not "thunderx" } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/target_attr_8.c
@@ -0,0 +1,22 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -save-temps" } */
+
+/* bar has a subset set of the architectural flags of bam.
+   Inlining should be allowed.  */
+
+__attribute__ ((target ("arch=armv8-a+nocrc")))
+int
+bar (int a)
+{
+  return a - 6;
+}
+
+__attribute__ ((target ("arch=armv8-a+crc")))
+int
+bam (int a)
+{
+  return a - bar (a);
+}
+
+
+/* { dg-final { scan-assembler-not "bl.*bar" } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/target_attr_9.c
@@ -0,0 +1,22 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -save-temps" } */
+
+/* bar does not have a subset of architectural flags of bam.
+   Inlining should be rejected.  */
+
+__attribute__ ((target ("arch=armv8-a+crc")))
+int
+bar (int a)
+{
+  return a - 6;
+}
+
+__attribute__ ((target ("arch=armv8-a+nocrc")))
+int
+bam (int a)
+{
+  return a - bar (a);
+}
+
+
+/* { dg-final { scan-assembler "bl.*bar" } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/target_attr_crypto_ice_1.c
@@ -0,0 +1,21 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -mcpu=thunderx+nofp" } */
+
+#include "arm_neon.h"
+
+/* Unless we do something about re-laying out the SIMD builtin types
+   this testcase ICEs during expansion of the crypto builtin.  */
+
+__attribute__ ((target ("cpu=cortex-a57+crypto")))
+uint32x4_t
+test_vsha1cq_u32 (uint32x4_t hash_abcd, uint32_t hash_e, uint32x4_t wk)
+{
+  return vsha1cq_u32 (hash_abcd, hash_e, wk);
+}
+
+/* This one should be compiled for thunderx with no fp.  */
+int
+foo (int a)
+{
+  return a + 5;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/target_attr_crypto_ice_2.c
@@ -0,0 +1,20 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -mcpu=thunderx+nofp" } */
+
+/* Make sure that we don't ICE when dealing with vector parameters
+   in a simd-tagged function within a non-simd translation unit.  */
+
+#pragma GCC push_options
+#pragma GCC target ("+nothing+simd")
+typedef unsigned int __uint32_t;
+typedef __uint32_t uint32_t ;
+typedef __Uint32x4_t uint32x4_t;
+#pragma GCC pop_options
+
+
+__attribute__ ((target ("cpu=cortex-a57")))
+uint32x4_t
+foo (uint32x4_t a, uint32_t b, uint32x4_t c)
+{
+  return c;
+}
--- a/src/gcc/testsuite/gcc.target/aarch64/test-framepointer-1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/test-framepointer-1.c
@@ -12,4 +12,3 @@
 
 /* { dg-final { scan-assembler-times "stp\tx29, x30, \\\[sp, -\[0-9\]+\\\]!" 2 } } */
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/test-framepointer-2.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/test-framepointer-2.c
@@ -12,4 +12,3 @@
 
 /* { dg-final { scan-assembler-not "stp\tx29, x30, \\\[sp, -\[0-9\]+\\\]!" } } */
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/test-framepointer-3.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/test-framepointer-3.c
@@ -12,4 +12,3 @@
 
 /* { dg-final { scan-assembler-not "stp\tx29, x30, \\\[sp, -\[0-9\]+\\\]!" } } */
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/test-framepointer-4.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/test-framepointer-4.c
@@ -13,4 +13,3 @@
 
 /* { dg-final { scan-assembler-times "stp\tx29, x30, \\\[sp, -\[0-9\]+\\\]!" 1 } } */
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/test-framepointer-5.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/test-framepointer-5.c
@@ -12,4 +12,3 @@
 
 /* { dg-final { scan-assembler-times "stp\tx29, x30, \\\[sp, -\[0-9\]+\\\]!" 2 } } */
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/test-framepointer-6.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/test-framepointer-6.c
@@ -12,4 +12,3 @@
 
 /* { dg-final { scan-assembler-not "stp\tx29, x30, \\\[sp, -\[0-9\]+\\\]!" } } */
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/test-framepointer-7.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/test-framepointer-7.c
@@ -12,4 +12,3 @@
 
 /* { dg-final { scan-assembler-not "stp\tx29, x30, \\\[sp, -\[0-9\]+\\\]!" } } */
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/test-framepointer-8.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/test-framepointer-8.c
@@ -13,4 +13,3 @@
 
 /* { dg-final { scan-assembler-times "stp\tx29, x30, \\\[sp, -\[0-9\]+\\\]!" 2 } } */
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/test_fp_attribute_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/test_fp_attribute_1.c
@@ -23,4 +23,3 @@ non_leaf_2 (void)
 
 /* { dg-final { scan-assembler-times "str\tx30, \\\[sp, -\[0-9\]+\\\]!" 2 } } */
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/test_fp_attribute_2.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/test_fp_attribute_2.c
@@ -23,4 +23,3 @@ non_leaf_2 (void)
 
 /* { dg-final { scan-assembler-times "stp\tx29, x30, \\\[sp, -\[0-9\]+\\\]!" 2 } } */
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/test_frame_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/test_frame_1.c
@@ -16,4 +16,3 @@ t_frame_run (test1)
 /* { dg-final { scan-assembler-times "str\tx30, \\\[sp, -\[0-9\]+\\\]!" 2 } } */
 /* { dg-final { scan-assembler-times "ldr\tx30, \\\[sp\\\], \[0-9\]+" 2 } } */
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/test_frame_10.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/test_frame_10.c
@@ -18,4 +18,3 @@ t_frame_run (test10)
 /* { dg-final { scan-assembler-times "stp\tx19, x30, \\\[sp, -\[0-9\]+\\\]!" 1 } } */
 /* { dg-final { scan-assembler-times "ldp\tx19, x30, \\\[sp\\\], \[0-9\]+" 1 } } */
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/test_frame_11.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/test_frame_11.c
@@ -13,4 +13,3 @@ t_frame_pattern (test11, 400, )
 t_frame_run (test11)
 
 /* { dg-final { scan-assembler-times "stp\tx29, x30, \\\[sp, -\[0-9\]+\\\]!" 2 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/test_frame_12.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/test_frame_12.c
@@ -16,4 +16,3 @@ t_frame_run (test12)
 /* Check epilogue using write-back.  */
 /* { dg-final { scan-assembler-times "ldp\tx29, x30, \\\[sp\\\], \[0-9\]+" 3 } } */
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/test_frame_13.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/test_frame_13.c
@@ -15,4 +15,3 @@ t_frame_run (test13)
 
 /* { dg-final { scan-assembler-times "sub\tsp, sp, #\[0-9\]+" 1 } } */
 /* { dg-final { scan-assembler-times "stp\tx29, x30, \\\[sp, -\[0-9\]+\\\]!" 2 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/test_frame_15.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/test_frame_15.c
@@ -16,4 +16,3 @@ t_frame_run (test15)
 
 /* { dg-final { scan-assembler-times "sub\tsp, sp, #\[0-9\]+" 1 } } */
 /* { dg-final { scan-assembler-times "stp\tx29, x30, \\\[sp, -\[0-9\]+\\\]!" 3 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/test_frame_2.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/test_frame_2.c
@@ -17,4 +17,3 @@ t_frame_run (test2)
 /* { dg-final { scan-assembler-times "stp\tx19, x30, \\\[sp, -\[0-9\]+\\\]!" 1 } } */
 /* { dg-final { scan-assembler-times "ldp\tx19, x30, \\\[sp\\\], \[0-9\]+" 1 } } */
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/test_frame_4.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/test_frame_4.c
@@ -16,4 +16,3 @@ t_frame_run (test4)
 /* { dg-final { scan-assembler-times "stp\tx19, x30, \\\[sp, -\[0-9\]+\\\]!" 1 } } */
 /* { dg-final { scan-assembler-times "ldp\tx19, x30, \\\[sp\\\], \[0-9\]+" 1 } } */
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/test_frame_6.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/test_frame_6.c
@@ -17,4 +17,3 @@ t_frame_run (test6)
 /* { dg-final { scan-assembler-times "str\tx30, \\\[sp, -\[0-9\]+\\\]!" 2 } } */
 /* { dg-final { scan-assembler-times "ldr\tx30, \\\[sp\\\], \[0-9\]+" 2 } } */
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/test_frame_7.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/test_frame_7.c
@@ -17,4 +17,3 @@ t_frame_run (test7)
 /* { dg-final { scan-assembler-times "stp\tx19, x30, \\\[sp, -\[0-9\]+\\\]!" 1 } } */
 /* { dg-final { scan-assembler-times "ldp\tx19, x30, \\\[sp\\\], \[0-9\]+" 1 } } */
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/test_frame_8.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/test_frame_8.c
@@ -15,4 +15,3 @@ t_frame_run (test8)
 /* { dg-final { scan-assembler-times "str\tx30, \\\[sp, -\[0-9\]+\\\]!" 3 } } */
 /* { dg-final { scan-assembler-times "ldr\tx30, \\\[sp\\\], \[0-9\]+" 3 } } */
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/tst_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/tst_1.c
@@ -147,4 +147,3 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/tst_2.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/tst_2.c
@@ -153,4 +153,3 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/unsigned-float.c
@@ -0,0 +1,18 @@
+/* { dg-do compile } */
+/* { dg-options "-O1" } */
+
+#include <stdint.h>
+
+double
+f1 (uint16_t x)
+{
+  return (double)(float)x;
+}
+
+float
+f2 (uint16_t x)
+{
+  return (float)(double)x;
+}
+
+/* { dg-final { scan-assembler-not "fcvt" } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/ushr64_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/ushr64_1.c
@@ -80,4 +80,3 @@ main (int argc, char *argv[])
   return 0;
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/vabs_intrinsic_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/vabs_intrinsic_1.c
@@ -98,4 +98,3 @@ main (int argc, char **argv)
   return 0;
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/vadd_f64.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/vadd_f64.c
@@ -79,4 +79,3 @@ main (int argc, char **argv)
   return 0;
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/vbslq_f64_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/vbslq_f64_1.c
@@ -17,5 +17,4 @@ fold_me (float32x4_t a, float32x4_t b)
 /* { dg-final { scan-assembler-not "bit\\tv" } } */
 /* { dg-final { scan-assembler-not "bif\\tv" } } */
 
-/* { dg-final { cleanup-saved-temps } } */
 
--- a/src/gcc/testsuite/gcc.target/aarch64/vbslq_f64_2.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/vbslq_f64_2.c
@@ -20,5 +20,4 @@ half_fold_me (uint32x4_t mask)
 /* { dg-final { scan-assembler-not "bif\\tv" } } */
 /* { dg-final { scan-assembler "bic\\tv" } } */
 
-/* { dg-final { cleanup-saved-temps } } */
 
--- a/src/gcc/testsuite/gcc.target/aarch64/vbslq_u64_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/vbslq_u64_1.c
@@ -13,5 +13,4 @@ vbslq_dummy_u32 (uint32x4_t a, uint32x4_t b, uint32x4_t mask)
 }
 
 /* { dg-final { scan-assembler-times "bif\\tv" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
 
--- a/src/gcc/testsuite/gcc.target/aarch64/vbslq_u64_2.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/vbslq_u64_2.c
@@ -18,5 +18,4 @@ half_fold_int (uint32x4_t mask)
 /* { dg-final { scan-assembler-not "bif\\tv" } } */
 /* { dg-final { scan-assembler "bic\\tv" } } */
 
-/* { dg-final { cleanup-saved-temps } } */
 
--- a/src/gcc/testsuite/gcc.target/aarch64/vclz.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/vclz.c
@@ -571,4 +571,3 @@ main (int argc, char **argv)
   return 0;
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/vdiv_f.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/vdiv_f.c
@@ -7,7 +7,7 @@
 #define FLT_INFINITY (__builtin_inff ())
 #define DBL_INFINITY (__builtin_inf ())
 
-#define NAN (0.0 / 0.0)
+#define NAN (__builtin_nan (""))
 
 #define PI 3.141592653589793
 #define PI_4 0.7853981633974483
@@ -228,9 +228,7 @@ test_vdiv_f64 ()
   return 0;
 }
 
-/* The following assembly should match 2 more times,
-   in 64bit NAN generation.  */
-/* { dg-final { scan-assembler-times "fdiv\\td\[0-9\]+, d\[0-9\]+, d\[0-9\]+" 3 } } */
+/* { dg-final { scan-assembler-times "fdiv\\td\[0-9\]+, d\[0-9\]+, d\[0-9\]+" 1 } } */
 
 #undef TESTA8
 #undef ANSW8
@@ -349,4 +347,3 @@ main (int argc, char **argv)
   return 0;
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/vdup_lane_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/vdup_lane_1.c
@@ -401,4 +401,3 @@ main ()
 /* { dg-final { scan-assembler-times "dup\\tv\[0-9\]+\.4s, v\[0-9\]+\.s\\\[0\\\]" 2 } } */
 /* { dg-final { scan-assembler-times "dup\\tv\[0-9\]+\.4s, v\[0-9\]+\.s\\\[1\\\]" 2 } } */
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/vdup_lane_2.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/vdup_lane_2.c
@@ -338,6 +338,5 @@ main ()
 
 /* Asm check for vdupd_lane_f64, vdupd_lane_s64, vdupd_lane_u64.  */
 /* Attempts to make the compiler generate vdupd are not practical.  */
-/* { dg-final { scan-assembler-not "dup\\td\[0-9\]+, v\[0-9\]+\.d\\\[0\\\]" } }
+/* { dg-final { scan-assembler-not "dup\\td\[0-9\]+, v\[0-9\]+\.d\\\[0\\\]" } } */
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/vdup_n_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/vdup_n_1.c
@@ -616,4 +616,3 @@ main ()
 /* Asm check for test_vdupq_n_s64, test_vdupq_n_u64.  */
 /* { dg-final { scan-assembler-times "dup\\tv\[0-9\]+\.2d, x\[0-9\]+" 2 } } */
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/vdup_n_2.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/vdup_n_2.c
@@ -24,5 +24,4 @@ main (int argc, char **argv)
 
 /* { dg-final { scan-assembler-times "\[ \t\]*dup\[ \t\]+v\[0-9\]+\.2s, ?v\[0-9\]+\.s\\\[\[01\]\\\]" 1 } } */
 /* { dg-final { scan-assembler-not "zip" } } */
-/* { dg-final { cleanup-saved-temps } } */
 
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/vec_init_1.c
@@ -0,0 +1,33 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -fomit-frame-pointer --save-temps -fno-inline" } */
+
+extern void abort (void);
+
+typedef float float16x4_t __attribute__ ((vector_size ((16))));
+
+float a;
+float b;
+
+float16x4_t
+make_vector ()
+{
+  return (float16x4_t) { 0, 0, a, b };
+}
+
+int
+main (int argc, char **argv)
+{
+  a = 4.0;
+  b = 3.0;
+  float16x4_t vec = make_vector ();
+  if (vec[0] != 0 || vec[1] != 0 || vec[2] != a || vec[3] != b)
+    abort ();
+  return 0;
+}
+
+/* { dg-final { scan-assembler-times "ins\\t" 2 } } */
+/* What we want to check, is that make_vector does not stp the whole vector
+   to the stack.  Unfortunately here we scan the body of main() too, which may
+   be a bit fragile - the test is currently passing only because of the option
+   -fomit-frame-pointer which avoids use of stp in the prologue to main().  */
+/* { dg-final { scan-assembler-not "stp\\t" } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/vect-clz.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/vect-clz.c
@@ -32,4 +32,3 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/vect-fcm-eq-d.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/vect-fcm-eq-d.c
@@ -11,5 +11,3 @@
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 8 "vect" } } */
 /* { dg-final { scan-assembler "fcmeq\\tv\[0-9\]+\.2d, v\[0-9\]+\.2d, v\[0-9\]+\.2d" } } */
 /* { dg-final { scan-assembler "fcmeq\\tv\[0-9\]+\.2d, v\[0-9\]+\.2d, 0" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/vect-fcm-eq-f.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/vect-fcm-eq-f.c
@@ -11,5 +11,3 @@
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 8 "vect" } } */
 /* { dg-final { scan-assembler "fcmeq\\tv\[0-9\]+\.\[24\]s, v\[0-9\]+\.\[24\]s, v\[0-9\]+\.\[24\]s" } } */
 /* { dg-final { scan-assembler "fcmeq\\tv\[0-9\]+\.\[24\]s, v\[0-9\]+\.\[24\]s, 0" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/vect-fcm-ge-d.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/vect-fcm-ge-d.c
@@ -12,5 +12,3 @@
 /* { dg-final { scan-assembler "fcmge\\tv\[0-9\]+\.2d, v\[0-9\]+\.2d, v\[0-9\]+\.2d" } } */
 /* { dg-final { scan-assembler "fcmge\\tv\[0-9\]+\.2d, v\[0-9\]+\.2d, 0" } } */
 /* { dg-final { scan-assembler "fcmlt\\tv\[0-9\]+\.2d, v\[0-9\]+\.2d, 0" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/vect-fcm-ge-f.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/vect-fcm-ge-f.c
@@ -12,5 +12,3 @@
 /* { dg-final { scan-assembler "fcmge\\tv\[0-9\]+\.\[24\]s, v\[0-9\]+\.\[24\]s, v\[0-9\]+\.\[24\]s" } } */
 /* { dg-final { scan-assembler "fcmge\\tv\[0-9\]+\.\[24\]s, v\[0-9\]+\.\[24\]s, 0" } } */
 /* { dg-final { scan-assembler "fcmlt\\tv\[0-9\]+\.\[24\]s, v\[0-9\]+\.\[24\]s, 0" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/vect-fcm-gt-d.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/vect-fcm-gt-d.c
@@ -12,5 +12,3 @@
 /* { dg-final { scan-assembler "fcmgt\\tv\[0-9\]+\.2d, v\[0-9\]+\.2d, v\[0-9\]+\.2d" } } */
 /* { dg-final { scan-assembler "fcmgt\\tv\[0-9\]+\.2d, v\[0-9\]+\.2d, 0" } } */
 /* { dg-final { scan-assembler "fcmle\\tv\[0-9\]+\.2d, v\[0-9\]+\.2d, 0" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/vect-fcm-gt-f.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/vect-fcm-gt-f.c
@@ -12,5 +12,3 @@
 /* { dg-final { scan-assembler "fcmgt\\tv\[0-9\]+\.\[24\]s, v\[0-9\]+\.\[24\]s, v\[0-9\]+\.\[24\]s" } } */
 /* { dg-final { scan-assembler "fcmgt\\tv\[0-9\]+\.\[24\]s, v\[0-9\]+\.\[24\]s, 0" } } */
 /* { dg-final { scan-assembler "fcmle\\tv\[0-9\]+\.\[24\]s, v\[0-9\]+\.\[24\]s, 0" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/vect-fmovd-zero.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/vect-fmovd-zero.c
@@ -14,4 +14,3 @@ foo (double *output)
 
 /* { dg-final { scan-assembler "movi\\tv\[0-9\]+\\.2d, 0" } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/vect-fmovd.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/vect-fmovd.c
@@ -14,4 +14,3 @@ foo (double *output)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-assembler "fmov\\tv\[0-9\]+\\.2d, 4\\.25" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/vect-fmovf-zero.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/vect-fmovf-zero.c
@@ -14,4 +14,3 @@ foo (float *output)
 
 /* { dg-final { scan-assembler "movi\\tv\[0-9\]+\\.\[24\]s, 0" } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/vect-fmovf.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/vect-fmovf.c
@@ -14,4 +14,3 @@ foo (float *output)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-assembler "fmov\\tv\[0-9\]+\\.\[24\]s, 4\\.25" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/vect-movi.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/vect-movi.c
@@ -71,4 +71,3 @@ main (void)
   return 0;
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/vect-reduc-or_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/vect-reduc-or_1.c
@@ -31,4 +31,3 @@ main (unsigned char argc, char **argv)
 }
 
 /* { dg-final { scan-tree-dump "Reduce using vector shifts" "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/vect-vaddv.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/vect-vaddv.c
@@ -125,4 +125,3 @@ TEST (f64, q, float64, 2, D)
   return 0;
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/vect-vca.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/vect-vca.c
@@ -86,4 +86,3 @@ BUILD_VARIANTS (lt, <)
   return 0;
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/vect-vcvt.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/vect-vcvt.c
@@ -129,4 +129,3 @@ main (int argc, char **argv)
   return 0;
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/vect-vfmaxv.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/vect-vfmaxv.c
@@ -166,4 +166,3 @@ main (int argc, char **argv)
   return 0;
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/vect-vmaxv.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/vect-vmaxv.c
@@ -114,4 +114,3 @@ main (int argc, char **argv)
   return 0;
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/vect-vrnd.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/vect-vrnd.c
@@ -114,4 +114,3 @@ main (int argc, char **argv)
   return 0;
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/vect_combine_zeroes_1.c
@@ -0,0 +1,24 @@
+/* { dg-options "-O2 --save-temps" } */
+
+#include "arm_neon.h"
+
+int32x4_t
+foo (int32x2_t *x)
+{
+  int32x2_t i = *x;
+  int32x2_t zeroes = vcreate_s32 (0l);
+  int32x4_t ret = vcombine_s32 (i, zeroes);
+  return ret;
+}
+
+int32x4_t
+bar (int64_t x)
+{
+  int32x2_t i = vcreate_s32 (x);
+  int32x2_t zeroes = vcreate_s32 (0l);
+  int32x4_t ret = vcombine_s32 (i, zeroes);
+  return ret;
+}
+
+/* { dg-final { scan-assembler-not "mov\tv\[0-9\]+.8b, v\[0-9\]+.8b" } } */
+
--- a/src/gcc/testsuite/gcc.target/aarch64/vect_ctz_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/vect_ctz_1.c
@@ -38,4 +38,3 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/vect_int32x2x4_1.c
@@ -0,0 +1,22 @@
+/* { dg-do compile } */
+/* { dg-options "-O3 -fdump-rtl-expand" } */
+
+#include <arm_neon.h>
+
+uint32x2x4_t
+test_1 (uint32x2x4_t a, uint32x2x4_t b)
+{
+   uint32x2x4_t result;
+
+   for (unsigned index = 0; index < 4; ++index)
+     result.val[index] = a.val[index] + b.val[index];
+
+   return result;
+}
+
+/* Should not use the stack in expand.  */
+/* { dg-final { scan-rtl-dump-not "virtual-stack-vars" "expand" } } */
+/* Should not have to modify the stack pointer.  */
+/* { dg-final { scan-assembler-not "\t(add|sub).*sp" } } */
+/* Should not have to store or load anything.  */
+/* { dg-final { scan-assembler-not "\t(ld|st)\[rp\]" } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/vect_saddl_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/vect_saddl_1.c
@@ -311,5 +311,4 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-saved-temps } } */
 
--- a/src/gcc/testsuite/gcc.target/aarch64/vect_smlal_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/vect_smlal_1.c
@@ -322,4 +322,3 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/vget_high_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/vget_high_1.c
@@ -14,6 +14,7 @@ VARIANT (int8_t, 8, int8x8_t, int8x16_t, s8)		\
 VARIANT (int16_t, 4, int16x4_t, int16x8_t, s16)		\
 VARIANT (int32_t, 2, int32x2_t, int32x4_t, s32)		\
 VARIANT (int64_t, 1, int64x1_t, int64x2_t, s64)		\
+VARIANT (float16_t, 4, float16x4_t, float16x8_t, f16)	\
 VARIANT (float32_t, 2, float32x2_t, float32x4_t, f32)	\
 VARIANT (float64_t, 1, float64x1_t, float64x2_t, f64)
 
@@ -51,6 +52,8 @@ main (int argc, char **argv)
   int16_t int16_t_data[8] = { -17, 19, 3, -999, 44048, 505, 9999, 1000};
   int32_t int32_t_data[4] = { 123456789, -987654321, -135792468, 975318642 };
   int64_t int64_t_data[2] = {0xfedcba9876543210LL, 0xdeadbabecafebeefLL };
+  float16_t float16_t_data[8] = { 1.25, 4.5, 7.875, 2.3125, 5.675, 8.875,
+      3.6875, 6.75};
   float32_t float32_t_data[4] = { 3.14159, 2.718, 1.414, 100.0 };
   float64_t float64_t_data[2] = { 1.01001000100001, 12345.6789 };
 
--- a/src/gcc/testsuite/gcc.target/aarch64/vget_low_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/vget_low_1.c
@@ -14,6 +14,7 @@ VARIANT (int8_t, 8, int8x8_t, int8x16_t, s8)		\
 VARIANT (int16_t, 4, int16x4_t, int16x8_t, s16)		\
 VARIANT (int32_t, 2, int32x2_t, int32x4_t, s32)		\
 VARIANT (int64_t, 1, int64x1_t, int64x2_t, s64)		\
+VARIANT (float16_t, 4, float16x4_t, float16x8_t, f16)	\
 VARIANT (float32_t, 2, float32x2_t, float32x4_t, f32)	\
 VARIANT (float64_t, 1, float64x1_t, float64x2_t, f64)
 
@@ -51,6 +52,8 @@ main (int argc, char **argv)
   int16_t int16_t_data[8] = { -17, 19, 3, -999, 44048, 505, 9999, 1000};
   int32_t int32_t_data[4] = { 123456789, -987654321, -135792468, 975318642 };
   int64_t int64_t_data[2] = {0xfedcba9876543210LL, 0xdeadbabecafebeefLL };
+  float16_t float16_t_data[8] = { 1.25, 4.5, 7.875, 2.3125, 5.675, 8.875,
+      3.6875, 6.75};
   float32_t float32_t_data[4] = { 3.14159, 2.718, 1.414, 100.0 };
   float64_t float64_t_data[2] = { 1.01001000100001, 12345.6789 };
 
--- a/src/gcc/testsuite/gcc.target/aarch64/vld1-vst1_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/vld1-vst1_1.c
@@ -31,6 +31,7 @@ THING (int8x8_t, 8, int8_t, _s8)	\
 THING (uint8x8_t, 8, uint8_t, _u8)	\
 THING (int16x4_t, 4, int16_t, _s16)	\
 THING (uint16x4_t, 4, uint16_t, _u16)	\
+THING (float16x4_t, 4, float16_t, _f16)	\
 THING (int32x2_t, 2, int32_t, _s32)	\
 THING (uint32x2_t, 2, uint32_t, _u32)	\
 THING (float32x2_t, 2, float32_t, _f32) \
@@ -38,8 +39,10 @@ THING (int8x16_t, 16, int8_t, q_s8)	\
 THING (uint8x16_t, 16, uint8_t, q_u8)	\
 THING (int16x8_t, 8, int16_t, q_s16)	\
 THING (uint16x8_t, 8, uint16_t, q_u16)	\
+THING (float16x8_t, 8, float16_t, q_f16)\
 THING (int32x4_t, 4, int32_t, q_s32)	\
 THING (uint32x4_t, 4, uint32_t, q_u32)	\
+THING (float32x4_t, 4, float32_t, q_f32)\
 THING (int64x2_t, 2, int64_t, q_s64)	\
 THING (uint64x2_t, 2, uint64_t, q_u64)	\
 THING (float64x2_t, 2, float64_t, q_f64)
--- a/src/gcc/testsuite/gcc.target/aarch64/vld1_lane.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/vld1_lane.c
@@ -16,6 +16,7 @@ VARIANT (int32, , 2, _s32, 0)	\
 VARIANT (int64, , 1, _s64, 0)	\
 VARIANT (poly8, , 8, _p8, 7)	\
 VARIANT (poly16, , 4, _p16, 2)	\
+VARIANT (float16, , 4, _f16, 3)	\
 VARIANT (float32, , 2, _f32, 1)	\
 VARIANT (float64, , 1, _f64, 0)	\
 VARIANT (uint8, q, 16, _u8, 13)	\
@@ -28,6 +29,7 @@ VARIANT (int32, q, 4, _s32, 1)	\
 VARIANT (int64, q, 2, _s64, 1)	\
 VARIANT (poly8, q, 16, _p8, 7)	\
 VARIANT (poly16, q, 8, _p16, 4)	\
+VARIANT (float16, q, 8, _f16, 3)\
 VARIANT (float32, q, 4, _f32, 2)\
 VARIANT (float64, q, 2, _f64, 1)
 
@@ -56,7 +58,7 @@ VARIANTS (TESTMETH)
 
 #define CHECK(BASE, Q, ELTS, SUFFIX, LANE)			\
   if (test_vld1##Q##_lane##SUFFIX ((const BASE##_t *)orig_data,	\
-				   BASE##_data) != 0)	\
+				   & BASE##_data) != 0)	\
     abort ();
 
 int
@@ -65,20 +67,20 @@ main (int argc, char **argv)
   /* Original data for all vector formats.  */
   uint64_t orig_data[2] = {0x1234567890abcdefULL, 0x13579bdf02468aceULL};
 
-  /* Data with which vldN_lane will overwrite some of previous.  */
-  uint8_t uint8_data[4] = { 7, 11, 13, 17 };
-  uint16_t uint16_data[4] = { 257, 263, 269, 271 };
-  uint32_t uint32_data[4] = { 65537, 65539, 65543, 65551 };
-  uint64_t uint64_data[4] = { 0xdeadbeefcafebabeULL, 0x0123456789abcdefULL,
-			      0xfedcba9876543210LL, 0xdeadbabecafebeefLL };
-  int8_t int8_data[4] = { -1, 3, -5, 7 };
-  int16_t int16_data[4] = { 257, -259, 261, -263 };
-  int32_t int32_data[4] = { 123456789, -987654321, -135792468, 975318642 };
-  int64_t *int64_data = (int64_t *)uint64_data;
-  poly8_t poly8_data[4] = { 0, 7, 13, 18, };
-  poly16_t poly16_data[4] = { 11111, 2222, 333, 44 };
-  float32_t float32_data[4] = { 3.14159, 2.718, 1.414, 100.0 };
-  float64_t float64_data[4] = { 1.010010001, 12345.6789, -9876.54321, 1.618 };
+  /* Data with which vld1_lane will overwrite one element of previous.  */
+  uint8_t uint8_data = 7;
+  uint16_t uint16_data = 257;
+  uint32_t uint32_data = 65537;
+  uint64_t uint64_data = 0xdeadbeefcafebabeULL;
+  int8_t int8_data = -1;
+  int16_t int16_data = -259;
+  int32_t int32_data = -987654321;
+  int64_t int64_data = 0x1234567890abcdefLL;
+  poly8_t poly8_data = 13;
+  poly16_t poly16_data = 11111;
+  float16_t float16_data = 8.75;
+  float32_t float32_data = 3.14159;
+  float64_t float64_data = 1.010010001;
 
   VARIANTS (CHECK);
   return 0;
--- a/src/gcc/testsuite/gcc.target/aarch64/vldN_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/vldN_1.c
@@ -39,6 +39,7 @@ VARIANT (int32, 2, STRUCT, _s32)	\
 VARIANT (int64, 1, STRUCT, _s64)	\
 VARIANT (poly8, 8, STRUCT, _p8)		\
 VARIANT (poly16, 4, STRUCT, _p16)	\
+VARIANT (float16, 4, STRUCT, _f16)	\
 VARIANT (float32, 2, STRUCT, _f32)	\
 VARIANT (float64, 1, STRUCT, _f64)	\
 VARIANT (uint8, 16, STRUCT, q_u8)	\
@@ -51,6 +52,7 @@ VARIANT (int32, 4, STRUCT, q_s32)	\
 VARIANT (int64, 2, STRUCT, q_s64)	\
 VARIANT (poly8, 16, STRUCT, q_p8)	\
 VARIANT (poly16, 8, STRUCT, q_p16)	\
+VARIANT (float16, 8, STRUCT, q_f16)	\
 VARIANT (float32, 4, STRUCT, q_f32)	\
 VARIANT (float64, 2, STRUCT, q_f64)
 
--- a/src/gcc/testsuite/gcc.target/aarch64/vldN_dup_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/vldN_dup_1.c
@@ -16,6 +16,7 @@ VARIANT (int32, , 2, _s32, STRUCT)	\
 VARIANT (int64, , 1, _s64, STRUCT)	\
 VARIANT (poly8, , 8, _p8, STRUCT)	\
 VARIANT (poly16, , 4, _p16, STRUCT)	\
+VARIANT (float16, , 4, _f16, STRUCT)	\
 VARIANT (float32, , 2, _f32, STRUCT)	\
 VARIANT (float64, , 1, _f64, STRUCT)	\
 VARIANT (uint8, q, 16, _u8, STRUCT)	\
@@ -28,6 +29,7 @@ VARIANT (int32, q, 4, _s32, STRUCT)	\
 VARIANT (int64, q, 2, _s64, STRUCT)	\
 VARIANT (poly8, q, 16, _p8, STRUCT)	\
 VARIANT (poly16, q, 8, _p16, STRUCT)	\
+VARIANT (float16, q, 8, _f16, STRUCT)	\
 VARIANT (float32, q, 4, _f32, STRUCT)	\
 VARIANT (float64, q, 2, _f64, STRUCT)
 
@@ -74,6 +76,7 @@ main (int argc, char **argv)
   int64_t *int64_data = (int64_t *)uint64_data;
   poly8_t poly8_data[4] = { 0, 7, 13, 18, };
   poly16_t poly16_data[4] = { 11111, 2222, 333, 44 };
+  float16_t float16_data[4] = { 1.0625, 3.125, 0.03125, 7.75 };
   float32_t float32_data[4] = { 3.14159, 2.718, 1.414, 100.0 };
   float64_t float64_data[4] = { 1.010010001, 12345.6789, -9876.54321, 1.618 };
 
--- a/src/gcc/testsuite/gcc.target/aarch64/vldN_lane_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/vldN_lane_1.c
@@ -16,6 +16,7 @@ VARIANT (int32, , 2, _s32, 0, STRUCT)	\
 VARIANT (int64, , 1, _s64, 0, STRUCT)	\
 VARIANT (poly8, , 8, _p8, 7, STRUCT)	\
 VARIANT (poly16, , 4, _p16, 1, STRUCT)	\
+VARIANT (float16, , 4, _f16, 3, STRUCT)	\
 VARIANT (float32, , 2, _f32, 1, STRUCT)	\
 VARIANT (float64, , 1, _f64, 0, STRUCT)	\
 VARIANT (uint8, q, 16, _u8, 14, STRUCT)	\
@@ -28,6 +29,7 @@ VARIANT (int32, q, 4, _s32, 2, STRUCT)	\
 VARIANT (int64, q, 2, _s64, 1, STRUCT)	\
 VARIANT (poly8, q, 16, _p8, 12, STRUCT)	\
 VARIANT (poly16, q, 8, _p16, 5, STRUCT)	\
+VARIANT (float16, q, 8, _f16, 7, STRUCT)\
 VARIANT (float32, q, 4, _f32, 1, STRUCT)\
 VARIANT (float64, q, 2, _f64, 0, STRUCT)
 
@@ -54,11 +56,11 @@ test_vld##STRUCT##Q##_lane##SUFFIX (const BASE##_t *data,		\
 }
 
 
-/* Tests of vld2_dup and vld2q_dup.  */
+/* Tests of vld2_lane and vld2q_lane.  */
 VARIANTS (TESTMETH, 2)
-/* Tests of vld3_dup and vld3q_dup.  */
+/* Tests of vld3_lane and vld3q_lane.  */
 VARIANTS (TESTMETH, 3)
-/* Tests of vld4_dup and vld4q_dup.  */
+/* Tests of vld4_lane and vld4q_lane.  */
 VARIANTS (TESTMETH, 4)
 
 #define CHECK(BASE, Q, ELTS, SUFFIX, LANE, STRUCT)			\
@@ -71,7 +73,7 @@ main (int argc, char **argv)
 {
   /* Original data for all vector formats.  */
   uint64_t orig_data[8] = {0x1234567890abcdefULL, 0x13579bdf02468aceULL,
-			   0x012389ab4567cdefULL, 0xfeeddadacafe0431ULL,
+			   0x012389ab4567cdefULL, 0xdeeddadacafe0431ULL,
 			   0x1032547698badcfeULL, 0xbadbadbadbad0badULL,
 			   0x0102030405060708ULL, 0x0f0e0d0c0b0a0908ULL};
 
@@ -87,6 +89,7 @@ main (int argc, char **argv)
   int64_t *int64_data = (int64_t *)uint64_data;
   poly8_t poly8_data[4] = { 0, 7, 13, 18, };
   poly16_t poly16_data[4] = { 11111, 2222, 333, 44 };
+  float16_t float16_data[4] = { 0.8125, 7.5, 19, 0.046875 };
   float32_t float32_data[4] = { 3.14159, 2.718, 1.414, 100.0 };
   float64_t float64_data[4] = { 1.010010001, 12345.6789, -9876.54321, 1.618 };
 
--- a/src/gcc/testsuite/gcc.target/aarch64/vmov_n_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/vmov_n_1.c
@@ -346,4 +346,3 @@ main (int argc, char **argv)
   return 0;
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/vneg_f.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/vneg_f.c
@@ -267,4 +267,3 @@ main (int argc, char **argv)
   return 0;
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/vneg_s.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/vneg_s.c
@@ -298,4 +298,3 @@ main (int argc, char **argv)
   return 0;
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/vqabs_s64_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/vqabs_s64_1.c
@@ -51,4 +51,3 @@ main (int argc, char **argv)
 
   return 0;
 }
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/vqneg_s64_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/vqneg_s64_1.c
@@ -44,4 +44,3 @@ main (int argc, char **argv)
 
   return 0;
 }
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/vrecps.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/vrecps.c
@@ -141,4 +141,3 @@ main (int argc, char **argv)
   return 0;
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/vrecpx.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/vrecpx.c
@@ -51,4 +51,3 @@ main (int argc, char **argv)
   return 0;
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/vrnd_f64_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/vrnd_f64_1.c
@@ -102,4 +102,3 @@ main (int argc, char **argv)
 /* { dg-final { scan-assembler-times "frintm\\td\[0-9\]+, d\[0-9\]+" 1 } } */
 /* { dg-final { scan-assembler-times "frinti\\td\[0-9\]+, d\[0-9\]+" 1 } } */
 /* { dg-final { scan-assembler-times "frinta\\td\[0-9\]+, d\[0-9\]+" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/vset_lane_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/vset_lane_1.c
@@ -16,6 +16,7 @@ VARIANT (int32_t, , 2, int32x2_t, _s32, 0)	\
 VARIANT (int64_t, , 1, int64x1_t, _s64, 0)	\
 VARIANT (poly8_t, , 8, poly8x8_t, _p8, 6)	\
 VARIANT (poly16_t, , 4, poly16x4_t, _p16, 2)	\
+VARIANT (float16_t, , 4, float16x4_t, _f16, 3)	\
 VARIANT (float32_t, , 2, float32x2_t, _f32, 1)	\
 VARIANT (float64_t, , 1, float64x1_t, _f64, 0)	\
 VARIANT (uint8_t, q, 16, uint8x16_t, _u8, 11)	\
@@ -28,6 +29,7 @@ VARIANT (int32_t, q, 4, int32x4_t, _s32, 3)	\
 VARIANT (int64_t, q, 2, int64x2_t, _s64, 0)	\
 VARIANT (poly8_t, q, 16, poly8x16_t, _p8, 14)	\
 VARIANT (poly16_t, q, 8, poly16x8_t, _p16, 6)	\
+VARIANT (float16_t, q, 8, float16x8_t, _f16, 6)	\
 VARIANT (float32_t, q, 4, float32x4_t, _f32, 2) \
 VARIANT (float64_t, q, 2, float64x2_t, _f64, 1)
 
@@ -76,6 +78,9 @@ main (int argc, char **argv)
   poly8_t poly8_t_data[16] =
       { 0, 7, 13, 18, 22, 25, 27, 28, 29, 31, 34, 38, 43, 49, 56, 64 };
   poly16_t poly16_t_data[8] = { 11111, 2222, 333, 44, 5, 65432, 54321, 43210 };
+  float16_t float16_t_data[8] = { 1.25, 4.5, 7.875, 2.3125, 5.675, 8.875,
+      3.6875, 6.75};
+
   float32_t float32_t_data[4] = { 3.14159, 2.718, 1.414, 100.0 };
   float64_t float64_t_data[2] = { 1.01001000100001, 12345.6789 };
 
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/vstN_lane_1.c
@@ -0,0 +1,75 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -fno-inline" } */
+
+#include <arm_neon.h>
+
+extern void abort (void);
+
+#define VARIANTS(VARIANT, STRUCT)	\
+VARIANT (uint8, , 8, _u8, 6, STRUCT)	\
+VARIANT (uint16, , 4, _u16, 3, STRUCT)	\
+VARIANT (uint32, , 2, _u32, 1, STRUCT)	\
+VARIANT (uint64, , 1, _u64, 0, STRUCT)	\
+VARIANT (int8, , 8, _s8, 5, STRUCT)	\
+VARIANT (int16, , 4, _s16, 2, STRUCT)	\
+VARIANT (int32, , 2, _s32, 0, STRUCT)	\
+VARIANT (int64, , 1, _s64, 0, STRUCT)	\
+VARIANT (poly8, , 8, _p8, 7, STRUCT)	\
+VARIANT (poly16, , 4, _p16, 1, STRUCT)	\
+VARIANT (float32, , 2, _f32, 1, STRUCT)	\
+VARIANT (float64, , 1, _f64, 0, STRUCT)	\
+VARIANT (uint8, q, 16, _u8, 14, STRUCT)	\
+VARIANT (uint16, q, 8, _u16, 4, STRUCT)	\
+VARIANT (uint32, q, 4, _u32, 3, STRUCT)	\
+VARIANT (uint64, q, 2, _u64, 0, STRUCT)	\
+VARIANT (int8, q, 16, _s8, 13, STRUCT)	\
+VARIANT (int16, q, 8, _s16, 6, STRUCT)	\
+VARIANT (int32, q, 4, _s32, 2, STRUCT)	\
+VARIANT (int64, q, 2, _s64, 1, STRUCT)	\
+VARIANT (poly8, q, 16, _p8, 12, STRUCT)	\
+VARIANT (poly16, q, 8, _p16, 5, STRUCT)	\
+VARIANT (float32, q, 4, _f32, 1, STRUCT)\
+VARIANT (float64, q, 2, _f64, 0, STRUCT)
+
+#define TESTMETH(BASE, Q, ELTS, SUFFIX, LANE, STRUCT)			\
+int									\
+test_vst##STRUCT##Q##_lane##SUFFIX (const BASE##_t *data)		\
+{									\
+  BASE##x##ELTS##x##STRUCT##_t vectors;					\
+  for (int i = 0; i < STRUCT; i++, data += ELTS)			\
+    vectors.val[i] = vld1##Q##SUFFIX (data);				\
+  BASE##_t temp[STRUCT];						\
+  vst##STRUCT##Q##_lane##SUFFIX (temp, vectors, LANE);			\
+  for (int i = 0; i < STRUCT; i++)					\
+    {									\
+      if (temp[i] != vget##Q##_lane##SUFFIX (vectors.val[i], LANE))	\
+	return 1;							\
+    }									\
+  return 0;								\
+}
+
+/* Tests of vst2_lane and vst2q_lane.  */
+VARIANTS (TESTMETH, 2)
+/* Tests of vst3_lane and vst3q_lane.  */
+VARIANTS (TESTMETH, 3)
+/* Tests of vst4_lane and vst4q_lane.  */
+VARIANTS (TESTMETH, 4)
+
+#define CHECK(BASE, Q, ELTS, SUFFIX, LANE, STRUCT)			\
+  if (test_vst##STRUCT##Q##_lane##SUFFIX ((const BASE##_t *)orig_data))	\
+    abort ();
+
+int
+main (int argc, char **argv)
+{
+  /* Original data for all vector formats.  */
+  uint64_t orig_data[8] = {0x1234567890abcdefULL, 0x13579bdf02468aceULL,
+			   0x012389ab4567cdefULL, 0xfeeddadacafe0431ULL,
+			   0x1032547698badcfeULL, 0xbadbadbadbad0badULL,
+			   0x0102030405060708ULL, 0x0f0e0d0c0b0a0908ULL};
+
+  VARIANTS (CHECK, 2);
+  VARIANTS (CHECK, 3);
+  VARIANTS (CHECK, 4);
+  return 0;
+}
--- a/src/gcc/testsuite/gcc.target/aarch64/vsub_f64.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/vsub_f64.c
@@ -81,4 +81,3 @@ main (int argc, char **argv)
   return 0;
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/20131120.c
+++ b/src/gcc/testsuite/gcc.target/arm/20131120.c
@@ -11,4 +11,3 @@ foo (Arr2 a2, int i)
 }
 
 /* { dg-final { scan-rtl-dump-not "\\\(set \\\(reg:SI \[0-9\]*\\\)\[\n\r\]+\[ \t]*\\\(const_int 4000" "expand" } } */
-/* { dg-final { cleanup-rtl-dump "expand" } } */
--- a/src/gcc/testsuite/gcc.target/arm/acle/crc32b.c
+++ b/src/gcc/testsuite/gcc.target/arm/acle/crc32b.c
@@ -17,4 +17,3 @@ void test_crc32b (void)
 }
 
 /* { dg-final { scan-assembler "crc32b\t...?, ...?, ...?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/acle/crc32cb.c
+++ b/src/gcc/testsuite/gcc.target/arm/acle/crc32cb.c
@@ -17,4 +17,3 @@ void test_crc32cb (void)
 }
 
 /* { dg-final { scan-assembler "crc32cb\t...?, ...?, ...?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/acle/crc32cd.c
+++ b/src/gcc/testsuite/gcc.target/arm/acle/crc32cd.c
@@ -17,4 +17,3 @@ void test_crc32cd (void)
 }
 
 /* { dg-final { scan-assembler-times "crc32cw\t...?, ...?, ...?\n" 2 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/acle/crc32ch.c
+++ b/src/gcc/testsuite/gcc.target/arm/acle/crc32ch.c
@@ -17,4 +17,3 @@ void test_crc32ch (void)
 }
 
 /* { dg-final { scan-assembler "crc32ch\t...?, ...?, ...?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/acle/crc32cw.c
+++ b/src/gcc/testsuite/gcc.target/arm/acle/crc32cw.c
@@ -17,4 +17,3 @@ void test_crc32cw (void)
 }
 
 /* { dg-final { scan-assembler "crc32cw\t...?, ...?, ...?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/acle/crc32d.c
+++ b/src/gcc/testsuite/gcc.target/arm/acle/crc32d.c
@@ -17,4 +17,3 @@ void test_crc32d (void)
 }
 
 /* { dg-final { scan-assembler-times "crc32w\t...?, ...?, ...?\n" 2 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/acle/crc32h.c
+++ b/src/gcc/testsuite/gcc.target/arm/acle/crc32h.c
@@ -17,4 +17,3 @@ void test_crc32h (void)
 }
 
 /* { dg-final { scan-assembler "crc32h\t...?, ...?, ...?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/acle/crc32w.c
+++ b/src/gcc/testsuite/gcc.target/arm/acle/crc32w.c
@@ -17,4 +17,3 @@ void test_crc32w (void)
 }
 
 /* { dg-final { scan-assembler "crc32w\t...?, ...?, ...?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/anddi_notdi-1.c
+++ b/src/gcc/testsuite/gcc.target/arm/anddi_notdi-1.c
@@ -63,4 +63,3 @@ int main ()
 /* { dg-final { scan-assembler-times "bics\t" 6 { target arm_thumb1 } } } */
 /* { dg-final { scan-assembler-times "bic\t" 6 { target { ! arm_thumb1 } } } } */
 
-/* { dg-final { cleanup-saved-temps } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/arm/attr_arm-err.c
@@ -0,0 +1,13 @@
+/* Check that attribute target arm is rejected for M profile.  */
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_arm_ok } */
+/* { dg-skip-if "avoid conflicting multilib options" { *-*-* } { "-march=*" } { "-march=armv6-m" } } */
+/* { dg-add-options arm_arch_v6m } */
+
+int __attribute__((target("arm")))
+foo(int a)
+{  /* { dg-error "does not support" } */
+  return a ? 1 : 5;
+}
+
+
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/arm/attr_arm.c
@@ -0,0 +1,11 @@
+/* Check that attribute target arm is recognized.  */
+/* { dg-do compile } */
+/* { dg-final { scan-assembler "\\.arm" } } */
+/* { dg-final { scan-assembler-not "\\.thumb_func" } } */
+
+int __attribute__((target("arm")))
+foo(int a)
+{
+  return a ? 1 : 5;
+}
+
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/arm/attr_thumb-static.c
@@ -0,0 +1,25 @@
+/* Check that a change mode to a static function is correctly handled. */
+/* { dg-do run } */
+
+static void
+ __attribute__((__noinline__)) 
+foo (void)
+{
+  __asm__ ("");
+}
+
+static void
+__attribute__((__noinline__)) 
+__attribute__((target("thumb")))
+bar (void)
+{
+  __asm__ ("");
+}
+
+int
+main (void)
+{
+  foo();
+  bar();
+  return 0;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/arm/attr_thumb-static2.c
@@ -0,0 +1,40 @@
+/* Check interwork between static functions for thumb2. */
+
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_arch_v7a_ok } */
+/* { dg-options "-O0 -march=armv7-a" } */
+
+struct _NSPoint
+{
+  float x;
+  float y;
+};
+
+typedef struct _NSPoint NSPoint;
+
+static NSPoint
+__attribute__ ((target("arm")))
+NSMakePoint (float x, float y)
+{
+  NSPoint point;
+  point.x = x;
+  point.y = y;
+  return point;
+}
+
+static NSPoint
+__attribute__ ((target("thumb")))
+RelativePoint (NSPoint point, NSPoint refPoint)
+{
+  return NSMakePoint (refPoint.x + point.x, refPoint.y + point.y);
+}
+
+NSPoint
+__attribute__ ((target("arm")))
+g(NSPoint refPoint)
+{
+  float pointA, pointB;
+  return RelativePoint (NSMakePoint (0, pointA), refPoint);
+}
+
+/* { dg-final { scan-assembler-times "blx" 2 } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/arm/attr_thumb.c
@@ -0,0 +1,15 @@
+/* Check that attribute target thumb is recognized. */
+/* { dg-do compile } */
+/* Make sure the current multilib supports thumb.  */
+/* { dg-skip-if "" { ! { arm_thumb1_ok || arm_thumb2_ok } } } */
+/* { dg-options "-O2 -mno-restrict-it" } */
+/* { dg-final { scan-assembler-not "\\.arm"  } } */
+/* { dg-final { scan-assembler "\\.thumb_func" } } */
+
+int __attribute__((target("thumb")))
+foo(int a)
+{
+  /* { dg-final { scan-assembler "ite" { target { arm_thumb2_ok } } } } */
+  return a ? 1 : 5;
+}
+
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/arm/bics_1.c
@@ -0,0 +1,53 @@
+/* { dg-do run } */
+/* { dg-options "-O2 --save-temps -fno-inline" } */
+/* { dg-require-effective-target arm32 } */
+
+extern void abort (void);
+
+int
+bics_si_test1 (int a, int b, int c)
+{
+  int d = a & ~b;
+
+  /* { dg-final { scan-assembler-times "bics\tr\[0-9\]+, r\[0-9\]+, r\[0-9\]+" 2 } } */
+  if (d == 0)
+    return a + c;
+  else
+    return b + d + c;
+}
+
+int
+bics_si_test2 (int a, int b, int c)
+{
+  int d = a & ~(b << 3);
+
+  /* { dg-final { scan-assembler-times "bics\tr\[0-9\]+, r\[0-9\]+, r\[0-9\]+, .sl \#3" 1 } } */
+  if (d == 0)
+    return a + c;
+  else
+    return b + d + c;
+}
+
+int
+main ()
+{
+  int x;
+
+  x = bics_si_test1 (29, ~4, 5);
+  if (x != ((29 & 4) + ~4 + 5))
+    abort ();
+
+  x = bics_si_test1 (5, ~2, 20);
+  if (x != 25)
+    abort ();
+
+    x = bics_si_test2 (35, ~4, 5);
+  if (x != ((35 & ~(~4 << 3)) + ~4 + 5))
+    abort ();
+
+  x = bics_si_test2 (96, ~2, 20);
+  if (x != 116)
+  abort ();
+
+  return 0;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/arm/bics_2.c
@@ -0,0 +1,56 @@
+/* { dg-do run } */
+/* { dg-options "-O2 --save-temps -fno-inline" } */
+/* { dg-require-effective-target arm32 } */
+
+extern void abort (void);
+
+int
+bics_si_test1 (int a, int b, int c)
+{
+  int d = a & ~b;
+
+  /* { dg-final { scan-assembler-not "bics\tr\[0-9\]+, r\[0-9\]+, r\[0-9\]+" } } */
+  /* { dg-final { scan-assembler-times "bic\tr\[0-9\]+, r\[0-9\]+, r\[0-9\]+" 2 } } */
+  if (d <= 0)
+    return a + c;
+  else
+    return b + d + c;
+}
+
+int
+bics_si_test2 (int a, int b, int c)
+{
+  int d = a & ~(b << 3);
+
+  /* { dg-final { scan-assembler-not "bics\tr\[0-9\]+, r\[0-9\]+, r\[0-9\]+, .sl \#3" } } */
+  /* { dg-final { scan-assembler "bic\tr\[0-9\]+, r\[0-9\]+, r\[0-9\]+, .sl \#3" } } */
+  if (d <= 0)
+    return a + c;
+  else
+    return b + d + c;
+}
+
+int
+main ()
+{
+  int x;
+
+  x = bics_si_test1 (29, ~4, 5);
+  if (x != ((29 & 4) + ~4 + 5))
+    abort ();
+
+  x = bics_si_test1 (5, ~2, 20);
+  if (x != 25)
+    abort ();
+
+  x = bics_si_test2 (35, ~4, 5);
+  if (x != ((35 & ~(~4 << 3)) + ~4 + 5))
+    abort ();
+
+  x = bics_si_test2 (96, ~2, 20);
+  if (x != 116)
+    abort ();
+
+  return 0;
+}
+
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/arm/bics_3.c
@@ -0,0 +1,40 @@
+/* { dg-do run } */
+/* { dg-options "-O2 --save-temps -fno-inline" } */
+/* { dg-require-effective-target arm32 } */
+
+extern void abort (void);
+
+int
+bics_si_test (int a, int b)
+{
+  if (a & ~b)
+    return 1;
+  else
+    return 0;
+}
+
+int
+bics_si_test2 (int a, int b)
+{
+  if (a & ~ (b << 2))
+    return 1;
+  else
+    return 0;
+}
+
+int
+main (void)
+{
+  int a = 5;
+  int b = 5;
+  int c = 20;
+  if (bics_si_test (a, b))
+    abort ();
+  if (bics_si_test2 (c, b))
+    abort ();
+  return 0;
+}
+
+/* { dg-final { scan-assembler-times "bics\tr\[0-9\]+, r\[0-9\]+, r\[0-9\]+" 2 } } */
+/* { dg-final { scan-assembler-times "bics\tr\[0-9\]+, r\[0-9\]+, r\[0-9\]+, .sl #2" 1 } } */
+
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/arm/bics_4.c
@@ -0,0 +1,48 @@
+/* { dg-do run } */
+/* { dg-options "-O2 --save-temps -fno-inline" } */
+/* { dg-require-effective-target arm32 } */
+
+extern void abort (void);
+
+int
+bics_si_test1 (int a, int b, int c)
+{
+  if ((a & b) == a)
+    return a;
+  else
+    return c;
+}
+
+int
+bics_si_test2 (int a, int b, int c)
+{
+  if ((a & b) == b)
+    return b;
+  else
+    return c;
+}
+
+int
+main ()
+{
+  int x;
+  x = bics_si_test1 (0xf00d, 0xf11f, 0);
+  if (x != 0xf00d)
+    abort ();
+
+  x = bics_si_test1 (0xf11f, 0xf00d, 0);
+  if (x != 0)
+    abort ();
+
+  x = bics_si_test2 (0xf00d, 0xf11f, 0);
+  if (x != 0)
+    abort ();
+
+  x = bics_si_test2 (0xf11f, 0xf00d, 0);
+  if (x != 0xf00d)
+    abort ();
+
+  return 0;
+}
+
+/* { dg-final { scan-assembler-times "bics\tr\[0-9\]+, r\[0-9\]+, r\[0-9\]+" 2 } } */
--- a/src/gcc/testsuite/gcc.target/arm/copysign_softfloat_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/copysign_softfloat_1.c
@@ -58,4 +58,3 @@ main (int argc, char **argv)
   return 0;
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/divzero.c
+++ b/src/gcc/testsuite/gcc.target/arm/divzero.c
@@ -1,6 +1,6 @@
+/* { dg-do run } */
 /* { dg-require-effective-target arm_eabi } */
 /* { dg-options "" } */
-/* { dg-do run } */
 
 /* Check that long long divmod functions pass the right argument to
    __aeabi_ldiv0 on divide by zero.  */
--- a/src/gcc/testsuite/gcc.target/arm/fixed_float_conversion.c
+++ b/src/gcc/testsuite/gcc.target/arm/fixed_float_conversion.c
@@ -3,6 +3,7 @@
 /* { dg-require-effective-target arm_vfp3_ok } */
 /* { dg-options "-O1" } */
 /* { dg-add-options arm_vfp3 } */
+/* { dg-skip-if "need fp instructions" { *-*-* } { "-mfloat-abi=soft" } { "" } } */
 
 float
 fixed_to_float (int i)
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/arm/flip-thumb.c
@@ -0,0 +1,26 @@
+/* Check -mflip-thumb. */
+/* { dg-do compile } */
+/* Make sure the current multilib supports thumb.  */
+/* { dg-skip-if "" { ! { arm_thumb1_ok || arm_thumb2_ok } } } */
+/* { dg-options "-O2 -mflip-thumb -mno-restrict-it" } */
+/* { dg-final { scan-assembler "\\.arm" } } */
+/* { dg-final { scan-assembler-times "\\.thumb_func" 1} } */
+
+int 
+foo(int a)
+{
+  return a ? 1 : 5;
+}
+
+int 
+bar(int a)
+{
+  return a ? 1 : 5;
+}
+
+/* { dg-final { scan-assembler-times "ite" 1 { target { arm_thumb2_ok } } } } */
+
+
+
+
+
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/arm/fp16-inf.c
@@ -0,0 +1,14 @@
+/* { dg-do run } */
+/* { dg-options "-O -mfp16-format=ieee" } */
+
+/* Conversion of infinity to __fp16 and back again should preserve the
+   value.  */
+volatile float f = __builtin_inf ();
+
+int main ()
+{
+  __fp16 h = f;
+  if (h != __builtin_inf ())
+    __builtin_abort ();
+  return 0;
+}
--- a/src/gcc/testsuite/gcc.target/arm/identical-invariants.c
+++ b/src/gcc/testsuite/gcc.target/arm/identical-invariants.c
@@ -25,5 +25,4 @@ int foo (int a, int b, int c, int d)
 }
 
 /* { dg-final { scan-rtl-dump "Decided to move invariant 0" "loop2_invariant" } } */
-/* { dg-final { cleanup-rtl-dump "loop2_invariant" } } */
 
--- a/src/gcc/testsuite/gcc.target/arm/iordi_notdi-1.c
+++ b/src/gcc/testsuite/gcc.target/arm/iordi_notdi-1.c
@@ -62,4 +62,3 @@ int main ()
 
 /* { dg-final { scan-assembler-times "orn\t" 6 { target arm_thumb2 } } } */
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/ivopts-2.c
+++ b/src/gcc/testsuite/gcc.target/arm/ivopts-2.c
@@ -15,5 +15,3 @@ tr4 (short array[], int n)
 /* { dg-final { scan-tree-dump-times "PHI <ivtmp" 1 "ivopts"} } */
 /* { dg-final { scan-tree-dump-times "PHI <" 1 "ivopts"} } */
 /* { dg-final { object-size text <= 26 { target arm_thumb2 } } } */
-/* { dg-final { cleanup-tree-dump "ivopts" } } */
-/* { dg-final { cleanup-saved-temps "ivopts" } } */
--- a/src/gcc/testsuite/gcc.target/arm/ivopts-3.c
+++ b/src/gcc/testsuite/gcc.target/arm/ivopts-3.c
@@ -17,5 +17,3 @@ tr3 (short array[], unsigned int n)
 /* { dg-final { scan-tree-dump-times "PHI <x" 0 "ivopts"} } */
 /* { dg-final { scan-tree-dump-times ", x" 0 "ivopts"} } */
 /* { dg-final { object-size text <= 30 { target arm_thumb2 } } } */
-/* { dg-final { cleanup-tree-dump "ivopts" } } */
-/* { dg-final { cleanup-saved-temps "ivopts" } } */
--- a/src/gcc/testsuite/gcc.target/arm/ivopts-4.c
+++ b/src/gcc/testsuite/gcc.target/arm/ivopts-4.c
@@ -18,5 +18,3 @@ tr2 (int array[], int n)
 /* { dg-final { scan-tree-dump-times "PHI <x" 0 "ivopts"} } */
 /* { dg-final { scan-tree-dump-times ", x" 0 "ivopts"} } */
 /* { dg-final { object-size text <= 36 { target arm_thumb2 } } } */
-/* { dg-final { cleanup-tree-dump "ivopts" } } */
-/* { dg-final { cleanup-saved-temps "ivopts" } } */
--- a/src/gcc/testsuite/gcc.target/arm/ivopts-5.c
+++ b/src/gcc/testsuite/gcc.target/arm/ivopts-5.c
@@ -17,5 +17,3 @@ tr1 (int array[], unsigned int n)
 /* { dg-final { scan-tree-dump-times "PHI <x" 0 "ivopts"} } */
 /* { dg-final { scan-tree-dump-times ", x" 0 "ivopts"} } */
 /* { dg-final { object-size text <= 30 { target arm_thumb2 } } } */
-/* { dg-final { cleanup-tree-dump "ivopts" } } */
-/* { dg-final { cleanup-saved-temps "ivopts" } } */
--- a/src/gcc/testsuite/gcc.target/arm/ivopts-orig_biv-inc.c
+++ b/src/gcc/testsuite/gcc.target/arm/ivopts-orig_biv-inc.c
@@ -16,4 +16,3 @@ unsigned char * foo(unsigned char *ReadPtr)
 }
 
 /* { dg-final { scan-tree-dump-times "original biv" 2 "ivopts"} } */
-/* { dg-final { cleanup-tree-dump "ivopts" } } */
--- a/src/gcc/testsuite/gcc.target/arm/ivopts.c
+++ b/src/gcc/testsuite/gcc.target/arm/ivopts.c
@@ -14,5 +14,3 @@ tr5 (short array[], int n)
 /* { dg-final { object-size text <= 20 { target arm_thumb2 } } } */
 /* { dg-final { object-size text <= 32 { target { arm_nothumb && { ! arm_iwmmxt_ok } } } } } */
 /* { dg-final { object-size text <= 36 { target { arm_nothumb && arm_iwmmxt_ok }  } } } */
-/* { dg-final { cleanup-tree-dump "ivopts" } } */
-/* { dg-final { cleanup-saved-temps "ivopts" } } */
--- a/src/gcc/testsuite/gcc.target/arm/lp1243022.c
+++ b/src/gcc/testsuite/gcc.target/arm/lp1243022.c
@@ -2,7 +2,6 @@
 /* { dg-options "-O2 -fdump-rtl-subreg2" } */
 
 /* { dg-final { scan-rtl-dump "REG_INC" "subreg2" { target { ! arm_neon } } } } */
-/* { dg-final { cleanup-rtl-dump "subreg2" } } */
 struct device;
 typedef unsigned int __u32;
 typedef unsigned long long u64;
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/arm/maskdata.c
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+/* { dg-options " -O2" }  */
+/* { dg-require-effective-target arm_thumb2_ok } */
+
+#define MASK 0xff00ff
+void maskdata (int * data, int len)
+{
+   int i = len;
+   for (; i > 0; i -= 2)
+    {
+      data[i] &= MASK;
+      data[i + 1] &= MASK;
+    }
+}
+/* { dg-final { scan-assembler-not "65280" } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/arm/memcpy-aligned-1.c
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -save-temps" } */
+
+void *memcpy (void *dest, const void *src, unsigned int n);
+
+void foo (char *dst, int i)
+{
+  memcpy (dst, &i, sizeof (i));
+}
+
+/* { dg-final { scan-assembler-times "str\t" 1 } } */
+/* { dg-final { scan-assembler-not "ldr\t" } } */
--- a/src/gcc/testsuite/gcc.target/arm/memset-inline-1.c
+++ b/src/gcc/testsuite/gcc.target/arm/memset-inline-1.c
@@ -36,4 +36,3 @@ main(void)
 }
 
 /* { dg-final { scan-assembler-not "bl?\[ \t\]*memset" { target { arm_thumb2_ok } } } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/memset-inline-10.c
+++ b/src/gcc/testsuite/gcc.target/arm/memset-inline-10.c
@@ -1,5 +1,7 @@
 /* { dg-do compile } */
 /* { dg-options "-march=armv7-a -mfloat-abi=hard -mfpu=neon -O2" } */
+/* { dg-skip-if "need SIMD instructions" { *-*-* } { "-mfloat-abi=soft" } { "" } } */
+/* { dg-skip-if "need SIMD instructions" { *-*-* } { "-mfpu=vfp*" } { "" } } */
 
 #define BUF 100
 long a[BUF];
--- a/src/gcc/testsuite/gcc.target/arm/memset-inline-2.c
+++ b/src/gcc/testsuite/gcc.target/arm/memset-inline-2.c
@@ -35,4 +35,3 @@ main(void)
   return 0;
 }
 /* { dg-final { scan-assembler "bl?\[ \t\]*memset" { target { ! arm_neon } } } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/memset-inline-4.c
+++ b/src/gcc/testsuite/gcc.target/arm/memset-inline-4.c
@@ -64,4 +64,3 @@ main(void)
 /* { dg-final { scan-assembler-not "bl?\[ \t\]+memset" { target { ! arm_thumb1_ok } } } } */
 /* { dg-final { scan-assembler-times "vst1\.8" 1 { target { arm_little_endian && arm_neon } } } } */
 /* { dg-final { scan-assembler "vstr" { target { arm_little_endian && arm_neon } } } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/memset-inline-5.c
+++ b/src/gcc/testsuite/gcc.target/arm/memset-inline-5.c
@@ -73,5 +73,4 @@ main(void)
 /* { dg-final { scan-assembler-not "bl?\[ \t\]+memset" { target { arm_little_endian && arm_neon } } } } */
 /* { dg-final { scan-assembler "vst1" { target { arm_little_endian && arm_neon } } } } */
 /* { dg-final { scan-assembler-not "vstr"  { target { arm_little_endian && arm_neon } } } } */
-/* { dg-final { cleanup-saved-temps } } */
 
--- a/src/gcc/testsuite/gcc.target/arm/memset-inline-6.c
+++ b/src/gcc/testsuite/gcc.target/arm/memset-inline-6.c
@@ -62,6 +62,5 @@ main(void)
 /* { dg-final { scan-assembler-not "bl?\[ \t\]+memset" { target { arm_little_endian && arm_neon } } } } */
 /* { dg-final { scan-assembler-times "vst1" 3 { target { arm_little_endian && arm_neon } } } } */
 /* { dg-final { scan-assembler-times "vstr" 4 { target { arm_little_endian && arm_neon } } } } */
-/* { dg-final { cleanup-saved-temps } } */
 
 
--- a/src/gcc/testsuite/gcc.target/arm/memset-inline-8.c
+++ b/src/gcc/testsuite/gcc.target/arm/memset-inline-8.c
@@ -40,4 +40,3 @@ main(void)
 /* { dg-final { scan-assembler-not "bl?\[ \t\]*memset" { target { arm_thumb2_ok } } } } */
 /* { dg-final { scan-assembler "vst1" { target { arm_little_endian && arm_neon } } } } */
 /* { dg-final { scan-assembler-not "vstr" { target { arm_little_endian && arm_neon } } } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/memset-inline-9.c
+++ b/src/gcc/testsuite/gcc.target/arm/memset-inline-9.c
@@ -38,4 +38,3 @@ main(void)
 }
 /* { dg-final { scan-assembler-not "bl?\[ \t\]*memset" { target { arm_little_endian && arm_neon } } } } */
 /* { dg-final { scan-assembler "vst1" { target { arm_little_endian && arm_neon } } } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon-reload-class.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon-reload-class.c
@@ -15,4 +15,4 @@ _op_blend_p_caa_dp(unsigned *s, unsigned* e, unsigned *d, unsigned c) {
 
 /* These constants should be emitted as immediates rather than loaded from memory.  */
 
-/* { dg-final { scan-assembler-not "(\\.d?word|mov(w|t))" } } */
+/* { dg-final { scan-assembler-not "(\\.d?word)" } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon-vdup-1.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon-vdup-1.c
@@ -14,4 +14,3 @@ void test_vdupq_nf32 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.f32\[ 	\]+\[qQ\]\[0-9\]+, #0\.0\(\[ \]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon-vdup-10.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon-vdup-10.c
@@ -14,4 +14,3 @@ void test_vdupq_nu32 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.i32\[ 	\]+\[qQ\]\[0-9\]+, #3992977407\(\[ \]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon-vdup-11.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon-vdup-11.c
@@ -14,4 +14,3 @@ void test_vdupq_nu16 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.i16\[ 	\]+\[qQ\]\[0-9\]+, #18\(\[ \]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon-vdup-12.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon-vdup-12.c
@@ -14,4 +14,3 @@ void test_vdupq_nu16 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.i16\[ 	\]+\[qQ\]\[0-9\]+, #4608\(\[ \]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon-vdup-13.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon-vdup-13.c
@@ -14,4 +14,3 @@ void test_vdupq_nu16 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.i16\[ 	\]+\[qQ\]\[0-9\]+, #65517\(\[ \]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon-vdup-14.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon-vdup-14.c
@@ -14,4 +14,3 @@ void test_vdupq_nu16 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.i16\[ 	\]+\[qQ\]\[0-9\]+, #60927\(\[ \]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon-vdup-15.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon-vdup-15.c
@@ -14,4 +14,3 @@ void test_vdupq_nu8 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.i8\[ 	\]+\[qQ\]\[0-9\]+, #18\(\[ \]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon-vdup-16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon-vdup-16.c
@@ -14,4 +14,3 @@ void test_vdupq_nu32 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.i32\[ 	\]+\[qQ\]\[0-9\]+, #4863\(\[ \]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon-vdup-17.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon-vdup-17.c
@@ -14,4 +14,3 @@ void test_vdupq_nu32 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.i32\[ 	\]+\[qQ\]\[0-9\]+, #1245183\(\[ \]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon-vdup-18.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon-vdup-18.c
@@ -14,4 +14,3 @@ void test_vdupq_nu32 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.i32\[ 	\]+\[qQ\]\[0-9\]+, #4294962432\(\[ \]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon-vdup-19.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon-vdup-19.c
@@ -14,4 +14,3 @@ void test_vdupq_nu32 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.i32\[ 	\]+\[qQ\]\[0-9\]+, #4293722112\(\[ \]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon-vdup-2.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon-vdup-2.c
@@ -14,4 +14,3 @@ void test_vdupq_nf32 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.f32\[ 	\]+\[qQ\]\[0-9\]+, #1\.25e-1\(\[ \]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon-vdup-3.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon-vdup-3.c
@@ -14,4 +14,3 @@ void test_vdupq_nu32 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.i32\[ 	\]+\[qQ\]\[0-9\]+, #18\(\[ \]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon-vdup-4.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon-vdup-4.c
@@ -14,4 +14,3 @@ void test_vdupq_nu32 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.i32\[ 	\]+\[qQ\]\[0-9\]+, #4608\(\[ \]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon-vdup-5.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon-vdup-5.c
@@ -14,4 +14,3 @@ void test_vdupq_nu32 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.i32\[ 	\]+\[qQ\]\[0-9\]+, #1179648\(\[ \]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon-vdup-6.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon-vdup-6.c
@@ -14,4 +14,3 @@ void test_vdupq_nu32 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.i32\[ 	\]+\[qQ\]\[0-9\]+, #301989888\(\[ \]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon-vdup-7.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon-vdup-7.c
@@ -14,4 +14,3 @@ void test_vdupq_nu32 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.i32\[ 	\]+\[qQ\]\[0-9\]+, #4294967277\(\[ \]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon-vdup-8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon-vdup-8.c
@@ -14,4 +14,3 @@ void test_vdupq_nu32 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.i32\[ 	\]+\[qQ\]\[0-9\]+, #4294962687\(\[ \]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon-vdup-9.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon-vdup-9.c
@@ -14,4 +14,3 @@ void test_vdupq_nu32 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.i32\[ 	\]+\[qQ\]\[0-9\]+, #4293787647\(\[ \]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/pr51534.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/pr51534.c
@@ -58,18 +58,18 @@ GEN_COND_TESTS(vceq)
 /* { dg-final { scan-assembler-times "vcge\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+" 2 } } */
 /* { dg-final { scan-assembler "vcge\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #0" } } */
 /* { dg-final { scan-assembler-times "vcge\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+" 2 } } */
-/* { dg-final { scan-assembler "vcgt\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+" } } */
-/* { dg-final { scan-assembler "vcgt\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+" } } */
-/* { dg-final { scan-assembler "vcgt\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+" } } */
-/* { dg-final { scan-assembler "vcgt\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+" } } */
-/* { dg-final { scan-assembler "vcgt\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+" } } */
-/* { dg-final { scan-assembler "vcgt\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+" } } */
-/* { dg-final { scan-assembler "vcge\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+" } } */
-/* { dg-final { scan-assembler "vcge\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+" } } */
-/* { dg-final { scan-assembler "vcge\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+" } } */
-/* { dg-final { scan-assembler "vcge\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+" } } */
-/* { dg-final { scan-assembler "vcge\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+" } } */
-/* { dg-final { scan-assembler "vcge\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+" } } */
+/* { dg-final { scan-assembler "vclt\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #0" } } */
+/* { dg-final { scan-assembler "vclt\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #0" } } */
+/* { dg-final { scan-assembler "vclt\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #0" } } */
+/* { dg-final { scan-assembler "vclt\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #0" } } */
+/* { dg-final { scan-assembler "vclt\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #0" } } */
+/* { dg-final { scan-assembler "vclt\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #0" } } */
+/* { dg-final { scan-assembler "vcle\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #0" } } */
+/* { dg-final { scan-assembler "vcle\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #0" } } */
+/* { dg-final { scan-assembler "vcle\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #0" } } */
+/* { dg-final { scan-assembler "vcle\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #0" } } */
+/* { dg-final { scan-assembler "vcle\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #0" } } */
+/* { dg-final { scan-assembler "vcle\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #0" } } */
 /* { dg-final { scan-assembler-times "vceq\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #0" 2 } } */
 /* { dg-final { scan-assembler-times "vceq\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #0" 2 } } */
 /* { dg-final { scan-assembler-times "vceq\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #0" 2 } } */
@@ -81,4 +81,3 @@ GEN_COND_TESTS(vceq)
 /* { dg-final { scan-assembler-not "vc\[gl\]\[te\]\.u\[0-9\]+\[ 	\]+\[qQdD\]\[0-9\]+, \[qQdD\]\[0-9\]+, #0" } } */
 
 /* Tidy up.  */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRaddhns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRaddhns16.c
@@ -18,4 +18,3 @@ void test_vRaddhns16 (void)
 }
 
 /* { dg-final { scan-assembler "vraddhn\.i16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRaddhns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRaddhns32.c
@@ -18,4 +18,3 @@ void test_vRaddhns32 (void)
 }
 
 /* { dg-final { scan-assembler "vraddhn\.i32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRaddhns64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRaddhns64.c
@@ -18,4 +18,3 @@ void test_vRaddhns64 (void)
 }
 
 /* { dg-final { scan-assembler "vraddhn\.i64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRaddhnu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRaddhnu16.c
@@ -18,4 +18,3 @@ void test_vRaddhnu16 (void)
 }
 
 /* { dg-final { scan-assembler "vraddhn\.i16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRaddhnu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRaddhnu32.c
@@ -18,4 +18,3 @@ void test_vRaddhnu32 (void)
 }
 
 /* { dg-final { scan-assembler "vraddhn\.i32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRaddhnu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRaddhnu64.c
@@ -18,4 +18,3 @@ void test_vRaddhnu64 (void)
 }
 
 /* { dg-final { scan-assembler "vraddhn\.i64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRhaddQs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRhaddQs16.c
@@ -18,4 +18,3 @@ void test_vRhaddQs16 (void)
 }
 
 /* { dg-final { scan-assembler "vrhadd\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRhaddQs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRhaddQs32.c
@@ -18,4 +18,3 @@ void test_vRhaddQs32 (void)
 }
 
 /* { dg-final { scan-assembler "vrhadd\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRhaddQs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRhaddQs8.c
@@ -18,4 +18,3 @@ void test_vRhaddQs8 (void)
 }
 
 /* { dg-final { scan-assembler "vrhadd\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRhaddQu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRhaddQu16.c
@@ -18,4 +18,3 @@ void test_vRhaddQu16 (void)
 }
 
 /* { dg-final { scan-assembler "vrhadd\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRhaddQu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRhaddQu32.c
@@ -18,4 +18,3 @@ void test_vRhaddQu32 (void)
 }
 
 /* { dg-final { scan-assembler "vrhadd\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRhaddQu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRhaddQu8.c
@@ -18,4 +18,3 @@ void test_vRhaddQu8 (void)
 }
 
 /* { dg-final { scan-assembler "vrhadd\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRhadds16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRhadds16.c
@@ -18,4 +18,3 @@ void test_vRhadds16 (void)
 }
 
 /* { dg-final { scan-assembler "vrhadd\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRhadds32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRhadds32.c
@@ -18,4 +18,3 @@ void test_vRhadds32 (void)
 }
 
 /* { dg-final { scan-assembler "vrhadd\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRhadds8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRhadds8.c
@@ -18,4 +18,3 @@ void test_vRhadds8 (void)
 }
 
 /* { dg-final { scan-assembler "vrhadd\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRhaddu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRhaddu16.c
@@ -18,4 +18,3 @@ void test_vRhaddu16 (void)
 }
 
 /* { dg-final { scan-assembler "vrhadd\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRhaddu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRhaddu32.c
@@ -18,4 +18,3 @@ void test_vRhaddu32 (void)
 }
 
 /* { dg-final { scan-assembler "vrhadd\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRhaddu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRhaddu8.c
@@ -18,4 +18,3 @@ void test_vRhaddu8 (void)
 }
 
 /* { dg-final { scan-assembler "vrhadd\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRshlQs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRshlQs16.c
@@ -18,4 +18,3 @@ void test_vRshlQs16 (void)
 }
 
 /* { dg-final { scan-assembler "vrshl\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRshlQs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRshlQs32.c
@@ -18,4 +18,3 @@ void test_vRshlQs32 (void)
 }
 
 /* { dg-final { scan-assembler "vrshl\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRshlQs64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRshlQs64.c
@@ -18,4 +18,3 @@ void test_vRshlQs64 (void)
 }
 
 /* { dg-final { scan-assembler "vrshl\.s64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRshlQs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRshlQs8.c
@@ -18,4 +18,3 @@ void test_vRshlQs8 (void)
 }
 
 /* { dg-final { scan-assembler "vrshl\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRshlQu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRshlQu16.c
@@ -18,4 +18,3 @@ void test_vRshlQu16 (void)
 }
 
 /* { dg-final { scan-assembler "vrshl\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRshlQu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRshlQu32.c
@@ -18,4 +18,3 @@ void test_vRshlQu32 (void)
 }
 
 /* { dg-final { scan-assembler "vrshl\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRshlQu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRshlQu64.c
@@ -18,4 +18,3 @@ void test_vRshlQu64 (void)
 }
 
 /* { dg-final { scan-assembler "vrshl\.u64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRshlQu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRshlQu8.c
@@ -18,4 +18,3 @@ void test_vRshlQu8 (void)
 }
 
 /* { dg-final { scan-assembler "vrshl\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRshls16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRshls16.c
@@ -18,4 +18,3 @@ void test_vRshls16 (void)
 }
 
 /* { dg-final { scan-assembler "vrshl\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRshls32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRshls32.c
@@ -18,4 +18,3 @@ void test_vRshls32 (void)
 }
 
 /* { dg-final { scan-assembler "vrshl\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRshls64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRshls64.c
@@ -18,4 +18,3 @@ void test_vRshls64 (void)
 }
 
 /* { dg-final { scan-assembler "vrshl\.s64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRshls8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRshls8.c
@@ -18,4 +18,3 @@ void test_vRshls8 (void)
 }
 
 /* { dg-final { scan-assembler "vrshl\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRshlu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRshlu16.c
@@ -18,4 +18,3 @@ void test_vRshlu16 (void)
 }
 
 /* { dg-final { scan-assembler "vrshl\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRshlu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRshlu32.c
@@ -18,4 +18,3 @@ void test_vRshlu32 (void)
 }
 
 /* { dg-final { scan-assembler "vrshl\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRshlu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRshlu64.c
@@ -18,4 +18,3 @@ void test_vRshlu64 (void)
 }
 
 /* { dg-final { scan-assembler "vrshl\.u64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRshlu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRshlu8.c
@@ -18,4 +18,3 @@ void test_vRshlu8 (void)
 }
 
 /* { dg-final { scan-assembler "vrshl\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns16.c
@@ -17,4 +17,3 @@ void test_vRshrQ_ns16 (void)
 }
 
 /* { dg-final { scan-assembler "vrshr\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns32.c
@@ -17,4 +17,3 @@ void test_vRshrQ_ns32 (void)
 }
 
 /* { dg-final { scan-assembler "vrshr\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns64.c
@@ -17,4 +17,3 @@ void test_vRshrQ_ns64 (void)
 }
 
 /* { dg-final { scan-assembler "vrshr\.s64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns8.c
@@ -17,4 +17,3 @@ void test_vRshrQ_ns8 (void)
 }
 
 /* { dg-final { scan-assembler "vrshr\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu16.c
@@ -17,4 +17,3 @@ void test_vRshrQ_nu16 (void)
 }
 
 /* { dg-final { scan-assembler "vrshr\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu32.c
@@ -17,4 +17,3 @@ void test_vRshrQ_nu32 (void)
 }
 
 /* { dg-final { scan-assembler "vrshr\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu64.c
@@ -17,4 +17,3 @@ void test_vRshrQ_nu64 (void)
 }
 
 /* { dg-final { scan-assembler "vrshr\.u64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu8.c
@@ -17,4 +17,3 @@ void test_vRshrQ_nu8 (void)
 }
 
 /* { dg-final { scan-assembler "vrshr\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRshr_ns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRshr_ns16.c
@@ -17,4 +17,3 @@ void test_vRshr_ns16 (void)
 }
 
 /* { dg-final { scan-assembler "vrshr\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRshr_ns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRshr_ns32.c
@@ -17,4 +17,3 @@ void test_vRshr_ns32 (void)
 }
 
 /* { dg-final { scan-assembler "vrshr\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRshr_ns64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRshr_ns64.c
@@ -17,4 +17,3 @@ void test_vRshr_ns64 (void)
 }
 
 /* { dg-final { scan-assembler "vrshr\.s64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRshr_ns8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRshr_ns8.c
@@ -17,4 +17,3 @@ void test_vRshr_ns8 (void)
 }
 
 /* { dg-final { scan-assembler "vrshr\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRshr_nu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRshr_nu16.c
@@ -17,4 +17,3 @@ void test_vRshr_nu16 (void)
 }
 
 /* { dg-final { scan-assembler "vrshr\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRshr_nu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRshr_nu32.c
@@ -17,4 +17,3 @@ void test_vRshr_nu32 (void)
 }
 
 /* { dg-final { scan-assembler "vrshr\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRshr_nu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRshr_nu64.c
@@ -17,4 +17,3 @@ void test_vRshr_nu64 (void)
 }
 
 /* { dg-final { scan-assembler "vrshr\.u64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRshr_nu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRshr_nu8.c
@@ -17,4 +17,3 @@ void test_vRshr_nu8 (void)
 }
 
 /* { dg-final { scan-assembler "vrshr\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRshrn_ns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRshrn_ns16.c
@@ -17,4 +17,3 @@ void test_vRshrn_ns16 (void)
 }
 
 /* { dg-final { scan-assembler "vrshrn\.i16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRshrn_ns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRshrn_ns32.c
@@ -17,4 +17,3 @@ void test_vRshrn_ns32 (void)
 }
 
 /* { dg-final { scan-assembler "vrshrn\.i32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRshrn_ns64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRshrn_ns64.c
@@ -17,4 +17,3 @@ void test_vRshrn_ns64 (void)
 }
 
 /* { dg-final { scan-assembler "vrshrn\.i64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRshrn_nu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRshrn_nu16.c
@@ -17,4 +17,3 @@ void test_vRshrn_nu16 (void)
 }
 
 /* { dg-final { scan-assembler "vrshrn\.i16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRshrn_nu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRshrn_nu32.c
@@ -17,4 +17,3 @@ void test_vRshrn_nu32 (void)
 }
 
 /* { dg-final { scan-assembler "vrshrn\.i32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRshrn_nu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRshrn_nu64.c
@@ -17,4 +17,3 @@ void test_vRshrn_nu64 (void)
 }
 
 /* { dg-final { scan-assembler "vrshrn\.i64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns16.c
@@ -18,4 +18,3 @@ void test_vRsraQ_ns16 (void)
 }
 
 /* { dg-final { scan-assembler "vrsra\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns32.c
@@ -18,4 +18,3 @@ void test_vRsraQ_ns32 (void)
 }
 
 /* { dg-final { scan-assembler "vrsra\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns64.c
@@ -18,4 +18,3 @@ void test_vRsraQ_ns64 (void)
 }
 
 /* { dg-final { scan-assembler "vrsra\.s64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns8.c
@@ -18,4 +18,3 @@ void test_vRsraQ_ns8 (void)
 }
 
 /* { dg-final { scan-assembler "vrsra\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu16.c
@@ -18,4 +18,3 @@ void test_vRsraQ_nu16 (void)
 }
 
 /* { dg-final { scan-assembler "vrsra\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu32.c
@@ -18,4 +18,3 @@ void test_vRsraQ_nu32 (void)
 }
 
 /* { dg-final { scan-assembler "vrsra\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu64.c
@@ -18,4 +18,3 @@ void test_vRsraQ_nu64 (void)
 }
 
 /* { dg-final { scan-assembler "vrsra\.u64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu8.c
@@ -18,4 +18,3 @@ void test_vRsraQ_nu8 (void)
 }
 
 /* { dg-final { scan-assembler "vrsra\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRsra_ns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRsra_ns16.c
@@ -18,4 +18,3 @@ void test_vRsra_ns16 (void)
 }
 
 /* { dg-final { scan-assembler "vrsra\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRsra_ns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRsra_ns32.c
@@ -18,4 +18,3 @@ void test_vRsra_ns32 (void)
 }
 
 /* { dg-final { scan-assembler "vrsra\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRsra_ns64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRsra_ns64.c
@@ -18,4 +18,3 @@ void test_vRsra_ns64 (void)
 }
 
 /* { dg-final { scan-assembler "vrsra\.s64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRsra_ns8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRsra_ns8.c
@@ -18,4 +18,3 @@ void test_vRsra_ns8 (void)
 }
 
 /* { dg-final { scan-assembler "vrsra\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRsra_nu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRsra_nu16.c
@@ -18,4 +18,3 @@ void test_vRsra_nu16 (void)
 }
 
 /* { dg-final { scan-assembler "vrsra\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRsra_nu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRsra_nu32.c
@@ -18,4 +18,3 @@ void test_vRsra_nu32 (void)
 }
 
 /* { dg-final { scan-assembler "vrsra\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRsra_nu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRsra_nu64.c
@@ -18,4 +18,3 @@ void test_vRsra_nu64 (void)
 }
 
 /* { dg-final { scan-assembler "vrsra\.u64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRsra_nu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRsra_nu8.c
@@ -18,4 +18,3 @@ void test_vRsra_nu8 (void)
 }
 
 /* { dg-final { scan-assembler "vrsra\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRsubhns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRsubhns16.c
@@ -18,4 +18,3 @@ void test_vRsubhns16 (void)
 }
 
 /* { dg-final { scan-assembler "vrsubhn\.i16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRsubhns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRsubhns32.c
@@ -18,4 +18,3 @@ void test_vRsubhns32 (void)
 }
 
 /* { dg-final { scan-assembler "vrsubhn\.i32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRsubhns64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRsubhns64.c
@@ -18,4 +18,3 @@ void test_vRsubhns64 (void)
 }
 
 /* { dg-final { scan-assembler "vrsubhn\.i64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRsubhnu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRsubhnu16.c
@@ -18,4 +18,3 @@ void test_vRsubhnu16 (void)
 }
 
 /* { dg-final { scan-assembler "vrsubhn\.i16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRsubhnu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRsubhnu32.c
@@ -18,4 +18,3 @@ void test_vRsubhnu32 (void)
 }
 
 /* { dg-final { scan-assembler "vrsubhn\.i32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vRsubhnu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vRsubhnu64.c
@@ -18,4 +18,3 @@ void test_vRsubhnu64 (void)
 }
 
 /* { dg-final { scan-assembler "vrsubhn\.i64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vabaQs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vabaQs16.c
@@ -19,4 +19,3 @@ void test_vabaQs16 (void)
 }
 
 /* { dg-final { scan-assembler "vaba\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vabaQs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vabaQs32.c
@@ -19,4 +19,3 @@ void test_vabaQs32 (void)
 }
 
 /* { dg-final { scan-assembler "vaba\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vabaQs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vabaQs8.c
@@ -19,4 +19,3 @@ void test_vabaQs8 (void)
 }
 
 /* { dg-final { scan-assembler "vaba\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vabaQu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vabaQu16.c
@@ -19,4 +19,3 @@ void test_vabaQu16 (void)
 }
 
 /* { dg-final { scan-assembler "vaba\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vabaQu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vabaQu32.c
@@ -19,4 +19,3 @@ void test_vabaQu32 (void)
 }
 
 /* { dg-final { scan-assembler "vaba\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vabaQu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vabaQu8.c
@@ -19,4 +19,3 @@ void test_vabaQu8 (void)
 }
 
 /* { dg-final { scan-assembler "vaba\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vabals16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vabals16.c
@@ -19,4 +19,3 @@ void test_vabals16 (void)
 }
 
 /* { dg-final { scan-assembler "vabal\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vabals32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vabals32.c
@@ -19,4 +19,3 @@ void test_vabals32 (void)
 }
 
 /* { dg-final { scan-assembler "vabal\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vabals8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vabals8.c
@@ -19,4 +19,3 @@ void test_vabals8 (void)
 }
 
 /* { dg-final { scan-assembler "vabal\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vabalu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vabalu16.c
@@ -19,4 +19,3 @@ void test_vabalu16 (void)
 }
 
 /* { dg-final { scan-assembler "vabal\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vabalu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vabalu32.c
@@ -19,4 +19,3 @@ void test_vabalu32 (void)
 }
 
 /* { dg-final { scan-assembler "vabal\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vabalu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vabalu8.c
@@ -19,4 +19,3 @@ void test_vabalu8 (void)
 }
 
 /* { dg-final { scan-assembler "vabal\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vabas16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vabas16.c
@@ -19,4 +19,3 @@ void test_vabas16 (void)
 }
 
 /* { dg-final { scan-assembler "vaba\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vabas32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vabas32.c
@@ -19,4 +19,3 @@ void test_vabas32 (void)
 }
 
 /* { dg-final { scan-assembler "vaba\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vabas8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vabas8.c
@@ -19,4 +19,3 @@ void test_vabas8 (void)
 }
 
 /* { dg-final { scan-assembler "vaba\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vabau16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vabau16.c
@@ -19,4 +19,3 @@ void test_vabau16 (void)
 }
 
 /* { dg-final { scan-assembler "vaba\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vabau32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vabau32.c
@@ -19,4 +19,3 @@ void test_vabau32 (void)
 }
 
 /* { dg-final { scan-assembler "vaba\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vabau8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vabau8.c
@@ -19,4 +19,3 @@ void test_vabau8 (void)
 }
 
 /* { dg-final { scan-assembler "vaba\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vabdQf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vabdQf32.c
@@ -18,4 +18,3 @@ void test_vabdQf32 (void)
 }
 
 /* { dg-final { scan-assembler "vabd\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vabdQs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vabdQs16.c
@@ -18,4 +18,3 @@ void test_vabdQs16 (void)
 }
 
 /* { dg-final { scan-assembler "vabd\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vabdQs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vabdQs32.c
@@ -18,4 +18,3 @@ void test_vabdQs32 (void)
 }
 
 /* { dg-final { scan-assembler "vabd\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vabdQs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vabdQs8.c
@@ -18,4 +18,3 @@ void test_vabdQs8 (void)
 }
 
 /* { dg-final { scan-assembler "vabd\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vabdQu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vabdQu16.c
@@ -18,4 +18,3 @@ void test_vabdQu16 (void)
 }
 
 /* { dg-final { scan-assembler "vabd\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vabdQu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vabdQu32.c
@@ -18,4 +18,3 @@ void test_vabdQu32 (void)
 }
 
 /* { dg-final { scan-assembler "vabd\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vabdQu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vabdQu8.c
@@ -18,4 +18,3 @@ void test_vabdQu8 (void)
 }
 
 /* { dg-final { scan-assembler "vabd\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vabdf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vabdf32.c
@@ -18,4 +18,3 @@ void test_vabdf32 (void)
 }
 
 /* { dg-final { scan-assembler "vabd\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vabdls16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vabdls16.c
@@ -18,4 +18,3 @@ void test_vabdls16 (void)
 }
 
 /* { dg-final { scan-assembler "vabdl\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vabdls32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vabdls32.c
@@ -18,4 +18,3 @@ void test_vabdls32 (void)
 }
 
 /* { dg-final { scan-assembler "vabdl\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vabdls8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vabdls8.c
@@ -18,4 +18,3 @@ void test_vabdls8 (void)
 }
 
 /* { dg-final { scan-assembler "vabdl\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vabdlu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vabdlu16.c
@@ -18,4 +18,3 @@ void test_vabdlu16 (void)
 }
 
 /* { dg-final { scan-assembler "vabdl\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vabdlu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vabdlu32.c
@@ -18,4 +18,3 @@ void test_vabdlu32 (void)
 }
 
 /* { dg-final { scan-assembler "vabdl\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vabdlu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vabdlu8.c
@@ -18,4 +18,3 @@ void test_vabdlu8 (void)
 }
 
 /* { dg-final { scan-assembler "vabdl\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vabds16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vabds16.c
@@ -18,4 +18,3 @@ void test_vabds16 (void)
 }
 
 /* { dg-final { scan-assembler "vabd\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vabds32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vabds32.c
@@ -18,4 +18,3 @@ void test_vabds32 (void)
 }
 
 /* { dg-final { scan-assembler "vabd\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vabds8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vabds8.c
@@ -18,4 +18,3 @@ void test_vabds8 (void)
 }
 
 /* { dg-final { scan-assembler "vabd\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vabdu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vabdu16.c
@@ -18,4 +18,3 @@ void test_vabdu16 (void)
 }
 
 /* { dg-final { scan-assembler "vabd\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vabdu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vabdu32.c
@@ -18,4 +18,3 @@ void test_vabdu32 (void)
 }
 
 /* { dg-final { scan-assembler "vabd\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vabdu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vabdu8.c
@@ -18,4 +18,3 @@ void test_vabdu8 (void)
 }
 
 /* { dg-final { scan-assembler "vabd\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vabsQf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vabsQf32.c
@@ -17,4 +17,3 @@ void test_vabsQf32 (void)
 }
 
 /* { dg-final { scan-assembler "vabs\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vabsQs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vabsQs16.c
@@ -17,4 +17,3 @@ void test_vabsQs16 (void)
 }
 
 /* { dg-final { scan-assembler "vabs\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vabsQs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vabsQs32.c
@@ -17,4 +17,3 @@ void test_vabsQs32 (void)
 }
 
 /* { dg-final { scan-assembler "vabs\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vabsQs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vabsQs8.c
@@ -17,4 +17,3 @@ void test_vabsQs8 (void)
 }
 
 /* { dg-final { scan-assembler "vabs\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vabsf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vabsf32.c
@@ -17,4 +17,3 @@ void test_vabsf32 (void)
 }
 
 /* { dg-final { scan-assembler "vabs\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vabss16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vabss16.c
@@ -17,4 +17,3 @@ void test_vabss16 (void)
 }
 
 /* { dg-final { scan-assembler "vabs\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vabss32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vabss32.c
@@ -17,4 +17,3 @@ void test_vabss32 (void)
 }
 
 /* { dg-final { scan-assembler "vabs\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vabss8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vabss8.c
@@ -17,4 +17,3 @@ void test_vabss8 (void)
 }
 
 /* { dg-final { scan-assembler "vabs\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vaddQf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vaddQf32.c
@@ -18,4 +18,3 @@ void test_vaddQf32 (void)
 }
 
 /* { dg-final { scan-assembler "vadd\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vaddQs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vaddQs16.c
@@ -18,4 +18,3 @@ void test_vaddQs16 (void)
 }
 
 /* { dg-final { scan-assembler "vadd\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vaddQs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vaddQs32.c
@@ -18,4 +18,3 @@ void test_vaddQs32 (void)
 }
 
 /* { dg-final { scan-assembler "vadd\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vaddQs64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vaddQs64.c
@@ -18,4 +18,3 @@ void test_vaddQs64 (void)
 }
 
 /* { dg-final { scan-assembler "vadd\.i64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vaddQs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vaddQs8.c
@@ -18,4 +18,3 @@ void test_vaddQs8 (void)
 }
 
 /* { dg-final { scan-assembler "vadd\.i8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vaddQu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vaddQu16.c
@@ -18,4 +18,3 @@ void test_vaddQu16 (void)
 }
 
 /* { dg-final { scan-assembler "vadd\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vaddQu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vaddQu32.c
@@ -18,4 +18,3 @@ void test_vaddQu32 (void)
 }
 
 /* { dg-final { scan-assembler "vadd\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vaddQu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vaddQu64.c
@@ -18,4 +18,3 @@ void test_vaddQu64 (void)
 }
 
 /* { dg-final { scan-assembler "vadd\.i64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vaddQu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vaddQu8.c
@@ -18,4 +18,3 @@ void test_vaddQu8 (void)
 }
 
 /* { dg-final { scan-assembler "vadd\.i8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vaddf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vaddf32.c
@@ -18,4 +18,3 @@ void test_vaddf32 (void)
 }
 
 /* { dg-final { scan-assembler "vadd\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vaddhns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vaddhns16.c
@@ -18,4 +18,3 @@ void test_vaddhns16 (void)
 }
 
 /* { dg-final { scan-assembler "vaddhn\.i16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vaddhns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vaddhns32.c
@@ -18,4 +18,3 @@ void test_vaddhns32 (void)
 }
 
 /* { dg-final { scan-assembler "vaddhn\.i32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vaddhns64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vaddhns64.c
@@ -18,4 +18,3 @@ void test_vaddhns64 (void)
 }
 
 /* { dg-final { scan-assembler "vaddhn\.i64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vaddhnu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vaddhnu16.c
@@ -18,4 +18,3 @@ void test_vaddhnu16 (void)
 }
 
 /* { dg-final { scan-assembler "vaddhn\.i16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vaddhnu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vaddhnu32.c
@@ -18,4 +18,3 @@ void test_vaddhnu32 (void)
 }
 
 /* { dg-final { scan-assembler "vaddhn\.i32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vaddhnu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vaddhnu64.c
@@ -18,4 +18,3 @@ void test_vaddhnu64 (void)
 }
 
 /* { dg-final { scan-assembler "vaddhn\.i64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vaddls16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vaddls16.c
@@ -18,4 +18,3 @@ void test_vaddls16 (void)
 }
 
 /* { dg-final { scan-assembler "vaddl\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vaddls32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vaddls32.c
@@ -18,4 +18,3 @@ void test_vaddls32 (void)
 }
 
 /* { dg-final { scan-assembler "vaddl\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vaddls8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vaddls8.c
@@ -18,4 +18,3 @@ void test_vaddls8 (void)
 }
 
 /* { dg-final { scan-assembler "vaddl\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vaddlu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vaddlu16.c
@@ -18,4 +18,3 @@ void test_vaddlu16 (void)
 }
 
 /* { dg-final { scan-assembler "vaddl\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vaddlu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vaddlu32.c
@@ -18,4 +18,3 @@ void test_vaddlu32 (void)
 }
 
 /* { dg-final { scan-assembler "vaddl\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vaddlu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vaddlu8.c
@@ -18,4 +18,3 @@ void test_vaddlu8 (void)
 }
 
 /* { dg-final { scan-assembler "vaddl\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vadds16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vadds16.c
@@ -18,4 +18,3 @@ void test_vadds16 (void)
 }
 
 /* { dg-final { scan-assembler "vadd\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vadds32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vadds32.c
@@ -18,4 +18,3 @@ void test_vadds32 (void)
 }
 
 /* { dg-final { scan-assembler "vadd\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vadds64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vadds64.c
@@ -17,4 +17,3 @@ void test_vadds64 (void)
   out_int64x1_t = vadd_s64 (arg0_int64x1_t, arg1_int64x1_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vadds8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vadds8.c
@@ -18,4 +18,3 @@ void test_vadds8 (void)
 }
 
 /* { dg-final { scan-assembler "vadd\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vaddu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vaddu16.c
@@ -18,4 +18,3 @@ void test_vaddu16 (void)
 }
 
 /* { dg-final { scan-assembler "vadd\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vaddu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vaddu32.c
@@ -18,4 +18,3 @@ void test_vaddu32 (void)
 }
 
 /* { dg-final { scan-assembler "vadd\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vaddu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vaddu64.c
@@ -17,4 +17,3 @@ void test_vaddu64 (void)
   out_uint64x1_t = vadd_u64 (arg0_uint64x1_t, arg1_uint64x1_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vaddu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vaddu8.c
@@ -18,4 +18,3 @@ void test_vaddu8 (void)
 }
 
 /* { dg-final { scan-assembler "vadd\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vaddws16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vaddws16.c
@@ -18,4 +18,3 @@ void test_vaddws16 (void)
 }
 
 /* { dg-final { scan-assembler "vaddw\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vaddws32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vaddws32.c
@@ -18,4 +18,3 @@ void test_vaddws32 (void)
 }
 
 /* { dg-final { scan-assembler "vaddw\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vaddws8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vaddws8.c
@@ -18,4 +18,3 @@ void test_vaddws8 (void)
 }
 
 /* { dg-final { scan-assembler "vaddw\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vaddwu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vaddwu16.c
@@ -18,4 +18,3 @@ void test_vaddwu16 (void)
 }
 
 /* { dg-final { scan-assembler "vaddw\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vaddwu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vaddwu32.c
@@ -18,4 +18,3 @@ void test_vaddwu32 (void)
 }
 
 /* { dg-final { scan-assembler "vaddw\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vaddwu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vaddwu8.c
@@ -18,4 +18,3 @@ void test_vaddwu8 (void)
 }
 
 /* { dg-final { scan-assembler "vaddw\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vandQs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vandQs16.c
@@ -18,4 +18,3 @@ void test_vandQs16 (void)
 }
 
 /* { dg-final { scan-assembler "vand\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vandQs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vandQs32.c
@@ -18,4 +18,3 @@ void test_vandQs32 (void)
 }
 
 /* { dg-final { scan-assembler "vand\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vandQs64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vandQs64.c
@@ -18,4 +18,3 @@ void test_vandQs64 (void)
 }
 
 /* { dg-final { scan-assembler "vand\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vandQs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vandQs8.c
@@ -18,4 +18,3 @@ void test_vandQs8 (void)
 }
 
 /* { dg-final { scan-assembler "vand\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vandQu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vandQu16.c
@@ -18,4 +18,3 @@ void test_vandQu16 (void)
 }
 
 /* { dg-final { scan-assembler "vand\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vandQu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vandQu32.c
@@ -18,4 +18,3 @@ void test_vandQu32 (void)
 }
 
 /* { dg-final { scan-assembler "vand\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vandQu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vandQu64.c
@@ -18,4 +18,3 @@ void test_vandQu64 (void)
 }
 
 /* { dg-final { scan-assembler "vand\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vandQu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vandQu8.c
@@ -18,4 +18,3 @@ void test_vandQu8 (void)
 }
 
 /* { dg-final { scan-assembler "vand\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vands16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vands16.c
@@ -18,4 +18,3 @@ void test_vands16 (void)
 }
 
 /* { dg-final { scan-assembler "vand\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vands32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vands32.c
@@ -18,4 +18,3 @@ void test_vands32 (void)
 }
 
 /* { dg-final { scan-assembler "vand\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vands64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vands64.c
@@ -17,4 +17,3 @@ void test_vands64 (void)
   out_int64x1_t = vand_s64 (arg0_int64x1_t, arg1_int64x1_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vands8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vands8.c
@@ -18,4 +18,3 @@ void test_vands8 (void)
 }
 
 /* { dg-final { scan-assembler "vand\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vandu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vandu16.c
@@ -18,4 +18,3 @@ void test_vandu16 (void)
 }
 
 /* { dg-final { scan-assembler "vand\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vandu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vandu32.c
@@ -18,4 +18,3 @@ void test_vandu32 (void)
 }
 
 /* { dg-final { scan-assembler "vand\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vandu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vandu64.c
@@ -17,4 +17,3 @@ void test_vandu64 (void)
   out_uint64x1_t = vand_u64 (arg0_uint64x1_t, arg1_uint64x1_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vandu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vandu8.c
@@ -18,4 +18,3 @@ void test_vandu8 (void)
 }
 
 /* { dg-final { scan-assembler "vand\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vbicQs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vbicQs16.c
@@ -18,4 +18,3 @@ void test_vbicQs16 (void)
 }
 
 /* { dg-final { scan-assembler "vbic\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vbicQs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vbicQs32.c
@@ -18,4 +18,3 @@ void test_vbicQs32 (void)
 }
 
 /* { dg-final { scan-assembler "vbic\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vbicQs64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vbicQs64.c
@@ -18,4 +18,3 @@ void test_vbicQs64 (void)
 }
 
 /* { dg-final { scan-assembler "vbic\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vbicQs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vbicQs8.c
@@ -18,4 +18,3 @@ void test_vbicQs8 (void)
 }
 
 /* { dg-final { scan-assembler "vbic\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vbicQu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vbicQu16.c
@@ -18,4 +18,3 @@ void test_vbicQu16 (void)
 }
 
 /* { dg-final { scan-assembler "vbic\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vbicQu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vbicQu32.c
@@ -18,4 +18,3 @@ void test_vbicQu32 (void)
 }
 
 /* { dg-final { scan-assembler "vbic\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vbicQu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vbicQu64.c
@@ -18,4 +18,3 @@ void test_vbicQu64 (void)
 }
 
 /* { dg-final { scan-assembler "vbic\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vbicQu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vbicQu8.c
@@ -18,4 +18,3 @@ void test_vbicQu8 (void)
 }
 
 /* { dg-final { scan-assembler "vbic\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vbics16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vbics16.c
@@ -18,4 +18,3 @@ void test_vbics16 (void)
 }
 
 /* { dg-final { scan-assembler "vbic\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vbics32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vbics32.c
@@ -18,4 +18,3 @@ void test_vbics32 (void)
 }
 
 /* { dg-final { scan-assembler "vbic\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vbics64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vbics64.c
@@ -17,4 +17,3 @@ void test_vbics64 (void)
   out_int64x1_t = vbic_s64 (arg0_int64x1_t, arg1_int64x1_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vbics8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vbics8.c
@@ -18,4 +18,3 @@ void test_vbics8 (void)
 }
 
 /* { dg-final { scan-assembler "vbic\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vbicu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vbicu16.c
@@ -18,4 +18,3 @@ void test_vbicu16 (void)
 }
 
 /* { dg-final { scan-assembler "vbic\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vbicu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vbicu32.c
@@ -18,4 +18,3 @@ void test_vbicu32 (void)
 }
 
 /* { dg-final { scan-assembler "vbic\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vbicu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vbicu64.c
@@ -17,4 +17,3 @@ void test_vbicu64 (void)
   out_uint64x1_t = vbic_u64 (arg0_uint64x1_t, arg1_uint64x1_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vbicu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vbicu8.c
@@ -18,4 +18,3 @@ void test_vbicu8 (void)
 }
 
 /* { dg-final { scan-assembler "vbic\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vbslQf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vbslQf32.c
@@ -19,4 +19,3 @@ void test_vbslQf32 (void)
 }
 
 /* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vbslQp16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vbslQp16.c
@@ -19,4 +19,3 @@ void test_vbslQp16 (void)
 }
 
 /* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vbslQp64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vbslQp64.c
@@ -19,4 +19,3 @@ void test_vbslQp64 (void)
 }
 
 /* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vbslQp8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vbslQp8.c
@@ -19,4 +19,3 @@ void test_vbslQp8 (void)
 }
 
 /* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vbslQs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vbslQs16.c
@@ -19,4 +19,3 @@ void test_vbslQs16 (void)
 }
 
 /* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vbslQs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vbslQs32.c
@@ -19,4 +19,3 @@ void test_vbslQs32 (void)
 }
 
 /* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vbslQs64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vbslQs64.c
@@ -19,4 +19,3 @@ void test_vbslQs64 (void)
 }
 
 /* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vbslQs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vbslQs8.c
@@ -19,4 +19,3 @@ void test_vbslQs8 (void)
 }
 
 /* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vbslQu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vbslQu16.c
@@ -19,4 +19,3 @@ void test_vbslQu16 (void)
 }
 
 /* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vbslQu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vbslQu32.c
@@ -19,4 +19,3 @@ void test_vbslQu32 (void)
 }
 
 /* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vbslQu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vbslQu64.c
@@ -19,4 +19,3 @@ void test_vbslQu64 (void)
 }
 
 /* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vbslQu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vbslQu8.c
@@ -19,4 +19,3 @@ void test_vbslQu8 (void)
 }
 
 /* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vbslf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vbslf32.c
@@ -19,4 +19,3 @@ void test_vbslf32 (void)
 }
 
 /* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vbslp16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vbslp16.c
@@ -19,4 +19,3 @@ void test_vbslp16 (void)
 }
 
 /* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vbslp64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vbslp64.c
@@ -19,4 +19,3 @@ void test_vbslp64 (void)
 }
 
 /* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vbslp8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vbslp8.c
@@ -19,4 +19,3 @@ void test_vbslp8 (void)
 }
 
 /* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vbsls16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vbsls16.c
@@ -19,4 +19,3 @@ void test_vbsls16 (void)
 }
 
 /* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vbsls32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vbsls32.c
@@ -19,4 +19,3 @@ void test_vbsls32 (void)
 }
 
 /* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vbsls64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vbsls64.c
@@ -19,4 +19,3 @@ void test_vbsls64 (void)
 }
 
 /* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vbsls8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vbsls8.c
@@ -19,4 +19,3 @@ void test_vbsls8 (void)
 }
 
 /* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vbslu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vbslu16.c
@@ -19,4 +19,3 @@ void test_vbslu16 (void)
 }
 
 /* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vbslu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vbslu32.c
@@ -19,4 +19,3 @@ void test_vbslu32 (void)
 }
 
 /* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vbslu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vbslu64.c
@@ -19,4 +19,3 @@ void test_vbslu64 (void)
 }
 
 /* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vbslu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vbslu8.c
@@ -19,4 +19,3 @@ void test_vbslu8 (void)
 }
 
 /* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcageQf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcageQf32.c
@@ -18,4 +18,3 @@ void test_vcageQf32 (void)
 }
 
 /* { dg-final { scan-assembler "vacge\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcagef32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcagef32.c
@@ -18,4 +18,3 @@ void test_vcagef32 (void)
 }
 
 /* { dg-final { scan-assembler "vacge\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcagtQf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcagtQf32.c
@@ -18,4 +18,3 @@ void test_vcagtQf32 (void)
 }
 
 /* { dg-final { scan-assembler "vacgt\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcagtf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcagtf32.c
@@ -18,4 +18,3 @@ void test_vcagtf32 (void)
 }
 
 /* { dg-final { scan-assembler "vacgt\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcaleQf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcaleQf32.c
@@ -18,4 +18,3 @@ void test_vcaleQf32 (void)
 }
 
 /* { dg-final { scan-assembler "vacge\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcalef32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcalef32.c
@@ -18,4 +18,3 @@ void test_vcalef32 (void)
 }
 
 /* { dg-final { scan-assembler "vacge\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcaltQf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcaltQf32.c
@@ -18,4 +18,3 @@ void test_vcaltQf32 (void)
 }
 
 /* { dg-final { scan-assembler "vacgt\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcaltf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcaltf32.c
@@ -18,4 +18,3 @@ void test_vcaltf32 (void)
 }
 
 /* { dg-final { scan-assembler "vacgt\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vceqQf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vceqQf32.c
@@ -18,4 +18,3 @@ void test_vceqQf32 (void)
 }
 
 /* { dg-final { scan-assembler "vceq\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vceqQp8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vceqQp8.c
@@ -18,4 +18,3 @@ void test_vceqQp8 (void)
 }
 
 /* { dg-final { scan-assembler "vceq\.i8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vceqQs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vceqQs16.c
@@ -18,4 +18,3 @@ void test_vceqQs16 (void)
 }
 
 /* { dg-final { scan-assembler "vceq\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vceqQs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vceqQs32.c
@@ -18,4 +18,3 @@ void test_vceqQs32 (void)
 }
 
 /* { dg-final { scan-assembler "vceq\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vceqQs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vceqQs8.c
@@ -18,4 +18,3 @@ void test_vceqQs8 (void)
 }
 
 /* { dg-final { scan-assembler "vceq\.i8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vceqQu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vceqQu16.c
@@ -18,4 +18,3 @@ void test_vceqQu16 (void)
 }
 
 /* { dg-final { scan-assembler "vceq\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vceqQu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vceqQu32.c
@@ -18,4 +18,3 @@ void test_vceqQu32 (void)
 }
 
 /* { dg-final { scan-assembler "vceq\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vceqQu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vceqQu8.c
@@ -18,4 +18,3 @@ void test_vceqQu8 (void)
 }
 
 /* { dg-final { scan-assembler "vceq\.i8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vceqf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vceqf32.c
@@ -18,4 +18,3 @@ void test_vceqf32 (void)
 }
 
 /* { dg-final { scan-assembler "vceq\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vceqp8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vceqp8.c
@@ -18,4 +18,3 @@ void test_vceqp8 (void)
 }
 
 /* { dg-final { scan-assembler "vceq\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vceqs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vceqs16.c
@@ -18,4 +18,3 @@ void test_vceqs16 (void)
 }
 
 /* { dg-final { scan-assembler "vceq\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vceqs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vceqs32.c
@@ -18,4 +18,3 @@ void test_vceqs32 (void)
 }
 
 /* { dg-final { scan-assembler "vceq\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vceqs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vceqs8.c
@@ -18,4 +18,3 @@ void test_vceqs8 (void)
 }
 
 /* { dg-final { scan-assembler "vceq\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcequ16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcequ16.c
@@ -18,4 +18,3 @@ void test_vcequ16 (void)
 }
 
 /* { dg-final { scan-assembler "vceq\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcequ32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcequ32.c
@@ -18,4 +18,3 @@ void test_vcequ32 (void)
 }
 
 /* { dg-final { scan-assembler "vceq\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcequ8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcequ8.c
@@ -18,4 +18,3 @@ void test_vcequ8 (void)
 }
 
 /* { dg-final { scan-assembler "vceq\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcgeQf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcgeQf32.c
@@ -18,4 +18,3 @@ void test_vcgeQf32 (void)
 }
 
 /* { dg-final { scan-assembler "vcge\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcgeQs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcgeQs16.c
@@ -18,4 +18,3 @@ void test_vcgeQs16 (void)
 }
 
 /* { dg-final { scan-assembler "vcge\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcgeQs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcgeQs32.c
@@ -18,4 +18,3 @@ void test_vcgeQs32 (void)
 }
 
 /* { dg-final { scan-assembler "vcge\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcgeQs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcgeQs8.c
@@ -18,4 +18,3 @@ void test_vcgeQs8 (void)
 }
 
 /* { dg-final { scan-assembler "vcge\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcgeQu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcgeQu16.c
@@ -18,4 +18,3 @@ void test_vcgeQu16 (void)
 }
 
 /* { dg-final { scan-assembler "vcge\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcgeQu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcgeQu32.c
@@ -18,4 +18,3 @@ void test_vcgeQu32 (void)
 }
 
 /* { dg-final { scan-assembler "vcge\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcgeQu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcgeQu8.c
@@ -18,4 +18,3 @@ void test_vcgeQu8 (void)
 }
 
 /* { dg-final { scan-assembler "vcge\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcgef32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcgef32.c
@@ -18,4 +18,3 @@ void test_vcgef32 (void)
 }
 
 /* { dg-final { scan-assembler "vcge\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcges16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcges16.c
@@ -18,4 +18,3 @@ void test_vcges16 (void)
 }
 
 /* { dg-final { scan-assembler "vcge\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcges32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcges32.c
@@ -18,4 +18,3 @@ void test_vcges32 (void)
 }
 
 /* { dg-final { scan-assembler "vcge\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcges8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcges8.c
@@ -18,4 +18,3 @@ void test_vcges8 (void)
 }
 
 /* { dg-final { scan-assembler "vcge\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcgeu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcgeu16.c
@@ -18,4 +18,3 @@ void test_vcgeu16 (void)
 }
 
 /* { dg-final { scan-assembler "vcge\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcgeu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcgeu32.c
@@ -18,4 +18,3 @@ void test_vcgeu32 (void)
 }
 
 /* { dg-final { scan-assembler "vcge\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcgeu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcgeu8.c
@@ -18,4 +18,3 @@ void test_vcgeu8 (void)
 }
 
 /* { dg-final { scan-assembler "vcge\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcgtQf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcgtQf32.c
@@ -18,4 +18,3 @@ void test_vcgtQf32 (void)
 }
 
 /* { dg-final { scan-assembler "vcgt\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcgtQs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcgtQs16.c
@@ -18,4 +18,3 @@ void test_vcgtQs16 (void)
 }
 
 /* { dg-final { scan-assembler "vcgt\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcgtQs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcgtQs32.c
@@ -18,4 +18,3 @@ void test_vcgtQs32 (void)
 }
 
 /* { dg-final { scan-assembler "vcgt\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcgtQs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcgtQs8.c
@@ -18,4 +18,3 @@ void test_vcgtQs8 (void)
 }
 
 /* { dg-final { scan-assembler "vcgt\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcgtQu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcgtQu16.c
@@ -18,4 +18,3 @@ void test_vcgtQu16 (void)
 }
 
 /* { dg-final { scan-assembler "vcgt\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcgtQu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcgtQu32.c
@@ -18,4 +18,3 @@ void test_vcgtQu32 (void)
 }
 
 /* { dg-final { scan-assembler "vcgt\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcgtQu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcgtQu8.c
@@ -18,4 +18,3 @@ void test_vcgtQu8 (void)
 }
 
 /* { dg-final { scan-assembler "vcgt\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcgtf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcgtf32.c
@@ -18,4 +18,3 @@ void test_vcgtf32 (void)
 }
 
 /* { dg-final { scan-assembler "vcgt\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcgts16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcgts16.c
@@ -18,4 +18,3 @@ void test_vcgts16 (void)
 }
 
 /* { dg-final { scan-assembler "vcgt\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcgts32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcgts32.c
@@ -18,4 +18,3 @@ void test_vcgts32 (void)
 }
 
 /* { dg-final { scan-assembler "vcgt\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcgts8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcgts8.c
@@ -18,4 +18,3 @@ void test_vcgts8 (void)
 }
 
 /* { dg-final { scan-assembler "vcgt\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcgtu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcgtu16.c
@@ -18,4 +18,3 @@ void test_vcgtu16 (void)
 }
 
 /* { dg-final { scan-assembler "vcgt\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcgtu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcgtu32.c
@@ -18,4 +18,3 @@ void test_vcgtu32 (void)
 }
 
 /* { dg-final { scan-assembler "vcgt\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcgtu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcgtu8.c
@@ -18,4 +18,3 @@ void test_vcgtu8 (void)
 }
 
 /* { dg-final { scan-assembler "vcgt\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcleQf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcleQf32.c
@@ -18,4 +18,3 @@ void test_vcleQf32 (void)
 }
 
 /* { dg-final { scan-assembler "vcge\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcleQs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcleQs16.c
@@ -18,4 +18,3 @@ void test_vcleQs16 (void)
 }
 
 /* { dg-final { scan-assembler "vcge\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcleQs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcleQs32.c
@@ -18,4 +18,3 @@ void test_vcleQs32 (void)
 }
 
 /* { dg-final { scan-assembler "vcge\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcleQs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcleQs8.c
@@ -18,4 +18,3 @@ void test_vcleQs8 (void)
 }
 
 /* { dg-final { scan-assembler "vcge\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcleQu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcleQu16.c
@@ -18,4 +18,3 @@ void test_vcleQu16 (void)
 }
 
 /* { dg-final { scan-assembler "vcge\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcleQu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcleQu32.c
@@ -18,4 +18,3 @@ void test_vcleQu32 (void)
 }
 
 /* { dg-final { scan-assembler "vcge\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcleQu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcleQu8.c
@@ -18,4 +18,3 @@ void test_vcleQu8 (void)
 }
 
 /* { dg-final { scan-assembler "vcge\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vclef32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vclef32.c
@@ -18,4 +18,3 @@ void test_vclef32 (void)
 }
 
 /* { dg-final { scan-assembler "vcge\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcles16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcles16.c
@@ -18,4 +18,3 @@ void test_vcles16 (void)
 }
 
 /* { dg-final { scan-assembler "vcge\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcles32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcles32.c
@@ -18,4 +18,3 @@ void test_vcles32 (void)
 }
 
 /* { dg-final { scan-assembler "vcge\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcles8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcles8.c
@@ -18,4 +18,3 @@ void test_vcles8 (void)
 }
 
 /* { dg-final { scan-assembler "vcge\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcleu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcleu16.c
@@ -18,4 +18,3 @@ void test_vcleu16 (void)
 }
 
 /* { dg-final { scan-assembler "vcge\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcleu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcleu32.c
@@ -18,4 +18,3 @@ void test_vcleu32 (void)
 }
 
 /* { dg-final { scan-assembler "vcge\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcleu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcleu8.c
@@ -18,4 +18,3 @@ void test_vcleu8 (void)
 }
 
 /* { dg-final { scan-assembler "vcge\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vclsQs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vclsQs16.c
@@ -17,4 +17,3 @@ void test_vclsQs16 (void)
 }
 
 /* { dg-final { scan-assembler "vcls\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vclsQs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vclsQs32.c
@@ -17,4 +17,3 @@ void test_vclsQs32 (void)
 }
 
 /* { dg-final { scan-assembler "vcls\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vclsQs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vclsQs8.c
@@ -17,4 +17,3 @@ void test_vclsQs8 (void)
 }
 
 /* { dg-final { scan-assembler "vcls\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vclss16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vclss16.c
@@ -17,4 +17,3 @@ void test_vclss16 (void)
 }
 
 /* { dg-final { scan-assembler "vcls\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vclss32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vclss32.c
@@ -17,4 +17,3 @@ void test_vclss32 (void)
 }
 
 /* { dg-final { scan-assembler "vcls\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vclss8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vclss8.c
@@ -17,4 +17,3 @@ void test_vclss8 (void)
 }
 
 /* { dg-final { scan-assembler "vcls\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcltQf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcltQf32.c
@@ -18,4 +18,3 @@ void test_vcltQf32 (void)
 }
 
 /* { dg-final { scan-assembler "vcgt\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcltQs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcltQs16.c
@@ -18,4 +18,3 @@ void test_vcltQs16 (void)
 }
 
 /* { dg-final { scan-assembler "vcgt\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcltQs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcltQs32.c
@@ -18,4 +18,3 @@ void test_vcltQs32 (void)
 }
 
 /* { dg-final { scan-assembler "vcgt\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcltQs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcltQs8.c
@@ -18,4 +18,3 @@ void test_vcltQs8 (void)
 }
 
 /* { dg-final { scan-assembler "vcgt\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcltQu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcltQu16.c
@@ -18,4 +18,3 @@ void test_vcltQu16 (void)
 }
 
 /* { dg-final { scan-assembler "vcgt\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcltQu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcltQu32.c
@@ -18,4 +18,3 @@ void test_vcltQu32 (void)
 }
 
 /* { dg-final { scan-assembler "vcgt\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcltQu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcltQu8.c
@@ -18,4 +18,3 @@ void test_vcltQu8 (void)
 }
 
 /* { dg-final { scan-assembler "vcgt\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcltf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcltf32.c
@@ -18,4 +18,3 @@ void test_vcltf32 (void)
 }
 
 /* { dg-final { scan-assembler "vcgt\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vclts16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vclts16.c
@@ -18,4 +18,3 @@ void test_vclts16 (void)
 }
 
 /* { dg-final { scan-assembler "vcgt\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vclts32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vclts32.c
@@ -18,4 +18,3 @@ void test_vclts32 (void)
 }
 
 /* { dg-final { scan-assembler "vcgt\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vclts8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vclts8.c
@@ -18,4 +18,3 @@ void test_vclts8 (void)
 }
 
 /* { dg-final { scan-assembler "vcgt\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcltu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcltu16.c
@@ -18,4 +18,3 @@ void test_vcltu16 (void)
 }
 
 /* { dg-final { scan-assembler "vcgt\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcltu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcltu32.c
@@ -18,4 +18,3 @@ void test_vcltu32 (void)
 }
 
 /* { dg-final { scan-assembler "vcgt\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcltu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcltu8.c
@@ -18,4 +18,3 @@ void test_vcltu8 (void)
 }
 
 /* { dg-final { scan-assembler "vcgt\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vclzQs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vclzQs16.c
@@ -17,4 +17,3 @@ void test_vclzQs16 (void)
 }
 
 /* { dg-final { scan-assembler "vclz\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vclzQs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vclzQs32.c
@@ -17,4 +17,3 @@ void test_vclzQs32 (void)
 }
 
 /* { dg-final { scan-assembler "vclz\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vclzQs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vclzQs8.c
@@ -17,4 +17,3 @@ void test_vclzQs8 (void)
 }
 
 /* { dg-final { scan-assembler "vclz\.i8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vclzQu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vclzQu16.c
@@ -17,4 +17,3 @@ void test_vclzQu16 (void)
 }
 
 /* { dg-final { scan-assembler "vclz\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vclzQu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vclzQu32.c
@@ -17,4 +17,3 @@ void test_vclzQu32 (void)
 }
 
 /* { dg-final { scan-assembler "vclz\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vclzQu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vclzQu8.c
@@ -17,4 +17,3 @@ void test_vclzQu8 (void)
 }
 
 /* { dg-final { scan-assembler "vclz\.i8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vclzs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vclzs16.c
@@ -17,4 +17,3 @@ void test_vclzs16 (void)
 }
 
 /* { dg-final { scan-assembler "vclz\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vclzs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vclzs32.c
@@ -17,4 +17,3 @@ void test_vclzs32 (void)
 }
 
 /* { dg-final { scan-assembler "vclz\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vclzs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vclzs8.c
@@ -17,4 +17,3 @@ void test_vclzs8 (void)
 }
 
 /* { dg-final { scan-assembler "vclz\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vclzu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vclzu16.c
@@ -17,4 +17,3 @@ void test_vclzu16 (void)
 }
 
 /* { dg-final { scan-assembler "vclz\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vclzu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vclzu32.c
@@ -17,4 +17,3 @@ void test_vclzu32 (void)
 }
 
 /* { dg-final { scan-assembler "vclz\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vclzu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vclzu8.c
@@ -17,4 +17,3 @@ void test_vclzu8 (void)
 }
 
 /* { dg-final { scan-assembler "vclz\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcntQp8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcntQp8.c
@@ -17,4 +17,3 @@ void test_vcntQp8 (void)
 }
 
 /* { dg-final { scan-assembler "vcnt\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcntQs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcntQs8.c
@@ -17,4 +17,3 @@ void test_vcntQs8 (void)
 }
 
 /* { dg-final { scan-assembler "vcnt\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcntQu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcntQu8.c
@@ -17,4 +17,3 @@ void test_vcntQu8 (void)
 }
 
 /* { dg-final { scan-assembler "vcnt\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcntp8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcntp8.c
@@ -17,4 +17,3 @@ void test_vcntp8 (void)
 }
 
 /* { dg-final { scan-assembler "vcnt\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcnts8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcnts8.c
@@ -17,4 +17,3 @@ void test_vcnts8 (void)
 }
 
 /* { dg-final { scan-assembler "vcnt\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcntu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcntu8.c
@@ -17,4 +17,3 @@ void test_vcntu8 (void)
 }
 
 /* { dg-final { scan-assembler "vcnt\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcombinef32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcombinef32.c
@@ -17,4 +17,3 @@ void test_vcombinef32 (void)
   out_float32x4_t = vcombine_f32 (arg0_float32x2_t, arg1_float32x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcombinep16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcombinep16.c
@@ -17,4 +17,3 @@ void test_vcombinep16 (void)
   out_poly16x8_t = vcombine_p16 (arg0_poly16x4_t, arg1_poly16x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcombinep64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcombinep64.c
@@ -17,4 +17,3 @@ void test_vcombinep64 (void)
   out_poly64x2_t = vcombine_p64 (arg0_poly64x1_t, arg1_poly64x1_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcombinep8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcombinep8.c
@@ -17,4 +17,3 @@ void test_vcombinep8 (void)
   out_poly8x16_t = vcombine_p8 (arg0_poly8x8_t, arg1_poly8x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcombines16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcombines16.c
@@ -17,4 +17,3 @@ void test_vcombines16 (void)
   out_int16x8_t = vcombine_s16 (arg0_int16x4_t, arg1_int16x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcombines32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcombines32.c
@@ -17,4 +17,3 @@ void test_vcombines32 (void)
   out_int32x4_t = vcombine_s32 (arg0_int32x2_t, arg1_int32x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcombines64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcombines64.c
@@ -17,4 +17,3 @@ void test_vcombines64 (void)
   out_int64x2_t = vcombine_s64 (arg0_int64x1_t, arg1_int64x1_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcombines8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcombines8.c
@@ -17,4 +17,3 @@ void test_vcombines8 (void)
   out_int8x16_t = vcombine_s8 (arg0_int8x8_t, arg1_int8x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcombineu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcombineu16.c
@@ -17,4 +17,3 @@ void test_vcombineu16 (void)
   out_uint16x8_t = vcombine_u16 (arg0_uint16x4_t, arg1_uint16x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcombineu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcombineu32.c
@@ -17,4 +17,3 @@ void test_vcombineu32 (void)
   out_uint32x4_t = vcombine_u32 (arg0_uint32x2_t, arg1_uint32x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcombineu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcombineu64.c
@@ -17,4 +17,3 @@ void test_vcombineu64 (void)
   out_uint64x2_t = vcombine_u64 (arg0_uint64x1_t, arg1_uint64x1_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcombineu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcombineu8.c
@@ -17,4 +17,3 @@ void test_vcombineu8 (void)
   out_uint8x16_t = vcombine_u8 (arg0_uint8x8_t, arg1_uint8x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcreatef32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcreatef32.c
@@ -16,4 +16,3 @@ void test_vcreatef32 (void)
   out_float32x2_t = vcreate_f32 (arg0_uint64_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcreatep16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcreatep16.c
@@ -16,4 +16,3 @@ void test_vcreatep16 (void)
   out_poly16x4_t = vcreate_p16 (arg0_uint64_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcreatep64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcreatep64.c
@@ -16,4 +16,3 @@ void test_vcreatep64 (void)
   out_poly64x1_t = vcreate_p64 (arg0_uint64_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcreatep8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcreatep8.c
@@ -16,4 +16,3 @@ void test_vcreatep8 (void)
   out_poly8x8_t = vcreate_p8 (arg0_uint64_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcreates16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcreates16.c
@@ -16,4 +16,3 @@ void test_vcreates16 (void)
   out_int16x4_t = vcreate_s16 (arg0_uint64_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcreates32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcreates32.c
@@ -16,4 +16,3 @@ void test_vcreates32 (void)
   out_int32x2_t = vcreate_s32 (arg0_uint64_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcreates64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcreates64.c
@@ -16,4 +16,3 @@ void test_vcreates64 (void)
   out_int64x1_t = vcreate_s64 (arg0_uint64_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcreates8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcreates8.c
@@ -16,4 +16,3 @@ void test_vcreates8 (void)
   out_int8x8_t = vcreate_s8 (arg0_uint64_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcreateu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcreateu16.c
@@ -16,4 +16,3 @@ void test_vcreateu16 (void)
   out_uint16x4_t = vcreate_u16 (arg0_uint64_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcreateu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcreateu32.c
@@ -16,4 +16,3 @@ void test_vcreateu32 (void)
   out_uint32x2_t = vcreate_u32 (arg0_uint64_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcreateu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcreateu64.c
@@ -16,4 +16,3 @@ void test_vcreateu64 (void)
   out_uint64x1_t = vcreate_u64 (arg0_uint64_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcreateu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcreateu8.c
@@ -16,4 +16,3 @@ void test_vcreateu8 (void)
   out_uint8x8_t = vcreate_u8 (arg0_uint64_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcvtQ_nf32_s32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcvtQ_nf32_s32.c
@@ -17,4 +17,3 @@ void test_vcvtQ_nf32_s32 (void)
 }
 
 /* { dg-final { scan-assembler "vcvt\.f32.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcvtQ_nf32_u32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcvtQ_nf32_u32.c
@@ -17,4 +17,3 @@ void test_vcvtQ_nf32_u32 (void)
 }
 
 /* { dg-final { scan-assembler "vcvt\.f32.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcvtQ_ns32_f32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcvtQ_ns32_f32.c
@@ -17,4 +17,3 @@ void test_vcvtQ_ns32_f32 (void)
 }
 
 /* { dg-final { scan-assembler "vcvt\.s32.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcvtQ_nu32_f32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcvtQ_nu32_f32.c
@@ -17,4 +17,3 @@ void test_vcvtQ_nu32_f32 (void)
 }
 
 /* { dg-final { scan-assembler "vcvt\.u32.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcvtQf32_s32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcvtQf32_s32.c
@@ -17,4 +17,3 @@ void test_vcvtQf32_s32 (void)
 }
 
 /* { dg-final { scan-assembler "vcvt\.f32.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcvtQf32_u32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcvtQf32_u32.c
@@ -17,4 +17,3 @@ void test_vcvtQf32_u32 (void)
 }
 
 /* { dg-final { scan-assembler "vcvt\.f32.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcvtQs32_f32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcvtQs32_f32.c
@@ -17,4 +17,3 @@ void test_vcvtQs32_f32 (void)
 }
 
 /* { dg-final { scan-assembler "vcvt\.s32.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcvtQu32_f32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcvtQu32_f32.c
@@ -17,4 +17,3 @@ void test_vcvtQu32_f32 (void)
 }
 
 /* { dg-final { scan-assembler "vcvt\.u32.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcvt_nf32_s32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcvt_nf32_s32.c
@@ -17,4 +17,3 @@ void test_vcvt_nf32_s32 (void)
 }
 
 /* { dg-final { scan-assembler "vcvt\.f32.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcvt_nf32_u32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcvt_nf32_u32.c
@@ -17,4 +17,3 @@ void test_vcvt_nf32_u32 (void)
 }
 
 /* { dg-final { scan-assembler "vcvt\.f32.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcvt_ns32_f32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcvt_ns32_f32.c
@@ -17,4 +17,3 @@ void test_vcvt_ns32_f32 (void)
 }
 
 /* { dg-final { scan-assembler "vcvt\.s32.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcvt_nu32_f32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcvt_nu32_f32.c
@@ -17,4 +17,3 @@ void test_vcvt_nu32_f32 (void)
 }
 
 /* { dg-final { scan-assembler "vcvt\.u32.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcvtf16_f32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcvtf16_f32.c
@@ -17,4 +17,3 @@ void test_vcvtf16_f32 (void)
 }
 
 /* { dg-final { scan-assembler "vcvt\.f16.f32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcvtf32_f16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcvtf32_f16.c
@@ -17,4 +17,3 @@ void test_vcvtf32_f16 (void)
 }
 
 /* { dg-final { scan-assembler "vcvt\.f32.f16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcvtf32_s32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcvtf32_s32.c
@@ -17,4 +17,3 @@ void test_vcvtf32_s32 (void)
 }
 
 /* { dg-final { scan-assembler "vcvt\.f32.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcvtf32_u32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcvtf32_u32.c
@@ -17,4 +17,3 @@ void test_vcvtf32_u32 (void)
 }
 
 /* { dg-final { scan-assembler "vcvt\.f32.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcvts32_f32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcvts32_f32.c
@@ -17,4 +17,3 @@ void test_vcvts32_f32 (void)
 }
 
 /* { dg-final { scan-assembler "vcvt\.s32.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vcvtu32_f32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vcvtu32_f32.c
@@ -17,4 +17,3 @@ void test_vcvtu32_f32 (void)
 }
 
 /* { dg-final { scan-assembler "vcvt\.u32.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanef32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanef32.c
@@ -17,4 +17,3 @@ void test_vdupQ_lanef32 (void)
 }
 
 /* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanep16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanep16.c
@@ -17,4 +17,3 @@ void test_vdupQ_lanep16 (void)
 }
 
 /* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanep64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanep64.c
@@ -16,4 +16,3 @@ void test_vdupQ_lanep64 (void)
   out_poly64x2_t = vdupq_lane_p64 (arg0_poly64x1_t, 0);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanep8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanep8.c
@@ -17,4 +17,3 @@ void test_vdupQ_lanep8 (void)
 }
 
 /* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanes16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanes16.c
@@ -17,4 +17,3 @@ void test_vdupQ_lanes16 (void)
 }
 
 /* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanes32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanes32.c
@@ -17,4 +17,3 @@ void test_vdupQ_lanes32 (void)
 }
 
 /* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanes64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanes64.c
@@ -16,4 +16,3 @@ void test_vdupQ_lanes64 (void)
   out_int64x2_t = vdupq_lane_s64 (arg0_int64x1_t, 0);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanes8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanes8.c
@@ -17,4 +17,3 @@ void test_vdupQ_lanes8 (void)
 }
 
 /* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vdupQ_laneu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vdupQ_laneu16.c
@@ -17,4 +17,3 @@ void test_vdupQ_laneu16 (void)
 }
 
 /* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vdupQ_laneu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vdupQ_laneu32.c
@@ -17,4 +17,3 @@ void test_vdupQ_laneu32 (void)
 }
 
 /* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vdupQ_laneu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vdupQ_laneu64.c
@@ -16,4 +16,3 @@ void test_vdupQ_laneu64 (void)
   out_uint64x2_t = vdupq_lane_u64 (arg0_uint64x1_t, 0);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vdupQ_laneu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vdupQ_laneu8.c
@@ -17,4 +17,3 @@ void test_vdupQ_laneu8 (void)
 }
 
 /* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vdupQ_nf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vdupQ_nf32.c
@@ -17,4 +17,3 @@ void test_vdupQ_nf32 (void)
 }
 
 /* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vdupQ_np16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vdupQ_np16.c
@@ -17,4 +17,3 @@ void test_vdupQ_np16 (void)
 }
 
 /* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vdupQ_np64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vdupQ_np64.c
@@ -16,4 +16,3 @@ void test_vdupQ_np64 (void)
   out_poly64x2_t = vdupq_n_p64 (arg0_poly64_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vdupQ_np8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vdupQ_np8.c
@@ -17,4 +17,3 @@ void test_vdupQ_np8 (void)
 }
 
 /* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vdupQ_ns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vdupQ_ns16.c
@@ -17,4 +17,3 @@ void test_vdupQ_ns16 (void)
 }
 
 /* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vdupQ_ns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vdupQ_ns32.c
@@ -17,4 +17,3 @@ void test_vdupQ_ns32 (void)
 }
 
 /* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vdupQ_ns64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vdupQ_ns64.c
@@ -16,4 +16,3 @@ void test_vdupQ_ns64 (void)
   out_int64x2_t = vdupq_n_s64 (arg0_int64_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vdupQ_ns8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vdupQ_ns8.c
@@ -17,4 +17,3 @@ void test_vdupQ_ns8 (void)
 }
 
 /* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vdupQ_nu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vdupQ_nu16.c
@@ -17,4 +17,3 @@ void test_vdupQ_nu16 (void)
 }
 
 /* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vdupQ_nu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vdupQ_nu32.c
@@ -17,4 +17,3 @@ void test_vdupQ_nu32 (void)
 }
 
 /* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vdupQ_nu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vdupQ_nu64.c
@@ -16,4 +16,3 @@ void test_vdupQ_nu64 (void)
   out_uint64x2_t = vdupq_n_u64 (arg0_uint64_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vdupQ_nu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vdupQ_nu8.c
@@ -17,4 +17,3 @@ void test_vdupQ_nu8 (void)
 }
 
 /* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vdup_lanef32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vdup_lanef32.c
@@ -17,4 +17,3 @@ void test_vdup_lanef32 (void)
 }
 
 /* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vdup_lanep16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vdup_lanep16.c
@@ -17,4 +17,3 @@ void test_vdup_lanep16 (void)
 }
 
 /* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vdup_lanep64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vdup_lanep64.c
@@ -16,4 +16,3 @@ void test_vdup_lanep64 (void)
   out_poly64x1_t = vdup_lane_p64 (arg0_poly64x1_t, 0);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vdup_lanep8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vdup_lanep8.c
@@ -17,4 +17,3 @@ void test_vdup_lanep8 (void)
 }
 
 /* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vdup_lanes16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vdup_lanes16.c
@@ -17,4 +17,3 @@ void test_vdup_lanes16 (void)
 }
 
 /* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vdup_lanes32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vdup_lanes32.c
@@ -17,4 +17,3 @@ void test_vdup_lanes32 (void)
 }
 
 /* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vdup_lanes64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vdup_lanes64.c
@@ -16,4 +16,3 @@ void test_vdup_lanes64 (void)
   out_int64x1_t = vdup_lane_s64 (arg0_int64x1_t, 0);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vdup_lanes8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vdup_lanes8.c
@@ -17,4 +17,3 @@ void test_vdup_lanes8 (void)
 }
 
 /* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vdup_laneu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vdup_laneu16.c
@@ -17,4 +17,3 @@ void test_vdup_laneu16 (void)
 }
 
 /* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vdup_laneu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vdup_laneu32.c
@@ -17,4 +17,3 @@ void test_vdup_laneu32 (void)
 }
 
 /* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vdup_laneu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vdup_laneu64.c
@@ -16,4 +16,3 @@ void test_vdup_laneu64 (void)
   out_uint64x1_t = vdup_lane_u64 (arg0_uint64x1_t, 0);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vdup_laneu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vdup_laneu8.c
@@ -17,4 +17,3 @@ void test_vdup_laneu8 (void)
 }
 
 /* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vdup_nf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vdup_nf32.c
@@ -17,4 +17,3 @@ void test_vdup_nf32 (void)
 }
 
 /* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vdup_np16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vdup_np16.c
@@ -17,4 +17,3 @@ void test_vdup_np16 (void)
 }
 
 /* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vdup_np64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vdup_np64.c
@@ -16,4 +16,3 @@ void test_vdup_np64 (void)
   out_poly64x1_t = vdup_n_p64 (arg0_poly64_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vdup_np8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vdup_np8.c
@@ -17,4 +17,3 @@ void test_vdup_np8 (void)
 }
 
 /* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vdup_ns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vdup_ns16.c
@@ -17,4 +17,3 @@ void test_vdup_ns16 (void)
 }
 
 /* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vdup_ns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vdup_ns32.c
@@ -17,4 +17,3 @@ void test_vdup_ns32 (void)
 }
 
 /* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vdup_ns64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vdup_ns64.c
@@ -16,4 +16,3 @@ void test_vdup_ns64 (void)
   out_int64x1_t = vdup_n_s64 (arg0_int64_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vdup_ns8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vdup_ns8.c
@@ -17,4 +17,3 @@ void test_vdup_ns8 (void)
 }
 
 /* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vdup_nu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vdup_nu16.c
@@ -17,4 +17,3 @@ void test_vdup_nu16 (void)
 }
 
 /* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vdup_nu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vdup_nu32.c
@@ -17,4 +17,3 @@ void test_vdup_nu32 (void)
 }
 
 /* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vdup_nu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vdup_nu64.c
@@ -16,4 +16,3 @@ void test_vdup_nu64 (void)
   out_uint64x1_t = vdup_n_u64 (arg0_uint64_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vdup_nu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vdup_nu8.c
@@ -17,4 +17,3 @@ void test_vdup_nu8 (void)
 }
 
 /* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vect-vcvt.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vect-vcvt.c
@@ -25,4 +25,3 @@ int convert()
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 2 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vect-vcvtq.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vect-vcvtq.c
@@ -25,4 +25,3 @@ int convert()
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 2 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/veorQs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/veorQs16.c
@@ -18,4 +18,3 @@ void test_veorQs16 (void)
 }
 
 /* { dg-final { scan-assembler "veor\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/veorQs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/veorQs32.c
@@ -18,4 +18,3 @@ void test_veorQs32 (void)
 }
 
 /* { dg-final { scan-assembler "veor\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/veorQs64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/veorQs64.c
@@ -18,4 +18,3 @@ void test_veorQs64 (void)
 }
 
 /* { dg-final { scan-assembler "veor\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/veorQs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/veorQs8.c
@@ -18,4 +18,3 @@ void test_veorQs8 (void)
 }
 
 /* { dg-final { scan-assembler "veor\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/veorQu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/veorQu16.c
@@ -18,4 +18,3 @@ void test_veorQu16 (void)
 }
 
 /* { dg-final { scan-assembler "veor\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/veorQu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/veorQu32.c
@@ -18,4 +18,3 @@ void test_veorQu32 (void)
 }
 
 /* { dg-final { scan-assembler "veor\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/veorQu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/veorQu64.c
@@ -18,4 +18,3 @@ void test_veorQu64 (void)
 }
 
 /* { dg-final { scan-assembler "veor\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/veorQu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/veorQu8.c
@@ -18,4 +18,3 @@ void test_veorQu8 (void)
 }
 
 /* { dg-final { scan-assembler "veor\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/veors16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/veors16.c
@@ -18,4 +18,3 @@ void test_veors16 (void)
 }
 
 /* { dg-final { scan-assembler "veor\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/veors32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/veors32.c
@@ -18,4 +18,3 @@ void test_veors32 (void)
 }
 
 /* { dg-final { scan-assembler "veor\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/veors64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/veors64.c
@@ -17,4 +17,3 @@ void test_veors64 (void)
   out_int64x1_t = veor_s64 (arg0_int64x1_t, arg1_int64x1_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/veors8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/veors8.c
@@ -18,4 +18,3 @@ void test_veors8 (void)
 }
 
 /* { dg-final { scan-assembler "veor\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/veoru16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/veoru16.c
@@ -18,4 +18,3 @@ void test_veoru16 (void)
 }
 
 /* { dg-final { scan-assembler "veor\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/veoru32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/veoru32.c
@@ -18,4 +18,3 @@ void test_veoru32 (void)
 }
 
 /* { dg-final { scan-assembler "veor\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/veoru64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/veoru64.c
@@ -17,4 +17,3 @@ void test_veoru64 (void)
   out_uint64x1_t = veor_u64 (arg0_uint64x1_t, arg1_uint64x1_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/veoru8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/veoru8.c
@@ -18,4 +18,3 @@ void test_veoru8 (void)
 }
 
 /* { dg-final { scan-assembler "veor\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vextQf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vextQf32.c
@@ -18,4 +18,3 @@ void test_vextQf32 (void)
 }
 
 /* { dg-final { scan-assembler "vext\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vextQp16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vextQp16.c
@@ -18,4 +18,3 @@ void test_vextQp16 (void)
 }
 
 /* { dg-final { scan-assembler "vext\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vextQp64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vextQp64.c
@@ -18,4 +18,3 @@ void test_vextQp64 (void)
 }
 
 /* { dg-final { scan-assembler "vext\.64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vextQp8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vextQp8.c
@@ -18,4 +18,3 @@ void test_vextQp8 (void)
 }
 
 /* { dg-final { scan-assembler "vext\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vextQs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vextQs16.c
@@ -18,4 +18,3 @@ void test_vextQs16 (void)
 }
 
 /* { dg-final { scan-assembler "vext\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vextQs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vextQs32.c
@@ -18,4 +18,3 @@ void test_vextQs32 (void)
 }
 
 /* { dg-final { scan-assembler "vext\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vextQs64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vextQs64.c
@@ -18,4 +18,3 @@ void test_vextQs64 (void)
 }
 
 /* { dg-final { scan-assembler "vext\.64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vextQs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vextQs8.c
@@ -18,4 +18,3 @@ void test_vextQs8 (void)
 }
 
 /* { dg-final { scan-assembler "vext\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vextQu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vextQu16.c
@@ -18,4 +18,3 @@ void test_vextQu16 (void)
 }
 
 /* { dg-final { scan-assembler "vext\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vextQu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vextQu32.c
@@ -18,4 +18,3 @@ void test_vextQu32 (void)
 }
 
 /* { dg-final { scan-assembler "vext\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vextQu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vextQu64.c
@@ -18,4 +18,3 @@ void test_vextQu64 (void)
 }
 
 /* { dg-final { scan-assembler "vext\.64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vextQu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vextQu8.c
@@ -18,4 +18,3 @@ void test_vextQu8 (void)
 }
 
 /* { dg-final { scan-assembler "vext\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vextf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vextf32.c
@@ -18,4 +18,3 @@ void test_vextf32 (void)
 }
 
 /* { dg-final { scan-assembler "vext\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vextp16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vextp16.c
@@ -18,4 +18,3 @@ void test_vextp16 (void)
 }
 
 /* { dg-final { scan-assembler "vext\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vextp64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vextp64.c
@@ -18,4 +18,3 @@ void test_vextp64 (void)
 }
 
 /* { dg-final { scan-assembler "vext\.64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vextp8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vextp8.c
@@ -18,4 +18,3 @@ void test_vextp8 (void)
 }
 
 /* { dg-final { scan-assembler "vext\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vexts16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vexts16.c
@@ -18,4 +18,3 @@ void test_vexts16 (void)
 }
 
 /* { dg-final { scan-assembler "vext\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vexts32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vexts32.c
@@ -18,4 +18,3 @@ void test_vexts32 (void)
 }
 
 /* { dg-final { scan-assembler "vext\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vexts64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vexts64.c
@@ -18,4 +18,3 @@ void test_vexts64 (void)
 }
 
 /* { dg-final { scan-assembler "vext\.64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vexts8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vexts8.c
@@ -18,4 +18,3 @@ void test_vexts8 (void)
 }
 
 /* { dg-final { scan-assembler "vext\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vextu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vextu16.c
@@ -18,4 +18,3 @@ void test_vextu16 (void)
 }
 
 /* { dg-final { scan-assembler "vext\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vextu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vextu32.c
@@ -18,4 +18,3 @@ void test_vextu32 (void)
 }
 
 /* { dg-final { scan-assembler "vext\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vextu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vextu64.c
@@ -18,4 +18,3 @@ void test_vextu64 (void)
 }
 
 /* { dg-final { scan-assembler "vext\.64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vextu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vextu8.c
@@ -18,4 +18,3 @@ void test_vextu8 (void)
 }
 
 /* { dg-final { scan-assembler "vext\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vfmaQf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vfmaQf32.c
@@ -19,4 +19,3 @@ void test_vfmaQf32 (void)
 }
 
 /* { dg-final { scan-assembler "vfma\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vfmaf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vfmaf32.c
@@ -19,4 +19,3 @@ void test_vfmaf32 (void)
 }
 
 /* { dg-final { scan-assembler "vfma\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vfmsQf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vfmsQf32.c
@@ -19,4 +19,3 @@ void test_vfmsQf32 (void)
 }
 
 /* { dg-final { scan-assembler "vfms\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vfmsf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vfmsf32.c
@@ -19,4 +19,3 @@ void test_vfmsf32 (void)
 }
 
 /* { dg-final { scan-assembler "vfms\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vfp-shift-a2t2.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vfp-shift-a2t2.c
@@ -25,4 +25,3 @@ uint64x2_t test_vshll_n_u32 (uint32x2_t a)
 /* { dg-final { scan-assembler "vshll\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vshll\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vshll\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanef32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanef32.c
@@ -17,4 +17,3 @@ void test_vgetQ_lanef32 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.32\[ 	\]+\[rR\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanep16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanep16.c
@@ -17,4 +17,3 @@ void test_vgetQ_lanep16 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.u16\[ 	\]+\[rR\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanep8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanep8.c
@@ -17,4 +17,3 @@ void test_vgetQ_lanep8 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.u8\[ 	\]+\[rR\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes16.c
@@ -17,4 +17,3 @@ void test_vgetQ_lanes16 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.s16\[ 	\]+\[rR\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes32.c
@@ -17,4 +17,3 @@ void test_vgetQ_lanes32 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.32\[ 	\]+\[rR\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes64.c
@@ -17,4 +17,3 @@ void test_vgetQ_lanes64 (void)
 }
 
 /* { dg-final { scan-assembler "((vmov)|(fmrrd))\[ 	\]+\[rR\]\[0-9\]+, \[rR\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes8.c
@@ -17,4 +17,3 @@ void test_vgetQ_lanes8 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.s8\[ 	\]+\[rR\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu16.c
@@ -17,4 +17,3 @@ void test_vgetQ_laneu16 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.u16\[ 	\]+\[rR\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu32.c
@@ -17,4 +17,3 @@ void test_vgetQ_laneu32 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.32\[ 	\]+\[rR\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu64.c
@@ -17,4 +17,3 @@ void test_vgetQ_laneu64 (void)
 }
 
 /* { dg-final { scan-assembler "((vmov)|(fmrrd))\[ 	\]+\[rR\]\[0-9\]+, \[rR\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu8.c
@@ -17,4 +17,3 @@ void test_vgetQ_laneu8 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.u8\[ 	\]+\[rR\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vget_highf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vget_highf32.c
@@ -16,4 +16,3 @@ void test_vget_highf32 (void)
   out_float32x2_t = vget_high_f32 (arg0_float32x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vget_highp16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vget_highp16.c
@@ -16,4 +16,3 @@ void test_vget_highp16 (void)
   out_poly16x4_t = vget_high_p16 (arg0_poly16x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vget_highp64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vget_highp64.c
@@ -16,4 +16,3 @@ void test_vget_highp64 (void)
   out_poly64x1_t = vget_high_p64 (arg0_poly64x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vget_highp8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vget_highp8.c
@@ -16,4 +16,3 @@ void test_vget_highp8 (void)
   out_poly8x8_t = vget_high_p8 (arg0_poly8x16_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vget_highs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vget_highs16.c
@@ -16,4 +16,3 @@ void test_vget_highs16 (void)
   out_int16x4_t = vget_high_s16 (arg0_int16x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vget_highs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vget_highs32.c
@@ -16,4 +16,3 @@ void test_vget_highs32 (void)
   out_int32x2_t = vget_high_s32 (arg0_int32x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vget_highs64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vget_highs64.c
@@ -16,4 +16,3 @@ void test_vget_highs64 (void)
   out_int64x1_t = vget_high_s64 (arg0_int64x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vget_highs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vget_highs8.c
@@ -16,4 +16,3 @@ void test_vget_highs8 (void)
   out_int8x8_t = vget_high_s8 (arg0_int8x16_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vget_highu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vget_highu16.c
@@ -16,4 +16,3 @@ void test_vget_highu16 (void)
   out_uint16x4_t = vget_high_u16 (arg0_uint16x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vget_highu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vget_highu32.c
@@ -16,4 +16,3 @@ void test_vget_highu32 (void)
   out_uint32x2_t = vget_high_u32 (arg0_uint32x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vget_highu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vget_highu64.c
@@ -16,4 +16,3 @@ void test_vget_highu64 (void)
   out_uint64x1_t = vget_high_u64 (arg0_uint64x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vget_highu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vget_highu8.c
@@ -16,4 +16,3 @@ void test_vget_highu8 (void)
   out_uint8x8_t = vget_high_u8 (arg0_uint8x16_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vget_lanef32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vget_lanef32.c
@@ -17,4 +17,3 @@ void test_vget_lanef32 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.32\[ 	\]+\[rR\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vget_lanep16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vget_lanep16.c
@@ -17,4 +17,3 @@ void test_vget_lanep16 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.u16\[ 	\]+\[rR\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vget_lanep8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vget_lanep8.c
@@ -17,4 +17,3 @@ void test_vget_lanep8 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.u8\[ 	\]+\[rR\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vget_lanes16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vget_lanes16.c
@@ -17,4 +17,3 @@ void test_vget_lanes16 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.s16\[ 	\]+\[rR\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vget_lanes32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vget_lanes32.c
@@ -17,4 +17,3 @@ void test_vget_lanes32 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.32\[ 	\]+\[rR\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vget_lanes64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vget_lanes64.c
@@ -16,4 +16,3 @@ void test_vget_lanes64 (void)
   out_int64_t = vget_lane_s64 (arg0_int64x1_t, 0);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vget_lanes8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vget_lanes8.c
@@ -17,4 +17,3 @@ void test_vget_lanes8 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.s8\[ 	\]+\[rR\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vget_laneu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vget_laneu16.c
@@ -17,4 +17,3 @@ void test_vget_laneu16 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.u16\[ 	\]+\[rR\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vget_laneu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vget_laneu32.c
@@ -17,4 +17,3 @@ void test_vget_laneu32 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.32\[ 	\]+\[rR\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vget_laneu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vget_laneu64.c
@@ -16,4 +16,3 @@ void test_vget_laneu64 (void)
   out_uint64_t = vget_lane_u64 (arg0_uint64x1_t, 0);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vget_laneu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vget_laneu8.c
@@ -17,4 +17,3 @@ void test_vget_laneu8 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.u8\[ 	\]+\[rR\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vget_lowf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vget_lowf32.c
@@ -17,4 +17,3 @@ void test_vget_lowf32 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vget_lowp16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vget_lowp16.c
@@ -17,4 +17,3 @@ void test_vget_lowp16 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vget_lowp64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vget_lowp64.c
@@ -16,4 +16,3 @@ void test_vget_lowp64 (void)
   out_poly64x1_t = vget_low_p64 (arg0_poly64x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vget_lowp8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vget_lowp8.c
@@ -17,4 +17,3 @@ void test_vget_lowp8 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vget_lows16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vget_lows16.c
@@ -17,4 +17,3 @@ void test_vget_lows16 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vget_lows32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vget_lows32.c
@@ -17,4 +17,3 @@ void test_vget_lows32 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vget_lows64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vget_lows64.c
@@ -16,4 +16,3 @@ void test_vget_lows64 (void)
   out_int64x1_t = vget_low_s64 (arg0_int64x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vget_lows8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vget_lows8.c
@@ -17,4 +17,3 @@ void test_vget_lows8 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vget_lowu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vget_lowu16.c
@@ -17,4 +17,3 @@ void test_vget_lowu16 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vget_lowu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vget_lowu32.c
@@ -17,4 +17,3 @@ void test_vget_lowu32 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vget_lowu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vget_lowu64.c
@@ -16,4 +16,3 @@ void test_vget_lowu64 (void)
   out_uint64x1_t = vget_low_u64 (arg0_uint64x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vget_lowu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vget_lowu8.c
@@ -17,4 +17,3 @@ void test_vget_lowu8 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vhaddQs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vhaddQs16.c
@@ -18,4 +18,3 @@ void test_vhaddQs16 (void)
 }
 
 /* { dg-final { scan-assembler "vhadd\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vhaddQs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vhaddQs32.c
@@ -18,4 +18,3 @@ void test_vhaddQs32 (void)
 }
 
 /* { dg-final { scan-assembler "vhadd\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vhaddQs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vhaddQs8.c
@@ -18,4 +18,3 @@ void test_vhaddQs8 (void)
 }
 
 /* { dg-final { scan-assembler "vhadd\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vhaddQu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vhaddQu16.c
@@ -18,4 +18,3 @@ void test_vhaddQu16 (void)
 }
 
 /* { dg-final { scan-assembler "vhadd\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vhaddQu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vhaddQu32.c
@@ -18,4 +18,3 @@ void test_vhaddQu32 (void)
 }
 
 /* { dg-final { scan-assembler "vhadd\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vhaddQu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vhaddQu8.c
@@ -18,4 +18,3 @@ void test_vhaddQu8 (void)
 }
 
 /* { dg-final { scan-assembler "vhadd\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vhadds16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vhadds16.c
@@ -18,4 +18,3 @@ void test_vhadds16 (void)
 }
 
 /* { dg-final { scan-assembler "vhadd\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vhadds32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vhadds32.c
@@ -18,4 +18,3 @@ void test_vhadds32 (void)
 }
 
 /* { dg-final { scan-assembler "vhadd\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vhadds8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vhadds8.c
@@ -18,4 +18,3 @@ void test_vhadds8 (void)
 }
 
 /* { dg-final { scan-assembler "vhadd\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vhaddu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vhaddu16.c
@@ -18,4 +18,3 @@ void test_vhaddu16 (void)
 }
 
 /* { dg-final { scan-assembler "vhadd\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vhaddu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vhaddu32.c
@@ -18,4 +18,3 @@ void test_vhaddu32 (void)
 }
 
 /* { dg-final { scan-assembler "vhadd\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vhaddu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vhaddu8.c
@@ -18,4 +18,3 @@ void test_vhaddu8 (void)
 }
 
 /* { dg-final { scan-assembler "vhadd\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vhsubQs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vhsubQs16.c
@@ -18,4 +18,3 @@ void test_vhsubQs16 (void)
 }
 
 /* { dg-final { scan-assembler "vhsub\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vhsubQs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vhsubQs32.c
@@ -18,4 +18,3 @@ void test_vhsubQs32 (void)
 }
 
 /* { dg-final { scan-assembler "vhsub\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vhsubQs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vhsubQs8.c
@@ -18,4 +18,3 @@ void test_vhsubQs8 (void)
 }
 
 /* { dg-final { scan-assembler "vhsub\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vhsubQu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vhsubQu16.c
@@ -18,4 +18,3 @@ void test_vhsubQu16 (void)
 }
 
 /* { dg-final { scan-assembler "vhsub\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vhsubQu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vhsubQu32.c
@@ -18,4 +18,3 @@ void test_vhsubQu32 (void)
 }
 
 /* { dg-final { scan-assembler "vhsub\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vhsubQu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vhsubQu8.c
@@ -18,4 +18,3 @@ void test_vhsubQu8 (void)
 }
 
 /* { dg-final { scan-assembler "vhsub\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vhsubs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vhsubs16.c
@@ -18,4 +18,3 @@ void test_vhsubs16 (void)
 }
 
 /* { dg-final { scan-assembler "vhsub\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vhsubs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vhsubs32.c
@@ -18,4 +18,3 @@ void test_vhsubs32 (void)
 }
 
 /* { dg-final { scan-assembler "vhsub\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vhsubs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vhsubs8.c
@@ -18,4 +18,3 @@ void test_vhsubs8 (void)
 }
 
 /* { dg-final { scan-assembler "vhsub\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vhsubu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vhsubu16.c
@@ -18,4 +18,3 @@ void test_vhsubu16 (void)
 }
 
 /* { dg-final { scan-assembler "vhsub\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vhsubu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vhsubu32.c
@@ -18,4 +18,3 @@ void test_vhsubu32 (void)
 }
 
 /* { dg-final { scan-assembler "vhsub\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vhsubu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vhsubu8.c
@@ -18,4 +18,3 @@ void test_vhsubu8 (void)
 }
 
 /* { dg-final { scan-assembler "vhsub\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupf32.c
@@ -16,4 +16,3 @@ void test_vld1Q_dupf32 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupp16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupp16.c
@@ -16,4 +16,3 @@ void test_vld1Q_dupp16 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupp64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupp64.c
@@ -16,4 +16,3 @@ void test_vld1Q_dupp64 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.64\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupp8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupp8.c
@@ -16,4 +16,3 @@ void test_vld1Q_dupp8 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1Q_dups16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1Q_dups16.c
@@ -16,4 +16,3 @@ void test_vld1Q_dups16 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1Q_dups32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1Q_dups32.c
@@ -16,4 +16,3 @@ void test_vld1Q_dups32 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1Q_dups64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1Q_dups64.c
@@ -16,4 +16,3 @@ void test_vld1Q_dups64 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.64\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1Q_dups8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1Q_dups8.c
@@ -16,4 +16,3 @@ void test_vld1Q_dups8 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu16.c
@@ -16,4 +16,3 @@ void test_vld1Q_dupu16 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu32.c
@@ -16,4 +16,3 @@ void test_vld1Q_dupu32 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu64.c
@@ -16,4 +16,3 @@ void test_vld1Q_dupu64 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.64\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu8.c
@@ -16,4 +16,3 @@ void test_vld1Q_dupu8 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanef32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanef32.c
@@ -17,4 +17,3 @@ void test_vld1Q_lanef32 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanep16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanep16.c
@@ -17,4 +17,3 @@ void test_vld1Q_lanep16 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanep64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanep64.c
@@ -17,4 +17,3 @@ void test_vld1Q_lanep64 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.64\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanep8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanep8.c
@@ -17,4 +17,3 @@ void test_vld1Q_lanep8 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes16.c
@@ -17,4 +17,3 @@ void test_vld1Q_lanes16 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes32.c
@@ -17,4 +17,3 @@ void test_vld1Q_lanes32 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes64.c
@@ -17,4 +17,3 @@ void test_vld1Q_lanes64 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.64\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes8.c
@@ -17,4 +17,3 @@ void test_vld1Q_lanes8 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu16.c
@@ -17,4 +17,3 @@ void test_vld1Q_laneu16 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu32.c
@@ -17,4 +17,3 @@ void test_vld1Q_laneu32 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu64.c
@@ -17,4 +17,3 @@ void test_vld1Q_laneu64 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.64\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu8.c
@@ -17,4 +17,3 @@ void test_vld1Q_laneu8 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1Qf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1Qf32.c
@@ -16,4 +16,3 @@ void test_vld1Qf32 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1Qp16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1Qp16.c
@@ -16,4 +16,3 @@ void test_vld1Qp16 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1Qp64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1Qp64.c
@@ -16,4 +16,3 @@ void test_vld1Qp64 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1Qp8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1Qp8.c
@@ -16,4 +16,3 @@ void test_vld1Qp8 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1Qs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1Qs16.c
@@ -16,4 +16,3 @@ void test_vld1Qs16 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1Qs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1Qs32.c
@@ -16,4 +16,3 @@ void test_vld1Qs32 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1Qs64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1Qs64.c
@@ -16,4 +16,3 @@ void test_vld1Qs64 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1Qs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1Qs8.c
@@ -16,4 +16,3 @@ void test_vld1Qs8 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1Qu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1Qu16.c
@@ -16,4 +16,3 @@ void test_vld1Qu16 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1Qu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1Qu32.c
@@ -16,4 +16,3 @@ void test_vld1Qu32 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1Qu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1Qu64.c
@@ -16,4 +16,3 @@ void test_vld1Qu64 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1Qu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1Qu8.c
@@ -16,4 +16,3 @@ void test_vld1Qu8 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1_dupf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1_dupf32.c
@@ -16,4 +16,3 @@ void test_vld1_dupf32 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\\\]\\\})|(\[dD\]\[0-9\]+\\\[\\\])), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1_dupp16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1_dupp16.c
@@ -16,4 +16,3 @@ void test_vld1_dupp16 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\\\]\\\})|(\[dD\]\[0-9\]+\\\[\\\])), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1_dupp64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1_dupp64.c
@@ -16,4 +16,3 @@ void test_vld1_dupp64 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.64\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1_dupp8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1_dupp8.c
@@ -16,4 +16,3 @@ void test_vld1_dupp8 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\\\]\\\})|(\[dD\]\[0-9\]+\\\[\\\])), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1_dups16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1_dups16.c
@@ -16,4 +16,3 @@ void test_vld1_dups16 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\\\]\\\})|(\[dD\]\[0-9\]+\\\[\\\])), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1_dups32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1_dups32.c
@@ -16,4 +16,3 @@ void test_vld1_dups32 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\\\]\\\})|(\[dD\]\[0-9\]+\\\[\\\])), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1_dups64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1_dups64.c
@@ -16,4 +16,3 @@ void test_vld1_dups64 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.64\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1_dups8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1_dups8.c
@@ -16,4 +16,3 @@ void test_vld1_dups8 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\\\]\\\})|(\[dD\]\[0-9\]+\\\[\\\])), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1_dupu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1_dupu16.c
@@ -16,4 +16,3 @@ void test_vld1_dupu16 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\\\]\\\})|(\[dD\]\[0-9\]+\\\[\\\])), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1_dupu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1_dupu32.c
@@ -16,4 +16,3 @@ void test_vld1_dupu32 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\\\]\\\})|(\[dD\]\[0-9\]+\\\[\\\])), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1_dupu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1_dupu64.c
@@ -16,4 +16,3 @@ void test_vld1_dupu64 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.64\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1_dupu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1_dupu8.c
@@ -16,4 +16,3 @@ void test_vld1_dupu8 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\\\]\\\})|(\[dD\]\[0-9\]+\\\[\\\])), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1_lanef32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1_lanef32.c
@@ -17,4 +17,3 @@ void test_vld1_lanef32 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1_lanep16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1_lanep16.c
@@ -17,4 +17,3 @@ void test_vld1_lanep16 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1_lanep64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1_lanep64.c
@@ -17,4 +17,3 @@ void test_vld1_lanep64 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.64\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1_lanep8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1_lanep8.c
@@ -17,4 +17,3 @@ void test_vld1_lanep8 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1_lanes16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1_lanes16.c
@@ -17,4 +17,3 @@ void test_vld1_lanes16 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1_lanes32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1_lanes32.c
@@ -17,4 +17,3 @@ void test_vld1_lanes32 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1_lanes64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1_lanes64.c
@@ -17,4 +17,3 @@ void test_vld1_lanes64 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.64\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1_lanes8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1_lanes8.c
@@ -17,4 +17,3 @@ void test_vld1_lanes8 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1_laneu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1_laneu16.c
@@ -17,4 +17,3 @@ void test_vld1_laneu16 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1_laneu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1_laneu32.c
@@ -17,4 +17,3 @@ void test_vld1_laneu32 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1_laneu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1_laneu64.c
@@ -17,4 +17,3 @@ void test_vld1_laneu64 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.64\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1_laneu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1_laneu8.c
@@ -17,4 +17,3 @@ void test_vld1_laneu8 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1f32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1f32.c
@@ -16,4 +16,3 @@ void test_vld1f32 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1p16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1p16.c
@@ -16,4 +16,3 @@ void test_vld1p16 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1p64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1p64.c
@@ -16,4 +16,3 @@ void test_vld1p64 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.64\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1p8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1p8.c
@@ -16,4 +16,3 @@ void test_vld1p8 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1s16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1s16.c
@@ -16,4 +16,3 @@ void test_vld1s16 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1s32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1s32.c
@@ -16,4 +16,3 @@ void test_vld1s32 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1s64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1s64.c
@@ -16,4 +16,3 @@ void test_vld1s64 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.64\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1s8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1s8.c
@@ -16,4 +16,3 @@ void test_vld1s8 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1u16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1u16.c
@@ -16,4 +16,3 @@ void test_vld1u16 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1u32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1u32.c
@@ -16,4 +16,3 @@ void test_vld1u32 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1u64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1u64.c
@@ -16,4 +16,3 @@ void test_vld1u64 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.64\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld1u8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld1u8.c
@@ -16,4 +16,3 @@ void test_vld1u8 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld2Q_lanef32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld2Q_lanef32.c
@@ -17,4 +17,3 @@ void test_vld2Q_lanef32 (void)
 }
 
 /* { dg-final { scan-assembler "vld2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld2Q_lanep16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld2Q_lanep16.c
@@ -17,4 +17,3 @@ void test_vld2Q_lanep16 (void)
 }
 
 /* { dg-final { scan-assembler "vld2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld2Q_lanes16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld2Q_lanes16.c
@@ -17,4 +17,3 @@ void test_vld2Q_lanes16 (void)
 }
 
 /* { dg-final { scan-assembler "vld2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld2Q_lanes32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld2Q_lanes32.c
@@ -17,4 +17,3 @@ void test_vld2Q_lanes32 (void)
 }
 
 /* { dg-final { scan-assembler "vld2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld2Q_laneu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld2Q_laneu16.c
@@ -17,4 +17,3 @@ void test_vld2Q_laneu16 (void)
 }
 
 /* { dg-final { scan-assembler "vld2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld2Q_laneu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld2Q_laneu32.c
@@ -17,4 +17,3 @@ void test_vld2Q_laneu32 (void)
 }
 
 /* { dg-final { scan-assembler "vld2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld2Qf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld2Qf32.c
@@ -17,4 +17,3 @@ void test_vld2Qf32 (void)
 
 /* { dg-final { scan-assembler "vld2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vld2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld2Qp16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld2Qp16.c
@@ -17,4 +17,3 @@ void test_vld2Qp16 (void)
 
 /* { dg-final { scan-assembler "vld2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vld2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld2Qp8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld2Qp8.c
@@ -17,4 +17,3 @@ void test_vld2Qp8 (void)
 
 /* { dg-final { scan-assembler "vld2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vld2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld2Qs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld2Qs16.c
@@ -17,4 +17,3 @@ void test_vld2Qs16 (void)
 
 /* { dg-final { scan-assembler "vld2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vld2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld2Qs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld2Qs32.c
@@ -17,4 +17,3 @@ void test_vld2Qs32 (void)
 
 /* { dg-final { scan-assembler "vld2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vld2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld2Qs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld2Qs8.c
@@ -17,4 +17,3 @@ void test_vld2Qs8 (void)
 
 /* { dg-final { scan-assembler "vld2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vld2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld2Qu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld2Qu16.c
@@ -17,4 +17,3 @@ void test_vld2Qu16 (void)
 
 /* { dg-final { scan-assembler "vld2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vld2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld2Qu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld2Qu32.c
@@ -17,4 +17,3 @@ void test_vld2Qu32 (void)
 
 /* { dg-final { scan-assembler "vld2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vld2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld2Qu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld2Qu8.c
@@ -17,4 +17,3 @@ void test_vld2Qu8 (void)
 
 /* { dg-final { scan-assembler "vld2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vld2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld2_dupf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld2_dupf32.c
@@ -16,4 +16,3 @@ void test_vld2_dupf32 (void)
 }
 
 /* { dg-final { scan-assembler "vld2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld2_dupp16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld2_dupp16.c
@@ -16,4 +16,3 @@ void test_vld2_dupp16 (void)
 }
 
 /* { dg-final { scan-assembler "vld2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld2_dupp64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld2_dupp64.c
@@ -16,4 +16,3 @@ void test_vld2_dupp64 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld2_dupp8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld2_dupp8.c
@@ -16,4 +16,3 @@ void test_vld2_dupp8 (void)
 }
 
 /* { dg-final { scan-assembler "vld2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld2_dups16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld2_dups16.c
@@ -16,4 +16,3 @@ void test_vld2_dups16 (void)
 }
 
 /* { dg-final { scan-assembler "vld2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld2_dups32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld2_dups32.c
@@ -16,4 +16,3 @@ void test_vld2_dups32 (void)
 }
 
 /* { dg-final { scan-assembler "vld2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld2_dups64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld2_dups64.c
@@ -16,4 +16,3 @@ void test_vld2_dups64 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld2_dups8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld2_dups8.c
@@ -16,4 +16,3 @@ void test_vld2_dups8 (void)
 }
 
 /* { dg-final { scan-assembler "vld2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld2_dupu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld2_dupu16.c
@@ -16,4 +16,3 @@ void test_vld2_dupu16 (void)
 }
 
 /* { dg-final { scan-assembler "vld2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld2_dupu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld2_dupu32.c
@@ -16,4 +16,3 @@ void test_vld2_dupu32 (void)
 }
 
 /* { dg-final { scan-assembler "vld2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld2_dupu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld2_dupu64.c
@@ -16,4 +16,3 @@ void test_vld2_dupu64 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld2_dupu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld2_dupu8.c
@@ -16,4 +16,3 @@ void test_vld2_dupu8 (void)
 }
 
 /* { dg-final { scan-assembler "vld2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld2_lanef32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld2_lanef32.c
@@ -17,4 +17,3 @@ void test_vld2_lanef32 (void)
 }
 
 /* { dg-final { scan-assembler "vld2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld2_lanep16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld2_lanep16.c
@@ -17,4 +17,3 @@ void test_vld2_lanep16 (void)
 }
 
 /* { dg-final { scan-assembler "vld2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld2_lanep8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld2_lanep8.c
@@ -17,4 +17,3 @@ void test_vld2_lanep8 (void)
 }
 
 /* { dg-final { scan-assembler "vld2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld2_lanes16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld2_lanes16.c
@@ -17,4 +17,3 @@ void test_vld2_lanes16 (void)
 }
 
 /* { dg-final { scan-assembler "vld2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld2_lanes32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld2_lanes32.c
@@ -17,4 +17,3 @@ void test_vld2_lanes32 (void)
 }
 
 /* { dg-final { scan-assembler "vld2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld2_lanes8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld2_lanes8.c
@@ -17,4 +17,3 @@ void test_vld2_lanes8 (void)
 }
 
 /* { dg-final { scan-assembler "vld2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld2_laneu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld2_laneu16.c
@@ -17,4 +17,3 @@ void test_vld2_laneu16 (void)
 }
 
 /* { dg-final { scan-assembler "vld2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld2_laneu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld2_laneu32.c
@@ -17,4 +17,3 @@ void test_vld2_laneu32 (void)
 }
 
 /* { dg-final { scan-assembler "vld2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld2_laneu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld2_laneu8.c
@@ -17,4 +17,3 @@ void test_vld2_laneu8 (void)
 }
 
 /* { dg-final { scan-assembler "vld2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld2f32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld2f32.c
@@ -16,4 +16,3 @@ void test_vld2f32 (void)
 }
 
 /* { dg-final { scan-assembler "vld2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld2p16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld2p16.c
@@ -16,4 +16,3 @@ void test_vld2p16 (void)
 }
 
 /* { dg-final { scan-assembler "vld2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld2p64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld2p64.c
@@ -16,4 +16,3 @@ void test_vld2p64 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld2p8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld2p8.c
@@ -16,4 +16,3 @@ void test_vld2p8 (void)
 }
 
 /* { dg-final { scan-assembler "vld2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld2s16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld2s16.c
@@ -16,4 +16,3 @@ void test_vld2s16 (void)
 }
 
 /* { dg-final { scan-assembler "vld2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld2s32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld2s32.c
@@ -16,4 +16,3 @@ void test_vld2s32 (void)
 }
 
 /* { dg-final { scan-assembler "vld2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld2s64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld2s64.c
@@ -16,4 +16,3 @@ void test_vld2s64 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld2s8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld2s8.c
@@ -16,4 +16,3 @@ void test_vld2s8 (void)
 }
 
 /* { dg-final { scan-assembler "vld2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld2u16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld2u16.c
@@ -16,4 +16,3 @@ void test_vld2u16 (void)
 }
 
 /* { dg-final { scan-assembler "vld2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld2u32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld2u32.c
@@ -16,4 +16,3 @@ void test_vld2u32 (void)
 }
 
 /* { dg-final { scan-assembler "vld2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld2u64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld2u64.c
@@ -16,4 +16,3 @@ void test_vld2u64 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld2u8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld2u8.c
@@ -16,4 +16,3 @@ void test_vld2u8 (void)
 }
 
 /* { dg-final { scan-assembler "vld2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld3Q_lanef32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld3Q_lanef32.c
@@ -17,4 +17,3 @@ void test_vld3Q_lanef32 (void)
 }
 
 /* { dg-final { scan-assembler "vld3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld3Q_lanep16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld3Q_lanep16.c
@@ -17,4 +17,3 @@ void test_vld3Q_lanep16 (void)
 }
 
 /* { dg-final { scan-assembler "vld3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld3Q_lanes16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld3Q_lanes16.c
@@ -17,4 +17,3 @@ void test_vld3Q_lanes16 (void)
 }
 
 /* { dg-final { scan-assembler "vld3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld3Q_lanes32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld3Q_lanes32.c
@@ -17,4 +17,3 @@ void test_vld3Q_lanes32 (void)
 }
 
 /* { dg-final { scan-assembler "vld3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld3Q_laneu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld3Q_laneu16.c
@@ -17,4 +17,3 @@ void test_vld3Q_laneu16 (void)
 }
 
 /* { dg-final { scan-assembler "vld3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld3Q_laneu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld3Q_laneu32.c
@@ -17,4 +17,3 @@ void test_vld3Q_laneu32 (void)
 }
 
 /* { dg-final { scan-assembler "vld3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld3Qf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld3Qf32.c
@@ -17,4 +17,3 @@ void test_vld3Qf32 (void)
 
 /* { dg-final { scan-assembler "vld3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vld3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld3Qp16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld3Qp16.c
@@ -17,4 +17,3 @@ void test_vld3Qp16 (void)
 
 /* { dg-final { scan-assembler "vld3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vld3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld3Qp8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld3Qp8.c
@@ -17,4 +17,3 @@ void test_vld3Qp8 (void)
 
 /* { dg-final { scan-assembler "vld3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vld3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld3Qs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld3Qs16.c
@@ -17,4 +17,3 @@ void test_vld3Qs16 (void)
 
 /* { dg-final { scan-assembler "vld3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vld3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld3Qs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld3Qs32.c
@@ -17,4 +17,3 @@ void test_vld3Qs32 (void)
 
 /* { dg-final { scan-assembler "vld3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vld3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld3Qs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld3Qs8.c
@@ -17,4 +17,3 @@ void test_vld3Qs8 (void)
 
 /* { dg-final { scan-assembler "vld3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vld3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld3Qu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld3Qu16.c
@@ -17,4 +17,3 @@ void test_vld3Qu16 (void)
 
 /* { dg-final { scan-assembler "vld3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vld3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld3Qu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld3Qu32.c
@@ -17,4 +17,3 @@ void test_vld3Qu32 (void)
 
 /* { dg-final { scan-assembler "vld3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vld3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld3Qu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld3Qu8.c
@@ -17,4 +17,3 @@ void test_vld3Qu8 (void)
 
 /* { dg-final { scan-assembler "vld3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vld3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld3_dupf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld3_dupf32.c
@@ -16,4 +16,3 @@ void test_vld3_dupf32 (void)
 }
 
 /* { dg-final { scan-assembler "vld3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld3_dupp16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld3_dupp16.c
@@ -16,4 +16,3 @@ void test_vld3_dupp16 (void)
 }
 
 /* { dg-final { scan-assembler "vld3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld3_dupp64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld3_dupp64.c
@@ -16,4 +16,3 @@ void test_vld3_dupp64 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld3_dupp8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld3_dupp8.c
@@ -16,4 +16,3 @@ void test_vld3_dupp8 (void)
 }
 
 /* { dg-final { scan-assembler "vld3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld3_dups16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld3_dups16.c
@@ -16,4 +16,3 @@ void test_vld3_dups16 (void)
 }
 
 /* { dg-final { scan-assembler "vld3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld3_dups32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld3_dups32.c
@@ -16,4 +16,3 @@ void test_vld3_dups32 (void)
 }
 
 /* { dg-final { scan-assembler "vld3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld3_dups64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld3_dups64.c
@@ -16,4 +16,3 @@ void test_vld3_dups64 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld3_dups8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld3_dups8.c
@@ -16,4 +16,3 @@ void test_vld3_dups8 (void)
 }
 
 /* { dg-final { scan-assembler "vld3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld3_dupu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld3_dupu16.c
@@ -16,4 +16,3 @@ void test_vld3_dupu16 (void)
 }
 
 /* { dg-final { scan-assembler "vld3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld3_dupu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld3_dupu32.c
@@ -16,4 +16,3 @@ void test_vld3_dupu32 (void)
 }
 
 /* { dg-final { scan-assembler "vld3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld3_dupu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld3_dupu64.c
@@ -16,4 +16,3 @@ void test_vld3_dupu64 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld3_dupu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld3_dupu8.c
@@ -16,4 +16,3 @@ void test_vld3_dupu8 (void)
 }
 
 /* { dg-final { scan-assembler "vld3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld3_lanef32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld3_lanef32.c
@@ -17,4 +17,3 @@ void test_vld3_lanef32 (void)
 }
 
 /* { dg-final { scan-assembler "vld3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld3_lanep16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld3_lanep16.c
@@ -17,4 +17,3 @@ void test_vld3_lanep16 (void)
 }
 
 /* { dg-final { scan-assembler "vld3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld3_lanep8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld3_lanep8.c
@@ -17,4 +17,3 @@ void test_vld3_lanep8 (void)
 }
 
 /* { dg-final { scan-assembler "vld3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld3_lanes16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld3_lanes16.c
@@ -17,4 +17,3 @@ void test_vld3_lanes16 (void)
 }
 
 /* { dg-final { scan-assembler "vld3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld3_lanes32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld3_lanes32.c
@@ -17,4 +17,3 @@ void test_vld3_lanes32 (void)
 }
 
 /* { dg-final { scan-assembler "vld3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld3_lanes8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld3_lanes8.c
@@ -17,4 +17,3 @@ void test_vld3_lanes8 (void)
 }
 
 /* { dg-final { scan-assembler "vld3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld3_laneu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld3_laneu16.c
@@ -17,4 +17,3 @@ void test_vld3_laneu16 (void)
 }
 
 /* { dg-final { scan-assembler "vld3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld3_laneu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld3_laneu32.c
@@ -17,4 +17,3 @@ void test_vld3_laneu32 (void)
 }
 
 /* { dg-final { scan-assembler "vld3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld3_laneu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld3_laneu8.c
@@ -17,4 +17,3 @@ void test_vld3_laneu8 (void)
 }
 
 /* { dg-final { scan-assembler "vld3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld3f32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld3f32.c
@@ -16,4 +16,3 @@ void test_vld3f32 (void)
 }
 
 /* { dg-final { scan-assembler "vld3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld3p16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld3p16.c
@@ -16,4 +16,3 @@ void test_vld3p16 (void)
 }
 
 /* { dg-final { scan-assembler "vld3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld3p64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld3p64.c
@@ -16,4 +16,3 @@ void test_vld3p64 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld3p8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld3p8.c
@@ -16,4 +16,3 @@ void test_vld3p8 (void)
 }
 
 /* { dg-final { scan-assembler "vld3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld3s16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld3s16.c
@@ -16,4 +16,3 @@ void test_vld3s16 (void)
 }
 
 /* { dg-final { scan-assembler "vld3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld3s32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld3s32.c
@@ -16,4 +16,3 @@ void test_vld3s32 (void)
 }
 
 /* { dg-final { scan-assembler "vld3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld3s64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld3s64.c
@@ -16,4 +16,3 @@ void test_vld3s64 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld3s8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld3s8.c
@@ -16,4 +16,3 @@ void test_vld3s8 (void)
 }
 
 /* { dg-final { scan-assembler "vld3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld3u16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld3u16.c
@@ -16,4 +16,3 @@ void test_vld3u16 (void)
 }
 
 /* { dg-final { scan-assembler "vld3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld3u32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld3u32.c
@@ -16,4 +16,3 @@ void test_vld3u32 (void)
 }
 
 /* { dg-final { scan-assembler "vld3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld3u64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld3u64.c
@@ -16,4 +16,3 @@ void test_vld3u64 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld3u8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld3u8.c
@@ -16,4 +16,3 @@ void test_vld3u8 (void)
 }
 
 /* { dg-final { scan-assembler "vld3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld4Q_lanef32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld4Q_lanef32.c
@@ -17,4 +17,3 @@ void test_vld4Q_lanef32 (void)
 }
 
 /* { dg-final { scan-assembler "vld4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld4Q_lanep16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld4Q_lanep16.c
@@ -17,4 +17,3 @@ void test_vld4Q_lanep16 (void)
 }
 
 /* { dg-final { scan-assembler "vld4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld4Q_lanes16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld4Q_lanes16.c
@@ -17,4 +17,3 @@ void test_vld4Q_lanes16 (void)
 }
 
 /* { dg-final { scan-assembler "vld4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld4Q_lanes32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld4Q_lanes32.c
@@ -17,4 +17,3 @@ void test_vld4Q_lanes32 (void)
 }
 
 /* { dg-final { scan-assembler "vld4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld4Q_laneu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld4Q_laneu16.c
@@ -17,4 +17,3 @@ void test_vld4Q_laneu16 (void)
 }
 
 /* { dg-final { scan-assembler "vld4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld4Q_laneu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld4Q_laneu32.c
@@ -17,4 +17,3 @@ void test_vld4Q_laneu32 (void)
 }
 
 /* { dg-final { scan-assembler "vld4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld4Qf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld4Qf32.c
@@ -17,4 +17,3 @@ void test_vld4Qf32 (void)
 
 /* { dg-final { scan-assembler "vld4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vld4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld4Qp16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld4Qp16.c
@@ -17,4 +17,3 @@ void test_vld4Qp16 (void)
 
 /* { dg-final { scan-assembler "vld4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vld4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld4Qp8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld4Qp8.c
@@ -17,4 +17,3 @@ void test_vld4Qp8 (void)
 
 /* { dg-final { scan-assembler "vld4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vld4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld4Qs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld4Qs16.c
@@ -17,4 +17,3 @@ void test_vld4Qs16 (void)
 
 /* { dg-final { scan-assembler "vld4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vld4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld4Qs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld4Qs32.c
@@ -17,4 +17,3 @@ void test_vld4Qs32 (void)
 
 /* { dg-final { scan-assembler "vld4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vld4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld4Qs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld4Qs8.c
@@ -17,4 +17,3 @@ void test_vld4Qs8 (void)
 
 /* { dg-final { scan-assembler "vld4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vld4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld4Qu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld4Qu16.c
@@ -17,4 +17,3 @@ void test_vld4Qu16 (void)
 
 /* { dg-final { scan-assembler "vld4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vld4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld4Qu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld4Qu32.c
@@ -17,4 +17,3 @@ void test_vld4Qu32 (void)
 
 /* { dg-final { scan-assembler "vld4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vld4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld4Qu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld4Qu8.c
@@ -17,4 +17,3 @@ void test_vld4Qu8 (void)
 
 /* { dg-final { scan-assembler "vld4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vld4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld4_dupf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld4_dupf32.c
@@ -16,4 +16,3 @@ void test_vld4_dupf32 (void)
 }
 
 /* { dg-final { scan-assembler "vld4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld4_dupp16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld4_dupp16.c
@@ -16,4 +16,3 @@ void test_vld4_dupp16 (void)
 }
 
 /* { dg-final { scan-assembler "vld4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld4_dupp64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld4_dupp64.c
@@ -16,4 +16,3 @@ void test_vld4_dupp64 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld4_dupp8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld4_dupp8.c
@@ -16,4 +16,3 @@ void test_vld4_dupp8 (void)
 }
 
 /* { dg-final { scan-assembler "vld4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld4_dups16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld4_dups16.c
@@ -16,4 +16,3 @@ void test_vld4_dups16 (void)
 }
 
 /* { dg-final { scan-assembler "vld4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld4_dups32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld4_dups32.c
@@ -16,4 +16,3 @@ void test_vld4_dups32 (void)
 }
 
 /* { dg-final { scan-assembler "vld4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld4_dups64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld4_dups64.c
@@ -16,4 +16,3 @@ void test_vld4_dups64 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld4_dups8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld4_dups8.c
@@ -16,4 +16,3 @@ void test_vld4_dups8 (void)
 }
 
 /* { dg-final { scan-assembler "vld4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld4_dupu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld4_dupu16.c
@@ -16,4 +16,3 @@ void test_vld4_dupu16 (void)
 }
 
 /* { dg-final { scan-assembler "vld4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld4_dupu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld4_dupu32.c
@@ -16,4 +16,3 @@ void test_vld4_dupu32 (void)
 }
 
 /* { dg-final { scan-assembler "vld4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld4_dupu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld4_dupu64.c
@@ -16,4 +16,3 @@ void test_vld4_dupu64 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld4_dupu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld4_dupu8.c
@@ -16,4 +16,3 @@ void test_vld4_dupu8 (void)
 }
 
 /* { dg-final { scan-assembler "vld4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld4_lanef32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld4_lanef32.c
@@ -17,4 +17,3 @@ void test_vld4_lanef32 (void)
 }
 
 /* { dg-final { scan-assembler "vld4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld4_lanep16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld4_lanep16.c
@@ -17,4 +17,3 @@ void test_vld4_lanep16 (void)
 }
 
 /* { dg-final { scan-assembler "vld4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld4_lanep8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld4_lanep8.c
@@ -17,4 +17,3 @@ void test_vld4_lanep8 (void)
 }
 
 /* { dg-final { scan-assembler "vld4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld4_lanes16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld4_lanes16.c
@@ -17,4 +17,3 @@ void test_vld4_lanes16 (void)
 }
 
 /* { dg-final { scan-assembler "vld4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld4_lanes32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld4_lanes32.c
@@ -17,4 +17,3 @@ void test_vld4_lanes32 (void)
 }
 
 /* { dg-final { scan-assembler "vld4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld4_lanes8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld4_lanes8.c
@@ -17,4 +17,3 @@ void test_vld4_lanes8 (void)
 }
 
 /* { dg-final { scan-assembler "vld4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld4_laneu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld4_laneu16.c
@@ -17,4 +17,3 @@ void test_vld4_laneu16 (void)
 }
 
 /* { dg-final { scan-assembler "vld4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld4_laneu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld4_laneu32.c
@@ -17,4 +17,3 @@ void test_vld4_laneu32 (void)
 }
 
 /* { dg-final { scan-assembler "vld4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld4_laneu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld4_laneu8.c
@@ -17,4 +17,3 @@ void test_vld4_laneu8 (void)
 }
 
 /* { dg-final { scan-assembler "vld4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld4f32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld4f32.c
@@ -16,4 +16,3 @@ void test_vld4f32 (void)
 }
 
 /* { dg-final { scan-assembler "vld4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld4p16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld4p16.c
@@ -16,4 +16,3 @@ void test_vld4p16 (void)
 }
 
 /* { dg-final { scan-assembler "vld4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld4p64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld4p64.c
@@ -16,4 +16,3 @@ void test_vld4p64 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld4p8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld4p8.c
@@ -16,4 +16,3 @@ void test_vld4p8 (void)
 }
 
 /* { dg-final { scan-assembler "vld4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld4s16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld4s16.c
@@ -16,4 +16,3 @@ void test_vld4s16 (void)
 }
 
 /* { dg-final { scan-assembler "vld4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld4s32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld4s32.c
@@ -16,4 +16,3 @@ void test_vld4s32 (void)
 }
 
 /* { dg-final { scan-assembler "vld4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld4s64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld4s64.c
@@ -16,4 +16,3 @@ void test_vld4s64 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld4s8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld4s8.c
@@ -16,4 +16,3 @@ void test_vld4s8 (void)
 }
 
 /* { dg-final { scan-assembler "vld4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld4u16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld4u16.c
@@ -16,4 +16,3 @@ void test_vld4u16 (void)
 }
 
 /* { dg-final { scan-assembler "vld4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld4u32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld4u32.c
@@ -16,4 +16,3 @@ void test_vld4u32 (void)
 }
 
 /* { dg-final { scan-assembler "vld4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld4u64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld4u64.c
@@ -16,4 +16,3 @@ void test_vld4u64 (void)
 }
 
 /* { dg-final { scan-assembler "vld1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vld4u8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vld4u8.c
@@ -16,4 +16,3 @@ void test_vld4u8 (void)
 }
 
 /* { dg-final { scan-assembler "vld4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmaxQf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmaxQf32.c
@@ -18,4 +18,3 @@ void test_vmaxQf32 (void)
 }
 
 /* { dg-final { scan-assembler "vmax\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmaxQs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmaxQs16.c
@@ -18,4 +18,3 @@ void test_vmaxQs16 (void)
 }
 
 /* { dg-final { scan-assembler "vmax\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmaxQs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmaxQs32.c
@@ -18,4 +18,3 @@ void test_vmaxQs32 (void)
 }
 
 /* { dg-final { scan-assembler "vmax\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmaxQs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmaxQs8.c
@@ -18,4 +18,3 @@ void test_vmaxQs8 (void)
 }
 
 /* { dg-final { scan-assembler "vmax\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmaxQu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmaxQu16.c
@@ -18,4 +18,3 @@ void test_vmaxQu16 (void)
 }
 
 /* { dg-final { scan-assembler "vmax\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmaxQu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmaxQu32.c
@@ -18,4 +18,3 @@ void test_vmaxQu32 (void)
 }
 
 /* { dg-final { scan-assembler "vmax\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmaxQu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmaxQu8.c
@@ -18,4 +18,3 @@ void test_vmaxQu8 (void)
 }
 
 /* { dg-final { scan-assembler "vmax\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmaxf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmaxf32.c
@@ -18,4 +18,3 @@ void test_vmaxf32 (void)
 }
 
 /* { dg-final { scan-assembler "vmax\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmaxs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmaxs16.c
@@ -18,4 +18,3 @@ void test_vmaxs16 (void)
 }
 
 /* { dg-final { scan-assembler "vmax\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmaxs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmaxs32.c
@@ -18,4 +18,3 @@ void test_vmaxs32 (void)
 }
 
 /* { dg-final { scan-assembler "vmax\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmaxs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmaxs8.c
@@ -18,4 +18,3 @@ void test_vmaxs8 (void)
 }
 
 /* { dg-final { scan-assembler "vmax\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmaxu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmaxu16.c
@@ -18,4 +18,3 @@ void test_vmaxu16 (void)
 }
 
 /* { dg-final { scan-assembler "vmax\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmaxu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmaxu32.c
@@ -18,4 +18,3 @@ void test_vmaxu32 (void)
 }
 
 /* { dg-final { scan-assembler "vmax\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmaxu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmaxu8.c
@@ -18,4 +18,3 @@ void test_vmaxu8 (void)
 }
 
 /* { dg-final { scan-assembler "vmax\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vminQf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vminQf32.c
@@ -18,4 +18,3 @@ void test_vminQf32 (void)
 }
 
 /* { dg-final { scan-assembler "vmin\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vminQs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vminQs16.c
@@ -18,4 +18,3 @@ void test_vminQs16 (void)
 }
 
 /* { dg-final { scan-assembler "vmin\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vminQs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vminQs32.c
@@ -18,4 +18,3 @@ void test_vminQs32 (void)
 }
 
 /* { dg-final { scan-assembler "vmin\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vminQs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vminQs8.c
@@ -18,4 +18,3 @@ void test_vminQs8 (void)
 }
 
 /* { dg-final { scan-assembler "vmin\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vminQu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vminQu16.c
@@ -18,4 +18,3 @@ void test_vminQu16 (void)
 }
 
 /* { dg-final { scan-assembler "vmin\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vminQu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vminQu32.c
@@ -18,4 +18,3 @@ void test_vminQu32 (void)
 }
 
 /* { dg-final { scan-assembler "vmin\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vminQu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vminQu8.c
@@ -18,4 +18,3 @@ void test_vminQu8 (void)
 }
 
 /* { dg-final { scan-assembler "vmin\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vminf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vminf32.c
@@ -18,4 +18,3 @@ void test_vminf32 (void)
 }
 
 /* { dg-final { scan-assembler "vmin\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmins16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmins16.c
@@ -18,4 +18,3 @@ void test_vmins16 (void)
 }
 
 /* { dg-final { scan-assembler "vmin\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmins32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmins32.c
@@ -18,4 +18,3 @@ void test_vmins32 (void)
 }
 
 /* { dg-final { scan-assembler "vmin\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmins8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmins8.c
@@ -18,4 +18,3 @@ void test_vmins8 (void)
 }
 
 /* { dg-final { scan-assembler "vmin\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vminu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vminu16.c
@@ -18,4 +18,3 @@ void test_vminu16 (void)
 }
 
 /* { dg-final { scan-assembler "vmin\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vminu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vminu32.c
@@ -18,4 +18,3 @@ void test_vminu32 (void)
 }
 
 /* { dg-final { scan-assembler "vmin\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vminu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vminu8.c
@@ -18,4 +18,3 @@ void test_vminu8 (void)
 }
 
 /* { dg-final { scan-assembler "vmin\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlaQ_lanef32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlaQ_lanef32.c
@@ -19,4 +19,3 @@ void test_vmlaQ_lanef32 (void)
 }
 
 /* { dg-final { scan-assembler "vmla\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlaQ_lanes16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlaQ_lanes16.c
@@ -19,4 +19,3 @@ void test_vmlaQ_lanes16 (void)
 }
 
 /* { dg-final { scan-assembler "vmla\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlaQ_lanes32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlaQ_lanes32.c
@@ -19,4 +19,3 @@ void test_vmlaQ_lanes32 (void)
 }
 
 /* { dg-final { scan-assembler "vmla\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlaQ_laneu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlaQ_laneu16.c
@@ -19,4 +19,3 @@ void test_vmlaQ_laneu16 (void)
 }
 
 /* { dg-final { scan-assembler "vmla\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlaQ_laneu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlaQ_laneu32.c
@@ -19,4 +19,3 @@ void test_vmlaQ_laneu32 (void)
 }
 
 /* { dg-final { scan-assembler "vmla\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlaQ_nf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlaQ_nf32.c
@@ -19,4 +19,3 @@ void test_vmlaQ_nf32 (void)
 }
 
 /* { dg-final { scan-assembler "vmla\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlaQ_ns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlaQ_ns16.c
@@ -19,4 +19,3 @@ void test_vmlaQ_ns16 (void)
 }
 
 /* { dg-final { scan-assembler "vmla\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlaQ_ns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlaQ_ns32.c
@@ -19,4 +19,3 @@ void test_vmlaQ_ns32 (void)
 }
 
 /* { dg-final { scan-assembler "vmla\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlaQ_nu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlaQ_nu16.c
@@ -19,4 +19,3 @@ void test_vmlaQ_nu16 (void)
 }
 
 /* { dg-final { scan-assembler "vmla\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlaQ_nu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlaQ_nu32.c
@@ -19,4 +19,3 @@ void test_vmlaQ_nu32 (void)
 }
 
 /* { dg-final { scan-assembler "vmla\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlaQf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlaQf32.c
@@ -19,4 +19,3 @@ void test_vmlaQf32 (void)
 }
 
 /* { dg-final { scan-assembler "vmla\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlaQs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlaQs16.c
@@ -19,4 +19,3 @@ void test_vmlaQs16 (void)
 }
 
 /* { dg-final { scan-assembler "vmla\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlaQs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlaQs32.c
@@ -19,4 +19,3 @@ void test_vmlaQs32 (void)
 }
 
 /* { dg-final { scan-assembler "vmla\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlaQs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlaQs8.c
@@ -19,4 +19,3 @@ void test_vmlaQs8 (void)
 }
 
 /* { dg-final { scan-assembler "vmla\.i8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlaQu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlaQu16.c
@@ -19,4 +19,3 @@ void test_vmlaQu16 (void)
 }
 
 /* { dg-final { scan-assembler "vmla\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlaQu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlaQu32.c
@@ -19,4 +19,3 @@ void test_vmlaQu32 (void)
 }
 
 /* { dg-final { scan-assembler "vmla\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlaQu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlaQu8.c
@@ -19,4 +19,3 @@ void test_vmlaQu8 (void)
 }
 
 /* { dg-final { scan-assembler "vmla\.i8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmla_lanef32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmla_lanef32.c
@@ -19,4 +19,3 @@ void test_vmla_lanef32 (void)
 }
 
 /* { dg-final { scan-assembler "vmla\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmla_lanes16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmla_lanes16.c
@@ -19,4 +19,3 @@ void test_vmla_lanes16 (void)
 }
 
 /* { dg-final { scan-assembler "vmla\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmla_lanes32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmla_lanes32.c
@@ -19,4 +19,3 @@ void test_vmla_lanes32 (void)
 }
 
 /* { dg-final { scan-assembler "vmla\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmla_laneu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmla_laneu16.c
@@ -19,4 +19,3 @@ void test_vmla_laneu16 (void)
 }
 
 /* { dg-final { scan-assembler "vmla\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmla_laneu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmla_laneu32.c
@@ -19,4 +19,3 @@ void test_vmla_laneu32 (void)
 }
 
 /* { dg-final { scan-assembler "vmla\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmla_nf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmla_nf32.c
@@ -19,4 +19,3 @@ void test_vmla_nf32 (void)
 }
 
 /* { dg-final { scan-assembler "vmla\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmla_ns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmla_ns16.c
@@ -19,4 +19,3 @@ void test_vmla_ns16 (void)
 }
 
 /* { dg-final { scan-assembler "vmla\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmla_ns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmla_ns32.c
@@ -19,4 +19,3 @@ void test_vmla_ns32 (void)
 }
 
 /* { dg-final { scan-assembler "vmla\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmla_nu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmla_nu16.c
@@ -19,4 +19,3 @@ void test_vmla_nu16 (void)
 }
 
 /* { dg-final { scan-assembler "vmla\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmla_nu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmla_nu32.c
@@ -19,4 +19,3 @@ void test_vmla_nu32 (void)
 }
 
 /* { dg-final { scan-assembler "vmla\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlaf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlaf32.c
@@ -19,4 +19,3 @@ void test_vmlaf32 (void)
 }
 
 /* { dg-final { scan-assembler "vmla\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlal_lanes16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlal_lanes16.c
@@ -19,4 +19,3 @@ void test_vmlal_lanes16 (void)
 }
 
 /* { dg-final { scan-assembler "vmlal\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlal_lanes32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlal_lanes32.c
@@ -19,4 +19,3 @@ void test_vmlal_lanes32 (void)
 }
 
 /* { dg-final { scan-assembler "vmlal\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlal_laneu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlal_laneu16.c
@@ -19,4 +19,3 @@ void test_vmlal_laneu16 (void)
 }
 
 /* { dg-final { scan-assembler "vmlal\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlal_laneu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlal_laneu32.c
@@ -19,4 +19,3 @@ void test_vmlal_laneu32 (void)
 }
 
 /* { dg-final { scan-assembler "vmlal\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlal_ns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlal_ns16.c
@@ -19,4 +19,3 @@ void test_vmlal_ns16 (void)
 }
 
 /* { dg-final { scan-assembler "vmlal\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlal_ns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlal_ns32.c
@@ -19,4 +19,3 @@ void test_vmlal_ns32 (void)
 }
 
 /* { dg-final { scan-assembler "vmlal\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlal_nu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlal_nu16.c
@@ -19,4 +19,3 @@ void test_vmlal_nu16 (void)
 }
 
 /* { dg-final { scan-assembler "vmlal\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlal_nu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlal_nu32.c
@@ -19,4 +19,3 @@ void test_vmlal_nu32 (void)
 }
 
 /* { dg-final { scan-assembler "vmlal\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlals16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlals16.c
@@ -19,4 +19,3 @@ void test_vmlals16 (void)
 }
 
 /* { dg-final { scan-assembler "vmlal\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlals32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlals32.c
@@ -19,4 +19,3 @@ void test_vmlals32 (void)
 }
 
 /* { dg-final { scan-assembler "vmlal\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlals8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlals8.c
@@ -19,4 +19,3 @@ void test_vmlals8 (void)
 }
 
 /* { dg-final { scan-assembler "vmlal\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlalu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlalu16.c
@@ -19,4 +19,3 @@ void test_vmlalu16 (void)
 }
 
 /* { dg-final { scan-assembler "vmlal\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlalu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlalu32.c
@@ -19,4 +19,3 @@ void test_vmlalu32 (void)
 }
 
 /* { dg-final { scan-assembler "vmlal\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlalu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlalu8.c
@@ -19,4 +19,3 @@ void test_vmlalu8 (void)
 }
 
 /* { dg-final { scan-assembler "vmlal\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlas16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlas16.c
@@ -19,4 +19,3 @@ void test_vmlas16 (void)
 }
 
 /* { dg-final { scan-assembler "vmla\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlas32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlas32.c
@@ -19,4 +19,3 @@ void test_vmlas32 (void)
 }
 
 /* { dg-final { scan-assembler "vmla\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlas8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlas8.c
@@ -19,4 +19,3 @@ void test_vmlas8 (void)
 }
 
 /* { dg-final { scan-assembler "vmla\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlau16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlau16.c
@@ -19,4 +19,3 @@ void test_vmlau16 (void)
 }
 
 /* { dg-final { scan-assembler "vmla\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlau32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlau32.c
@@ -19,4 +19,3 @@ void test_vmlau32 (void)
 }
 
 /* { dg-final { scan-assembler "vmla\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlau8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlau8.c
@@ -19,4 +19,3 @@ void test_vmlau8 (void)
 }
 
 /* { dg-final { scan-assembler "vmla\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlsQ_lanef32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlsQ_lanef32.c
@@ -19,4 +19,3 @@ void test_vmlsQ_lanef32 (void)
 }
 
 /* { dg-final { scan-assembler "vmls\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlsQ_lanes16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlsQ_lanes16.c
@@ -19,4 +19,3 @@ void test_vmlsQ_lanes16 (void)
 }
 
 /* { dg-final { scan-assembler "vmls\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlsQ_lanes32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlsQ_lanes32.c
@@ -19,4 +19,3 @@ void test_vmlsQ_lanes32 (void)
 }
 
 /* { dg-final { scan-assembler "vmls\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlsQ_laneu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlsQ_laneu16.c
@@ -19,4 +19,3 @@ void test_vmlsQ_laneu16 (void)
 }
 
 /* { dg-final { scan-assembler "vmls\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlsQ_laneu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlsQ_laneu32.c
@@ -19,4 +19,3 @@ void test_vmlsQ_laneu32 (void)
 }
 
 /* { dg-final { scan-assembler "vmls\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlsQ_nf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlsQ_nf32.c
@@ -19,4 +19,3 @@ void test_vmlsQ_nf32 (void)
 }
 
 /* { dg-final { scan-assembler "vmls\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlsQ_ns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlsQ_ns16.c
@@ -19,4 +19,3 @@ void test_vmlsQ_ns16 (void)
 }
 
 /* { dg-final { scan-assembler "vmls\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlsQ_ns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlsQ_ns32.c
@@ -19,4 +19,3 @@ void test_vmlsQ_ns32 (void)
 }
 
 /* { dg-final { scan-assembler "vmls\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlsQ_nu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlsQ_nu16.c
@@ -19,4 +19,3 @@ void test_vmlsQ_nu16 (void)
 }
 
 /* { dg-final { scan-assembler "vmls\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlsQ_nu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlsQ_nu32.c
@@ -19,4 +19,3 @@ void test_vmlsQ_nu32 (void)
 }
 
 /* { dg-final { scan-assembler "vmls\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlsQf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlsQf32.c
@@ -19,4 +19,3 @@ void test_vmlsQf32 (void)
 }
 
 /* { dg-final { scan-assembler "vmls\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlsQs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlsQs16.c
@@ -19,4 +19,3 @@ void test_vmlsQs16 (void)
 }
 
 /* { dg-final { scan-assembler "vmls\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlsQs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlsQs32.c
@@ -19,4 +19,3 @@ void test_vmlsQs32 (void)
 }
 
 /* { dg-final { scan-assembler "vmls\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlsQs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlsQs8.c
@@ -19,4 +19,3 @@ void test_vmlsQs8 (void)
 }
 
 /* { dg-final { scan-assembler "vmls\.i8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlsQu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlsQu16.c
@@ -19,4 +19,3 @@ void test_vmlsQu16 (void)
 }
 
 /* { dg-final { scan-assembler "vmls\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlsQu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlsQu32.c
@@ -19,4 +19,3 @@ void test_vmlsQu32 (void)
 }
 
 /* { dg-final { scan-assembler "vmls\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlsQu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlsQu8.c
@@ -19,4 +19,3 @@ void test_vmlsQu8 (void)
 }
 
 /* { dg-final { scan-assembler "vmls\.i8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmls_lanef32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmls_lanef32.c
@@ -19,4 +19,3 @@ void test_vmls_lanef32 (void)
 }
 
 /* { dg-final { scan-assembler "vmls\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmls_lanes16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmls_lanes16.c
@@ -19,4 +19,3 @@ void test_vmls_lanes16 (void)
 }
 
 /* { dg-final { scan-assembler "vmls\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmls_lanes32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmls_lanes32.c
@@ -19,4 +19,3 @@ void test_vmls_lanes32 (void)
 }
 
 /* { dg-final { scan-assembler "vmls\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmls_laneu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmls_laneu16.c
@@ -19,4 +19,3 @@ void test_vmls_laneu16 (void)
 }
 
 /* { dg-final { scan-assembler "vmls\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmls_laneu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmls_laneu32.c
@@ -19,4 +19,3 @@ void test_vmls_laneu32 (void)
 }
 
 /* { dg-final { scan-assembler "vmls\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmls_nf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmls_nf32.c
@@ -19,4 +19,3 @@ void test_vmls_nf32 (void)
 }
 
 /* { dg-final { scan-assembler "vmls\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmls_ns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmls_ns16.c
@@ -19,4 +19,3 @@ void test_vmls_ns16 (void)
 }
 
 /* { dg-final { scan-assembler "vmls\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmls_ns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmls_ns32.c
@@ -19,4 +19,3 @@ void test_vmls_ns32 (void)
 }
 
 /* { dg-final { scan-assembler "vmls\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmls_nu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmls_nu16.c
@@ -19,4 +19,3 @@ void test_vmls_nu16 (void)
 }
 
 /* { dg-final { scan-assembler "vmls\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmls_nu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmls_nu32.c
@@ -19,4 +19,3 @@ void test_vmls_nu32 (void)
 }
 
 /* { dg-final { scan-assembler "vmls\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlsf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlsf32.c
@@ -19,4 +19,3 @@ void test_vmlsf32 (void)
 }
 
 /* { dg-final { scan-assembler "vmls\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlsl_lanes16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlsl_lanes16.c
@@ -19,4 +19,3 @@ void test_vmlsl_lanes16 (void)
 }
 
 /* { dg-final { scan-assembler "vmlsl\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlsl_lanes32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlsl_lanes32.c
@@ -19,4 +19,3 @@ void test_vmlsl_lanes32 (void)
 }
 
 /* { dg-final { scan-assembler "vmlsl\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlsl_laneu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlsl_laneu16.c
@@ -19,4 +19,3 @@ void test_vmlsl_laneu16 (void)
 }
 
 /* { dg-final { scan-assembler "vmlsl\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlsl_laneu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlsl_laneu32.c
@@ -19,4 +19,3 @@ void test_vmlsl_laneu32 (void)
 }
 
 /* { dg-final { scan-assembler "vmlsl\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlsl_ns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlsl_ns16.c
@@ -19,4 +19,3 @@ void test_vmlsl_ns16 (void)
 }
 
 /* { dg-final { scan-assembler "vmlsl\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlsl_ns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlsl_ns32.c
@@ -19,4 +19,3 @@ void test_vmlsl_ns32 (void)
 }
 
 /* { dg-final { scan-assembler "vmlsl\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlsl_nu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlsl_nu16.c
@@ -19,4 +19,3 @@ void test_vmlsl_nu16 (void)
 }
 
 /* { dg-final { scan-assembler "vmlsl\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlsl_nu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlsl_nu32.c
@@ -19,4 +19,3 @@ void test_vmlsl_nu32 (void)
 }
 
 /* { dg-final { scan-assembler "vmlsl\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlsls16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlsls16.c
@@ -19,4 +19,3 @@ void test_vmlsls16 (void)
 }
 
 /* { dg-final { scan-assembler "vmlsl\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlsls32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlsls32.c
@@ -19,4 +19,3 @@ void test_vmlsls32 (void)
 }
 
 /* { dg-final { scan-assembler "vmlsl\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlsls8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlsls8.c
@@ -19,4 +19,3 @@ void test_vmlsls8 (void)
 }
 
 /* { dg-final { scan-assembler "vmlsl\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlslu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlslu16.c
@@ -19,4 +19,3 @@ void test_vmlslu16 (void)
 }
 
 /* { dg-final { scan-assembler "vmlsl\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlslu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlslu32.c
@@ -19,4 +19,3 @@ void test_vmlslu32 (void)
 }
 
 /* { dg-final { scan-assembler "vmlsl\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlslu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlslu8.c
@@ -19,4 +19,3 @@ void test_vmlslu8 (void)
 }
 
 /* { dg-final { scan-assembler "vmlsl\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlss16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlss16.c
@@ -19,4 +19,3 @@ void test_vmlss16 (void)
 }
 
 /* { dg-final { scan-assembler "vmls\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlss32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlss32.c
@@ -19,4 +19,3 @@ void test_vmlss32 (void)
 }
 
 /* { dg-final { scan-assembler "vmls\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlss8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlss8.c
@@ -19,4 +19,3 @@ void test_vmlss8 (void)
 }
 
 /* { dg-final { scan-assembler "vmls\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlsu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlsu16.c
@@ -19,4 +19,3 @@ void test_vmlsu16 (void)
 }
 
 /* { dg-final { scan-assembler "vmls\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlsu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlsu32.c
@@ -19,4 +19,3 @@ void test_vmlsu32 (void)
 }
 
 /* { dg-final { scan-assembler "vmls\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmlsu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmlsu8.c
@@ -19,4 +19,3 @@ void test_vmlsu8 (void)
 }
 
 /* { dg-final { scan-assembler "vmls\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmovQ_nf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmovQ_nf32.c
@@ -17,4 +17,3 @@ void test_vmovQ_nf32 (void)
 }
 
 /* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmovQ_np16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmovQ_np16.c
@@ -17,4 +17,3 @@ void test_vmovQ_np16 (void)
 }
 
 /* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmovQ_np8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmovQ_np8.c
@@ -17,4 +17,3 @@ void test_vmovQ_np8 (void)
 }
 
 /* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmovQ_ns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmovQ_ns16.c
@@ -17,4 +17,3 @@ void test_vmovQ_ns16 (void)
 }
 
 /* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmovQ_ns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmovQ_ns32.c
@@ -17,4 +17,3 @@ void test_vmovQ_ns32 (void)
 }
 
 /* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmovQ_ns64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmovQ_ns64.c
@@ -16,4 +16,3 @@ void test_vmovQ_ns64 (void)
   out_int64x2_t = vmovq_n_s64 (arg0_int64_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmovQ_ns8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmovQ_ns8.c
@@ -17,4 +17,3 @@ void test_vmovQ_ns8 (void)
 }
 
 /* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmovQ_nu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmovQ_nu16.c
@@ -17,4 +17,3 @@ void test_vmovQ_nu16 (void)
 }
 
 /* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmovQ_nu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmovQ_nu32.c
@@ -17,4 +17,3 @@ void test_vmovQ_nu32 (void)
 }
 
 /* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmovQ_nu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmovQ_nu64.c
@@ -16,4 +16,3 @@ void test_vmovQ_nu64 (void)
   out_uint64x2_t = vmovq_n_u64 (arg0_uint64_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmovQ_nu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmovQ_nu8.c
@@ -17,4 +17,3 @@ void test_vmovQ_nu8 (void)
 }
 
 /* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmov_nf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmov_nf32.c
@@ -17,4 +17,3 @@ void test_vmov_nf32 (void)
 }
 
 /* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmov_np16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmov_np16.c
@@ -17,4 +17,3 @@ void test_vmov_np16 (void)
 }
 
 /* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmov_np8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmov_np8.c
@@ -17,4 +17,3 @@ void test_vmov_np8 (void)
 }
 
 /* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmov_ns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmov_ns16.c
@@ -17,4 +17,3 @@ void test_vmov_ns16 (void)
 }
 
 /* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmov_ns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmov_ns32.c
@@ -17,4 +17,3 @@ void test_vmov_ns32 (void)
 }
 
 /* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmov_ns64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmov_ns64.c
@@ -16,4 +16,3 @@ void test_vmov_ns64 (void)
   out_int64x1_t = vmov_n_s64 (arg0_int64_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmov_ns8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmov_ns8.c
@@ -17,4 +17,3 @@ void test_vmov_ns8 (void)
 }
 
 /* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmov_nu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmov_nu16.c
@@ -17,4 +17,3 @@ void test_vmov_nu16 (void)
 }
 
 /* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmov_nu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmov_nu32.c
@@ -17,4 +17,3 @@ void test_vmov_nu32 (void)
 }
 
 /* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmov_nu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmov_nu64.c
@@ -16,4 +16,3 @@ void test_vmov_nu64 (void)
   out_uint64x1_t = vmov_n_u64 (arg0_uint64_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmov_nu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmov_nu8.c
@@ -17,4 +17,3 @@ void test_vmov_nu8 (void)
 }
 
 /* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmovls16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmovls16.c
@@ -17,4 +17,3 @@ void test_vmovls16 (void)
 }
 
 /* { dg-final { scan-assembler "vmovl\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmovls32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmovls32.c
@@ -17,4 +17,3 @@ void test_vmovls32 (void)
 }
 
 /* { dg-final { scan-assembler "vmovl\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmovls8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmovls8.c
@@ -17,4 +17,3 @@ void test_vmovls8 (void)
 }
 
 /* { dg-final { scan-assembler "vmovl\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmovlu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmovlu16.c
@@ -17,4 +17,3 @@ void test_vmovlu16 (void)
 }
 
 /* { dg-final { scan-assembler "vmovl\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmovlu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmovlu32.c
@@ -17,4 +17,3 @@ void test_vmovlu32 (void)
 }
 
 /* { dg-final { scan-assembler "vmovl\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmovlu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmovlu8.c
@@ -17,4 +17,3 @@ void test_vmovlu8 (void)
 }
 
 /* { dg-final { scan-assembler "vmovl\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmovns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmovns16.c
@@ -17,4 +17,3 @@ void test_vmovns16 (void)
 }
 
 /* { dg-final { scan-assembler "vmovn\.i16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmovns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmovns32.c
@@ -17,4 +17,3 @@ void test_vmovns32 (void)
 }
 
 /* { dg-final { scan-assembler "vmovn\.i32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmovns64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmovns64.c
@@ -17,4 +17,3 @@ void test_vmovns64 (void)
 }
 
 /* { dg-final { scan-assembler "vmovn\.i64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmovnu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmovnu16.c
@@ -17,4 +17,3 @@ void test_vmovnu16 (void)
 }
 
 /* { dg-final { scan-assembler "vmovn\.i16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmovnu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmovnu32.c
@@ -17,4 +17,3 @@ void test_vmovnu32 (void)
 }
 
 /* { dg-final { scan-assembler "vmovn\.i32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmovnu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmovnu64.c
@@ -17,4 +17,3 @@ void test_vmovnu64 (void)
 }
 
 /* { dg-final { scan-assembler "vmovn\.i64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmulQ_lanef32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmulQ_lanef32.c
@@ -18,4 +18,3 @@ void test_vmulQ_lanef32 (void)
 }
 
 /* { dg-final { scan-assembler "vmul\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmulQ_lanes16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmulQ_lanes16.c
@@ -18,4 +18,3 @@ void test_vmulQ_lanes16 (void)
 }
 
 /* { dg-final { scan-assembler "vmul\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmulQ_lanes32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmulQ_lanes32.c
@@ -18,4 +18,3 @@ void test_vmulQ_lanes32 (void)
 }
 
 /* { dg-final { scan-assembler "vmul\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmulQ_laneu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmulQ_laneu16.c
@@ -18,4 +18,3 @@ void test_vmulQ_laneu16 (void)
 }
 
 /* { dg-final { scan-assembler "vmul\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmulQ_laneu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmulQ_laneu32.c
@@ -18,4 +18,3 @@ void test_vmulQ_laneu32 (void)
 }
 
 /* { dg-final { scan-assembler "vmul\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmulQ_nf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmulQ_nf32.c
@@ -18,4 +18,3 @@ void test_vmulQ_nf32 (void)
 }
 
 /* { dg-final { scan-assembler "vmul\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmulQ_ns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmulQ_ns16.c
@@ -18,4 +18,3 @@ void test_vmulQ_ns16 (void)
 }
 
 /* { dg-final { scan-assembler "vmul\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmulQ_ns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmulQ_ns32.c
@@ -18,4 +18,3 @@ void test_vmulQ_ns32 (void)
 }
 
 /* { dg-final { scan-assembler "vmul\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmulQ_nu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmulQ_nu16.c
@@ -18,4 +18,3 @@ void test_vmulQ_nu16 (void)
 }
 
 /* { dg-final { scan-assembler "vmul\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmulQ_nu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmulQ_nu32.c
@@ -18,4 +18,3 @@ void test_vmulQ_nu32 (void)
 }
 
 /* { dg-final { scan-assembler "vmul\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmulQf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmulQf32.c
@@ -18,4 +18,3 @@ void test_vmulQf32 (void)
 }
 
 /* { dg-final { scan-assembler "vmul\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmulQp8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmulQp8.c
@@ -18,4 +18,3 @@ void test_vmulQp8 (void)
 }
 
 /* { dg-final { scan-assembler "vmul\.p8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmulQs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmulQs16.c
@@ -18,4 +18,3 @@ void test_vmulQs16 (void)
 }
 
 /* { dg-final { scan-assembler "vmul\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmulQs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmulQs32.c
@@ -18,4 +18,3 @@ void test_vmulQs32 (void)
 }
 
 /* { dg-final { scan-assembler "vmul\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmulQs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmulQs8.c
@@ -18,4 +18,3 @@ void test_vmulQs8 (void)
 }
 
 /* { dg-final { scan-assembler "vmul\.i8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmulQu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmulQu16.c
@@ -18,4 +18,3 @@ void test_vmulQu16 (void)
 }
 
 /* { dg-final { scan-assembler "vmul\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmulQu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmulQu32.c
@@ -18,4 +18,3 @@ void test_vmulQu32 (void)
 }
 
 /* { dg-final { scan-assembler "vmul\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmulQu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmulQu8.c
@@ -18,4 +18,3 @@ void test_vmulQu8 (void)
 }
 
 /* { dg-final { scan-assembler "vmul\.i8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmul_lanef32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmul_lanef32.c
@@ -18,4 +18,3 @@ void test_vmul_lanef32 (void)
 }
 
 /* { dg-final { scan-assembler "vmul\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmul_lanes16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmul_lanes16.c
@@ -18,4 +18,3 @@ void test_vmul_lanes16 (void)
 }
 
 /* { dg-final { scan-assembler "vmul\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmul_lanes32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmul_lanes32.c
@@ -18,4 +18,3 @@ void test_vmul_lanes32 (void)
 }
 
 /* { dg-final { scan-assembler "vmul\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmul_laneu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmul_laneu16.c
@@ -18,4 +18,3 @@ void test_vmul_laneu16 (void)
 }
 
 /* { dg-final { scan-assembler "vmul\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmul_laneu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmul_laneu32.c
@@ -18,4 +18,3 @@ void test_vmul_laneu32 (void)
 }
 
 /* { dg-final { scan-assembler "vmul\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmul_nf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmul_nf32.c
@@ -18,4 +18,3 @@ void test_vmul_nf32 (void)
 }
 
 /* { dg-final { scan-assembler "vmul\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmul_ns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmul_ns16.c
@@ -18,4 +18,3 @@ void test_vmul_ns16 (void)
 }
 
 /* { dg-final { scan-assembler "vmul\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmul_ns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmul_ns32.c
@@ -18,4 +18,3 @@ void test_vmul_ns32 (void)
 }
 
 /* { dg-final { scan-assembler "vmul\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmul_nu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmul_nu16.c
@@ -18,4 +18,3 @@ void test_vmul_nu16 (void)
 }
 
 /* { dg-final { scan-assembler "vmul\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmul_nu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmul_nu32.c
@@ -18,4 +18,3 @@ void test_vmul_nu32 (void)
 }
 
 /* { dg-final { scan-assembler "vmul\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmulf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmulf32.c
@@ -18,4 +18,3 @@ void test_vmulf32 (void)
 }
 
 /* { dg-final { scan-assembler "vmul\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmull_lanes16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmull_lanes16.c
@@ -18,4 +18,3 @@ void test_vmull_lanes16 (void)
 }
 
 /* { dg-final { scan-assembler "vmull\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmull_lanes32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmull_lanes32.c
@@ -18,4 +18,3 @@ void test_vmull_lanes32 (void)
 }
 
 /* { dg-final { scan-assembler "vmull\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmull_laneu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmull_laneu16.c
@@ -18,4 +18,3 @@ void test_vmull_laneu16 (void)
 }
 
 /* { dg-final { scan-assembler "vmull\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmull_laneu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmull_laneu32.c
@@ -18,4 +18,3 @@ void test_vmull_laneu32 (void)
 }
 
 /* { dg-final { scan-assembler "vmull\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmull_ns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmull_ns16.c
@@ -18,4 +18,3 @@ void test_vmull_ns16 (void)
 }
 
 /* { dg-final { scan-assembler "vmull\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmull_ns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmull_ns32.c
@@ -18,4 +18,3 @@ void test_vmull_ns32 (void)
 }
 
 /* { dg-final { scan-assembler "vmull\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmull_nu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmull_nu16.c
@@ -18,4 +18,3 @@ void test_vmull_nu16 (void)
 }
 
 /* { dg-final { scan-assembler "vmull\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmull_nu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmull_nu32.c
@@ -18,4 +18,3 @@ void test_vmull_nu32 (void)
 }
 
 /* { dg-final { scan-assembler "vmull\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmullp8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmullp8.c
@@ -18,4 +18,3 @@ void test_vmullp8 (void)
 }
 
 /* { dg-final { scan-assembler "vmull\.p8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmulls16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmulls16.c
@@ -18,4 +18,3 @@ void test_vmulls16 (void)
 }
 
 /* { dg-final { scan-assembler "vmull\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmulls32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmulls32.c
@@ -18,4 +18,3 @@ void test_vmulls32 (void)
 }
 
 /* { dg-final { scan-assembler "vmull\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmulls8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmulls8.c
@@ -18,4 +18,3 @@ void test_vmulls8 (void)
 }
 
 /* { dg-final { scan-assembler "vmull\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmullu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmullu16.c
@@ -18,4 +18,3 @@ void test_vmullu16 (void)
 }
 
 /* { dg-final { scan-assembler "vmull\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmullu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmullu32.c
@@ -18,4 +18,3 @@ void test_vmullu32 (void)
 }
 
 /* { dg-final { scan-assembler "vmull\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmullu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmullu8.c
@@ -18,4 +18,3 @@ void test_vmullu8 (void)
 }
 
 /* { dg-final { scan-assembler "vmull\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmulp8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmulp8.c
@@ -18,4 +18,3 @@ void test_vmulp8 (void)
 }
 
 /* { dg-final { scan-assembler "vmul\.p8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmuls16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmuls16.c
@@ -18,4 +18,3 @@ void test_vmuls16 (void)
 }
 
 /* { dg-final { scan-assembler "vmul\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmuls32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmuls32.c
@@ -18,4 +18,3 @@ void test_vmuls32 (void)
 }
 
 /* { dg-final { scan-assembler "vmul\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmuls8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmuls8.c
@@ -18,4 +18,3 @@ void test_vmuls8 (void)
 }
 
 /* { dg-final { scan-assembler "vmul\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmulu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmulu16.c
@@ -18,4 +18,3 @@ void test_vmulu16 (void)
 }
 
 /* { dg-final { scan-assembler "vmul\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmulu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmulu32.c
@@ -18,4 +18,3 @@ void test_vmulu32 (void)
 }
 
 /* { dg-final { scan-assembler "vmul\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmulu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmulu8.c
@@ -18,4 +18,3 @@ void test_vmulu8 (void)
 }
 
 /* { dg-final { scan-assembler "vmul\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmvnQp8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmvnQp8.c
@@ -17,4 +17,3 @@ void test_vmvnQp8 (void)
 }
 
 /* { dg-final { scan-assembler "vmvn\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmvnQs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmvnQs16.c
@@ -17,4 +17,3 @@ void test_vmvnQs16 (void)
 }
 
 /* { dg-final { scan-assembler "vmvn\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmvnQs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmvnQs32.c
@@ -17,4 +17,3 @@ void test_vmvnQs32 (void)
 }
 
 /* { dg-final { scan-assembler "vmvn\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmvnQs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmvnQs8.c
@@ -17,4 +17,3 @@ void test_vmvnQs8 (void)
 }
 
 /* { dg-final { scan-assembler "vmvn\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmvnQu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmvnQu16.c
@@ -17,4 +17,3 @@ void test_vmvnQu16 (void)
 }
 
 /* { dg-final { scan-assembler "vmvn\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmvnQu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmvnQu32.c
@@ -17,4 +17,3 @@ void test_vmvnQu32 (void)
 }
 
 /* { dg-final { scan-assembler "vmvn\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmvnQu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmvnQu8.c
@@ -17,4 +17,3 @@ void test_vmvnQu8 (void)
 }
 
 /* { dg-final { scan-assembler "vmvn\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmvnp8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmvnp8.c
@@ -17,4 +17,3 @@ void test_vmvnp8 (void)
 }
 
 /* { dg-final { scan-assembler "vmvn\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmvns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmvns16.c
@@ -17,4 +17,3 @@ void test_vmvns16 (void)
 }
 
 /* { dg-final { scan-assembler "vmvn\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmvns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmvns32.c
@@ -17,4 +17,3 @@ void test_vmvns32 (void)
 }
 
 /* { dg-final { scan-assembler "vmvn\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmvns8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmvns8.c
@@ -17,4 +17,3 @@ void test_vmvns8 (void)
 }
 
 /* { dg-final { scan-assembler "vmvn\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmvnu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmvnu16.c
@@ -17,4 +17,3 @@ void test_vmvnu16 (void)
 }
 
 /* { dg-final { scan-assembler "vmvn\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmvnu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmvnu32.c
@@ -17,4 +17,3 @@ void test_vmvnu32 (void)
 }
 
 /* { dg-final { scan-assembler "vmvn\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vmvnu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vmvnu8.c
@@ -17,4 +17,3 @@ void test_vmvnu8 (void)
 }
 
 /* { dg-final { scan-assembler "vmvn\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vnegQf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vnegQf32.c
@@ -17,4 +17,3 @@ void test_vnegQf32 (void)
 }
 
 /* { dg-final { scan-assembler "vneg\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vnegQs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vnegQs16.c
@@ -17,4 +17,3 @@ void test_vnegQs16 (void)
 }
 
 /* { dg-final { scan-assembler "vneg\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vnegQs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vnegQs32.c
@@ -17,4 +17,3 @@ void test_vnegQs32 (void)
 }
 
 /* { dg-final { scan-assembler "vneg\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vnegQs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vnegQs8.c
@@ -17,4 +17,3 @@ void test_vnegQs8 (void)
 }
 
 /* { dg-final { scan-assembler "vneg\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vnegf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vnegf32.c
@@ -17,4 +17,3 @@ void test_vnegf32 (void)
 }
 
 /* { dg-final { scan-assembler "vneg\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vnegs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vnegs16.c
@@ -17,4 +17,3 @@ void test_vnegs16 (void)
 }
 
 /* { dg-final { scan-assembler "vneg\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vnegs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vnegs32.c
@@ -17,4 +17,3 @@ void test_vnegs32 (void)
 }
 
 /* { dg-final { scan-assembler "vneg\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vnegs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vnegs8.c
@@ -17,4 +17,3 @@ void test_vnegs8 (void)
 }
 
 /* { dg-final { scan-assembler "vneg\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vornQs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vornQs16.c
@@ -18,4 +18,3 @@ void test_vornQs16 (void)
 }
 
 /* { dg-final { scan-assembler "vorn\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vornQs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vornQs32.c
@@ -18,4 +18,3 @@ void test_vornQs32 (void)
 }
 
 /* { dg-final { scan-assembler "vorn\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vornQs64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vornQs64.c
@@ -18,4 +18,3 @@ void test_vornQs64 (void)
 }
 
 /* { dg-final { scan-assembler "vorn\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vornQs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vornQs8.c
@@ -18,4 +18,3 @@ void test_vornQs8 (void)
 }
 
 /* { dg-final { scan-assembler "vorn\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vornQu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vornQu16.c
@@ -18,4 +18,3 @@ void test_vornQu16 (void)
 }
 
 /* { dg-final { scan-assembler "vorn\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vornQu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vornQu32.c
@@ -18,4 +18,3 @@ void test_vornQu32 (void)
 }
 
 /* { dg-final { scan-assembler "vorn\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vornQu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vornQu64.c
@@ -18,4 +18,3 @@ void test_vornQu64 (void)
 }
 
 /* { dg-final { scan-assembler "vorn\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vornQu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vornQu8.c
@@ -18,4 +18,3 @@ void test_vornQu8 (void)
 }
 
 /* { dg-final { scan-assembler "vorn\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vorns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vorns16.c
@@ -18,4 +18,3 @@ void test_vorns16 (void)
 }
 
 /* { dg-final { scan-assembler "vorn\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vorns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vorns32.c
@@ -18,4 +18,3 @@ void test_vorns32 (void)
 }
 
 /* { dg-final { scan-assembler "vorn\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vorns64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vorns64.c
@@ -17,4 +17,3 @@ void test_vorns64 (void)
   out_int64x1_t = vorn_s64 (arg0_int64x1_t, arg1_int64x1_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vorns8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vorns8.c
@@ -18,4 +18,3 @@ void test_vorns8 (void)
 }
 
 /* { dg-final { scan-assembler "vorn\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vornu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vornu16.c
@@ -18,4 +18,3 @@ void test_vornu16 (void)
 }
 
 /* { dg-final { scan-assembler "vorn\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vornu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vornu32.c
@@ -18,4 +18,3 @@ void test_vornu32 (void)
 }
 
 /* { dg-final { scan-assembler "vorn\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vornu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vornu64.c
@@ -17,4 +17,3 @@ void test_vornu64 (void)
   out_uint64x1_t = vorn_u64 (arg0_uint64x1_t, arg1_uint64x1_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vornu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vornu8.c
@@ -18,4 +18,3 @@ void test_vornu8 (void)
 }
 
 /* { dg-final { scan-assembler "vorn\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vorrQs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vorrQs16.c
@@ -18,4 +18,3 @@ void test_vorrQs16 (void)
 }
 
 /* { dg-final { scan-assembler "vorr\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vorrQs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vorrQs32.c
@@ -18,4 +18,3 @@ void test_vorrQs32 (void)
 }
 
 /* { dg-final { scan-assembler "vorr\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vorrQs64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vorrQs64.c
@@ -18,4 +18,3 @@ void test_vorrQs64 (void)
 }
 
 /* { dg-final { scan-assembler "vorr\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vorrQs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vorrQs8.c
@@ -18,4 +18,3 @@ void test_vorrQs8 (void)
 }
 
 /* { dg-final { scan-assembler "vorr\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vorrQu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vorrQu16.c
@@ -18,4 +18,3 @@ void test_vorrQu16 (void)
 }
 
 /* { dg-final { scan-assembler "vorr\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vorrQu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vorrQu32.c
@@ -18,4 +18,3 @@ void test_vorrQu32 (void)
 }
 
 /* { dg-final { scan-assembler "vorr\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vorrQu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vorrQu64.c
@@ -18,4 +18,3 @@ void test_vorrQu64 (void)
 }
 
 /* { dg-final { scan-assembler "vorr\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vorrQu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vorrQu8.c
@@ -18,4 +18,3 @@ void test_vorrQu8 (void)
 }
 
 /* { dg-final { scan-assembler "vorr\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vorrs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vorrs16.c
@@ -18,4 +18,3 @@ void test_vorrs16 (void)
 }
 
 /* { dg-final { scan-assembler "vorr\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vorrs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vorrs32.c
@@ -18,4 +18,3 @@ void test_vorrs32 (void)
 }
 
 /* { dg-final { scan-assembler "vorr\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vorrs64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vorrs64.c
@@ -17,4 +17,3 @@ void test_vorrs64 (void)
   out_int64x1_t = vorr_s64 (arg0_int64x1_t, arg1_int64x1_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vorrs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vorrs8.c
@@ -18,4 +18,3 @@ void test_vorrs8 (void)
 }
 
 /* { dg-final { scan-assembler "vorr\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vorru16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vorru16.c
@@ -18,4 +18,3 @@ void test_vorru16 (void)
 }
 
 /* { dg-final { scan-assembler "vorr\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vorru32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vorru32.c
@@ -18,4 +18,3 @@ void test_vorru32 (void)
 }
 
 /* { dg-final { scan-assembler "vorr\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vorru64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vorru64.c
@@ -17,4 +17,3 @@ void test_vorru64 (void)
   out_uint64x1_t = vorr_u64 (arg0_uint64x1_t, arg1_uint64x1_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vorru8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vorru8.c
@@ -18,4 +18,3 @@ void test_vorru8 (void)
 }
 
 /* { dg-final { scan-assembler "vorr\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vpadalQs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vpadalQs16.c
@@ -18,4 +18,3 @@ void test_vpadalQs16 (void)
 }
 
 /* { dg-final { scan-assembler "vpadal\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vpadalQs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vpadalQs32.c
@@ -18,4 +18,3 @@ void test_vpadalQs32 (void)
 }
 
 /* { dg-final { scan-assembler "vpadal\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vpadalQs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vpadalQs8.c
@@ -18,4 +18,3 @@ void test_vpadalQs8 (void)
 }
 
 /* { dg-final { scan-assembler "vpadal\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vpadalQu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vpadalQu16.c
@@ -18,4 +18,3 @@ void test_vpadalQu16 (void)
 }
 
 /* { dg-final { scan-assembler "vpadal\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vpadalQu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vpadalQu32.c
@@ -18,4 +18,3 @@ void test_vpadalQu32 (void)
 }
 
 /* { dg-final { scan-assembler "vpadal\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vpadalQu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vpadalQu8.c
@@ -18,4 +18,3 @@ void test_vpadalQu8 (void)
 }
 
 /* { dg-final { scan-assembler "vpadal\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vpadals16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vpadals16.c
@@ -18,4 +18,3 @@ void test_vpadals16 (void)
 }
 
 /* { dg-final { scan-assembler "vpadal\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vpadals32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vpadals32.c
@@ -18,4 +18,3 @@ void test_vpadals32 (void)
 }
 
 /* { dg-final { scan-assembler "vpadal\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vpadals8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vpadals8.c
@@ -18,4 +18,3 @@ void test_vpadals8 (void)
 }
 
 /* { dg-final { scan-assembler "vpadal\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vpadalu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vpadalu16.c
@@ -18,4 +18,3 @@ void test_vpadalu16 (void)
 }
 
 /* { dg-final { scan-assembler "vpadal\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vpadalu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vpadalu32.c
@@ -18,4 +18,3 @@ void test_vpadalu32 (void)
 }
 
 /* { dg-final { scan-assembler "vpadal\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vpadalu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vpadalu8.c
@@ -18,4 +18,3 @@ void test_vpadalu8 (void)
 }
 
 /* { dg-final { scan-assembler "vpadal\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vpaddf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vpaddf32.c
@@ -18,4 +18,3 @@ void test_vpaddf32 (void)
 }
 
 /* { dg-final { scan-assembler "vpadd\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vpaddlQs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vpaddlQs16.c
@@ -17,4 +17,3 @@ void test_vpaddlQs16 (void)
 }
 
 /* { dg-final { scan-assembler "vpaddl\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vpaddlQs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vpaddlQs32.c
@@ -17,4 +17,3 @@ void test_vpaddlQs32 (void)
 }
 
 /* { dg-final { scan-assembler "vpaddl\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vpaddlQs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vpaddlQs8.c
@@ -17,4 +17,3 @@ void test_vpaddlQs8 (void)
 }
 
 /* { dg-final { scan-assembler "vpaddl\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vpaddlQu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vpaddlQu16.c
@@ -17,4 +17,3 @@ void test_vpaddlQu16 (void)
 }
 
 /* { dg-final { scan-assembler "vpaddl\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vpaddlQu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vpaddlQu32.c
@@ -17,4 +17,3 @@ void test_vpaddlQu32 (void)
 }
 
 /* { dg-final { scan-assembler "vpaddl\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vpaddlQu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vpaddlQu8.c
@@ -17,4 +17,3 @@ void test_vpaddlQu8 (void)
 }
 
 /* { dg-final { scan-assembler "vpaddl\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vpaddls16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vpaddls16.c
@@ -17,4 +17,3 @@ void test_vpaddls16 (void)
 }
 
 /* { dg-final { scan-assembler "vpaddl\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vpaddls32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vpaddls32.c
@@ -17,4 +17,3 @@ void test_vpaddls32 (void)
 }
 
 /* { dg-final { scan-assembler "vpaddl\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vpaddls8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vpaddls8.c
@@ -17,4 +17,3 @@ void test_vpaddls8 (void)
 }
 
 /* { dg-final { scan-assembler "vpaddl\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vpaddlu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vpaddlu16.c
@@ -17,4 +17,3 @@ void test_vpaddlu16 (void)
 }
 
 /* { dg-final { scan-assembler "vpaddl\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vpaddlu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vpaddlu32.c
@@ -17,4 +17,3 @@ void test_vpaddlu32 (void)
 }
 
 /* { dg-final { scan-assembler "vpaddl\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vpaddlu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vpaddlu8.c
@@ -17,4 +17,3 @@ void test_vpaddlu8 (void)
 }
 
 /* { dg-final { scan-assembler "vpaddl\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vpadds16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vpadds16.c
@@ -18,4 +18,3 @@ void test_vpadds16 (void)
 }
 
 /* { dg-final { scan-assembler "vpadd\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vpadds32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vpadds32.c
@@ -18,4 +18,3 @@ void test_vpadds32 (void)
 }
 
 /* { dg-final { scan-assembler "vpadd\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vpadds8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vpadds8.c
@@ -18,4 +18,3 @@ void test_vpadds8 (void)
 }
 
 /* { dg-final { scan-assembler "vpadd\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vpaddu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vpaddu16.c
@@ -18,4 +18,3 @@ void test_vpaddu16 (void)
 }
 
 /* { dg-final { scan-assembler "vpadd\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vpaddu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vpaddu32.c
@@ -18,4 +18,3 @@ void test_vpaddu32 (void)
 }
 
 /* { dg-final { scan-assembler "vpadd\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vpaddu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vpaddu8.c
@@ -18,4 +18,3 @@ void test_vpaddu8 (void)
 }
 
 /* { dg-final { scan-assembler "vpadd\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vpmaxf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vpmaxf32.c
@@ -18,4 +18,3 @@ void test_vpmaxf32 (void)
 }
 
 /* { dg-final { scan-assembler "vpmax\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vpmaxs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vpmaxs16.c
@@ -18,4 +18,3 @@ void test_vpmaxs16 (void)
 }
 
 /* { dg-final { scan-assembler "vpmax\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vpmaxs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vpmaxs32.c
@@ -18,4 +18,3 @@ void test_vpmaxs32 (void)
 }
 
 /* { dg-final { scan-assembler "vpmax\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vpmaxs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vpmaxs8.c
@@ -18,4 +18,3 @@ void test_vpmaxs8 (void)
 }
 
 /* { dg-final { scan-assembler "vpmax\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vpmaxu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vpmaxu16.c
@@ -18,4 +18,3 @@ void test_vpmaxu16 (void)
 }
 
 /* { dg-final { scan-assembler "vpmax\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vpmaxu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vpmaxu32.c
@@ -18,4 +18,3 @@ void test_vpmaxu32 (void)
 }
 
 /* { dg-final { scan-assembler "vpmax\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vpmaxu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vpmaxu8.c
@@ -18,4 +18,3 @@ void test_vpmaxu8 (void)
 }
 
 /* { dg-final { scan-assembler "vpmax\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vpminf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vpminf32.c
@@ -18,4 +18,3 @@ void test_vpminf32 (void)
 }
 
 /* { dg-final { scan-assembler "vpmin\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vpmins16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vpmins16.c
@@ -18,4 +18,3 @@ void test_vpmins16 (void)
 }
 
 /* { dg-final { scan-assembler "vpmin\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vpmins32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vpmins32.c
@@ -18,4 +18,3 @@ void test_vpmins32 (void)
 }
 
 /* { dg-final { scan-assembler "vpmin\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vpmins8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vpmins8.c
@@ -18,4 +18,3 @@ void test_vpmins8 (void)
 }
 
 /* { dg-final { scan-assembler "vpmin\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vpminu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vpminu16.c
@@ -18,4 +18,3 @@ void test_vpminu16 (void)
 }
 
 /* { dg-final { scan-assembler "vpmin\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vpminu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vpminu32.c
@@ -18,4 +18,3 @@ void test_vpminu32 (void)
 }
 
 /* { dg-final { scan-assembler "vpmin\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vpminu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vpminu8.c
@@ -18,4 +18,3 @@ void test_vpminu8 (void)
 }
 
 /* { dg-final { scan-assembler "vpmin\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_lanes16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_lanes16.c
@@ -18,4 +18,3 @@ void test_vqRdmulhQ_lanes16 (void)
 }
 
 /* { dg-final { scan-assembler "vqrdmulh\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_lanes32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_lanes32.c
@@ -18,4 +18,3 @@ void test_vqRdmulhQ_lanes32 (void)
 }
 
 /* { dg-final { scan-assembler "vqrdmulh\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_ns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_ns16.c
@@ -18,4 +18,3 @@ void test_vqRdmulhQ_ns16 (void)
 }
 
 /* { dg-final { scan-assembler "vqrdmulh\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_ns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_ns32.c
@@ -18,4 +18,3 @@ void test_vqRdmulhQ_ns32 (void)
 }
 
 /* { dg-final { scan-assembler "vqrdmulh\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQs16.c
@@ -18,4 +18,3 @@ void test_vqRdmulhQs16 (void)
 }
 
 /* { dg-final { scan-assembler "vqrdmulh\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQs32.c
@@ -18,4 +18,3 @@ void test_vqRdmulhQs32 (void)
 }
 
 /* { dg-final { scan-assembler "vqrdmulh\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqRdmulh_lanes16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqRdmulh_lanes16.c
@@ -18,4 +18,3 @@ void test_vqRdmulh_lanes16 (void)
 }
 
 /* { dg-final { scan-assembler "vqrdmulh\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqRdmulh_lanes32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqRdmulh_lanes32.c
@@ -18,4 +18,3 @@ void test_vqRdmulh_lanes32 (void)
 }
 
 /* { dg-final { scan-assembler "vqrdmulh\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqRdmulh_ns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqRdmulh_ns16.c
@@ -18,4 +18,3 @@ void test_vqRdmulh_ns16 (void)
 }
 
 /* { dg-final { scan-assembler "vqrdmulh\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqRdmulh_ns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqRdmulh_ns32.c
@@ -18,4 +18,3 @@ void test_vqRdmulh_ns32 (void)
 }
 
 /* { dg-final { scan-assembler "vqrdmulh\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqRdmulhs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqRdmulhs16.c
@@ -18,4 +18,3 @@ void test_vqRdmulhs16 (void)
 }
 
 /* { dg-final { scan-assembler "vqrdmulh\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqRdmulhs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqRdmulhs32.c
@@ -18,4 +18,3 @@ void test_vqRdmulhs32 (void)
 }
 
 /* { dg-final { scan-assembler "vqrdmulh\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqRshlQs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqRshlQs16.c
@@ -18,4 +18,3 @@ void test_vqRshlQs16 (void)
 }
 
 /* { dg-final { scan-assembler "vqrshl\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqRshlQs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqRshlQs32.c
@@ -18,4 +18,3 @@ void test_vqRshlQs32 (void)
 }
 
 /* { dg-final { scan-assembler "vqrshl\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqRshlQs64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqRshlQs64.c
@@ -18,4 +18,3 @@ void test_vqRshlQs64 (void)
 }
 
 /* { dg-final { scan-assembler "vqrshl\.s64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqRshlQs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqRshlQs8.c
@@ -18,4 +18,3 @@ void test_vqRshlQs8 (void)
 }
 
 /* { dg-final { scan-assembler "vqrshl\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqRshlQu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqRshlQu16.c
@@ -18,4 +18,3 @@ void test_vqRshlQu16 (void)
 }
 
 /* { dg-final { scan-assembler "vqrshl\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqRshlQu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqRshlQu32.c
@@ -18,4 +18,3 @@ void test_vqRshlQu32 (void)
 }
 
 /* { dg-final { scan-assembler "vqrshl\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqRshlQu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqRshlQu64.c
@@ -18,4 +18,3 @@ void test_vqRshlQu64 (void)
 }
 
 /* { dg-final { scan-assembler "vqrshl\.u64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqRshlQu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqRshlQu8.c
@@ -18,4 +18,3 @@ void test_vqRshlQu8 (void)
 }
 
 /* { dg-final { scan-assembler "vqrshl\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqRshls16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqRshls16.c
@@ -18,4 +18,3 @@ void test_vqRshls16 (void)
 }
 
 /* { dg-final { scan-assembler "vqrshl\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqRshls32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqRshls32.c
@@ -18,4 +18,3 @@ void test_vqRshls32 (void)
 }
 
 /* { dg-final { scan-assembler "vqrshl\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqRshls64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqRshls64.c
@@ -18,4 +18,3 @@ void test_vqRshls64 (void)
 }
 
 /* { dg-final { scan-assembler "vqrshl\.s64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqRshls8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqRshls8.c
@@ -18,4 +18,3 @@ void test_vqRshls8 (void)
 }
 
 /* { dg-final { scan-assembler "vqrshl\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqRshlu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqRshlu16.c
@@ -18,4 +18,3 @@ void test_vqRshlu16 (void)
 }
 
 /* { dg-final { scan-assembler "vqrshl\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqRshlu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqRshlu32.c
@@ -18,4 +18,3 @@ void test_vqRshlu32 (void)
 }
 
 /* { dg-final { scan-assembler "vqrshl\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqRshlu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqRshlu64.c
@@ -18,4 +18,3 @@ void test_vqRshlu64 (void)
 }
 
 /* { dg-final { scan-assembler "vqrshl\.u64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqRshlu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqRshlu8.c
@@ -18,4 +18,3 @@ void test_vqRshlu8 (void)
 }
 
 /* { dg-final { scan-assembler "vqrshl\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqRshrn_ns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqRshrn_ns16.c
@@ -17,4 +17,3 @@ void test_vqRshrn_ns16 (void)
 }
 
 /* { dg-final { scan-assembler "vqrshrn\.s16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqRshrn_ns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqRshrn_ns32.c
@@ -17,4 +17,3 @@ void test_vqRshrn_ns32 (void)
 }
 
 /* { dg-final { scan-assembler "vqrshrn\.s32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqRshrn_ns64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqRshrn_ns64.c
@@ -17,4 +17,3 @@ void test_vqRshrn_ns64 (void)
 }
 
 /* { dg-final { scan-assembler "vqrshrn\.s64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqRshrn_nu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqRshrn_nu16.c
@@ -17,4 +17,3 @@ void test_vqRshrn_nu16 (void)
 }
 
 /* { dg-final { scan-assembler "vqrshrn\.u16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqRshrn_nu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqRshrn_nu32.c
@@ -17,4 +17,3 @@ void test_vqRshrn_nu32 (void)
 }
 
 /* { dg-final { scan-assembler "vqrshrn\.u32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqRshrn_nu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqRshrn_nu64.c
@@ -17,4 +17,3 @@ void test_vqRshrn_nu64 (void)
 }
 
 /* { dg-final { scan-assembler "vqrshrn\.u64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqRshrun_ns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqRshrun_ns16.c
@@ -17,4 +17,3 @@ void test_vqRshrun_ns16 (void)
 }
 
 /* { dg-final { scan-assembler "vqrshrun\.s16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqRshrun_ns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqRshrun_ns32.c
@@ -17,4 +17,3 @@ void test_vqRshrun_ns32 (void)
 }
 
 /* { dg-final { scan-assembler "vqrshrun\.s32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqRshrun_ns64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqRshrun_ns64.c
@@ -17,4 +17,3 @@ void test_vqRshrun_ns64 (void)
 }
 
 /* { dg-final { scan-assembler "vqrshrun\.s64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqabsQs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqabsQs16.c
@@ -17,4 +17,3 @@ void test_vqabsQs16 (void)
 }
 
 /* { dg-final { scan-assembler "vqabs\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqabsQs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqabsQs32.c
@@ -17,4 +17,3 @@ void test_vqabsQs32 (void)
 }
 
 /* { dg-final { scan-assembler "vqabs\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqabsQs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqabsQs8.c
@@ -17,4 +17,3 @@ void test_vqabsQs8 (void)
 }
 
 /* { dg-final { scan-assembler "vqabs\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqabss16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqabss16.c
@@ -17,4 +17,3 @@ void test_vqabss16 (void)
 }
 
 /* { dg-final { scan-assembler "vqabs\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqabss32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqabss32.c
@@ -17,4 +17,3 @@ void test_vqabss32 (void)
 }
 
 /* { dg-final { scan-assembler "vqabs\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqabss8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqabss8.c
@@ -17,4 +17,3 @@ void test_vqabss8 (void)
 }
 
 /* { dg-final { scan-assembler "vqabs\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqaddQs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqaddQs16.c
@@ -18,4 +18,3 @@ void test_vqaddQs16 (void)
 }
 
 /* { dg-final { scan-assembler "vqadd\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqaddQs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqaddQs32.c
@@ -18,4 +18,3 @@ void test_vqaddQs32 (void)
 }
 
 /* { dg-final { scan-assembler "vqadd\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqaddQs64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqaddQs64.c
@@ -18,4 +18,3 @@ void test_vqaddQs64 (void)
 }
 
 /* { dg-final { scan-assembler "vqadd\.s64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqaddQs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqaddQs8.c
@@ -18,4 +18,3 @@ void test_vqaddQs8 (void)
 }
 
 /* { dg-final { scan-assembler "vqadd\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqaddQu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqaddQu16.c
@@ -18,4 +18,3 @@ void test_vqaddQu16 (void)
 }
 
 /* { dg-final { scan-assembler "vqadd\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqaddQu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqaddQu32.c
@@ -18,4 +18,3 @@ void test_vqaddQu32 (void)
 }
 
 /* { dg-final { scan-assembler "vqadd\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqaddQu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqaddQu64.c
@@ -18,4 +18,3 @@ void test_vqaddQu64 (void)
 }
 
 /* { dg-final { scan-assembler "vqadd\.u64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqaddQu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqaddQu8.c
@@ -18,4 +18,3 @@ void test_vqaddQu8 (void)
 }
 
 /* { dg-final { scan-assembler "vqadd\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqadds16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqadds16.c
@@ -18,4 +18,3 @@ void test_vqadds16 (void)
 }
 
 /* { dg-final { scan-assembler "vqadd\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqadds32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqadds32.c
@@ -18,4 +18,3 @@ void test_vqadds32 (void)
 }
 
 /* { dg-final { scan-assembler "vqadd\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqadds64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqadds64.c
@@ -18,4 +18,3 @@ void test_vqadds64 (void)
 }
 
 /* { dg-final { scan-assembler "vqadd\.s64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqadds8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqadds8.c
@@ -18,4 +18,3 @@ void test_vqadds8 (void)
 }
 
 /* { dg-final { scan-assembler "vqadd\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqaddu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqaddu16.c
@@ -18,4 +18,3 @@ void test_vqaddu16 (void)
 }
 
 /* { dg-final { scan-assembler "vqadd\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqaddu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqaddu32.c
@@ -18,4 +18,3 @@ void test_vqaddu32 (void)
 }
 
 /* { dg-final { scan-assembler "vqadd\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqaddu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqaddu64.c
@@ -18,4 +18,3 @@ void test_vqaddu64 (void)
 }
 
 /* { dg-final { scan-assembler "vqadd\.u64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqaddu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqaddu8.c
@@ -18,4 +18,3 @@ void test_vqaddu8 (void)
 }
 
 /* { dg-final { scan-assembler "vqadd\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqdmlal_lanes16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqdmlal_lanes16.c
@@ -19,4 +19,3 @@ void test_vqdmlal_lanes16 (void)
 }
 
 /* { dg-final { scan-assembler "vqdmlal\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqdmlal_lanes32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqdmlal_lanes32.c
@@ -19,4 +19,3 @@ void test_vqdmlal_lanes32 (void)
 }
 
 /* { dg-final { scan-assembler "vqdmlal\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqdmlal_ns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqdmlal_ns16.c
@@ -19,4 +19,3 @@ void test_vqdmlal_ns16 (void)
 }
 
 /* { dg-final { scan-assembler "vqdmlal\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqdmlal_ns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqdmlal_ns32.c
@@ -19,4 +19,3 @@ void test_vqdmlal_ns32 (void)
 }
 
 /* { dg-final { scan-assembler "vqdmlal\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqdmlals16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqdmlals16.c
@@ -19,4 +19,3 @@ void test_vqdmlals16 (void)
 }
 
 /* { dg-final { scan-assembler "vqdmlal\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqdmlals32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqdmlals32.c
@@ -19,4 +19,3 @@ void test_vqdmlals32 (void)
 }
 
 /* { dg-final { scan-assembler "vqdmlal\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqdmlsl_lanes16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqdmlsl_lanes16.c
@@ -19,4 +19,3 @@ void test_vqdmlsl_lanes16 (void)
 }
 
 /* { dg-final { scan-assembler "vqdmlsl\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqdmlsl_lanes32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqdmlsl_lanes32.c
@@ -19,4 +19,3 @@ void test_vqdmlsl_lanes32 (void)
 }
 
 /* { dg-final { scan-assembler "vqdmlsl\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqdmlsl_ns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqdmlsl_ns16.c
@@ -19,4 +19,3 @@ void test_vqdmlsl_ns16 (void)
 }
 
 /* { dg-final { scan-assembler "vqdmlsl\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqdmlsl_ns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqdmlsl_ns32.c
@@ -19,4 +19,3 @@ void test_vqdmlsl_ns32 (void)
 }
 
 /* { dg-final { scan-assembler "vqdmlsl\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqdmlsls16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqdmlsls16.c
@@ -19,4 +19,3 @@ void test_vqdmlsls16 (void)
 }
 
 /* { dg-final { scan-assembler "vqdmlsl\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqdmlsls32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqdmlsls32.c
@@ -19,4 +19,3 @@ void test_vqdmlsls32 (void)
 }
 
 /* { dg-final { scan-assembler "vqdmlsl\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_lanes16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_lanes16.c
@@ -18,4 +18,3 @@ void test_vqdmulhQ_lanes16 (void)
 }
 
 /* { dg-final { scan-assembler "vqdmulh\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_lanes32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_lanes32.c
@@ -18,4 +18,3 @@ void test_vqdmulhQ_lanes32 (void)
 }
 
 /* { dg-final { scan-assembler "vqdmulh\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_ns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_ns16.c
@@ -18,4 +18,3 @@ void test_vqdmulhQ_ns16 (void)
 }
 
 /* { dg-final { scan-assembler "vqdmulh\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_ns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_ns32.c
@@ -18,4 +18,3 @@ void test_vqdmulhQ_ns32 (void)
 }
 
 /* { dg-final { scan-assembler "vqdmulh\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqdmulhQs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqdmulhQs16.c
@@ -18,4 +18,3 @@ void test_vqdmulhQs16 (void)
 }
 
 /* { dg-final { scan-assembler "vqdmulh\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqdmulhQs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqdmulhQs32.c
@@ -18,4 +18,3 @@ void test_vqdmulhQs32 (void)
 }
 
 /* { dg-final { scan-assembler "vqdmulh\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqdmulh_lanes16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqdmulh_lanes16.c
@@ -18,4 +18,3 @@ void test_vqdmulh_lanes16 (void)
 }
 
 /* { dg-final { scan-assembler "vqdmulh\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqdmulh_lanes32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqdmulh_lanes32.c
@@ -18,4 +18,3 @@ void test_vqdmulh_lanes32 (void)
 }
 
 /* { dg-final { scan-assembler "vqdmulh\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqdmulh_ns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqdmulh_ns16.c
@@ -18,4 +18,3 @@ void test_vqdmulh_ns16 (void)
 }
 
 /* { dg-final { scan-assembler "vqdmulh\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqdmulh_ns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqdmulh_ns32.c
@@ -18,4 +18,3 @@ void test_vqdmulh_ns32 (void)
 }
 
 /* { dg-final { scan-assembler "vqdmulh\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqdmulhs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqdmulhs16.c
@@ -18,4 +18,3 @@ void test_vqdmulhs16 (void)
 }
 
 /* { dg-final { scan-assembler "vqdmulh\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqdmulhs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqdmulhs32.c
@@ -18,4 +18,3 @@ void test_vqdmulhs32 (void)
 }
 
 /* { dg-final { scan-assembler "vqdmulh\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqdmull_lanes16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqdmull_lanes16.c
@@ -18,4 +18,3 @@ void test_vqdmull_lanes16 (void)
 }
 
 /* { dg-final { scan-assembler "vqdmull\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqdmull_lanes32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqdmull_lanes32.c
@@ -18,4 +18,3 @@ void test_vqdmull_lanes32 (void)
 }
 
 /* { dg-final { scan-assembler "vqdmull\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqdmull_ns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqdmull_ns16.c
@@ -18,4 +18,3 @@ void test_vqdmull_ns16 (void)
 }
 
 /* { dg-final { scan-assembler "vqdmull\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqdmull_ns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqdmull_ns32.c
@@ -18,4 +18,3 @@ void test_vqdmull_ns32 (void)
 }
 
 /* { dg-final { scan-assembler "vqdmull\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqdmulls16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqdmulls16.c
@@ -18,4 +18,3 @@ void test_vqdmulls16 (void)
 }
 
 /* { dg-final { scan-assembler "vqdmull\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqdmulls32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqdmulls32.c
@@ -18,4 +18,3 @@ void test_vqdmulls32 (void)
 }
 
 /* { dg-final { scan-assembler "vqdmull\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqmovns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqmovns16.c
@@ -17,4 +17,3 @@ void test_vqmovns16 (void)
 }
 
 /* { dg-final { scan-assembler "vqmovn\.s16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqmovns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqmovns32.c
@@ -17,4 +17,3 @@ void test_vqmovns32 (void)
 }
 
 /* { dg-final { scan-assembler "vqmovn\.s32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqmovns64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqmovns64.c
@@ -17,4 +17,3 @@ void test_vqmovns64 (void)
 }
 
 /* { dg-final { scan-assembler "vqmovn\.s64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqmovnu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqmovnu16.c
@@ -17,4 +17,3 @@ void test_vqmovnu16 (void)
 }
 
 /* { dg-final { scan-assembler "vqmovn\.u16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqmovnu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqmovnu32.c
@@ -17,4 +17,3 @@ void test_vqmovnu32 (void)
 }
 
 /* { dg-final { scan-assembler "vqmovn\.u32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqmovnu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqmovnu64.c
@@ -17,4 +17,3 @@ void test_vqmovnu64 (void)
 }
 
 /* { dg-final { scan-assembler "vqmovn\.u64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqmovuns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqmovuns16.c
@@ -17,4 +17,3 @@ void test_vqmovuns16 (void)
 }
 
 /* { dg-final { scan-assembler "vqmovun\.s16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqmovuns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqmovuns32.c
@@ -17,4 +17,3 @@ void test_vqmovuns32 (void)
 }
 
 /* { dg-final { scan-assembler "vqmovun\.s32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqmovuns64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqmovuns64.c
@@ -17,4 +17,3 @@ void test_vqmovuns64 (void)
 }
 
 /* { dg-final { scan-assembler "vqmovun\.s64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqnegQs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqnegQs16.c
@@ -17,4 +17,3 @@ void test_vqnegQs16 (void)
 }
 
 /* { dg-final { scan-assembler "vqneg\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqnegQs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqnegQs32.c
@@ -17,4 +17,3 @@ void test_vqnegQs32 (void)
 }
 
 /* { dg-final { scan-assembler "vqneg\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqnegQs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqnegQs8.c
@@ -17,4 +17,3 @@ void test_vqnegQs8 (void)
 }
 
 /* { dg-final { scan-assembler "vqneg\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqnegs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqnegs16.c
@@ -17,4 +17,3 @@ void test_vqnegs16 (void)
 }
 
 /* { dg-final { scan-assembler "vqneg\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqnegs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqnegs32.c
@@ -17,4 +17,3 @@ void test_vqnegs32 (void)
 }
 
 /* { dg-final { scan-assembler "vqneg\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqnegs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqnegs8.c
@@ -17,4 +17,3 @@ void test_vqnegs8 (void)
 }
 
 /* { dg-final { scan-assembler "vqneg\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns16.c
@@ -17,4 +17,3 @@ void test_vqshlQ_ns16 (void)
 }
 
 /* { dg-final { scan-assembler "vqshl\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns32.c
@@ -17,4 +17,3 @@ void test_vqshlQ_ns32 (void)
 }
 
 /* { dg-final { scan-assembler "vqshl\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns64.c
@@ -17,4 +17,3 @@ void test_vqshlQ_ns64 (void)
 }
 
 /* { dg-final { scan-assembler "vqshl\.s64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns8.c
@@ -17,4 +17,3 @@ void test_vqshlQ_ns8 (void)
 }
 
 /* { dg-final { scan-assembler "vqshl\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu16.c
@@ -17,4 +17,3 @@ void test_vqshlQ_nu16 (void)
 }
 
 /* { dg-final { scan-assembler "vqshl\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu32.c
@@ -17,4 +17,3 @@ void test_vqshlQ_nu32 (void)
 }
 
 /* { dg-final { scan-assembler "vqshl\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu64.c
@@ -17,4 +17,3 @@ void test_vqshlQ_nu64 (void)
 }
 
 /* { dg-final { scan-assembler "vqshl\.u64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu8.c
@@ -17,4 +17,3 @@ void test_vqshlQ_nu8 (void)
 }
 
 /* { dg-final { scan-assembler "vqshl\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqshlQs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqshlQs16.c
@@ -18,4 +18,3 @@ void test_vqshlQs16 (void)
 }
 
 /* { dg-final { scan-assembler "vqshl\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqshlQs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqshlQs32.c
@@ -18,4 +18,3 @@ void test_vqshlQs32 (void)
 }
 
 /* { dg-final { scan-assembler "vqshl\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqshlQs64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqshlQs64.c
@@ -18,4 +18,3 @@ void test_vqshlQs64 (void)
 }
 
 /* { dg-final { scan-assembler "vqshl\.s64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqshlQs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqshlQs8.c
@@ -18,4 +18,3 @@ void test_vqshlQs8 (void)
 }
 
 /* { dg-final { scan-assembler "vqshl\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqshlQu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqshlQu16.c
@@ -18,4 +18,3 @@ void test_vqshlQu16 (void)
 }
 
 /* { dg-final { scan-assembler "vqshl\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqshlQu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqshlQu32.c
@@ -18,4 +18,3 @@ void test_vqshlQu32 (void)
 }
 
 /* { dg-final { scan-assembler "vqshl\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqshlQu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqshlQu64.c
@@ -18,4 +18,3 @@ void test_vqshlQu64 (void)
 }
 
 /* { dg-final { scan-assembler "vqshl\.u64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqshlQu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqshlQu8.c
@@ -18,4 +18,3 @@ void test_vqshlQu8 (void)
 }
 
 /* { dg-final { scan-assembler "vqshl\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqshl_ns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqshl_ns16.c
@@ -17,4 +17,3 @@ void test_vqshl_ns16 (void)
 }
 
 /* { dg-final { scan-assembler "vqshl\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqshl_ns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqshl_ns32.c
@@ -17,4 +17,3 @@ void test_vqshl_ns32 (void)
 }
 
 /* { dg-final { scan-assembler "vqshl\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqshl_ns64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqshl_ns64.c
@@ -17,4 +17,3 @@ void test_vqshl_ns64 (void)
 }
 
 /* { dg-final { scan-assembler "vqshl\.s64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqshl_ns8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqshl_ns8.c
@@ -17,4 +17,3 @@ void test_vqshl_ns8 (void)
 }
 
 /* { dg-final { scan-assembler "vqshl\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqshl_nu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqshl_nu16.c
@@ -17,4 +17,3 @@ void test_vqshl_nu16 (void)
 }
 
 /* { dg-final { scan-assembler "vqshl\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqshl_nu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqshl_nu32.c
@@ -17,4 +17,3 @@ void test_vqshl_nu32 (void)
 }
 
 /* { dg-final { scan-assembler "vqshl\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqshl_nu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqshl_nu64.c
@@ -17,4 +17,3 @@ void test_vqshl_nu64 (void)
 }
 
 /* { dg-final { scan-assembler "vqshl\.u64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqshl_nu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqshl_nu8.c
@@ -17,4 +17,3 @@ void test_vqshl_nu8 (void)
 }
 
 /* { dg-final { scan-assembler "vqshl\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqshls16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqshls16.c
@@ -18,4 +18,3 @@ void test_vqshls16 (void)
 }
 
 /* { dg-final { scan-assembler "vqshl\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqshls32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqshls32.c
@@ -18,4 +18,3 @@ void test_vqshls32 (void)
 }
 
 /* { dg-final { scan-assembler "vqshl\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqshls64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqshls64.c
@@ -18,4 +18,3 @@ void test_vqshls64 (void)
 }
 
 /* { dg-final { scan-assembler "vqshl\.s64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqshls8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqshls8.c
@@ -18,4 +18,3 @@ void test_vqshls8 (void)
 }
 
 /* { dg-final { scan-assembler "vqshl\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqshlu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqshlu16.c
@@ -18,4 +18,3 @@ void test_vqshlu16 (void)
 }
 
 /* { dg-final { scan-assembler "vqshl\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqshlu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqshlu32.c
@@ -18,4 +18,3 @@ void test_vqshlu32 (void)
 }
 
 /* { dg-final { scan-assembler "vqshl\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqshlu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqshlu64.c
@@ -18,4 +18,3 @@ void test_vqshlu64 (void)
 }
 
 /* { dg-final { scan-assembler "vqshl\.u64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqshlu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqshlu8.c
@@ -18,4 +18,3 @@ void test_vqshlu8 (void)
 }
 
 /* { dg-final { scan-assembler "vqshl\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns16.c
@@ -17,4 +17,3 @@ void test_vqshluQ_ns16 (void)
 }
 
 /* { dg-final { scan-assembler "vqshlu\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns32.c
@@ -17,4 +17,3 @@ void test_vqshluQ_ns32 (void)
 }
 
 /* { dg-final { scan-assembler "vqshlu\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns64.c
@@ -17,4 +17,3 @@ void test_vqshluQ_ns64 (void)
 }
 
 /* { dg-final { scan-assembler "vqshlu\.s64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns8.c
@@ -17,4 +17,3 @@ void test_vqshluQ_ns8 (void)
 }
 
 /* { dg-final { scan-assembler "vqshlu\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqshlu_ns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqshlu_ns16.c
@@ -17,4 +17,3 @@ void test_vqshlu_ns16 (void)
 }
 
 /* { dg-final { scan-assembler "vqshlu\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqshlu_ns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqshlu_ns32.c
@@ -17,4 +17,3 @@ void test_vqshlu_ns32 (void)
 }
 
 /* { dg-final { scan-assembler "vqshlu\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqshlu_ns64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqshlu_ns64.c
@@ -17,4 +17,3 @@ void test_vqshlu_ns64 (void)
 }
 
 /* { dg-final { scan-assembler "vqshlu\.s64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqshlu_ns8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqshlu_ns8.c
@@ -17,4 +17,3 @@ void test_vqshlu_ns8 (void)
 }
 
 /* { dg-final { scan-assembler "vqshlu\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqshrn_ns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqshrn_ns16.c
@@ -17,4 +17,3 @@ void test_vqshrn_ns16 (void)
 }
 
 /* { dg-final { scan-assembler "vqshrn\.s16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqshrn_ns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqshrn_ns32.c
@@ -17,4 +17,3 @@ void test_vqshrn_ns32 (void)
 }
 
 /* { dg-final { scan-assembler "vqshrn\.s32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqshrn_ns64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqshrn_ns64.c
@@ -17,4 +17,3 @@ void test_vqshrn_ns64 (void)
 }
 
 /* { dg-final { scan-assembler "vqshrn\.s64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqshrn_nu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqshrn_nu16.c
@@ -17,4 +17,3 @@ void test_vqshrn_nu16 (void)
 }
 
 /* { dg-final { scan-assembler "vqshrn\.u16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqshrn_nu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqshrn_nu32.c
@@ -17,4 +17,3 @@ void test_vqshrn_nu32 (void)
 }
 
 /* { dg-final { scan-assembler "vqshrn\.u32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqshrn_nu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqshrn_nu64.c
@@ -17,4 +17,3 @@ void test_vqshrn_nu64 (void)
 }
 
 /* { dg-final { scan-assembler "vqshrn\.u64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqshrun_ns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqshrun_ns16.c
@@ -17,4 +17,3 @@ void test_vqshrun_ns16 (void)
 }
 
 /* { dg-final { scan-assembler "vqshrun\.s16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqshrun_ns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqshrun_ns32.c
@@ -17,4 +17,3 @@ void test_vqshrun_ns32 (void)
 }
 
 /* { dg-final { scan-assembler "vqshrun\.s32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqshrun_ns64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqshrun_ns64.c
@@ -17,4 +17,3 @@ void test_vqshrun_ns64 (void)
 }
 
 /* { dg-final { scan-assembler "vqshrun\.s64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqsubQs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqsubQs16.c
@@ -18,4 +18,3 @@ void test_vqsubQs16 (void)
 }
 
 /* { dg-final { scan-assembler "vqsub\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqsubQs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqsubQs32.c
@@ -18,4 +18,3 @@ void test_vqsubQs32 (void)
 }
 
 /* { dg-final { scan-assembler "vqsub\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqsubQs64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqsubQs64.c
@@ -18,4 +18,3 @@ void test_vqsubQs64 (void)
 }
 
 /* { dg-final { scan-assembler "vqsub\.s64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqsubQs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqsubQs8.c
@@ -18,4 +18,3 @@ void test_vqsubQs8 (void)
 }
 
 /* { dg-final { scan-assembler "vqsub\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqsubQu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqsubQu16.c
@@ -18,4 +18,3 @@ void test_vqsubQu16 (void)
 }
 
 /* { dg-final { scan-assembler "vqsub\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqsubQu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqsubQu32.c
@@ -18,4 +18,3 @@ void test_vqsubQu32 (void)
 }
 
 /* { dg-final { scan-assembler "vqsub\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqsubQu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqsubQu64.c
@@ -18,4 +18,3 @@ void test_vqsubQu64 (void)
 }
 
 /* { dg-final { scan-assembler "vqsub\.u64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqsubQu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqsubQu8.c
@@ -18,4 +18,3 @@ void test_vqsubQu8 (void)
 }
 
 /* { dg-final { scan-assembler "vqsub\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqsubs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqsubs16.c
@@ -18,4 +18,3 @@ void test_vqsubs16 (void)
 }
 
 /* { dg-final { scan-assembler "vqsub\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqsubs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqsubs32.c
@@ -18,4 +18,3 @@ void test_vqsubs32 (void)
 }
 
 /* { dg-final { scan-assembler "vqsub\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqsubs64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqsubs64.c
@@ -18,4 +18,3 @@ void test_vqsubs64 (void)
 }
 
 /* { dg-final { scan-assembler "vqsub\.s64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqsubs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqsubs8.c
@@ -18,4 +18,3 @@ void test_vqsubs8 (void)
 }
 
 /* { dg-final { scan-assembler "vqsub\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqsubu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqsubu16.c
@@ -18,4 +18,3 @@ void test_vqsubu16 (void)
 }
 
 /* { dg-final { scan-assembler "vqsub\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqsubu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqsubu32.c
@@ -18,4 +18,3 @@ void test_vqsubu32 (void)
 }
 
 /* { dg-final { scan-assembler "vqsub\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqsubu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqsubu64.c
@@ -18,4 +18,3 @@ void test_vqsubu64 (void)
 }
 
 /* { dg-final { scan-assembler "vqsub\.u64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vqsubu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vqsubu8.c
@@ -18,4 +18,3 @@ void test_vqsubu8 (void)
 }
 
 /* { dg-final { scan-assembler "vqsub\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrecpeQf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrecpeQf32.c
@@ -17,4 +17,3 @@ void test_vrecpeQf32 (void)
 }
 
 /* { dg-final { scan-assembler "vrecpe\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrecpeQu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrecpeQu32.c
@@ -17,4 +17,3 @@ void test_vrecpeQu32 (void)
 }
 
 /* { dg-final { scan-assembler "vrecpe\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrecpef32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrecpef32.c
@@ -17,4 +17,3 @@ void test_vrecpef32 (void)
 }
 
 /* { dg-final { scan-assembler "vrecpe\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrecpeu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrecpeu32.c
@@ -17,4 +17,3 @@ void test_vrecpeu32 (void)
 }
 
 /* { dg-final { scan-assembler "vrecpe\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrecpsQf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrecpsQf32.c
@@ -18,4 +18,3 @@ void test_vrecpsQf32 (void)
 }
 
 /* { dg-final { scan-assembler "vrecps\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrecpsf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrecpsf32.c
@@ -18,4 +18,3 @@ void test_vrecpsf32 (void)
 }
 
 /* { dg-final { scan-assembler "vrecps\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_p128.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_p128.c
@@ -16,4 +16,3 @@ void test_vreinterpretQf32_p128 (void)
   out_float32x4_t = vreinterpretq_f32_p128 (arg0_poly128_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_p16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_p16.c
@@ -16,4 +16,3 @@ void test_vreinterpretQf32_p16 (void)
   out_float32x4_t = vreinterpretq_f32_p16 (arg0_poly16x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_p64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_p64.c
@@ -16,4 +16,3 @@ void test_vreinterpretQf32_p64 (void)
   out_float32x4_t = vreinterpretq_f32_p64 (arg0_poly64x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_p8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_p8.c
@@ -16,4 +16,3 @@ void test_vreinterpretQf32_p8 (void)
   out_float32x4_t = vreinterpretq_f32_p8 (arg0_poly8x16_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_s16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_s16.c
@@ -16,4 +16,3 @@ void test_vreinterpretQf32_s16 (void)
   out_float32x4_t = vreinterpretq_f32_s16 (arg0_int16x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_s32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_s32.c
@@ -16,4 +16,3 @@ void test_vreinterpretQf32_s32 (void)
   out_float32x4_t = vreinterpretq_f32_s32 (arg0_int32x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_s64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_s64.c
@@ -16,4 +16,3 @@ void test_vreinterpretQf32_s64 (void)
   out_float32x4_t = vreinterpretq_f32_s64 (arg0_int64x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_s8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_s8.c
@@ -16,4 +16,3 @@ void test_vreinterpretQf32_s8 (void)
   out_float32x4_t = vreinterpretq_f32_s8 (arg0_int8x16_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_u16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_u16.c
@@ -16,4 +16,3 @@ void test_vreinterpretQf32_u16 (void)
   out_float32x4_t = vreinterpretq_f32_u16 (arg0_uint16x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_u32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_u32.c
@@ -16,4 +16,3 @@ void test_vreinterpretQf32_u32 (void)
   out_float32x4_t = vreinterpretq_f32_u32 (arg0_uint32x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_u64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_u64.c
@@ -16,4 +16,3 @@ void test_vreinterpretQf32_u64 (void)
   out_float32x4_t = vreinterpretq_f32_u64 (arg0_uint64x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_u8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_u8.c
@@ -16,4 +16,3 @@ void test_vreinterpretQf32_u8 (void)
   out_float32x4_t = vreinterpretq_f32_u8 (arg0_uint8x16_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp128_f32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp128_f32.c
@@ -16,4 +16,3 @@ void test_vreinterpretQp128_f32 (void)
   out_poly128_t = vreinterpretq_p128_f32 (arg0_float32x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp128_p16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp128_p16.c
@@ -16,4 +16,3 @@ void test_vreinterpretQp128_p16 (void)
   out_poly128_t = vreinterpretq_p128_p16 (arg0_poly16x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp128_p64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp128_p64.c
@@ -16,4 +16,3 @@ void test_vreinterpretQp128_p64 (void)
   out_poly128_t = vreinterpretq_p128_p64 (arg0_poly64x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp128_p8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp128_p8.c
@@ -16,4 +16,3 @@ void test_vreinterpretQp128_p8 (void)
   out_poly128_t = vreinterpretq_p128_p8 (arg0_poly8x16_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp128_s16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp128_s16.c
@@ -16,4 +16,3 @@ void test_vreinterpretQp128_s16 (void)
   out_poly128_t = vreinterpretq_p128_s16 (arg0_int16x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp128_s32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp128_s32.c
@@ -16,4 +16,3 @@ void test_vreinterpretQp128_s32 (void)
   out_poly128_t = vreinterpretq_p128_s32 (arg0_int32x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp128_s64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp128_s64.c
@@ -16,4 +16,3 @@ void test_vreinterpretQp128_s64 (void)
   out_poly128_t = vreinterpretq_p128_s64 (arg0_int64x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp128_s8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp128_s8.c
@@ -16,4 +16,3 @@ void test_vreinterpretQp128_s8 (void)
   out_poly128_t = vreinterpretq_p128_s8 (arg0_int8x16_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp128_u16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp128_u16.c
@@ -16,4 +16,3 @@ void test_vreinterpretQp128_u16 (void)
   out_poly128_t = vreinterpretq_p128_u16 (arg0_uint16x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp128_u32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp128_u32.c
@@ -16,4 +16,3 @@ void test_vreinterpretQp128_u32 (void)
   out_poly128_t = vreinterpretq_p128_u32 (arg0_uint32x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp128_u64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp128_u64.c
@@ -16,4 +16,3 @@ void test_vreinterpretQp128_u64 (void)
   out_poly128_t = vreinterpretq_p128_u64 (arg0_uint64x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp128_u8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp128_u8.c
@@ -16,4 +16,3 @@ void test_vreinterpretQp128_u8 (void)
   out_poly128_t = vreinterpretq_p128_u8 (arg0_uint8x16_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_f32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_f32.c
@@ -16,4 +16,3 @@ void test_vreinterpretQp16_f32 (void)
   out_poly16x8_t = vreinterpretq_p16_f32 (arg0_float32x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_p128.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_p128.c
@@ -16,4 +16,3 @@ void test_vreinterpretQp16_p128 (void)
   out_poly16x8_t = vreinterpretq_p16_p128 (arg0_poly128_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_p64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_p64.c
@@ -16,4 +16,3 @@ void test_vreinterpretQp16_p64 (void)
   out_poly16x8_t = vreinterpretq_p16_p64 (arg0_poly64x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_p8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_p8.c
@@ -16,4 +16,3 @@ void test_vreinterpretQp16_p8 (void)
   out_poly16x8_t = vreinterpretq_p16_p8 (arg0_poly8x16_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_s16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_s16.c
@@ -16,4 +16,3 @@ void test_vreinterpretQp16_s16 (void)
   out_poly16x8_t = vreinterpretq_p16_s16 (arg0_int16x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_s32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_s32.c
@@ -16,4 +16,3 @@ void test_vreinterpretQp16_s32 (void)
   out_poly16x8_t = vreinterpretq_p16_s32 (arg0_int32x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_s64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_s64.c
@@ -16,4 +16,3 @@ void test_vreinterpretQp16_s64 (void)
   out_poly16x8_t = vreinterpretq_p16_s64 (arg0_int64x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_s8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_s8.c
@@ -16,4 +16,3 @@ void test_vreinterpretQp16_s8 (void)
   out_poly16x8_t = vreinterpretq_p16_s8 (arg0_int8x16_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_u16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_u16.c
@@ -16,4 +16,3 @@ void test_vreinterpretQp16_u16 (void)
   out_poly16x8_t = vreinterpretq_p16_u16 (arg0_uint16x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_u32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_u32.c
@@ -16,4 +16,3 @@ void test_vreinterpretQp16_u32 (void)
   out_poly16x8_t = vreinterpretq_p16_u32 (arg0_uint32x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_u64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_u64.c
@@ -16,4 +16,3 @@ void test_vreinterpretQp16_u64 (void)
   out_poly16x8_t = vreinterpretq_p16_u64 (arg0_uint64x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_u8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_u8.c
@@ -16,4 +16,3 @@ void test_vreinterpretQp16_u8 (void)
   out_poly16x8_t = vreinterpretq_p16_u8 (arg0_uint8x16_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp64_f32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp64_f32.c
@@ -16,4 +16,3 @@ void test_vreinterpretQp64_f32 (void)
   out_poly64x2_t = vreinterpretq_p64_f32 (arg0_float32x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp64_p128.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp64_p128.c
@@ -16,4 +16,3 @@ void test_vreinterpretQp64_p128 (void)
   out_poly64x2_t = vreinterpretq_p64_p128 (arg0_poly128_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp64_p16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp64_p16.c
@@ -16,4 +16,3 @@ void test_vreinterpretQp64_p16 (void)
   out_poly64x2_t = vreinterpretq_p64_p16 (arg0_poly16x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp64_p8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp64_p8.c
@@ -16,4 +16,3 @@ void test_vreinterpretQp64_p8 (void)
   out_poly64x2_t = vreinterpretq_p64_p8 (arg0_poly8x16_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp64_s16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp64_s16.c
@@ -16,4 +16,3 @@ void test_vreinterpretQp64_s16 (void)
   out_poly64x2_t = vreinterpretq_p64_s16 (arg0_int16x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp64_s32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp64_s32.c
@@ -16,4 +16,3 @@ void test_vreinterpretQp64_s32 (void)
   out_poly64x2_t = vreinterpretq_p64_s32 (arg0_int32x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp64_s64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp64_s64.c
@@ -16,4 +16,3 @@ void test_vreinterpretQp64_s64 (void)
   out_poly64x2_t = vreinterpretq_p64_s64 (arg0_int64x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp64_s8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp64_s8.c
@@ -16,4 +16,3 @@ void test_vreinterpretQp64_s8 (void)
   out_poly64x2_t = vreinterpretq_p64_s8 (arg0_int8x16_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp64_u16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp64_u16.c
@@ -16,4 +16,3 @@ void test_vreinterpretQp64_u16 (void)
   out_poly64x2_t = vreinterpretq_p64_u16 (arg0_uint16x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp64_u32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp64_u32.c
@@ -16,4 +16,3 @@ void test_vreinterpretQp64_u32 (void)
   out_poly64x2_t = vreinterpretq_p64_u32 (arg0_uint32x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp64_u64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp64_u64.c
@@ -16,4 +16,3 @@ void test_vreinterpretQp64_u64 (void)
   out_poly64x2_t = vreinterpretq_p64_u64 (arg0_uint64x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp64_u8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp64_u8.c
@@ -16,4 +16,3 @@ void test_vreinterpretQp64_u8 (void)
   out_poly64x2_t = vreinterpretq_p64_u8 (arg0_uint8x16_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_f32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_f32.c
@@ -16,4 +16,3 @@ void test_vreinterpretQp8_f32 (void)
   out_poly8x16_t = vreinterpretq_p8_f32 (arg0_float32x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_p128.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_p128.c
@@ -16,4 +16,3 @@ void test_vreinterpretQp8_p128 (void)
   out_poly8x16_t = vreinterpretq_p8_p128 (arg0_poly128_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_p16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_p16.c
@@ -16,4 +16,3 @@ void test_vreinterpretQp8_p16 (void)
   out_poly8x16_t = vreinterpretq_p8_p16 (arg0_poly16x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_p64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_p64.c
@@ -16,4 +16,3 @@ void test_vreinterpretQp8_p64 (void)
   out_poly8x16_t = vreinterpretq_p8_p64 (arg0_poly64x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_s16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_s16.c
@@ -16,4 +16,3 @@ void test_vreinterpretQp8_s16 (void)
   out_poly8x16_t = vreinterpretq_p8_s16 (arg0_int16x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_s32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_s32.c
@@ -16,4 +16,3 @@ void test_vreinterpretQp8_s32 (void)
   out_poly8x16_t = vreinterpretq_p8_s32 (arg0_int32x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_s64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_s64.c
@@ -16,4 +16,3 @@ void test_vreinterpretQp8_s64 (void)
   out_poly8x16_t = vreinterpretq_p8_s64 (arg0_int64x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_s8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_s8.c
@@ -16,4 +16,3 @@ void test_vreinterpretQp8_s8 (void)
   out_poly8x16_t = vreinterpretq_p8_s8 (arg0_int8x16_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_u16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_u16.c
@@ -16,4 +16,3 @@ void test_vreinterpretQp8_u16 (void)
   out_poly8x16_t = vreinterpretq_p8_u16 (arg0_uint16x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_u32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_u32.c
@@ -16,4 +16,3 @@ void test_vreinterpretQp8_u32 (void)
   out_poly8x16_t = vreinterpretq_p8_u32 (arg0_uint32x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_u64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_u64.c
@@ -16,4 +16,3 @@ void test_vreinterpretQp8_u64 (void)
   out_poly8x16_t = vreinterpretq_p8_u64 (arg0_uint64x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_u8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_u8.c
@@ -16,4 +16,3 @@ void test_vreinterpretQp8_u8 (void)
   out_poly8x16_t = vreinterpretq_p8_u8 (arg0_uint8x16_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_f32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_f32.c
@@ -16,4 +16,3 @@ void test_vreinterpretQs16_f32 (void)
   out_int16x8_t = vreinterpretq_s16_f32 (arg0_float32x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_p128.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_p128.c
@@ -16,4 +16,3 @@ void test_vreinterpretQs16_p128 (void)
   out_int16x8_t = vreinterpretq_s16_p128 (arg0_poly128_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_p16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_p16.c
@@ -16,4 +16,3 @@ void test_vreinterpretQs16_p16 (void)
   out_int16x8_t = vreinterpretq_s16_p16 (arg0_poly16x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_p64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_p64.c
@@ -16,4 +16,3 @@ void test_vreinterpretQs16_p64 (void)
   out_int16x8_t = vreinterpretq_s16_p64 (arg0_poly64x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_p8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_p8.c
@@ -16,4 +16,3 @@ void test_vreinterpretQs16_p8 (void)
   out_int16x8_t = vreinterpretq_s16_p8 (arg0_poly8x16_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_s32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_s32.c
@@ -16,4 +16,3 @@ void test_vreinterpretQs16_s32 (void)
   out_int16x8_t = vreinterpretq_s16_s32 (arg0_int32x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_s64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_s64.c
@@ -16,4 +16,3 @@ void test_vreinterpretQs16_s64 (void)
   out_int16x8_t = vreinterpretq_s16_s64 (arg0_int64x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_s8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_s8.c
@@ -16,4 +16,3 @@ void test_vreinterpretQs16_s8 (void)
   out_int16x8_t = vreinterpretq_s16_s8 (arg0_int8x16_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_u16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_u16.c
@@ -16,4 +16,3 @@ void test_vreinterpretQs16_u16 (void)
   out_int16x8_t = vreinterpretq_s16_u16 (arg0_uint16x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_u32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_u32.c
@@ -16,4 +16,3 @@ void test_vreinterpretQs16_u32 (void)
   out_int16x8_t = vreinterpretq_s16_u32 (arg0_uint32x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_u64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_u64.c
@@ -16,4 +16,3 @@ void test_vreinterpretQs16_u64 (void)
   out_int16x8_t = vreinterpretq_s16_u64 (arg0_uint64x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_u8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_u8.c
@@ -16,4 +16,3 @@ void test_vreinterpretQs16_u8 (void)
   out_int16x8_t = vreinterpretq_s16_u8 (arg0_uint8x16_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_f32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_f32.c
@@ -16,4 +16,3 @@ void test_vreinterpretQs32_f32 (void)
   out_int32x4_t = vreinterpretq_s32_f32 (arg0_float32x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_p128.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_p128.c
@@ -16,4 +16,3 @@ void test_vreinterpretQs32_p128 (void)
   out_int32x4_t = vreinterpretq_s32_p128 (arg0_poly128_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_p16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_p16.c
@@ -16,4 +16,3 @@ void test_vreinterpretQs32_p16 (void)
   out_int32x4_t = vreinterpretq_s32_p16 (arg0_poly16x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_p64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_p64.c
@@ -16,4 +16,3 @@ void test_vreinterpretQs32_p64 (void)
   out_int32x4_t = vreinterpretq_s32_p64 (arg0_poly64x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_p8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_p8.c
@@ -16,4 +16,3 @@ void test_vreinterpretQs32_p8 (void)
   out_int32x4_t = vreinterpretq_s32_p8 (arg0_poly8x16_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_s16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_s16.c
@@ -16,4 +16,3 @@ void test_vreinterpretQs32_s16 (void)
   out_int32x4_t = vreinterpretq_s32_s16 (arg0_int16x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_s64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_s64.c
@@ -16,4 +16,3 @@ void test_vreinterpretQs32_s64 (void)
   out_int32x4_t = vreinterpretq_s32_s64 (arg0_int64x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_s8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_s8.c
@@ -16,4 +16,3 @@ void test_vreinterpretQs32_s8 (void)
   out_int32x4_t = vreinterpretq_s32_s8 (arg0_int8x16_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_u16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_u16.c
@@ -16,4 +16,3 @@ void test_vreinterpretQs32_u16 (void)
   out_int32x4_t = vreinterpretq_s32_u16 (arg0_uint16x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_u32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_u32.c
@@ -16,4 +16,3 @@ void test_vreinterpretQs32_u32 (void)
   out_int32x4_t = vreinterpretq_s32_u32 (arg0_uint32x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_u64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_u64.c
@@ -16,4 +16,3 @@ void test_vreinterpretQs32_u64 (void)
   out_int32x4_t = vreinterpretq_s32_u64 (arg0_uint64x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_u8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_u8.c
@@ -16,4 +16,3 @@ void test_vreinterpretQs32_u8 (void)
   out_int32x4_t = vreinterpretq_s32_u8 (arg0_uint8x16_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_f32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_f32.c
@@ -16,4 +16,3 @@ void test_vreinterpretQs64_f32 (void)
   out_int64x2_t = vreinterpretq_s64_f32 (arg0_float32x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_p128.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_p128.c
@@ -16,4 +16,3 @@ void test_vreinterpretQs64_p128 (void)
   out_int64x2_t = vreinterpretq_s64_p128 (arg0_poly128_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_p16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_p16.c
@@ -16,4 +16,3 @@ void test_vreinterpretQs64_p16 (void)
   out_int64x2_t = vreinterpretq_s64_p16 (arg0_poly16x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_p64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_p64.c
@@ -16,4 +16,3 @@ void test_vreinterpretQs64_p64 (void)
   out_int64x2_t = vreinterpretq_s64_p64 (arg0_poly64x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_p8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_p8.c
@@ -16,4 +16,3 @@ void test_vreinterpretQs64_p8 (void)
   out_int64x2_t = vreinterpretq_s64_p8 (arg0_poly8x16_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_s16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_s16.c
@@ -16,4 +16,3 @@ void test_vreinterpretQs64_s16 (void)
   out_int64x2_t = vreinterpretq_s64_s16 (arg0_int16x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_s32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_s32.c
@@ -16,4 +16,3 @@ void test_vreinterpretQs64_s32 (void)
   out_int64x2_t = vreinterpretq_s64_s32 (arg0_int32x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_s8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_s8.c
@@ -16,4 +16,3 @@ void test_vreinterpretQs64_s8 (void)
   out_int64x2_t = vreinterpretq_s64_s8 (arg0_int8x16_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_u16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_u16.c
@@ -16,4 +16,3 @@ void test_vreinterpretQs64_u16 (void)
   out_int64x2_t = vreinterpretq_s64_u16 (arg0_uint16x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_u32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_u32.c
@@ -16,4 +16,3 @@ void test_vreinterpretQs64_u32 (void)
   out_int64x2_t = vreinterpretq_s64_u32 (arg0_uint32x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_u64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_u64.c
@@ -16,4 +16,3 @@ void test_vreinterpretQs64_u64 (void)
   out_int64x2_t = vreinterpretq_s64_u64 (arg0_uint64x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_u8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_u8.c
@@ -16,4 +16,3 @@ void test_vreinterpretQs64_u8 (void)
   out_int64x2_t = vreinterpretq_s64_u8 (arg0_uint8x16_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_f32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_f32.c
@@ -16,4 +16,3 @@ void test_vreinterpretQs8_f32 (void)
   out_int8x16_t = vreinterpretq_s8_f32 (arg0_float32x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_p128.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_p128.c
@@ -16,4 +16,3 @@ void test_vreinterpretQs8_p128 (void)
   out_int8x16_t = vreinterpretq_s8_p128 (arg0_poly128_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_p16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_p16.c
@@ -16,4 +16,3 @@ void test_vreinterpretQs8_p16 (void)
   out_int8x16_t = vreinterpretq_s8_p16 (arg0_poly16x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_p64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_p64.c
@@ -16,4 +16,3 @@ void test_vreinterpretQs8_p64 (void)
   out_int8x16_t = vreinterpretq_s8_p64 (arg0_poly64x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_p8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_p8.c
@@ -16,4 +16,3 @@ void test_vreinterpretQs8_p8 (void)
   out_int8x16_t = vreinterpretq_s8_p8 (arg0_poly8x16_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_s16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_s16.c
@@ -16,4 +16,3 @@ void test_vreinterpretQs8_s16 (void)
   out_int8x16_t = vreinterpretq_s8_s16 (arg0_int16x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_s32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_s32.c
@@ -16,4 +16,3 @@ void test_vreinterpretQs8_s32 (void)
   out_int8x16_t = vreinterpretq_s8_s32 (arg0_int32x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_s64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_s64.c
@@ -16,4 +16,3 @@ void test_vreinterpretQs8_s64 (void)
   out_int8x16_t = vreinterpretq_s8_s64 (arg0_int64x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_u16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_u16.c
@@ -16,4 +16,3 @@ void test_vreinterpretQs8_u16 (void)
   out_int8x16_t = vreinterpretq_s8_u16 (arg0_uint16x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_u32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_u32.c
@@ -16,4 +16,3 @@ void test_vreinterpretQs8_u32 (void)
   out_int8x16_t = vreinterpretq_s8_u32 (arg0_uint32x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_u64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_u64.c
@@ -16,4 +16,3 @@ void test_vreinterpretQs8_u64 (void)
   out_int8x16_t = vreinterpretq_s8_u64 (arg0_uint64x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_u8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_u8.c
@@ -16,4 +16,3 @@ void test_vreinterpretQs8_u8 (void)
   out_int8x16_t = vreinterpretq_s8_u8 (arg0_uint8x16_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_f32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_f32.c
@@ -16,4 +16,3 @@ void test_vreinterpretQu16_f32 (void)
   out_uint16x8_t = vreinterpretq_u16_f32 (arg0_float32x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_p128.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_p128.c
@@ -16,4 +16,3 @@ void test_vreinterpretQu16_p128 (void)
   out_uint16x8_t = vreinterpretq_u16_p128 (arg0_poly128_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_p16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_p16.c
@@ -16,4 +16,3 @@ void test_vreinterpretQu16_p16 (void)
   out_uint16x8_t = vreinterpretq_u16_p16 (arg0_poly16x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_p64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_p64.c
@@ -16,4 +16,3 @@ void test_vreinterpretQu16_p64 (void)
   out_uint16x8_t = vreinterpretq_u16_p64 (arg0_poly64x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_p8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_p8.c
@@ -16,4 +16,3 @@ void test_vreinterpretQu16_p8 (void)
   out_uint16x8_t = vreinterpretq_u16_p8 (arg0_poly8x16_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_s16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_s16.c
@@ -16,4 +16,3 @@ void test_vreinterpretQu16_s16 (void)
   out_uint16x8_t = vreinterpretq_u16_s16 (arg0_int16x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_s32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_s32.c
@@ -16,4 +16,3 @@ void test_vreinterpretQu16_s32 (void)
   out_uint16x8_t = vreinterpretq_u16_s32 (arg0_int32x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_s64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_s64.c
@@ -16,4 +16,3 @@ void test_vreinterpretQu16_s64 (void)
   out_uint16x8_t = vreinterpretq_u16_s64 (arg0_int64x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_s8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_s8.c
@@ -16,4 +16,3 @@ void test_vreinterpretQu16_s8 (void)
   out_uint16x8_t = vreinterpretq_u16_s8 (arg0_int8x16_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_u32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_u32.c
@@ -16,4 +16,3 @@ void test_vreinterpretQu16_u32 (void)
   out_uint16x8_t = vreinterpretq_u16_u32 (arg0_uint32x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_u64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_u64.c
@@ -16,4 +16,3 @@ void test_vreinterpretQu16_u64 (void)
   out_uint16x8_t = vreinterpretq_u16_u64 (arg0_uint64x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_u8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_u8.c
@@ -16,4 +16,3 @@ void test_vreinterpretQu16_u8 (void)
   out_uint16x8_t = vreinterpretq_u16_u8 (arg0_uint8x16_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_f32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_f32.c
@@ -16,4 +16,3 @@ void test_vreinterpretQu32_f32 (void)
   out_uint32x4_t = vreinterpretq_u32_f32 (arg0_float32x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_p128.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_p128.c
@@ -16,4 +16,3 @@ void test_vreinterpretQu32_p128 (void)
   out_uint32x4_t = vreinterpretq_u32_p128 (arg0_poly128_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_p16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_p16.c
@@ -16,4 +16,3 @@ void test_vreinterpretQu32_p16 (void)
   out_uint32x4_t = vreinterpretq_u32_p16 (arg0_poly16x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_p64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_p64.c
@@ -16,4 +16,3 @@ void test_vreinterpretQu32_p64 (void)
   out_uint32x4_t = vreinterpretq_u32_p64 (arg0_poly64x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_p8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_p8.c
@@ -16,4 +16,3 @@ void test_vreinterpretQu32_p8 (void)
   out_uint32x4_t = vreinterpretq_u32_p8 (arg0_poly8x16_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_s16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_s16.c
@@ -16,4 +16,3 @@ void test_vreinterpretQu32_s16 (void)
   out_uint32x4_t = vreinterpretq_u32_s16 (arg0_int16x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_s32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_s32.c
@@ -16,4 +16,3 @@ void test_vreinterpretQu32_s32 (void)
   out_uint32x4_t = vreinterpretq_u32_s32 (arg0_int32x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_s64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_s64.c
@@ -16,4 +16,3 @@ void test_vreinterpretQu32_s64 (void)
   out_uint32x4_t = vreinterpretq_u32_s64 (arg0_int64x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_s8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_s8.c
@@ -16,4 +16,3 @@ void test_vreinterpretQu32_s8 (void)
   out_uint32x4_t = vreinterpretq_u32_s8 (arg0_int8x16_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_u16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_u16.c
@@ -16,4 +16,3 @@ void test_vreinterpretQu32_u16 (void)
   out_uint32x4_t = vreinterpretq_u32_u16 (arg0_uint16x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_u64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_u64.c
@@ -16,4 +16,3 @@ void test_vreinterpretQu32_u64 (void)
   out_uint32x4_t = vreinterpretq_u32_u64 (arg0_uint64x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_u8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_u8.c
@@ -16,4 +16,3 @@ void test_vreinterpretQu32_u8 (void)
   out_uint32x4_t = vreinterpretq_u32_u8 (arg0_uint8x16_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_f32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_f32.c
@@ -16,4 +16,3 @@ void test_vreinterpretQu64_f32 (void)
   out_uint64x2_t = vreinterpretq_u64_f32 (arg0_float32x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_p128.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_p128.c
@@ -16,4 +16,3 @@ void test_vreinterpretQu64_p128 (void)
   out_uint64x2_t = vreinterpretq_u64_p128 (arg0_poly128_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_p16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_p16.c
@@ -16,4 +16,3 @@ void test_vreinterpretQu64_p16 (void)
   out_uint64x2_t = vreinterpretq_u64_p16 (arg0_poly16x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_p64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_p64.c
@@ -16,4 +16,3 @@ void test_vreinterpretQu64_p64 (void)
   out_uint64x2_t = vreinterpretq_u64_p64 (arg0_poly64x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_p8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_p8.c
@@ -16,4 +16,3 @@ void test_vreinterpretQu64_p8 (void)
   out_uint64x2_t = vreinterpretq_u64_p8 (arg0_poly8x16_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_s16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_s16.c
@@ -16,4 +16,3 @@ void test_vreinterpretQu64_s16 (void)
   out_uint64x2_t = vreinterpretq_u64_s16 (arg0_int16x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_s32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_s32.c
@@ -16,4 +16,3 @@ void test_vreinterpretQu64_s32 (void)
   out_uint64x2_t = vreinterpretq_u64_s32 (arg0_int32x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_s64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_s64.c
@@ -16,4 +16,3 @@ void test_vreinterpretQu64_s64 (void)
   out_uint64x2_t = vreinterpretq_u64_s64 (arg0_int64x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_s8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_s8.c
@@ -16,4 +16,3 @@ void test_vreinterpretQu64_s8 (void)
   out_uint64x2_t = vreinterpretq_u64_s8 (arg0_int8x16_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_u16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_u16.c
@@ -16,4 +16,3 @@ void test_vreinterpretQu64_u16 (void)
   out_uint64x2_t = vreinterpretq_u64_u16 (arg0_uint16x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_u32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_u32.c
@@ -16,4 +16,3 @@ void test_vreinterpretQu64_u32 (void)
   out_uint64x2_t = vreinterpretq_u64_u32 (arg0_uint32x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_u8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_u8.c
@@ -16,4 +16,3 @@ void test_vreinterpretQu64_u8 (void)
   out_uint64x2_t = vreinterpretq_u64_u8 (arg0_uint8x16_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_f32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_f32.c
@@ -16,4 +16,3 @@ void test_vreinterpretQu8_f32 (void)
   out_uint8x16_t = vreinterpretq_u8_f32 (arg0_float32x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_p128.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_p128.c
@@ -16,4 +16,3 @@ void test_vreinterpretQu8_p128 (void)
   out_uint8x16_t = vreinterpretq_u8_p128 (arg0_poly128_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_p16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_p16.c
@@ -16,4 +16,3 @@ void test_vreinterpretQu8_p16 (void)
   out_uint8x16_t = vreinterpretq_u8_p16 (arg0_poly16x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_p64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_p64.c
@@ -16,4 +16,3 @@ void test_vreinterpretQu8_p64 (void)
   out_uint8x16_t = vreinterpretq_u8_p64 (arg0_poly64x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_p8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_p8.c
@@ -16,4 +16,3 @@ void test_vreinterpretQu8_p8 (void)
   out_uint8x16_t = vreinterpretq_u8_p8 (arg0_poly8x16_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_s16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_s16.c
@@ -16,4 +16,3 @@ void test_vreinterpretQu8_s16 (void)
   out_uint8x16_t = vreinterpretq_u8_s16 (arg0_int16x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_s32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_s32.c
@@ -16,4 +16,3 @@ void test_vreinterpretQu8_s32 (void)
   out_uint8x16_t = vreinterpretq_u8_s32 (arg0_int32x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_s64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_s64.c
@@ -16,4 +16,3 @@ void test_vreinterpretQu8_s64 (void)
   out_uint8x16_t = vreinterpretq_u8_s64 (arg0_int64x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_s8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_s8.c
@@ -16,4 +16,3 @@ void test_vreinterpretQu8_s8 (void)
   out_uint8x16_t = vreinterpretq_u8_s8 (arg0_int8x16_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_u16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_u16.c
@@ -16,4 +16,3 @@ void test_vreinterpretQu8_u16 (void)
   out_uint8x16_t = vreinterpretq_u8_u16 (arg0_uint16x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_u32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_u32.c
@@ -16,4 +16,3 @@ void test_vreinterpretQu8_u32 (void)
   out_uint8x16_t = vreinterpretq_u8_u32 (arg0_uint32x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_u64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_u64.c
@@ -16,4 +16,3 @@ void test_vreinterpretQu8_u64 (void)
   out_uint8x16_t = vreinterpretq_u8_u64 (arg0_uint64x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_p16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_p16.c
@@ -16,4 +16,3 @@ void test_vreinterpretf32_p16 (void)
   out_float32x2_t = vreinterpret_f32_p16 (arg0_poly16x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_p64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_p64.c
@@ -16,4 +16,3 @@ void test_vreinterpretf32_p64 (void)
   out_float32x2_t = vreinterpret_f32_p64 (arg0_poly64x1_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_p8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_p8.c
@@ -16,4 +16,3 @@ void test_vreinterpretf32_p8 (void)
   out_float32x2_t = vreinterpret_f32_p8 (arg0_poly8x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_s16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_s16.c
@@ -16,4 +16,3 @@ void test_vreinterpretf32_s16 (void)
   out_float32x2_t = vreinterpret_f32_s16 (arg0_int16x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_s32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_s32.c
@@ -16,4 +16,3 @@ void test_vreinterpretf32_s32 (void)
   out_float32x2_t = vreinterpret_f32_s32 (arg0_int32x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_s64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_s64.c
@@ -16,4 +16,3 @@ void test_vreinterpretf32_s64 (void)
   out_float32x2_t = vreinterpret_f32_s64 (arg0_int64x1_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_s8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_s8.c
@@ -16,4 +16,3 @@ void test_vreinterpretf32_s8 (void)
   out_float32x2_t = vreinterpret_f32_s8 (arg0_int8x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_u16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_u16.c
@@ -16,4 +16,3 @@ void test_vreinterpretf32_u16 (void)
   out_float32x2_t = vreinterpret_f32_u16 (arg0_uint16x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_u32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_u32.c
@@ -16,4 +16,3 @@ void test_vreinterpretf32_u32 (void)
   out_float32x2_t = vreinterpret_f32_u32 (arg0_uint32x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_u64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_u64.c
@@ -16,4 +16,3 @@ void test_vreinterpretf32_u64 (void)
   out_float32x2_t = vreinterpret_f32_u64 (arg0_uint64x1_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_u8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_u8.c
@@ -16,4 +16,3 @@ void test_vreinterpretf32_u8 (void)
   out_float32x2_t = vreinterpret_f32_u8 (arg0_uint8x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_f32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_f32.c
@@ -16,4 +16,3 @@ void test_vreinterpretp16_f32 (void)
   out_poly16x4_t = vreinterpret_p16_f32 (arg0_float32x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_p64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_p64.c
@@ -16,4 +16,3 @@ void test_vreinterpretp16_p64 (void)
   out_poly16x4_t = vreinterpret_p16_p64 (arg0_poly64x1_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_p8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_p8.c
@@ -16,4 +16,3 @@ void test_vreinterpretp16_p8 (void)
   out_poly16x4_t = vreinterpret_p16_p8 (arg0_poly8x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_s16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_s16.c
@@ -16,4 +16,3 @@ void test_vreinterpretp16_s16 (void)
   out_poly16x4_t = vreinterpret_p16_s16 (arg0_int16x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_s32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_s32.c
@@ -16,4 +16,3 @@ void test_vreinterpretp16_s32 (void)
   out_poly16x4_t = vreinterpret_p16_s32 (arg0_int32x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_s64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_s64.c
@@ -16,4 +16,3 @@ void test_vreinterpretp16_s64 (void)
   out_poly16x4_t = vreinterpret_p16_s64 (arg0_int64x1_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_s8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_s8.c
@@ -16,4 +16,3 @@ void test_vreinterpretp16_s8 (void)
   out_poly16x4_t = vreinterpret_p16_s8 (arg0_int8x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_u16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_u16.c
@@ -16,4 +16,3 @@ void test_vreinterpretp16_u16 (void)
   out_poly16x4_t = vreinterpret_p16_u16 (arg0_uint16x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_u32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_u32.c
@@ -16,4 +16,3 @@ void test_vreinterpretp16_u32 (void)
   out_poly16x4_t = vreinterpret_p16_u32 (arg0_uint32x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_u64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_u64.c
@@ -16,4 +16,3 @@ void test_vreinterpretp16_u64 (void)
   out_poly16x4_t = vreinterpret_p16_u64 (arg0_uint64x1_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_u8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_u8.c
@@ -16,4 +16,3 @@ void test_vreinterpretp16_u8 (void)
   out_poly16x4_t = vreinterpret_p16_u8 (arg0_uint8x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp64_f32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp64_f32.c
@@ -16,4 +16,3 @@ void test_vreinterpretp64_f32 (void)
   out_poly64x1_t = vreinterpret_p64_f32 (arg0_float32x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp64_p16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp64_p16.c
@@ -16,4 +16,3 @@ void test_vreinterpretp64_p16 (void)
   out_poly64x1_t = vreinterpret_p64_p16 (arg0_poly16x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp64_p8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp64_p8.c
@@ -16,4 +16,3 @@ void test_vreinterpretp64_p8 (void)
   out_poly64x1_t = vreinterpret_p64_p8 (arg0_poly8x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp64_s16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp64_s16.c
@@ -16,4 +16,3 @@ void test_vreinterpretp64_s16 (void)
   out_poly64x1_t = vreinterpret_p64_s16 (arg0_int16x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp64_s32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp64_s32.c
@@ -16,4 +16,3 @@ void test_vreinterpretp64_s32 (void)
   out_poly64x1_t = vreinterpret_p64_s32 (arg0_int32x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp64_s64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp64_s64.c
@@ -16,4 +16,3 @@ void test_vreinterpretp64_s64 (void)
   out_poly64x1_t = vreinterpret_p64_s64 (arg0_int64x1_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp64_s8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp64_s8.c
@@ -16,4 +16,3 @@ void test_vreinterpretp64_s8 (void)
   out_poly64x1_t = vreinterpret_p64_s8 (arg0_int8x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp64_u16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp64_u16.c
@@ -16,4 +16,3 @@ void test_vreinterpretp64_u16 (void)
   out_poly64x1_t = vreinterpret_p64_u16 (arg0_uint16x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp64_u32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp64_u32.c
@@ -16,4 +16,3 @@ void test_vreinterpretp64_u32 (void)
   out_poly64x1_t = vreinterpret_p64_u32 (arg0_uint32x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp64_u64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp64_u64.c
@@ -16,4 +16,3 @@ void test_vreinterpretp64_u64 (void)
   out_poly64x1_t = vreinterpret_p64_u64 (arg0_uint64x1_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp64_u8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp64_u8.c
@@ -16,4 +16,3 @@ void test_vreinterpretp64_u8 (void)
   out_poly64x1_t = vreinterpret_p64_u8 (arg0_uint8x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_f32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_f32.c
@@ -16,4 +16,3 @@ void test_vreinterpretp8_f32 (void)
   out_poly8x8_t = vreinterpret_p8_f32 (arg0_float32x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_p16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_p16.c
@@ -16,4 +16,3 @@ void test_vreinterpretp8_p16 (void)
   out_poly8x8_t = vreinterpret_p8_p16 (arg0_poly16x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_p64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_p64.c
@@ -16,4 +16,3 @@ void test_vreinterpretp8_p64 (void)
   out_poly8x8_t = vreinterpret_p8_p64 (arg0_poly64x1_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_s16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_s16.c
@@ -16,4 +16,3 @@ void test_vreinterpretp8_s16 (void)
   out_poly8x8_t = vreinterpret_p8_s16 (arg0_int16x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_s32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_s32.c
@@ -16,4 +16,3 @@ void test_vreinterpretp8_s32 (void)
   out_poly8x8_t = vreinterpret_p8_s32 (arg0_int32x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_s64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_s64.c
@@ -16,4 +16,3 @@ void test_vreinterpretp8_s64 (void)
   out_poly8x8_t = vreinterpret_p8_s64 (arg0_int64x1_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_s8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_s8.c
@@ -16,4 +16,3 @@ void test_vreinterpretp8_s8 (void)
   out_poly8x8_t = vreinterpret_p8_s8 (arg0_int8x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_u16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_u16.c
@@ -16,4 +16,3 @@ void test_vreinterpretp8_u16 (void)
   out_poly8x8_t = vreinterpret_p8_u16 (arg0_uint16x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_u32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_u32.c
@@ -16,4 +16,3 @@ void test_vreinterpretp8_u32 (void)
   out_poly8x8_t = vreinterpret_p8_u32 (arg0_uint32x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_u64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_u64.c
@@ -16,4 +16,3 @@ void test_vreinterpretp8_u64 (void)
   out_poly8x8_t = vreinterpret_p8_u64 (arg0_uint64x1_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_u8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_u8.c
@@ -16,4 +16,3 @@ void test_vreinterpretp8_u8 (void)
   out_poly8x8_t = vreinterpret_p8_u8 (arg0_uint8x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_f32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_f32.c
@@ -16,4 +16,3 @@ void test_vreinterprets16_f32 (void)
   out_int16x4_t = vreinterpret_s16_f32 (arg0_float32x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_p16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_p16.c
@@ -16,4 +16,3 @@ void test_vreinterprets16_p16 (void)
   out_int16x4_t = vreinterpret_s16_p16 (arg0_poly16x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_p64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_p64.c
@@ -16,4 +16,3 @@ void test_vreinterprets16_p64 (void)
   out_int16x4_t = vreinterpret_s16_p64 (arg0_poly64x1_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_p8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_p8.c
@@ -16,4 +16,3 @@ void test_vreinterprets16_p8 (void)
   out_int16x4_t = vreinterpret_s16_p8 (arg0_poly8x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_s32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_s32.c
@@ -16,4 +16,3 @@ void test_vreinterprets16_s32 (void)
   out_int16x4_t = vreinterpret_s16_s32 (arg0_int32x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_s64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_s64.c
@@ -16,4 +16,3 @@ void test_vreinterprets16_s64 (void)
   out_int16x4_t = vreinterpret_s16_s64 (arg0_int64x1_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_s8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_s8.c
@@ -16,4 +16,3 @@ void test_vreinterprets16_s8 (void)
   out_int16x4_t = vreinterpret_s16_s8 (arg0_int8x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_u16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_u16.c
@@ -16,4 +16,3 @@ void test_vreinterprets16_u16 (void)
   out_int16x4_t = vreinterpret_s16_u16 (arg0_uint16x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_u32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_u32.c
@@ -16,4 +16,3 @@ void test_vreinterprets16_u32 (void)
   out_int16x4_t = vreinterpret_s16_u32 (arg0_uint32x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_u64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_u64.c
@@ -16,4 +16,3 @@ void test_vreinterprets16_u64 (void)
   out_int16x4_t = vreinterpret_s16_u64 (arg0_uint64x1_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_u8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_u8.c
@@ -16,4 +16,3 @@ void test_vreinterprets16_u8 (void)
   out_int16x4_t = vreinterpret_s16_u8 (arg0_uint8x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_f32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_f32.c
@@ -16,4 +16,3 @@ void test_vreinterprets32_f32 (void)
   out_int32x2_t = vreinterpret_s32_f32 (arg0_float32x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_p16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_p16.c
@@ -16,4 +16,3 @@ void test_vreinterprets32_p16 (void)
   out_int32x2_t = vreinterpret_s32_p16 (arg0_poly16x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_p64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_p64.c
@@ -16,4 +16,3 @@ void test_vreinterprets32_p64 (void)
   out_int32x2_t = vreinterpret_s32_p64 (arg0_poly64x1_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_p8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_p8.c
@@ -16,4 +16,3 @@ void test_vreinterprets32_p8 (void)
   out_int32x2_t = vreinterpret_s32_p8 (arg0_poly8x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_s16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_s16.c
@@ -16,4 +16,3 @@ void test_vreinterprets32_s16 (void)
   out_int32x2_t = vreinterpret_s32_s16 (arg0_int16x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_s64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_s64.c
@@ -16,4 +16,3 @@ void test_vreinterprets32_s64 (void)
   out_int32x2_t = vreinterpret_s32_s64 (arg0_int64x1_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_s8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_s8.c
@@ -16,4 +16,3 @@ void test_vreinterprets32_s8 (void)
   out_int32x2_t = vreinterpret_s32_s8 (arg0_int8x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_u16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_u16.c
@@ -16,4 +16,3 @@ void test_vreinterprets32_u16 (void)
   out_int32x2_t = vreinterpret_s32_u16 (arg0_uint16x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_u32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_u32.c
@@ -16,4 +16,3 @@ void test_vreinterprets32_u32 (void)
   out_int32x2_t = vreinterpret_s32_u32 (arg0_uint32x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_u64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_u64.c
@@ -16,4 +16,3 @@ void test_vreinterprets32_u64 (void)
   out_int32x2_t = vreinterpret_s32_u64 (arg0_uint64x1_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_u8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_u8.c
@@ -16,4 +16,3 @@ void test_vreinterprets32_u8 (void)
   out_int32x2_t = vreinterpret_s32_u8 (arg0_uint8x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_f32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_f32.c
@@ -16,4 +16,3 @@ void test_vreinterprets64_f32 (void)
   out_int64x1_t = vreinterpret_s64_f32 (arg0_float32x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_p16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_p16.c
@@ -16,4 +16,3 @@ void test_vreinterprets64_p16 (void)
   out_int64x1_t = vreinterpret_s64_p16 (arg0_poly16x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_p64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_p64.c
@@ -16,4 +16,3 @@ void test_vreinterprets64_p64 (void)
   out_int64x1_t = vreinterpret_s64_p64 (arg0_poly64x1_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_p8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_p8.c
@@ -16,4 +16,3 @@ void test_vreinterprets64_p8 (void)
   out_int64x1_t = vreinterpret_s64_p8 (arg0_poly8x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_s16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_s16.c
@@ -16,4 +16,3 @@ void test_vreinterprets64_s16 (void)
   out_int64x1_t = vreinterpret_s64_s16 (arg0_int16x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_s32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_s32.c
@@ -16,4 +16,3 @@ void test_vreinterprets64_s32 (void)
   out_int64x1_t = vreinterpret_s64_s32 (arg0_int32x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_s8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_s8.c
@@ -16,4 +16,3 @@ void test_vreinterprets64_s8 (void)
   out_int64x1_t = vreinterpret_s64_s8 (arg0_int8x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_u16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_u16.c
@@ -16,4 +16,3 @@ void test_vreinterprets64_u16 (void)
   out_int64x1_t = vreinterpret_s64_u16 (arg0_uint16x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_u32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_u32.c
@@ -16,4 +16,3 @@ void test_vreinterprets64_u32 (void)
   out_int64x1_t = vreinterpret_s64_u32 (arg0_uint32x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_u64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_u64.c
@@ -16,4 +16,3 @@ void test_vreinterprets64_u64 (void)
   out_int64x1_t = vreinterpret_s64_u64 (arg0_uint64x1_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_u8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_u8.c
@@ -16,4 +16,3 @@ void test_vreinterprets64_u8 (void)
   out_int64x1_t = vreinterpret_s64_u8 (arg0_uint8x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_f32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_f32.c
@@ -16,4 +16,3 @@ void test_vreinterprets8_f32 (void)
   out_int8x8_t = vreinterpret_s8_f32 (arg0_float32x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_p16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_p16.c
@@ -16,4 +16,3 @@ void test_vreinterprets8_p16 (void)
   out_int8x8_t = vreinterpret_s8_p16 (arg0_poly16x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_p64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_p64.c
@@ -16,4 +16,3 @@ void test_vreinterprets8_p64 (void)
   out_int8x8_t = vreinterpret_s8_p64 (arg0_poly64x1_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_p8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_p8.c
@@ -16,4 +16,3 @@ void test_vreinterprets8_p8 (void)
   out_int8x8_t = vreinterpret_s8_p8 (arg0_poly8x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_s16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_s16.c
@@ -16,4 +16,3 @@ void test_vreinterprets8_s16 (void)
   out_int8x8_t = vreinterpret_s8_s16 (arg0_int16x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_s32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_s32.c
@@ -16,4 +16,3 @@ void test_vreinterprets8_s32 (void)
   out_int8x8_t = vreinterpret_s8_s32 (arg0_int32x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_s64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_s64.c
@@ -16,4 +16,3 @@ void test_vreinterprets8_s64 (void)
   out_int8x8_t = vreinterpret_s8_s64 (arg0_int64x1_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_u16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_u16.c
@@ -16,4 +16,3 @@ void test_vreinterprets8_u16 (void)
   out_int8x8_t = vreinterpret_s8_u16 (arg0_uint16x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_u32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_u32.c
@@ -16,4 +16,3 @@ void test_vreinterprets8_u32 (void)
   out_int8x8_t = vreinterpret_s8_u32 (arg0_uint32x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_u64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_u64.c
@@ -16,4 +16,3 @@ void test_vreinterprets8_u64 (void)
   out_int8x8_t = vreinterpret_s8_u64 (arg0_uint64x1_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_u8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_u8.c
@@ -16,4 +16,3 @@ void test_vreinterprets8_u8 (void)
   out_int8x8_t = vreinterpret_s8_u8 (arg0_uint8x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_f32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_f32.c
@@ -16,4 +16,3 @@ void test_vreinterpretu16_f32 (void)
   out_uint16x4_t = vreinterpret_u16_f32 (arg0_float32x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_p16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_p16.c
@@ -16,4 +16,3 @@ void test_vreinterpretu16_p16 (void)
   out_uint16x4_t = vreinterpret_u16_p16 (arg0_poly16x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_p64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_p64.c
@@ -16,4 +16,3 @@ void test_vreinterpretu16_p64 (void)
   out_uint16x4_t = vreinterpret_u16_p64 (arg0_poly64x1_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_p8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_p8.c
@@ -16,4 +16,3 @@ void test_vreinterpretu16_p8 (void)
   out_uint16x4_t = vreinterpret_u16_p8 (arg0_poly8x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_s16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_s16.c
@@ -16,4 +16,3 @@ void test_vreinterpretu16_s16 (void)
   out_uint16x4_t = vreinterpret_u16_s16 (arg0_int16x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_s32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_s32.c
@@ -16,4 +16,3 @@ void test_vreinterpretu16_s32 (void)
   out_uint16x4_t = vreinterpret_u16_s32 (arg0_int32x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_s64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_s64.c
@@ -16,4 +16,3 @@ void test_vreinterpretu16_s64 (void)
   out_uint16x4_t = vreinterpret_u16_s64 (arg0_int64x1_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_s8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_s8.c
@@ -16,4 +16,3 @@ void test_vreinterpretu16_s8 (void)
   out_uint16x4_t = vreinterpret_u16_s8 (arg0_int8x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_u32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_u32.c
@@ -16,4 +16,3 @@ void test_vreinterpretu16_u32 (void)
   out_uint16x4_t = vreinterpret_u16_u32 (arg0_uint32x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_u64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_u64.c
@@ -16,4 +16,3 @@ void test_vreinterpretu16_u64 (void)
   out_uint16x4_t = vreinterpret_u16_u64 (arg0_uint64x1_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_u8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_u8.c
@@ -16,4 +16,3 @@ void test_vreinterpretu16_u8 (void)
   out_uint16x4_t = vreinterpret_u16_u8 (arg0_uint8x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_f32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_f32.c
@@ -16,4 +16,3 @@ void test_vreinterpretu32_f32 (void)
   out_uint32x2_t = vreinterpret_u32_f32 (arg0_float32x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_p16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_p16.c
@@ -16,4 +16,3 @@ void test_vreinterpretu32_p16 (void)
   out_uint32x2_t = vreinterpret_u32_p16 (arg0_poly16x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_p64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_p64.c
@@ -16,4 +16,3 @@ void test_vreinterpretu32_p64 (void)
   out_uint32x2_t = vreinterpret_u32_p64 (arg0_poly64x1_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_p8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_p8.c
@@ -16,4 +16,3 @@ void test_vreinterpretu32_p8 (void)
   out_uint32x2_t = vreinterpret_u32_p8 (arg0_poly8x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_s16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_s16.c
@@ -16,4 +16,3 @@ void test_vreinterpretu32_s16 (void)
   out_uint32x2_t = vreinterpret_u32_s16 (arg0_int16x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_s32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_s32.c
@@ -16,4 +16,3 @@ void test_vreinterpretu32_s32 (void)
   out_uint32x2_t = vreinterpret_u32_s32 (arg0_int32x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_s64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_s64.c
@@ -16,4 +16,3 @@ void test_vreinterpretu32_s64 (void)
   out_uint32x2_t = vreinterpret_u32_s64 (arg0_int64x1_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_s8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_s8.c
@@ -16,4 +16,3 @@ void test_vreinterpretu32_s8 (void)
   out_uint32x2_t = vreinterpret_u32_s8 (arg0_int8x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_u16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_u16.c
@@ -16,4 +16,3 @@ void test_vreinterpretu32_u16 (void)
   out_uint32x2_t = vreinterpret_u32_u16 (arg0_uint16x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_u64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_u64.c
@@ -16,4 +16,3 @@ void test_vreinterpretu32_u64 (void)
   out_uint32x2_t = vreinterpret_u32_u64 (arg0_uint64x1_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_u8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_u8.c
@@ -16,4 +16,3 @@ void test_vreinterpretu32_u8 (void)
   out_uint32x2_t = vreinterpret_u32_u8 (arg0_uint8x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_f32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_f32.c
@@ -16,4 +16,3 @@ void test_vreinterpretu64_f32 (void)
   out_uint64x1_t = vreinterpret_u64_f32 (arg0_float32x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_p16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_p16.c
@@ -16,4 +16,3 @@ void test_vreinterpretu64_p16 (void)
   out_uint64x1_t = vreinterpret_u64_p16 (arg0_poly16x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_p64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_p64.c
@@ -16,4 +16,3 @@ void test_vreinterpretu64_p64 (void)
   out_uint64x1_t = vreinterpret_u64_p64 (arg0_poly64x1_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_p8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_p8.c
@@ -16,4 +16,3 @@ void test_vreinterpretu64_p8 (void)
   out_uint64x1_t = vreinterpret_u64_p8 (arg0_poly8x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_s16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_s16.c
@@ -16,4 +16,3 @@ void test_vreinterpretu64_s16 (void)
   out_uint64x1_t = vreinterpret_u64_s16 (arg0_int16x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_s32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_s32.c
@@ -16,4 +16,3 @@ void test_vreinterpretu64_s32 (void)
   out_uint64x1_t = vreinterpret_u64_s32 (arg0_int32x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_s64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_s64.c
@@ -16,4 +16,3 @@ void test_vreinterpretu64_s64 (void)
   out_uint64x1_t = vreinterpret_u64_s64 (arg0_int64x1_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_s8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_s8.c
@@ -16,4 +16,3 @@ void test_vreinterpretu64_s8 (void)
   out_uint64x1_t = vreinterpret_u64_s8 (arg0_int8x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_u16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_u16.c
@@ -16,4 +16,3 @@ void test_vreinterpretu64_u16 (void)
   out_uint64x1_t = vreinterpret_u64_u16 (arg0_uint16x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_u32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_u32.c
@@ -16,4 +16,3 @@ void test_vreinterpretu64_u32 (void)
   out_uint64x1_t = vreinterpret_u64_u32 (arg0_uint32x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_u8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_u8.c
@@ -16,4 +16,3 @@ void test_vreinterpretu64_u8 (void)
   out_uint64x1_t = vreinterpret_u64_u8 (arg0_uint8x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_f32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_f32.c
@@ -16,4 +16,3 @@ void test_vreinterpretu8_f32 (void)
   out_uint8x8_t = vreinterpret_u8_f32 (arg0_float32x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_p16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_p16.c
@@ -16,4 +16,3 @@ void test_vreinterpretu8_p16 (void)
   out_uint8x8_t = vreinterpret_u8_p16 (arg0_poly16x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_p64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_p64.c
@@ -16,4 +16,3 @@ void test_vreinterpretu8_p64 (void)
   out_uint8x8_t = vreinterpret_u8_p64 (arg0_poly64x1_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_p8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_p8.c
@@ -16,4 +16,3 @@ void test_vreinterpretu8_p8 (void)
   out_uint8x8_t = vreinterpret_u8_p8 (arg0_poly8x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_s16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_s16.c
@@ -16,4 +16,3 @@ void test_vreinterpretu8_s16 (void)
   out_uint8x8_t = vreinterpret_u8_s16 (arg0_int16x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_s32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_s32.c
@@ -16,4 +16,3 @@ void test_vreinterpretu8_s32 (void)
   out_uint8x8_t = vreinterpret_u8_s32 (arg0_int32x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_s64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_s64.c
@@ -16,4 +16,3 @@ void test_vreinterpretu8_s64 (void)
   out_uint8x8_t = vreinterpret_u8_s64 (arg0_int64x1_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_s8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_s8.c
@@ -16,4 +16,3 @@ void test_vreinterpretu8_s8 (void)
   out_uint8x8_t = vreinterpret_u8_s8 (arg0_int8x8_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_u16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_u16.c
@@ -16,4 +16,3 @@ void test_vreinterpretu8_u16 (void)
   out_uint8x8_t = vreinterpret_u8_u16 (arg0_uint16x4_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_u32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_u32.c
@@ -16,4 +16,3 @@ void test_vreinterpretu8_u32 (void)
   out_uint8x8_t = vreinterpret_u8_u32 (arg0_uint32x2_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_u64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_u64.c
@@ -16,4 +16,3 @@ void test_vreinterpretu8_u64 (void)
   out_uint8x8_t = vreinterpret_u8_u64 (arg0_uint64x1_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrev16Qp8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrev16Qp8.c
@@ -17,4 +17,3 @@ void test_vrev16Qp8 (void)
 }
 
 /* { dg-final { scan-assembler "vrev16\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrev16Qs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrev16Qs8.c
@@ -17,4 +17,3 @@ void test_vrev16Qs8 (void)
 }
 
 /* { dg-final { scan-assembler "vrev16\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrev16Qu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrev16Qu8.c
@@ -17,4 +17,3 @@ void test_vrev16Qu8 (void)
 }
 
 /* { dg-final { scan-assembler "vrev16\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrev16p8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrev16p8.c
@@ -17,4 +17,3 @@ void test_vrev16p8 (void)
 }
 
 /* { dg-final { scan-assembler "vrev16\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrev16s8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrev16s8.c
@@ -17,4 +17,3 @@ void test_vrev16s8 (void)
 }
 
 /* { dg-final { scan-assembler "vrev16\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrev16u8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrev16u8.c
@@ -17,4 +17,3 @@ void test_vrev16u8 (void)
 }
 
 /* { dg-final { scan-assembler "vrev16\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrev32Qp16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrev32Qp16.c
@@ -17,4 +17,3 @@ void test_vrev32Qp16 (void)
 }
 
 /* { dg-final { scan-assembler "vrev32\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrev32Qp8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrev32Qp8.c
@@ -17,4 +17,3 @@ void test_vrev32Qp8 (void)
 }
 
 /* { dg-final { scan-assembler "vrev32\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrev32Qs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrev32Qs16.c
@@ -17,4 +17,3 @@ void test_vrev32Qs16 (void)
 }
 
 /* { dg-final { scan-assembler "vrev32\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrev32Qs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrev32Qs8.c
@@ -17,4 +17,3 @@ void test_vrev32Qs8 (void)
 }
 
 /* { dg-final { scan-assembler "vrev32\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrev32Qu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrev32Qu16.c
@@ -17,4 +17,3 @@ void test_vrev32Qu16 (void)
 }
 
 /* { dg-final { scan-assembler "vrev32\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrev32Qu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrev32Qu8.c
@@ -17,4 +17,3 @@ void test_vrev32Qu8 (void)
 }
 
 /* { dg-final { scan-assembler "vrev32\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrev32p16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrev32p16.c
@@ -17,4 +17,3 @@ void test_vrev32p16 (void)
 }
 
 /* { dg-final { scan-assembler "vrev32\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrev32p8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrev32p8.c
@@ -17,4 +17,3 @@ void test_vrev32p8 (void)
 }
 
 /* { dg-final { scan-assembler "vrev32\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrev32s16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrev32s16.c
@@ -17,4 +17,3 @@ void test_vrev32s16 (void)
 }
 
 /* { dg-final { scan-assembler "vrev32\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrev32s8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrev32s8.c
@@ -17,4 +17,3 @@ void test_vrev32s8 (void)
 }
 
 /* { dg-final { scan-assembler "vrev32\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrev32u16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrev32u16.c
@@ -17,4 +17,3 @@ void test_vrev32u16 (void)
 }
 
 /* { dg-final { scan-assembler "vrev32\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrev32u8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrev32u8.c
@@ -17,4 +17,3 @@ void test_vrev32u8 (void)
 }
 
 /* { dg-final { scan-assembler "vrev32\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrev64Qf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrev64Qf32.c
@@ -17,4 +17,3 @@ void test_vrev64Qf32 (void)
 }
 
 /* { dg-final { scan-assembler "vrev64\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrev64Qp16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrev64Qp16.c
@@ -17,4 +17,3 @@ void test_vrev64Qp16 (void)
 }
 
 /* { dg-final { scan-assembler "vrev64\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrev64Qp8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrev64Qp8.c
@@ -17,4 +17,3 @@ void test_vrev64Qp8 (void)
 }
 
 /* { dg-final { scan-assembler "vrev64\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrev64Qs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrev64Qs16.c
@@ -17,4 +17,3 @@ void test_vrev64Qs16 (void)
 }
 
 /* { dg-final { scan-assembler "vrev64\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrev64Qs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrev64Qs32.c
@@ -17,4 +17,3 @@ void test_vrev64Qs32 (void)
 }
 
 /* { dg-final { scan-assembler "vrev64\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrev64Qs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrev64Qs8.c
@@ -17,4 +17,3 @@ void test_vrev64Qs8 (void)
 }
 
 /* { dg-final { scan-assembler "vrev64\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrev64Qu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrev64Qu16.c
@@ -17,4 +17,3 @@ void test_vrev64Qu16 (void)
 }
 
 /* { dg-final { scan-assembler "vrev64\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrev64Qu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrev64Qu32.c
@@ -17,4 +17,3 @@ void test_vrev64Qu32 (void)
 }
 
 /* { dg-final { scan-assembler "vrev64\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrev64Qu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrev64Qu8.c
@@ -17,4 +17,3 @@ void test_vrev64Qu8 (void)
 }
 
 /* { dg-final { scan-assembler "vrev64\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrev64f32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrev64f32.c
@@ -17,4 +17,3 @@ void test_vrev64f32 (void)
 }
 
 /* { dg-final { scan-assembler "vrev64\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrev64p16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrev64p16.c
@@ -17,4 +17,3 @@ void test_vrev64p16 (void)
 }
 
 /* { dg-final { scan-assembler "vrev64\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrev64p8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrev64p8.c
@@ -17,4 +17,3 @@ void test_vrev64p8 (void)
 }
 
 /* { dg-final { scan-assembler "vrev64\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrev64s16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrev64s16.c
@@ -17,4 +17,3 @@ void test_vrev64s16 (void)
 }
 
 /* { dg-final { scan-assembler "vrev64\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrev64s32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrev64s32.c
@@ -17,4 +17,3 @@ void test_vrev64s32 (void)
 }
 
 /* { dg-final { scan-assembler "vrev64\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrev64s8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrev64s8.c
@@ -17,4 +17,3 @@ void test_vrev64s8 (void)
 }
 
 /* { dg-final { scan-assembler "vrev64\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrev64u16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrev64u16.c
@@ -17,4 +17,3 @@ void test_vrev64u16 (void)
 }
 
 /* { dg-final { scan-assembler "vrev64\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrev64u32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrev64u32.c
@@ -17,4 +17,3 @@ void test_vrev64u32 (void)
 }
 
 /* { dg-final { scan-assembler "vrev64\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrev64u8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrev64u8.c
@@ -17,4 +17,3 @@ void test_vrev64u8 (void)
 }
 
 /* { dg-final { scan-assembler "vrev64\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrndaf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrndaf32.c
@@ -17,4 +17,3 @@ void test_vrndaf32 (void)
 }
 
 /* { dg-final { scan-assembler "vrinta\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrndaqf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrndaqf32.c
@@ -17,4 +17,3 @@ void test_vrndaqf32 (void)
 }
 
 /* { dg-final { scan-assembler "vrinta\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrndf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrndf32.c
@@ -17,4 +17,3 @@ void test_vrndf32 (void)
 }
 
 /* { dg-final { scan-assembler "vrintz\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrndmf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrndmf32.c
@@ -17,4 +17,3 @@ void test_vrndmf32 (void)
 }
 
 /* { dg-final { scan-assembler "vrintm\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrndmqf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrndmqf32.c
@@ -17,4 +17,3 @@ void test_vrndmqf32 (void)
 }
 
 /* { dg-final { scan-assembler "vrintm\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrndnf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrndnf32.c
@@ -17,4 +17,3 @@ void test_vrndnf32 (void)
 }
 
 /* { dg-final { scan-assembler "vrintn\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrndnqf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrndnqf32.c
@@ -17,4 +17,3 @@ void test_vrndnqf32 (void)
 }
 
 /* { dg-final { scan-assembler "vrintn\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrndpf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrndpf32.c
@@ -17,4 +17,3 @@ void test_vrndpf32 (void)
 }
 
 /* { dg-final { scan-assembler "vrintp\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrndpqf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrndpqf32.c
@@ -17,4 +17,3 @@ void test_vrndpqf32 (void)
 }
 
 /* { dg-final { scan-assembler "vrintp\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrndqf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrndqf32.c
@@ -17,4 +17,3 @@ void test_vrndqf32 (void)
 }
 
 /* { dg-final { scan-assembler "vrintz\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrsqrteQf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrsqrteQf32.c
@@ -17,4 +17,3 @@ void test_vrsqrteQf32 (void)
 }
 
 /* { dg-final { scan-assembler "vrsqrte\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrsqrteQu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrsqrteQu32.c
@@ -17,4 +17,3 @@ void test_vrsqrteQu32 (void)
 }
 
 /* { dg-final { scan-assembler "vrsqrte\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrsqrtef32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrsqrtef32.c
@@ -17,4 +17,3 @@ void test_vrsqrtef32 (void)
 }
 
 /* { dg-final { scan-assembler "vrsqrte\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrsqrteu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrsqrteu32.c
@@ -17,4 +17,3 @@ void test_vrsqrteu32 (void)
 }
 
 /* { dg-final { scan-assembler "vrsqrte\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrsqrtsQf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrsqrtsQf32.c
@@ -18,4 +18,3 @@ void test_vrsqrtsQf32 (void)
 }
 
 /* { dg-final { scan-assembler "vrsqrts\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vrsqrtsf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vrsqrtsf32.c
@@ -18,4 +18,3 @@ void test_vrsqrtsf32 (void)
 }
 
 /* { dg-final { scan-assembler "vrsqrts\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanef32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanef32.c
@@ -18,4 +18,3 @@ void test_vsetQ_lanef32 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.32\[ 	\]+\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanep16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanep16.c
@@ -18,4 +18,3 @@ void test_vsetQ_lanep16 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.16\[ 	\]+\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanep8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanep8.c
@@ -18,4 +18,3 @@ void test_vsetQ_lanep8 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.8\[ 	\]+\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes16.c
@@ -18,4 +18,3 @@ void test_vsetQ_lanes16 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.16\[ 	\]+\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes32.c
@@ -18,4 +18,3 @@ void test_vsetQ_lanes32 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.32\[ 	\]+\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes64.c
@@ -18,4 +18,3 @@ void test_vsetQ_lanes64 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[rR\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes8.c
@@ -18,4 +18,3 @@ void test_vsetQ_lanes8 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.8\[ 	\]+\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu16.c
@@ -18,4 +18,3 @@ void test_vsetQ_laneu16 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.16\[ 	\]+\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu32.c
@@ -18,4 +18,3 @@ void test_vsetQ_laneu32 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.32\[ 	\]+\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu64.c
@@ -18,4 +18,3 @@ void test_vsetQ_laneu64 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[rR\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu8.c
@@ -18,4 +18,3 @@ void test_vsetQ_laneu8 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.8\[ 	\]+\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vset_lanef32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vset_lanef32.c
@@ -18,4 +18,3 @@ void test_vset_lanef32 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.32\[ 	\]+\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vset_lanep16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vset_lanep16.c
@@ -18,4 +18,3 @@ void test_vset_lanep16 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.16\[ 	\]+\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vset_lanep8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vset_lanep8.c
@@ -18,4 +18,3 @@ void test_vset_lanep8 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.8\[ 	\]+\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vset_lanes16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vset_lanes16.c
@@ -18,4 +18,3 @@ void test_vset_lanes16 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.16\[ 	\]+\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vset_lanes32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vset_lanes32.c
@@ -18,4 +18,3 @@ void test_vset_lanes32 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.32\[ 	\]+\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vset_lanes64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vset_lanes64.c
@@ -17,4 +17,3 @@ void test_vset_lanes64 (void)
   out_int64x1_t = vset_lane_s64 (arg0_int64_t, arg1_int64x1_t, 0);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vset_lanes8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vset_lanes8.c
@@ -18,4 +18,3 @@ void test_vset_lanes8 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.8\[ 	\]+\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vset_laneu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vset_laneu16.c
@@ -18,4 +18,3 @@ void test_vset_laneu16 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.16\[ 	\]+\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vset_laneu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vset_laneu32.c
@@ -18,4 +18,3 @@ void test_vset_laneu32 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.32\[ 	\]+\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vset_laneu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vset_laneu64.c
@@ -17,4 +17,3 @@ void test_vset_laneu64 (void)
   out_uint64x1_t = vset_lane_u64 (arg0_uint64_t, arg1_uint64x1_t, 0);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vset_laneu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vset_laneu8.c
@@ -18,4 +18,3 @@ void test_vset_laneu8 (void)
 }
 
 /* { dg-final { scan-assembler "vmov\.8\[ 	\]+\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshlQ_ns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshlQ_ns16.c
@@ -17,4 +17,3 @@ void test_vshlQ_ns16 (void)
 }
 
 /* { dg-final { scan-assembler "vshl\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshlQ_ns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshlQ_ns32.c
@@ -17,4 +17,3 @@ void test_vshlQ_ns32 (void)
 }
 
 /* { dg-final { scan-assembler "vshl\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshlQ_ns64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshlQ_ns64.c
@@ -17,4 +17,3 @@ void test_vshlQ_ns64 (void)
 }
 
 /* { dg-final { scan-assembler "vshl\.i64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshlQ_ns8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshlQ_ns8.c
@@ -17,4 +17,3 @@ void test_vshlQ_ns8 (void)
 }
 
 /* { dg-final { scan-assembler "vshl\.i8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshlQ_nu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshlQ_nu16.c
@@ -17,4 +17,3 @@ void test_vshlQ_nu16 (void)
 }
 
 /* { dg-final { scan-assembler "vshl\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshlQ_nu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshlQ_nu32.c
@@ -17,4 +17,3 @@ void test_vshlQ_nu32 (void)
 }
 
 /* { dg-final { scan-assembler "vshl\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshlQ_nu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshlQ_nu64.c
@@ -17,4 +17,3 @@ void test_vshlQ_nu64 (void)
 }
 
 /* { dg-final { scan-assembler "vshl\.i64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshlQ_nu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshlQ_nu8.c
@@ -17,4 +17,3 @@ void test_vshlQ_nu8 (void)
 }
 
 /* { dg-final { scan-assembler "vshl\.i8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshlQs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshlQs16.c
@@ -18,4 +18,3 @@ void test_vshlQs16 (void)
 }
 
 /* { dg-final { scan-assembler "vshl\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshlQs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshlQs32.c
@@ -18,4 +18,3 @@ void test_vshlQs32 (void)
 }
 
 /* { dg-final { scan-assembler "vshl\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshlQs64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshlQs64.c
@@ -18,4 +18,3 @@ void test_vshlQs64 (void)
 }
 
 /* { dg-final { scan-assembler "vshl\.s64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshlQs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshlQs8.c
@@ -18,4 +18,3 @@ void test_vshlQs8 (void)
 }
 
 /* { dg-final { scan-assembler "vshl\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshlQu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshlQu16.c
@@ -18,4 +18,3 @@ void test_vshlQu16 (void)
 }
 
 /* { dg-final { scan-assembler "vshl\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshlQu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshlQu32.c
@@ -18,4 +18,3 @@ void test_vshlQu32 (void)
 }
 
 /* { dg-final { scan-assembler "vshl\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshlQu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshlQu64.c
@@ -18,4 +18,3 @@ void test_vshlQu64 (void)
 }
 
 /* { dg-final { scan-assembler "vshl\.u64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshlQu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshlQu8.c
@@ -18,4 +18,3 @@ void test_vshlQu8 (void)
 }
 
 /* { dg-final { scan-assembler "vshl\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshl_ns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshl_ns16.c
@@ -17,4 +17,3 @@ void test_vshl_ns16 (void)
 }
 
 /* { dg-final { scan-assembler "vshl\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshl_ns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshl_ns32.c
@@ -17,4 +17,3 @@ void test_vshl_ns32 (void)
 }
 
 /* { dg-final { scan-assembler "vshl\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshl_ns64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshl_ns64.c
@@ -17,4 +17,3 @@ void test_vshl_ns64 (void)
 }
 
 /* { dg-final { scan-assembler "vshl\.i64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshl_ns8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshl_ns8.c
@@ -17,4 +17,3 @@ void test_vshl_ns8 (void)
 }
 
 /* { dg-final { scan-assembler "vshl\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshl_nu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshl_nu16.c
@@ -17,4 +17,3 @@ void test_vshl_nu16 (void)
 }
 
 /* { dg-final { scan-assembler "vshl\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshl_nu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshl_nu32.c
@@ -17,4 +17,3 @@ void test_vshl_nu32 (void)
 }
 
 /* { dg-final { scan-assembler "vshl\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshl_nu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshl_nu64.c
@@ -17,4 +17,3 @@ void test_vshl_nu64 (void)
 }
 
 /* { dg-final { scan-assembler "vshl\.i64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshl_nu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshl_nu8.c
@@ -17,4 +17,3 @@ void test_vshl_nu8 (void)
 }
 
 /* { dg-final { scan-assembler "vshl\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshll_ns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshll_ns16.c
@@ -17,4 +17,3 @@ void test_vshll_ns16 (void)
 }
 
 /* { dg-final { scan-assembler "vshll\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshll_ns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshll_ns32.c
@@ -17,4 +17,3 @@ void test_vshll_ns32 (void)
 }
 
 /* { dg-final { scan-assembler "vshll\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshll_ns8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshll_ns8.c
@@ -17,4 +17,3 @@ void test_vshll_ns8 (void)
 }
 
 /* { dg-final { scan-assembler "vshll\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshll_nu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshll_nu16.c
@@ -17,4 +17,3 @@ void test_vshll_nu16 (void)
 }
 
 /* { dg-final { scan-assembler "vshll\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshll_nu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshll_nu32.c
@@ -17,4 +17,3 @@ void test_vshll_nu32 (void)
 }
 
 /* { dg-final { scan-assembler "vshll\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshll_nu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshll_nu8.c
@@ -17,4 +17,3 @@ void test_vshll_nu8 (void)
 }
 
 /* { dg-final { scan-assembler "vshll\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshls16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshls16.c
@@ -18,4 +18,3 @@ void test_vshls16 (void)
 }
 
 /* { dg-final { scan-assembler "vshl\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshls32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshls32.c
@@ -18,4 +18,3 @@ void test_vshls32 (void)
 }
 
 /* { dg-final { scan-assembler "vshl\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshls64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshls64.c
@@ -18,4 +18,3 @@ void test_vshls64 (void)
 }
 
 /* { dg-final { scan-assembler "vshl\.s64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshls8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshls8.c
@@ -18,4 +18,3 @@ void test_vshls8 (void)
 }
 
 /* { dg-final { scan-assembler "vshl\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshlu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshlu16.c
@@ -18,4 +18,3 @@ void test_vshlu16 (void)
 }
 
 /* { dg-final { scan-assembler "vshl\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshlu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshlu32.c
@@ -18,4 +18,3 @@ void test_vshlu32 (void)
 }
 
 /* { dg-final { scan-assembler "vshl\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshlu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshlu64.c
@@ -18,4 +18,3 @@ void test_vshlu64 (void)
 }
 
 /* { dg-final { scan-assembler "vshl\.u64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshlu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshlu8.c
@@ -18,4 +18,3 @@ void test_vshlu8 (void)
 }
 
 /* { dg-final { scan-assembler "vshl\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshrQ_ns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshrQ_ns16.c
@@ -17,4 +17,3 @@ void test_vshrQ_ns16 (void)
 }
 
 /* { dg-final { scan-assembler "vshr\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshrQ_ns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshrQ_ns32.c
@@ -17,4 +17,3 @@ void test_vshrQ_ns32 (void)
 }
 
 /* { dg-final { scan-assembler "vshr\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshrQ_ns64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshrQ_ns64.c
@@ -17,4 +17,3 @@ void test_vshrQ_ns64 (void)
 }
 
 /* { dg-final { scan-assembler "vshr\.s64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshrQ_ns8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshrQ_ns8.c
@@ -17,4 +17,3 @@ void test_vshrQ_ns8 (void)
 }
 
 /* { dg-final { scan-assembler "vshr\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshrQ_nu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshrQ_nu16.c
@@ -17,4 +17,3 @@ void test_vshrQ_nu16 (void)
 }
 
 /* { dg-final { scan-assembler "vshr\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshrQ_nu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshrQ_nu32.c
@@ -17,4 +17,3 @@ void test_vshrQ_nu32 (void)
 }
 
 /* { dg-final { scan-assembler "vshr\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshrQ_nu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshrQ_nu64.c
@@ -17,4 +17,3 @@ void test_vshrQ_nu64 (void)
 }
 
 /* { dg-final { scan-assembler "vshr\.u64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshrQ_nu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshrQ_nu8.c
@@ -17,4 +17,3 @@ void test_vshrQ_nu8 (void)
 }
 
 /* { dg-final { scan-assembler "vshr\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshr_ns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshr_ns16.c
@@ -17,4 +17,3 @@ void test_vshr_ns16 (void)
 }
 
 /* { dg-final { scan-assembler "vshr\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshr_ns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshr_ns32.c
@@ -17,4 +17,3 @@ void test_vshr_ns32 (void)
 }
 
 /* { dg-final { scan-assembler "vshr\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshr_ns64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshr_ns64.c
@@ -17,4 +17,3 @@ void test_vshr_ns64 (void)
 }
 
 /* { dg-final { scan-assembler "vshr\.s64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshr_ns8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshr_ns8.c
@@ -17,4 +17,3 @@ void test_vshr_ns8 (void)
 }
 
 /* { dg-final { scan-assembler "vshr\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshr_nu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshr_nu16.c
@@ -17,4 +17,3 @@ void test_vshr_nu16 (void)
 }
 
 /* { dg-final { scan-assembler "vshr\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshr_nu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshr_nu32.c
@@ -17,4 +17,3 @@ void test_vshr_nu32 (void)
 }
 
 /* { dg-final { scan-assembler "vshr\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshr_nu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshr_nu64.c
@@ -17,4 +17,3 @@ void test_vshr_nu64 (void)
 }
 
 /* { dg-final { scan-assembler "vshr\.u64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshr_nu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshr_nu8.c
@@ -17,4 +17,3 @@ void test_vshr_nu8 (void)
 }
 
 /* { dg-final { scan-assembler "vshr\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshrn_ns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshrn_ns16.c
@@ -17,4 +17,3 @@ void test_vshrn_ns16 (void)
 }
 
 /* { dg-final { scan-assembler "vshrn\.i16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshrn_ns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshrn_ns32.c
@@ -17,4 +17,3 @@ void test_vshrn_ns32 (void)
 }
 
 /* { dg-final { scan-assembler "vshrn\.i32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshrn_ns64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshrn_ns64.c
@@ -17,4 +17,3 @@ void test_vshrn_ns64 (void)
 }
 
 /* { dg-final { scan-assembler "vshrn\.i64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshrn_nu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshrn_nu16.c
@@ -17,4 +17,3 @@ void test_vshrn_nu16 (void)
 }
 
 /* { dg-final { scan-assembler "vshrn\.i16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshrn_nu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshrn_nu32.c
@@ -17,4 +17,3 @@ void test_vshrn_nu32 (void)
 }
 
 /* { dg-final { scan-assembler "vshrn\.i32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vshrn_nu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vshrn_nu64.c
@@ -17,4 +17,3 @@ void test_vshrn_nu64 (void)
 }
 
 /* { dg-final { scan-assembler "vshrn\.i64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsliQ_np16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsliQ_np16.c
@@ -18,4 +18,3 @@ void test_vsliQ_np16 (void)
 }
 
 /* { dg-final { scan-assembler "vsli\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsliQ_np64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsliQ_np64.c
@@ -18,4 +18,3 @@ void test_vsliQ_np64 (void)
 }
 
 /* { dg-final { scan-assembler "vsli\.64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsliQ_np8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsliQ_np8.c
@@ -18,4 +18,3 @@ void test_vsliQ_np8 (void)
 }
 
 /* { dg-final { scan-assembler "vsli\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsliQ_ns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsliQ_ns16.c
@@ -18,4 +18,3 @@ void test_vsliQ_ns16 (void)
 }
 
 /* { dg-final { scan-assembler "vsli\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsliQ_ns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsliQ_ns32.c
@@ -18,4 +18,3 @@ void test_vsliQ_ns32 (void)
 }
 
 /* { dg-final { scan-assembler "vsli\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsliQ_ns64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsliQ_ns64.c
@@ -18,4 +18,3 @@ void test_vsliQ_ns64 (void)
 }
 
 /* { dg-final { scan-assembler "vsli\.64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsliQ_ns8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsliQ_ns8.c
@@ -18,4 +18,3 @@ void test_vsliQ_ns8 (void)
 }
 
 /* { dg-final { scan-assembler "vsli\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsliQ_nu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsliQ_nu16.c
@@ -18,4 +18,3 @@ void test_vsliQ_nu16 (void)
 }
 
 /* { dg-final { scan-assembler "vsli\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsliQ_nu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsliQ_nu32.c
@@ -18,4 +18,3 @@ void test_vsliQ_nu32 (void)
 }
 
 /* { dg-final { scan-assembler "vsli\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsliQ_nu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsliQ_nu64.c
@@ -18,4 +18,3 @@ void test_vsliQ_nu64 (void)
 }
 
 /* { dg-final { scan-assembler "vsli\.64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsliQ_nu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsliQ_nu8.c
@@ -18,4 +18,3 @@ void test_vsliQ_nu8 (void)
 }
 
 /* { dg-final { scan-assembler "vsli\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsli_np16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsli_np16.c
@@ -18,4 +18,3 @@ void test_vsli_np16 (void)
 }
 
 /* { dg-final { scan-assembler "vsli\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsli_np64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsli_np64.c
@@ -18,4 +18,3 @@ void test_vsli_np64 (void)
 }
 
 /* { dg-final { scan-assembler "vsli\.64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsli_np8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsli_np8.c
@@ -18,4 +18,3 @@ void test_vsli_np8 (void)
 }
 
 /* { dg-final { scan-assembler "vsli\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsli_ns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsli_ns16.c
@@ -18,4 +18,3 @@ void test_vsli_ns16 (void)
 }
 
 /* { dg-final { scan-assembler "vsli\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsli_ns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsli_ns32.c
@@ -18,4 +18,3 @@ void test_vsli_ns32 (void)
 }
 
 /* { dg-final { scan-assembler "vsli\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsli_ns64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsli_ns64.c
@@ -18,4 +18,3 @@ void test_vsli_ns64 (void)
 }
 
 /* { dg-final { scan-assembler "vsli\.64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsli_ns8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsli_ns8.c
@@ -18,4 +18,3 @@ void test_vsli_ns8 (void)
 }
 
 /* { dg-final { scan-assembler "vsli\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsli_nu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsli_nu16.c
@@ -18,4 +18,3 @@ void test_vsli_nu16 (void)
 }
 
 /* { dg-final { scan-assembler "vsli\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsli_nu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsli_nu32.c
@@ -18,4 +18,3 @@ void test_vsli_nu32 (void)
 }
 
 /* { dg-final { scan-assembler "vsli\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsli_nu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsli_nu64.c
@@ -18,4 +18,3 @@ void test_vsli_nu64 (void)
 }
 
 /* { dg-final { scan-assembler "vsli\.64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsli_nu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsli_nu8.c
@@ -18,4 +18,3 @@ void test_vsli_nu8 (void)
 }
 
 /* { dg-final { scan-assembler "vsli\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsraQ_ns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsraQ_ns16.c
@@ -18,4 +18,3 @@ void test_vsraQ_ns16 (void)
 }
 
 /* { dg-final { scan-assembler "vsra\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsraQ_ns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsraQ_ns32.c
@@ -18,4 +18,3 @@ void test_vsraQ_ns32 (void)
 }
 
 /* { dg-final { scan-assembler "vsra\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsraQ_ns64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsraQ_ns64.c
@@ -18,4 +18,3 @@ void test_vsraQ_ns64 (void)
 }
 
 /* { dg-final { scan-assembler "vsra\.s64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsraQ_ns8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsraQ_ns8.c
@@ -18,4 +18,3 @@ void test_vsraQ_ns8 (void)
 }
 
 /* { dg-final { scan-assembler "vsra\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsraQ_nu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsraQ_nu16.c
@@ -18,4 +18,3 @@ void test_vsraQ_nu16 (void)
 }
 
 /* { dg-final { scan-assembler "vsra\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsraQ_nu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsraQ_nu32.c
@@ -18,4 +18,3 @@ void test_vsraQ_nu32 (void)
 }
 
 /* { dg-final { scan-assembler "vsra\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsraQ_nu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsraQ_nu64.c
@@ -18,4 +18,3 @@ void test_vsraQ_nu64 (void)
 }
 
 /* { dg-final { scan-assembler "vsra\.u64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsraQ_nu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsraQ_nu8.c
@@ -18,4 +18,3 @@ void test_vsraQ_nu8 (void)
 }
 
 /* { dg-final { scan-assembler "vsra\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsra_ns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsra_ns16.c
@@ -18,4 +18,3 @@ void test_vsra_ns16 (void)
 }
 
 /* { dg-final { scan-assembler "vsra\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsra_ns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsra_ns32.c
@@ -18,4 +18,3 @@ void test_vsra_ns32 (void)
 }
 
 /* { dg-final { scan-assembler "vsra\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsra_ns64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsra_ns64.c
@@ -18,4 +18,3 @@ void test_vsra_ns64 (void)
 }
 
 /* { dg-final { scan-assembler "vsra\.s64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsra_ns8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsra_ns8.c
@@ -18,4 +18,3 @@ void test_vsra_ns8 (void)
 }
 
 /* { dg-final { scan-assembler "vsra\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsra_nu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsra_nu16.c
@@ -18,4 +18,3 @@ void test_vsra_nu16 (void)
 }
 
 /* { dg-final { scan-assembler "vsra\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsra_nu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsra_nu32.c
@@ -18,4 +18,3 @@ void test_vsra_nu32 (void)
 }
 
 /* { dg-final { scan-assembler "vsra\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsra_nu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsra_nu64.c
@@ -18,4 +18,3 @@ void test_vsra_nu64 (void)
 }
 
 /* { dg-final { scan-assembler "vsra\.u64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsra_nu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsra_nu8.c
@@ -18,4 +18,3 @@ void test_vsra_nu8 (void)
 }
 
 /* { dg-final { scan-assembler "vsra\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsriQ_np16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsriQ_np16.c
@@ -18,4 +18,3 @@ void test_vsriQ_np16 (void)
 }
 
 /* { dg-final { scan-assembler "vsri\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsriQ_np64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsriQ_np64.c
@@ -18,4 +18,3 @@ void test_vsriQ_np64 (void)
 }
 
 /* { dg-final { scan-assembler "vsri\.64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsriQ_np8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsriQ_np8.c
@@ -18,4 +18,3 @@ void test_vsriQ_np8 (void)
 }
 
 /* { dg-final { scan-assembler "vsri\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsriQ_ns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsriQ_ns16.c
@@ -18,4 +18,3 @@ void test_vsriQ_ns16 (void)
 }
 
 /* { dg-final { scan-assembler "vsri\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsriQ_ns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsriQ_ns32.c
@@ -18,4 +18,3 @@ void test_vsriQ_ns32 (void)
 }
 
 /* { dg-final { scan-assembler "vsri\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsriQ_ns64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsriQ_ns64.c
@@ -18,4 +18,3 @@ void test_vsriQ_ns64 (void)
 }
 
 /* { dg-final { scan-assembler "vsri\.64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsriQ_ns8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsriQ_ns8.c
@@ -18,4 +18,3 @@ void test_vsriQ_ns8 (void)
 }
 
 /* { dg-final { scan-assembler "vsri\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsriQ_nu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsriQ_nu16.c
@@ -18,4 +18,3 @@ void test_vsriQ_nu16 (void)
 }
 
 /* { dg-final { scan-assembler "vsri\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsriQ_nu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsriQ_nu32.c
@@ -18,4 +18,3 @@ void test_vsriQ_nu32 (void)
 }
 
 /* { dg-final { scan-assembler "vsri\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsriQ_nu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsriQ_nu64.c
@@ -18,4 +18,3 @@ void test_vsriQ_nu64 (void)
 }
 
 /* { dg-final { scan-assembler "vsri\.64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsriQ_nu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsriQ_nu8.c
@@ -18,4 +18,3 @@ void test_vsriQ_nu8 (void)
 }
 
 /* { dg-final { scan-assembler "vsri\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsri_np16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsri_np16.c
@@ -18,4 +18,3 @@ void test_vsri_np16 (void)
 }
 
 /* { dg-final { scan-assembler "vsri\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsri_np64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsri_np64.c
@@ -18,4 +18,3 @@ void test_vsri_np64 (void)
 }
 
 /* { dg-final { scan-assembler "vsri\.64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsri_np8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsri_np8.c
@@ -18,4 +18,3 @@ void test_vsri_np8 (void)
 }
 
 /* { dg-final { scan-assembler "vsri\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsri_ns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsri_ns16.c
@@ -18,4 +18,3 @@ void test_vsri_ns16 (void)
 }
 
 /* { dg-final { scan-assembler "vsri\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsri_ns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsri_ns32.c
@@ -18,4 +18,3 @@ void test_vsri_ns32 (void)
 }
 
 /* { dg-final { scan-assembler "vsri\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsri_ns64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsri_ns64.c
@@ -18,4 +18,3 @@ void test_vsri_ns64 (void)
 }
 
 /* { dg-final { scan-assembler "vsri\.64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsri_ns8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsri_ns8.c
@@ -18,4 +18,3 @@ void test_vsri_ns8 (void)
 }
 
 /* { dg-final { scan-assembler "vsri\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsri_nu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsri_nu16.c
@@ -18,4 +18,3 @@ void test_vsri_nu16 (void)
 }
 
 /* { dg-final { scan-assembler "vsri\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsri_nu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsri_nu32.c
@@ -18,4 +18,3 @@ void test_vsri_nu32 (void)
 }
 
 /* { dg-final { scan-assembler "vsri\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsri_nu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsri_nu64.c
@@ -18,4 +18,3 @@ void test_vsri_nu64 (void)
 }
 
 /* { dg-final { scan-assembler "vsri\.64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsri_nu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsri_nu8.c
@@ -18,4 +18,3 @@ void test_vsri_nu8 (void)
 }
 
 /* { dg-final { scan-assembler "vsri\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanef32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanef32.c
@@ -17,4 +17,3 @@ void test_vst1Q_lanef32 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanep16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanep16.c
@@ -17,4 +17,3 @@ void test_vst1Q_lanep16 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanep64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanep64.c
@@ -17,4 +17,3 @@ void test_vst1Q_lanep64 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.64\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanep8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanep8.c
@@ -17,4 +17,3 @@ void test_vst1Q_lanep8 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes16.c
@@ -17,4 +17,3 @@ void test_vst1Q_lanes16 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes32.c
@@ -17,4 +17,3 @@ void test_vst1Q_lanes32 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes64.c
@@ -17,4 +17,3 @@ void test_vst1Q_lanes64 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.64\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes8.c
@@ -17,4 +17,3 @@ void test_vst1Q_lanes8 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu16.c
@@ -17,4 +17,3 @@ void test_vst1Q_laneu16 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu32.c
@@ -17,4 +17,3 @@ void test_vst1Q_laneu32 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu64.c
@@ -17,4 +17,3 @@ void test_vst1Q_laneu64 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.64\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu8.c
@@ -17,4 +17,3 @@ void test_vst1Q_laneu8 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst1Qf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst1Qf32.c
@@ -17,4 +17,3 @@ void test_vst1Qf32 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst1Qp16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst1Qp16.c
@@ -17,4 +17,3 @@ void test_vst1Qp16 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst1Qp64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst1Qp64.c
@@ -17,4 +17,3 @@ void test_vst1Qp64 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst1Qp8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst1Qp8.c
@@ -17,4 +17,3 @@ void test_vst1Qp8 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst1Qs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst1Qs16.c
@@ -17,4 +17,3 @@ void test_vst1Qs16 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst1Qs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst1Qs32.c
@@ -17,4 +17,3 @@ void test_vst1Qs32 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst1Qs64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst1Qs64.c
@@ -17,4 +17,3 @@ void test_vst1Qs64 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst1Qs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst1Qs8.c
@@ -17,4 +17,3 @@ void test_vst1Qs8 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst1Qu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst1Qu16.c
@@ -17,4 +17,3 @@ void test_vst1Qu16 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst1Qu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst1Qu32.c
@@ -17,4 +17,3 @@ void test_vst1Qu32 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst1Qu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst1Qu64.c
@@ -17,4 +17,3 @@ void test_vst1Qu64 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst1Qu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst1Qu8.c
@@ -17,4 +17,3 @@ void test_vst1Qu8 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst1_lanef32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst1_lanef32.c
@@ -17,4 +17,3 @@ void test_vst1_lanef32 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst1_lanep16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst1_lanep16.c
@@ -17,4 +17,3 @@ void test_vst1_lanep16 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst1_lanep64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst1_lanep64.c
@@ -17,4 +17,3 @@ void test_vst1_lanep64 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.64\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst1_lanep8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst1_lanep8.c
@@ -17,4 +17,3 @@ void test_vst1_lanep8 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst1_lanes16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst1_lanes16.c
@@ -17,4 +17,3 @@ void test_vst1_lanes16 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst1_lanes32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst1_lanes32.c
@@ -17,4 +17,3 @@ void test_vst1_lanes32 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst1_lanes64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst1_lanes64.c
@@ -17,4 +17,3 @@ void test_vst1_lanes64 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.64\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst1_lanes8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst1_lanes8.c
@@ -17,4 +17,3 @@ void test_vst1_lanes8 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst1_laneu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst1_laneu16.c
@@ -17,4 +17,3 @@ void test_vst1_laneu16 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst1_laneu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst1_laneu32.c
@@ -17,4 +17,3 @@ void test_vst1_laneu32 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst1_laneu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst1_laneu64.c
@@ -17,4 +17,3 @@ void test_vst1_laneu64 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.64\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst1_laneu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst1_laneu8.c
@@ -17,4 +17,3 @@ void test_vst1_laneu8 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst1f32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst1f32.c
@@ -17,4 +17,3 @@ void test_vst1f32 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst1p16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst1p16.c
@@ -17,4 +17,3 @@ void test_vst1p16 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst1p64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst1p64.c
@@ -17,4 +17,3 @@ void test_vst1p64 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.64\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst1p8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst1p8.c
@@ -17,4 +17,3 @@ void test_vst1p8 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst1s16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst1s16.c
@@ -17,4 +17,3 @@ void test_vst1s16 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst1s32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst1s32.c
@@ -17,4 +17,3 @@ void test_vst1s32 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst1s64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst1s64.c
@@ -17,4 +17,3 @@ void test_vst1s64 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.64\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst1s8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst1s8.c
@@ -17,4 +17,3 @@ void test_vst1s8 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst1u16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst1u16.c
@@ -17,4 +17,3 @@ void test_vst1u16 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst1u32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst1u32.c
@@ -17,4 +17,3 @@ void test_vst1u32 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst1u64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst1u64.c
@@ -17,4 +17,3 @@ void test_vst1u64 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.64\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst1u8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst1u8.c
@@ -17,4 +17,3 @@ void test_vst1u8 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst2Q_lanef32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst2Q_lanef32.c
@@ -17,4 +17,3 @@ void test_vst2Q_lanef32 (void)
 }
 
 /* { dg-final { scan-assembler "vst2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst2Q_lanep16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst2Q_lanep16.c
@@ -17,4 +17,3 @@ void test_vst2Q_lanep16 (void)
 }
 
 /* { dg-final { scan-assembler "vst2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst2Q_lanes16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst2Q_lanes16.c
@@ -17,4 +17,3 @@ void test_vst2Q_lanes16 (void)
 }
 
 /* { dg-final { scan-assembler "vst2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst2Q_lanes32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst2Q_lanes32.c
@@ -17,4 +17,3 @@ void test_vst2Q_lanes32 (void)
 }
 
 /* { dg-final { scan-assembler "vst2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst2Q_laneu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst2Q_laneu16.c
@@ -17,4 +17,3 @@ void test_vst2Q_laneu16 (void)
 }
 
 /* { dg-final { scan-assembler "vst2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst2Q_laneu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst2Q_laneu32.c
@@ -17,4 +17,3 @@ void test_vst2Q_laneu32 (void)
 }
 
 /* { dg-final { scan-assembler "vst2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst2Qf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst2Qf32.c
@@ -18,4 +18,3 @@ void test_vst2Qf32 (void)
 
 /* { dg-final { scan-assembler "vst2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vst2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst2Qp16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst2Qp16.c
@@ -18,4 +18,3 @@ void test_vst2Qp16 (void)
 
 /* { dg-final { scan-assembler "vst2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vst2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst2Qp8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst2Qp8.c
@@ -18,4 +18,3 @@ void test_vst2Qp8 (void)
 
 /* { dg-final { scan-assembler "vst2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vst2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst2Qs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst2Qs16.c
@@ -18,4 +18,3 @@ void test_vst2Qs16 (void)
 
 /* { dg-final { scan-assembler "vst2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vst2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst2Qs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst2Qs32.c
@@ -18,4 +18,3 @@ void test_vst2Qs32 (void)
 
 /* { dg-final { scan-assembler "vst2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vst2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst2Qs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst2Qs8.c
@@ -18,4 +18,3 @@ void test_vst2Qs8 (void)
 
 /* { dg-final { scan-assembler "vst2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vst2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst2Qu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst2Qu16.c
@@ -18,4 +18,3 @@ void test_vst2Qu16 (void)
 
 /* { dg-final { scan-assembler "vst2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vst2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst2Qu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst2Qu32.c
@@ -18,4 +18,3 @@ void test_vst2Qu32 (void)
 
 /* { dg-final { scan-assembler "vst2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vst2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst2Qu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst2Qu8.c
@@ -18,4 +18,3 @@ void test_vst2Qu8 (void)
 
 /* { dg-final { scan-assembler "vst2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vst2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst2_lanef32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst2_lanef32.c
@@ -17,4 +17,3 @@ void test_vst2_lanef32 (void)
 }
 
 /* { dg-final { scan-assembler "vst2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst2_lanep16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst2_lanep16.c
@@ -17,4 +17,3 @@ void test_vst2_lanep16 (void)
 }
 
 /* { dg-final { scan-assembler "vst2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst2_lanep8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst2_lanep8.c
@@ -17,4 +17,3 @@ void test_vst2_lanep8 (void)
 }
 
 /* { dg-final { scan-assembler "vst2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst2_lanes16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst2_lanes16.c
@@ -17,4 +17,3 @@ void test_vst2_lanes16 (void)
 }
 
 /* { dg-final { scan-assembler "vst2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst2_lanes32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst2_lanes32.c
@@ -17,4 +17,3 @@ void test_vst2_lanes32 (void)
 }
 
 /* { dg-final { scan-assembler "vst2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst2_lanes8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst2_lanes8.c
@@ -17,4 +17,3 @@ void test_vst2_lanes8 (void)
 }
 
 /* { dg-final { scan-assembler "vst2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst2_laneu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst2_laneu16.c
@@ -17,4 +17,3 @@ void test_vst2_laneu16 (void)
 }
 
 /* { dg-final { scan-assembler "vst2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst2_laneu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst2_laneu32.c
@@ -17,4 +17,3 @@ void test_vst2_laneu32 (void)
 }
 
 /* { dg-final { scan-assembler "vst2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst2_laneu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst2_laneu8.c
@@ -17,4 +17,3 @@ void test_vst2_laneu8 (void)
 }
 
 /* { dg-final { scan-assembler "vst2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst2f32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst2f32.c
@@ -17,4 +17,3 @@ void test_vst2f32 (void)
 }
 
 /* { dg-final { scan-assembler "vst2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst2p16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst2p16.c
@@ -17,4 +17,3 @@ void test_vst2p16 (void)
 }
 
 /* { dg-final { scan-assembler "vst2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst2p64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst2p64.c
@@ -17,4 +17,3 @@ void test_vst2p64 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst2p8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst2p8.c
@@ -17,4 +17,3 @@ void test_vst2p8 (void)
 }
 
 /* { dg-final { scan-assembler "vst2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst2s16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst2s16.c
@@ -17,4 +17,3 @@ void test_vst2s16 (void)
 }
 
 /* { dg-final { scan-assembler "vst2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst2s32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst2s32.c
@@ -17,4 +17,3 @@ void test_vst2s32 (void)
 }
 
 /* { dg-final { scan-assembler "vst2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst2s64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst2s64.c
@@ -17,4 +17,3 @@ void test_vst2s64 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst2s8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst2s8.c
@@ -17,4 +17,3 @@ void test_vst2s8 (void)
 }
 
 /* { dg-final { scan-assembler "vst2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst2u16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst2u16.c
@@ -17,4 +17,3 @@ void test_vst2u16 (void)
 }
 
 /* { dg-final { scan-assembler "vst2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst2u32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst2u32.c
@@ -17,4 +17,3 @@ void test_vst2u32 (void)
 }
 
 /* { dg-final { scan-assembler "vst2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst2u64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst2u64.c
@@ -17,4 +17,3 @@ void test_vst2u64 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst2u8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst2u8.c
@@ -17,4 +17,3 @@ void test_vst2u8 (void)
 }
 
 /* { dg-final { scan-assembler "vst2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst3Q_lanef32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst3Q_lanef32.c
@@ -17,4 +17,3 @@ void test_vst3Q_lanef32 (void)
 }
 
 /* { dg-final { scan-assembler "vst3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst3Q_lanep16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst3Q_lanep16.c
@@ -17,4 +17,3 @@ void test_vst3Q_lanep16 (void)
 }
 
 /* { dg-final { scan-assembler "vst3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst3Q_lanes16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst3Q_lanes16.c
@@ -17,4 +17,3 @@ void test_vst3Q_lanes16 (void)
 }
 
 /* { dg-final { scan-assembler "vst3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst3Q_lanes32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst3Q_lanes32.c
@@ -17,4 +17,3 @@ void test_vst3Q_lanes32 (void)
 }
 
 /* { dg-final { scan-assembler "vst3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst3Q_laneu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst3Q_laneu16.c
@@ -17,4 +17,3 @@ void test_vst3Q_laneu16 (void)
 }
 
 /* { dg-final { scan-assembler "vst3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst3Q_laneu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst3Q_laneu32.c
@@ -17,4 +17,3 @@ void test_vst3Q_laneu32 (void)
 }
 
 /* { dg-final { scan-assembler "vst3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst3Qf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst3Qf32.c
@@ -18,4 +18,3 @@ void test_vst3Qf32 (void)
 
 /* { dg-final { scan-assembler "vst3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vst3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst3Qp16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst3Qp16.c
@@ -18,4 +18,3 @@ void test_vst3Qp16 (void)
 
 /* { dg-final { scan-assembler "vst3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vst3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst3Qp8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst3Qp8.c
@@ -18,4 +18,3 @@ void test_vst3Qp8 (void)
 
 /* { dg-final { scan-assembler "vst3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vst3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst3Qs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst3Qs16.c
@@ -18,4 +18,3 @@ void test_vst3Qs16 (void)
 
 /* { dg-final { scan-assembler "vst3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vst3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst3Qs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst3Qs32.c
@@ -18,4 +18,3 @@ void test_vst3Qs32 (void)
 
 /* { dg-final { scan-assembler "vst3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vst3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst3Qs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst3Qs8.c
@@ -18,4 +18,3 @@ void test_vst3Qs8 (void)
 
 /* { dg-final { scan-assembler "vst3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vst3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst3Qu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst3Qu16.c
@@ -18,4 +18,3 @@ void test_vst3Qu16 (void)
 
 /* { dg-final { scan-assembler "vst3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vst3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst3Qu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst3Qu32.c
@@ -18,4 +18,3 @@ void test_vst3Qu32 (void)
 
 /* { dg-final { scan-assembler "vst3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vst3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst3Qu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst3Qu8.c
@@ -18,4 +18,3 @@ void test_vst3Qu8 (void)
 
 /* { dg-final { scan-assembler "vst3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vst3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst3_lanef32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst3_lanef32.c
@@ -17,4 +17,3 @@ void test_vst3_lanef32 (void)
 }
 
 /* { dg-final { scan-assembler "vst3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst3_lanep16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst3_lanep16.c
@@ -17,4 +17,3 @@ void test_vst3_lanep16 (void)
 }
 
 /* { dg-final { scan-assembler "vst3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst3_lanep8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst3_lanep8.c
@@ -17,4 +17,3 @@ void test_vst3_lanep8 (void)
 }
 
 /* { dg-final { scan-assembler "vst3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst3_lanes16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst3_lanes16.c
@@ -17,4 +17,3 @@ void test_vst3_lanes16 (void)
 }
 
 /* { dg-final { scan-assembler "vst3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst3_lanes32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst3_lanes32.c
@@ -17,4 +17,3 @@ void test_vst3_lanes32 (void)
 }
 
 /* { dg-final { scan-assembler "vst3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst3_lanes8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst3_lanes8.c
@@ -17,4 +17,3 @@ void test_vst3_lanes8 (void)
 }
 
 /* { dg-final { scan-assembler "vst3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst3_laneu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst3_laneu16.c
@@ -17,4 +17,3 @@ void test_vst3_laneu16 (void)
 }
 
 /* { dg-final { scan-assembler "vst3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst3_laneu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst3_laneu32.c
@@ -17,4 +17,3 @@ void test_vst3_laneu32 (void)
 }
 
 /* { dg-final { scan-assembler "vst3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst3_laneu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst3_laneu8.c
@@ -17,4 +17,3 @@ void test_vst3_laneu8 (void)
 }
 
 /* { dg-final { scan-assembler "vst3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst3f32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst3f32.c
@@ -17,4 +17,3 @@ void test_vst3f32 (void)
 }
 
 /* { dg-final { scan-assembler "vst3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst3p16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst3p16.c
@@ -17,4 +17,3 @@ void test_vst3p16 (void)
 }
 
 /* { dg-final { scan-assembler "vst3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst3p64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst3p64.c
@@ -17,4 +17,3 @@ void test_vst3p64 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst3p8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst3p8.c
@@ -17,4 +17,3 @@ void test_vst3p8 (void)
 }
 
 /* { dg-final { scan-assembler "vst3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst3s16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst3s16.c
@@ -17,4 +17,3 @@ void test_vst3s16 (void)
 }
 
 /* { dg-final { scan-assembler "vst3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst3s32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst3s32.c
@@ -17,4 +17,3 @@ void test_vst3s32 (void)
 }
 
 /* { dg-final { scan-assembler "vst3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst3s64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst3s64.c
@@ -17,4 +17,3 @@ void test_vst3s64 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst3s8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst3s8.c
@@ -17,4 +17,3 @@ void test_vst3s8 (void)
 }
 
 /* { dg-final { scan-assembler "vst3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst3u16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst3u16.c
@@ -17,4 +17,3 @@ void test_vst3u16 (void)
 }
 
 /* { dg-final { scan-assembler "vst3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst3u32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst3u32.c
@@ -17,4 +17,3 @@ void test_vst3u32 (void)
 }
 
 /* { dg-final { scan-assembler "vst3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst3u64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst3u64.c
@@ -17,4 +17,3 @@ void test_vst3u64 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst3u8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst3u8.c
@@ -17,4 +17,3 @@ void test_vst3u8 (void)
 }
 
 /* { dg-final { scan-assembler "vst3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst4Q_lanef32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst4Q_lanef32.c
@@ -17,4 +17,3 @@ void test_vst4Q_lanef32 (void)
 }
 
 /* { dg-final { scan-assembler "vst4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst4Q_lanep16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst4Q_lanep16.c
@@ -17,4 +17,3 @@ void test_vst4Q_lanep16 (void)
 }
 
 /* { dg-final { scan-assembler "vst4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst4Q_lanes16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst4Q_lanes16.c
@@ -17,4 +17,3 @@ void test_vst4Q_lanes16 (void)
 }
 
 /* { dg-final { scan-assembler "vst4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst4Q_lanes32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst4Q_lanes32.c
@@ -17,4 +17,3 @@ void test_vst4Q_lanes32 (void)
 }
 
 /* { dg-final { scan-assembler "vst4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst4Q_laneu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst4Q_laneu16.c
@@ -17,4 +17,3 @@ void test_vst4Q_laneu16 (void)
 }
 
 /* { dg-final { scan-assembler "vst4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst4Q_laneu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst4Q_laneu32.c
@@ -17,4 +17,3 @@ void test_vst4Q_laneu32 (void)
 }
 
 /* { dg-final { scan-assembler "vst4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst4Qf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst4Qf32.c
@@ -18,4 +18,3 @@ void test_vst4Qf32 (void)
 
 /* { dg-final { scan-assembler "vst4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vst4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst4Qp16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst4Qp16.c
@@ -18,4 +18,3 @@ void test_vst4Qp16 (void)
 
 /* { dg-final { scan-assembler "vst4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vst4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst4Qp8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst4Qp8.c
@@ -18,4 +18,3 @@ void test_vst4Qp8 (void)
 
 /* { dg-final { scan-assembler "vst4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vst4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst4Qs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst4Qs16.c
@@ -18,4 +18,3 @@ void test_vst4Qs16 (void)
 
 /* { dg-final { scan-assembler "vst4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vst4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst4Qs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst4Qs32.c
@@ -18,4 +18,3 @@ void test_vst4Qs32 (void)
 
 /* { dg-final { scan-assembler "vst4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vst4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst4Qs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst4Qs8.c
@@ -18,4 +18,3 @@ void test_vst4Qs8 (void)
 
 /* { dg-final { scan-assembler "vst4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vst4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst4Qu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst4Qu16.c
@@ -18,4 +18,3 @@ void test_vst4Qu16 (void)
 
 /* { dg-final { scan-assembler "vst4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vst4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst4Qu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst4Qu32.c
@@ -18,4 +18,3 @@ void test_vst4Qu32 (void)
 
 /* { dg-final { scan-assembler "vst4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vst4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst4Qu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst4Qu8.c
@@ -18,4 +18,3 @@ void test_vst4Qu8 (void)
 
 /* { dg-final { scan-assembler "vst4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { scan-assembler "vst4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst4_lanef32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst4_lanef32.c
@@ -17,4 +17,3 @@ void test_vst4_lanef32 (void)
 }
 
 /* { dg-final { scan-assembler "vst4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst4_lanep16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst4_lanep16.c
@@ -17,4 +17,3 @@ void test_vst4_lanep16 (void)
 }
 
 /* { dg-final { scan-assembler "vst4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst4_lanep8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst4_lanep8.c
@@ -17,4 +17,3 @@ void test_vst4_lanep8 (void)
 }
 
 /* { dg-final { scan-assembler "vst4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst4_lanes16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst4_lanes16.c
@@ -17,4 +17,3 @@ void test_vst4_lanes16 (void)
 }
 
 /* { dg-final { scan-assembler "vst4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst4_lanes32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst4_lanes32.c
@@ -17,4 +17,3 @@ void test_vst4_lanes32 (void)
 }
 
 /* { dg-final { scan-assembler "vst4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst4_lanes8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst4_lanes8.c
@@ -17,4 +17,3 @@ void test_vst4_lanes8 (void)
 }
 
 /* { dg-final { scan-assembler "vst4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst4_laneu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst4_laneu16.c
@@ -17,4 +17,3 @@ void test_vst4_laneu16 (void)
 }
 
 /* { dg-final { scan-assembler "vst4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst4_laneu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst4_laneu32.c
@@ -17,4 +17,3 @@ void test_vst4_laneu32 (void)
 }
 
 /* { dg-final { scan-assembler "vst4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst4_laneu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst4_laneu8.c
@@ -17,4 +17,3 @@ void test_vst4_laneu8 (void)
 }
 
 /* { dg-final { scan-assembler "vst4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst4f32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst4f32.c
@@ -17,4 +17,3 @@ void test_vst4f32 (void)
 }
 
 /* { dg-final { scan-assembler "vst4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst4p16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst4p16.c
@@ -17,4 +17,3 @@ void test_vst4p16 (void)
 }
 
 /* { dg-final { scan-assembler "vst4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst4p64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst4p64.c
@@ -17,4 +17,3 @@ void test_vst4p64 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst4p8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst4p8.c
@@ -17,4 +17,3 @@ void test_vst4p8 (void)
 }
 
 /* { dg-final { scan-assembler "vst4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst4s16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst4s16.c
@@ -17,4 +17,3 @@ void test_vst4s16 (void)
 }
 
 /* { dg-final { scan-assembler "vst4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst4s32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst4s32.c
@@ -17,4 +17,3 @@ void test_vst4s32 (void)
 }
 
 /* { dg-final { scan-assembler "vst4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst4s64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst4s64.c
@@ -17,4 +17,3 @@ void test_vst4s64 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst4s8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst4s8.c
@@ -17,4 +17,3 @@ void test_vst4s8 (void)
 }
 
 /* { dg-final { scan-assembler "vst4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst4u16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst4u16.c
@@ -17,4 +17,3 @@ void test_vst4u16 (void)
 }
 
 /* { dg-final { scan-assembler "vst4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst4u32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst4u32.c
@@ -17,4 +17,3 @@ void test_vst4u32 (void)
 }
 
 /* { dg-final { scan-assembler "vst4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst4u64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst4u64.c
@@ -17,4 +17,3 @@ void test_vst4u64 (void)
 }
 
 /* { dg-final { scan-assembler "vst1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vst4u8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vst4u8.c
@@ -17,4 +17,3 @@ void test_vst4u8 (void)
 }
 
 /* { dg-final { scan-assembler "vst4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\(:\[0-9\]+\)?\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsubQf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsubQf32.c
@@ -18,4 +18,3 @@ void test_vsubQf32 (void)
 }
 
 /* { dg-final { scan-assembler "vsub\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsubQs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsubQs16.c
@@ -18,4 +18,3 @@ void test_vsubQs16 (void)
 }
 
 /* { dg-final { scan-assembler "vsub\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsubQs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsubQs32.c
@@ -18,4 +18,3 @@ void test_vsubQs32 (void)
 }
 
 /* { dg-final { scan-assembler "vsub\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsubQs64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsubQs64.c
@@ -18,4 +18,3 @@ void test_vsubQs64 (void)
 }
 
 /* { dg-final { scan-assembler "vsub\.i64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsubQs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsubQs8.c
@@ -18,4 +18,3 @@ void test_vsubQs8 (void)
 }
 
 /* { dg-final { scan-assembler "vsub\.i8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsubQu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsubQu16.c
@@ -18,4 +18,3 @@ void test_vsubQu16 (void)
 }
 
 /* { dg-final { scan-assembler "vsub\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsubQu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsubQu32.c
@@ -18,4 +18,3 @@ void test_vsubQu32 (void)
 }
 
 /* { dg-final { scan-assembler "vsub\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsubQu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsubQu64.c
@@ -18,4 +18,3 @@ void test_vsubQu64 (void)
 }
 
 /* { dg-final { scan-assembler "vsub\.i64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsubQu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsubQu8.c
@@ -18,4 +18,3 @@ void test_vsubQu8 (void)
 }
 
 /* { dg-final { scan-assembler "vsub\.i8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsubf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsubf32.c
@@ -18,4 +18,3 @@ void test_vsubf32 (void)
 }
 
 /* { dg-final { scan-assembler "vsub\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsubhns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsubhns16.c
@@ -18,4 +18,3 @@ void test_vsubhns16 (void)
 }
 
 /* { dg-final { scan-assembler "vsubhn\.i16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsubhns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsubhns32.c
@@ -18,4 +18,3 @@ void test_vsubhns32 (void)
 }
 
 /* { dg-final { scan-assembler "vsubhn\.i32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsubhns64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsubhns64.c
@@ -18,4 +18,3 @@ void test_vsubhns64 (void)
 }
 
 /* { dg-final { scan-assembler "vsubhn\.i64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsubhnu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsubhnu16.c
@@ -18,4 +18,3 @@ void test_vsubhnu16 (void)
 }
 
 /* { dg-final { scan-assembler "vsubhn\.i16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsubhnu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsubhnu32.c
@@ -18,4 +18,3 @@ void test_vsubhnu32 (void)
 }
 
 /* { dg-final { scan-assembler "vsubhn\.i32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsubhnu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsubhnu64.c
@@ -18,4 +18,3 @@ void test_vsubhnu64 (void)
 }
 
 /* { dg-final { scan-assembler "vsubhn\.i64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsubls16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsubls16.c
@@ -18,4 +18,3 @@ void test_vsubls16 (void)
 }
 
 /* { dg-final { scan-assembler "vsubl\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsubls32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsubls32.c
@@ -18,4 +18,3 @@ void test_vsubls32 (void)
 }
 
 /* { dg-final { scan-assembler "vsubl\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsubls8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsubls8.c
@@ -18,4 +18,3 @@ void test_vsubls8 (void)
 }
 
 /* { dg-final { scan-assembler "vsubl\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsublu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsublu16.c
@@ -18,4 +18,3 @@ void test_vsublu16 (void)
 }
 
 /* { dg-final { scan-assembler "vsubl\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsublu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsublu32.c
@@ -18,4 +18,3 @@ void test_vsublu32 (void)
 }
 
 /* { dg-final { scan-assembler "vsubl\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsublu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsublu8.c
@@ -18,4 +18,3 @@ void test_vsublu8 (void)
 }
 
 /* { dg-final { scan-assembler "vsubl\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsubs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsubs16.c
@@ -18,4 +18,3 @@ void test_vsubs16 (void)
 }
 
 /* { dg-final { scan-assembler "vsub\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsubs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsubs32.c
@@ -18,4 +18,3 @@ void test_vsubs32 (void)
 }
 
 /* { dg-final { scan-assembler "vsub\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsubs64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsubs64.c
@@ -17,4 +17,3 @@ void test_vsubs64 (void)
   out_int64x1_t = vsub_s64 (arg0_int64x1_t, arg1_int64x1_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsubs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsubs8.c
@@ -18,4 +18,3 @@ void test_vsubs8 (void)
 }
 
 /* { dg-final { scan-assembler "vsub\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsubu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsubu16.c
@@ -18,4 +18,3 @@ void test_vsubu16 (void)
 }
 
 /* { dg-final { scan-assembler "vsub\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsubu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsubu32.c
@@ -18,4 +18,3 @@ void test_vsubu32 (void)
 }
 
 /* { dg-final { scan-assembler "vsub\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsubu64.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsubu64.c
@@ -17,4 +17,3 @@ void test_vsubu64 (void)
   out_uint64x1_t = vsub_u64 (arg0_uint64x1_t, arg1_uint64x1_t);
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsubu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsubu8.c
@@ -18,4 +18,3 @@ void test_vsubu8 (void)
 }
 
 /* { dg-final { scan-assembler "vsub\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsubws16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsubws16.c
@@ -18,4 +18,3 @@ void test_vsubws16 (void)
 }
 
 /* { dg-final { scan-assembler "vsubw\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsubws32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsubws32.c
@@ -18,4 +18,3 @@ void test_vsubws32 (void)
 }
 
 /* { dg-final { scan-assembler "vsubw\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsubws8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsubws8.c
@@ -18,4 +18,3 @@ void test_vsubws8 (void)
 }
 
 /* { dg-final { scan-assembler "vsubw\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsubwu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsubwu16.c
@@ -18,4 +18,3 @@ void test_vsubwu16 (void)
 }
 
 /* { dg-final { scan-assembler "vsubw\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsubwu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsubwu32.c
@@ -18,4 +18,3 @@ void test_vsubwu32 (void)
 }
 
 /* { dg-final { scan-assembler "vsubw\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vsubwu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vsubwu8.c
@@ -18,4 +18,3 @@ void test_vsubwu8 (void)
 }
 
 /* { dg-final { scan-assembler "vsubw\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtbl1p8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtbl1p8.c
@@ -18,4 +18,3 @@ void test_vtbl1p8 (void)
 }
 
 /* { dg-final { scan-assembler "vtbl\.8\[ 	\]+\[dD\]\[0-9\]+, ((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtbl1s8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtbl1s8.c
@@ -18,4 +18,3 @@ void test_vtbl1s8 (void)
 }
 
 /* { dg-final { scan-assembler "vtbl\.8\[ 	\]+\[dD\]\[0-9\]+, ((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtbl1u8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtbl1u8.c
@@ -18,4 +18,3 @@ void test_vtbl1u8 (void)
 }
 
 /* { dg-final { scan-assembler "vtbl\.8\[ 	\]+\[dD\]\[0-9\]+, ((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtbl2p8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtbl2p8.c
@@ -18,4 +18,3 @@ void test_vtbl2p8 (void)
 }
 
 /* { dg-final { scan-assembler "vtbl\.8\[ 	\]+\[dD\]\[0-9\]+, \\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtbl2s8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtbl2s8.c
@@ -18,4 +18,3 @@ void test_vtbl2s8 (void)
 }
 
 /* { dg-final { scan-assembler "vtbl\.8\[ 	\]+\[dD\]\[0-9\]+, \\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtbl2u8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtbl2u8.c
@@ -18,4 +18,3 @@ void test_vtbl2u8 (void)
 }
 
 /* { dg-final { scan-assembler "vtbl\.8\[ 	\]+\[dD\]\[0-9\]+, \\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtbl3p8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtbl3p8.c
@@ -18,4 +18,3 @@ void test_vtbl3p8 (void)
 }
 
 /* { dg-final { scan-assembler "vtbl\.8\[ 	\]+\[dD\]\[0-9\]+, \\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtbl3s8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtbl3s8.c
@@ -18,4 +18,3 @@ void test_vtbl3s8 (void)
 }
 
 /* { dg-final { scan-assembler "vtbl\.8\[ 	\]+\[dD\]\[0-9\]+, \\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtbl3u8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtbl3u8.c
@@ -18,4 +18,3 @@ void test_vtbl3u8 (void)
 }
 
 /* { dg-final { scan-assembler "vtbl\.8\[ 	\]+\[dD\]\[0-9\]+, \\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtbl4p8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtbl4p8.c
@@ -18,4 +18,3 @@ void test_vtbl4p8 (void)
 }
 
 /* { dg-final { scan-assembler "vtbl\.8\[ 	\]+\[dD\]\[0-9\]+, \\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtbl4s8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtbl4s8.c
@@ -18,4 +18,3 @@ void test_vtbl4s8 (void)
 }
 
 /* { dg-final { scan-assembler "vtbl\.8\[ 	\]+\[dD\]\[0-9\]+, \\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtbl4u8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtbl4u8.c
@@ -18,4 +18,3 @@ void test_vtbl4u8 (void)
 }
 
 /* { dg-final { scan-assembler "vtbl\.8\[ 	\]+\[dD\]\[0-9\]+, \\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtbx1p8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtbx1p8.c
@@ -19,4 +19,3 @@ void test_vtbx1p8 (void)
 }
 
 /* { dg-final { scan-assembler "vtbx\.8\[ 	\]+\[dD\]\[0-9\]+, ((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtbx1s8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtbx1s8.c
@@ -19,4 +19,3 @@ void test_vtbx1s8 (void)
 }
 
 /* { dg-final { scan-assembler "vtbx\.8\[ 	\]+\[dD\]\[0-9\]+, ((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtbx1u8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtbx1u8.c
@@ -19,4 +19,3 @@ void test_vtbx1u8 (void)
 }
 
 /* { dg-final { scan-assembler "vtbx\.8\[ 	\]+\[dD\]\[0-9\]+, ((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtbx2p8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtbx2p8.c
@@ -19,4 +19,3 @@ void test_vtbx2p8 (void)
 }
 
 /* { dg-final { scan-assembler "vtbx\.8\[ 	\]+\[dD\]\[0-9\]+, \\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtbx2s8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtbx2s8.c
@@ -19,4 +19,3 @@ void test_vtbx2s8 (void)
 }
 
 /* { dg-final { scan-assembler "vtbx\.8\[ 	\]+\[dD\]\[0-9\]+, \\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtbx2u8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtbx2u8.c
@@ -19,4 +19,3 @@ void test_vtbx2u8 (void)
 }
 
 /* { dg-final { scan-assembler "vtbx\.8\[ 	\]+\[dD\]\[0-9\]+, \\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtbx3p8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtbx3p8.c
@@ -19,4 +19,3 @@ void test_vtbx3p8 (void)
 }
 
 /* { dg-final { scan-assembler "vtbx\.8\[ 	\]+\[dD\]\[0-9\]+, \\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtbx3s8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtbx3s8.c
@@ -19,4 +19,3 @@ void test_vtbx3s8 (void)
 }
 
 /* { dg-final { scan-assembler "vtbx\.8\[ 	\]+\[dD\]\[0-9\]+, \\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtbx3u8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtbx3u8.c
@@ -19,4 +19,3 @@ void test_vtbx3u8 (void)
 }
 
 /* { dg-final { scan-assembler "vtbx\.8\[ 	\]+\[dD\]\[0-9\]+, \\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtbx4p8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtbx4p8.c
@@ -19,4 +19,3 @@ void test_vtbx4p8 (void)
 }
 
 /* { dg-final { scan-assembler "vtbx\.8\[ 	\]+\[dD\]\[0-9\]+, \\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtbx4s8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtbx4s8.c
@@ -19,4 +19,3 @@ void test_vtbx4s8 (void)
 }
 
 /* { dg-final { scan-assembler "vtbx\.8\[ 	\]+\[dD\]\[0-9\]+, \\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtbx4u8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtbx4u8.c
@@ -19,4 +19,3 @@ void test_vtbx4u8 (void)
 }
 
 /* { dg-final { scan-assembler "vtbx\.8\[ 	\]+\[dD\]\[0-9\]+, \\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtrnQf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtrnQf32.c
@@ -18,4 +18,3 @@ void test_vtrnQf32 (void)
 }
 
 /* { dg-final { scan-assembler "vtrn\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtrnQp16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtrnQp16.c
@@ -18,4 +18,3 @@ void test_vtrnQp16 (void)
 }
 
 /* { dg-final { scan-assembler "vtrn\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtrnQp8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtrnQp8.c
@@ -18,4 +18,3 @@ void test_vtrnQp8 (void)
 }
 
 /* { dg-final { scan-assembler "vtrn\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtrnQs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtrnQs16.c
@@ -18,4 +18,3 @@ void test_vtrnQs16 (void)
 }
 
 /* { dg-final { scan-assembler "vtrn\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtrnQs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtrnQs32.c
@@ -18,4 +18,3 @@ void test_vtrnQs32 (void)
 }
 
 /* { dg-final { scan-assembler "vtrn\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtrnQs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtrnQs8.c
@@ -18,4 +18,3 @@ void test_vtrnQs8 (void)
 }
 
 /* { dg-final { scan-assembler "vtrn\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtrnQu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtrnQu16.c
@@ -18,4 +18,3 @@ void test_vtrnQu16 (void)
 }
 
 /* { dg-final { scan-assembler "vtrn\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtrnQu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtrnQu32.c
@@ -18,4 +18,3 @@ void test_vtrnQu32 (void)
 }
 
 /* { dg-final { scan-assembler "vtrn\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtrnQu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtrnQu8.c
@@ -18,4 +18,3 @@ void test_vtrnQu8 (void)
 }
 
 /* { dg-final { scan-assembler "vtrn\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtrnf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtrnf32.c
@@ -18,4 +18,3 @@ void test_vtrnf32 (void)
 }
 
 /* { dg-final { scan-assembler "vuzp\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtrnp16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtrnp16.c
@@ -18,4 +18,3 @@ void test_vtrnp16 (void)
 }
 
 /* { dg-final { scan-assembler "vtrn\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtrnp8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtrnp8.c
@@ -18,4 +18,3 @@ void test_vtrnp8 (void)
 }
 
 /* { dg-final { scan-assembler "vtrn\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtrns16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtrns16.c
@@ -18,4 +18,3 @@ void test_vtrns16 (void)
 }
 
 /* { dg-final { scan-assembler "vtrn\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtrns32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtrns32.c
@@ -18,4 +18,3 @@ void test_vtrns32 (void)
 }
 
 /* { dg-final { scan-assembler "vuzp\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtrns8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtrns8.c
@@ -18,4 +18,3 @@ void test_vtrns8 (void)
 }
 
 /* { dg-final { scan-assembler "vtrn\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtrnu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtrnu16.c
@@ -18,4 +18,3 @@ void test_vtrnu16 (void)
 }
 
 /* { dg-final { scan-assembler "vtrn\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtrnu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtrnu32.c
@@ -18,4 +18,3 @@ void test_vtrnu32 (void)
 }
 
 /* { dg-final { scan-assembler "vuzp\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtrnu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtrnu8.c
@@ -18,4 +18,3 @@ void test_vtrnu8 (void)
 }
 
 /* { dg-final { scan-assembler "vtrn\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtstQp8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtstQp8.c
@@ -18,4 +18,3 @@ void test_vtstQp8 (void)
 }
 
 /* { dg-final { scan-assembler "vtst\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtstQs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtstQs16.c
@@ -18,4 +18,3 @@ void test_vtstQs16 (void)
 }
 
 /* { dg-final { scan-assembler "vtst\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtstQs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtstQs32.c
@@ -18,4 +18,3 @@ void test_vtstQs32 (void)
 }
 
 /* { dg-final { scan-assembler "vtst\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtstQs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtstQs8.c
@@ -18,4 +18,3 @@ void test_vtstQs8 (void)
 }
 
 /* { dg-final { scan-assembler "vtst\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtstQu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtstQu16.c
@@ -18,4 +18,3 @@ void test_vtstQu16 (void)
 }
 
 /* { dg-final { scan-assembler "vtst\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtstQu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtstQu32.c
@@ -18,4 +18,3 @@ void test_vtstQu32 (void)
 }
 
 /* { dg-final { scan-assembler "vtst\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtstQu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtstQu8.c
@@ -18,4 +18,3 @@ void test_vtstQu8 (void)
 }
 
 /* { dg-final { scan-assembler "vtst\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtstp8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtstp8.c
@@ -18,4 +18,3 @@ void test_vtstp8 (void)
 }
 
 /* { dg-final { scan-assembler "vtst\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtsts16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtsts16.c
@@ -18,4 +18,3 @@ void test_vtsts16 (void)
 }
 
 /* { dg-final { scan-assembler "vtst\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtsts32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtsts32.c
@@ -18,4 +18,3 @@ void test_vtsts32 (void)
 }
 
 /* { dg-final { scan-assembler "vtst\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtsts8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtsts8.c
@@ -18,4 +18,3 @@ void test_vtsts8 (void)
 }
 
 /* { dg-final { scan-assembler "vtst\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtstu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtstu16.c
@@ -18,4 +18,3 @@ void test_vtstu16 (void)
 }
 
 /* { dg-final { scan-assembler "vtst\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtstu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtstu32.c
@@ -18,4 +18,3 @@ void test_vtstu32 (void)
 }
 
 /* { dg-final { scan-assembler "vtst\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vtstu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vtstu8.c
@@ -18,4 +18,3 @@ void test_vtstu8 (void)
 }
 
 /* { dg-final { scan-assembler "vtst\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vuzpQf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vuzpQf32.c
@@ -18,4 +18,3 @@ void test_vuzpQf32 (void)
 }
 
 /* { dg-final { scan-assembler "vuzp\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vuzpQp16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vuzpQp16.c
@@ -18,4 +18,3 @@ void test_vuzpQp16 (void)
 }
 
 /* { dg-final { scan-assembler "vuzp\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vuzpQp8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vuzpQp8.c
@@ -18,4 +18,3 @@ void test_vuzpQp8 (void)
 }
 
 /* { dg-final { scan-assembler "vuzp\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vuzpQs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vuzpQs16.c
@@ -18,4 +18,3 @@ void test_vuzpQs16 (void)
 }
 
 /* { dg-final { scan-assembler "vuzp\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vuzpQs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vuzpQs32.c
@@ -18,4 +18,3 @@ void test_vuzpQs32 (void)
 }
 
 /* { dg-final { scan-assembler "vuzp\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vuzpQs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vuzpQs8.c
@@ -18,4 +18,3 @@ void test_vuzpQs8 (void)
 }
 
 /* { dg-final { scan-assembler "vuzp\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vuzpQu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vuzpQu16.c
@@ -18,4 +18,3 @@ void test_vuzpQu16 (void)
 }
 
 /* { dg-final { scan-assembler "vuzp\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vuzpQu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vuzpQu32.c
@@ -18,4 +18,3 @@ void test_vuzpQu32 (void)
 }
 
 /* { dg-final { scan-assembler "vuzp\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vuzpQu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vuzpQu8.c
@@ -18,4 +18,3 @@ void test_vuzpQu8 (void)
 }
 
 /* { dg-final { scan-assembler "vuzp\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vuzpf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vuzpf32.c
@@ -18,4 +18,3 @@ void test_vuzpf32 (void)
 }
 
 /* { dg-final { scan-assembler "vuzp\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vuzpp16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vuzpp16.c
@@ -18,4 +18,3 @@ void test_vuzpp16 (void)
 }
 
 /* { dg-final { scan-assembler "vuzp\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vuzpp8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vuzpp8.c
@@ -18,4 +18,3 @@ void test_vuzpp8 (void)
 }
 
 /* { dg-final { scan-assembler "vuzp\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vuzps16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vuzps16.c
@@ -18,4 +18,3 @@ void test_vuzps16 (void)
 }
 
 /* { dg-final { scan-assembler "vuzp\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vuzps32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vuzps32.c
@@ -18,4 +18,3 @@ void test_vuzps32 (void)
 }
 
 /* { dg-final { scan-assembler "vuzp\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vuzps8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vuzps8.c
@@ -18,4 +18,3 @@ void test_vuzps8 (void)
 }
 
 /* { dg-final { scan-assembler "vuzp\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vuzpu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vuzpu16.c
@@ -18,4 +18,3 @@ void test_vuzpu16 (void)
 }
 
 /* { dg-final { scan-assembler "vuzp\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vuzpu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vuzpu32.c
@@ -18,4 +18,3 @@ void test_vuzpu32 (void)
 }
 
 /* { dg-final { scan-assembler "vuzp\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vuzpu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vuzpu8.c
@@ -18,4 +18,3 @@ void test_vuzpu8 (void)
 }
 
 /* { dg-final { scan-assembler "vuzp\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vzipQf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vzipQf32.c
@@ -18,4 +18,3 @@ void test_vzipQf32 (void)
 }
 
 /* { dg-final { scan-assembler "vzip\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vzipQp16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vzipQp16.c
@@ -18,4 +18,3 @@ void test_vzipQp16 (void)
 }
 
 /* { dg-final { scan-assembler "vzip\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vzipQp8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vzipQp8.c
@@ -18,4 +18,3 @@ void test_vzipQp8 (void)
 }
 
 /* { dg-final { scan-assembler "vzip\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vzipQs16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vzipQs16.c
@@ -18,4 +18,3 @@ void test_vzipQs16 (void)
 }
 
 /* { dg-final { scan-assembler "vzip\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vzipQs32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vzipQs32.c
@@ -18,4 +18,3 @@ void test_vzipQs32 (void)
 }
 
 /* { dg-final { scan-assembler "vzip\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vzipQs8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vzipQs8.c
@@ -18,4 +18,3 @@ void test_vzipQs8 (void)
 }
 
 /* { dg-final { scan-assembler "vzip\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vzipQu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vzipQu16.c
@@ -18,4 +18,3 @@ void test_vzipQu16 (void)
 }
 
 /* { dg-final { scan-assembler "vzip\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vzipQu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vzipQu32.c
@@ -18,4 +18,3 @@ void test_vzipQu32 (void)
 }
 
 /* { dg-final { scan-assembler "vzip\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vzipQu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vzipQu8.c
@@ -18,4 +18,3 @@ void test_vzipQu8 (void)
 }
 
 /* { dg-final { scan-assembler "vzip\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vzipf32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vzipf32.c
@@ -18,4 +18,3 @@ void test_vzipf32 (void)
 }
 
 /* { dg-final { scan-assembler "vuzp\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vzipp16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vzipp16.c
@@ -18,4 +18,3 @@ void test_vzipp16 (void)
 }
 
 /* { dg-final { scan-assembler "vzip\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vzipp8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vzipp8.c
@@ -18,4 +18,3 @@ void test_vzipp8 (void)
 }
 
 /* { dg-final { scan-assembler "vzip\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vzips16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vzips16.c
@@ -18,4 +18,3 @@ void test_vzips16 (void)
 }
 
 /* { dg-final { scan-assembler "vzip\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vzips32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vzips32.c
@@ -18,4 +18,3 @@ void test_vzips32 (void)
 }
 
 /* { dg-final { scan-assembler "vuzp\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vzips8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vzips8.c
@@ -18,4 +18,3 @@ void test_vzips8 (void)
 }
 
 /* { dg-final { scan-assembler "vzip\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vzipu16.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vzipu16.c
@@ -18,4 +18,3 @@ void test_vzipu16 (void)
 }
 
 /* { dg-final { scan-assembler "vzip\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vzipu32.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vzipu32.c
@@ -18,4 +18,3 @@ void test_vzipu32 (void)
 }
 
 /* { dg-final { scan-assembler "vuzp\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/neon/vzipu8.c
+++ b/src/gcc/testsuite/gcc.target/arm/neon/vzipu8.c
@@ -18,4 +18,3 @@ void test_vzipu8 (void)
 }
 
 /* { dg-final { scan-assembler "vzip\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/no-volatile-in-it.c
+++ b/src/gcc/testsuite/gcc.target/arm/no-volatile-in-it.c
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
 /* { dg-require-effective-target arm_thumb2_ok } */
+/* { dg-skip-if "do not override -mcpu" { *-*-* } { "-march=*" "-mcpu=*" } { "-mcpu=cortex-m7" } } */
 /* { dg-options "-Os -mthumb -mcpu=cortex-m7" } */
 
 int
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/arm/pr26702.c
@@ -0,0 +1,4 @@
+/* { dg-do compile { target arm*-*-eabi* } } */
+/* { dg-final { scan-assembler "\\.size\[\\t \]+static_foo, 4" } } */
+int foo;
+static int static_foo;
--- a/src/gcc/testsuite/gcc.target/arm/pr42172-1.c
+++ b/src/gcc/testsuite/gcc.target/arm/pr42172-1.c
@@ -16,4 +16,4 @@ void init_A (struct A *this)
   this->f4 = 0;
 }
 
-/* { dg-final { scan-assembler-times "ldr" 1 } } */
+/* { dg-final { scan-assembler-times "str" 1 } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/arm/pr43404.c
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target naked_functions } */
+/* { dg-options "-O0" } */
+
+__attribute__ ((naked))
+void __data_abort(void)
+{
+  long foo; /* { dg-error "cannot allocate stack for variable" } */
+  long* bar = &foo;
+}
--- a/src/gcc/testsuite/gcc.target/arm/pr43597.c
+++ b/src/gcc/testsuite/gcc.target/arm/pr43597.c
@@ -25,4 +25,3 @@ foo4 ()
 /* { dg-final { scan-assembler-times "sub" 1 } } */
 /* { dg-final { scan-assembler-times "cmp" 0 } } */
 /* { dg-final { object-size text <= 30 } } */
-/* { dg-final { cleanup-saved-temps "pr43597" } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/arm/pr48470.c
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target naked_functions } */
+/* { dg-options "-O0" } */
+
+extern void g(int *x);
+
+void __attribute__((naked)) f(void)
+{
+    int x = 0; /* { dg-error "cannot allocate stack for variable" } */
+    g(&x);
+}
--- a/src/gcc/testsuite/gcc.target/arm/pr58784.c
+++ b/src/gcc/testsuite/gcc.target/arm/pr58784.c
@@ -1,6 +1,8 @@
 /* { dg-do compile } */
 /* { dg-skip-if "incompatible options" { arm_thumb1 } { "*" } { "" } } */
 /* { dg-options "-march=armv7-a -mfloat-abi=hard -mfpu=neon -marm -O2" } */
+/* { dg-skip-if "need hardfp ABI" { *-*-* } { "-mfloat-abi=soft" } { "" } } */
+
 
 typedef struct __attribute__ ((__packed__))
 {
--- a/src/gcc/testsuite/gcc.target/arm/pr59985.C
+++ b/src/gcc/testsuite/gcc.target/arm/pr59985.C
@@ -1,6 +1,7 @@
 /* { dg-do compile } */
 /* { dg-skip-if "incompatible options" { arm_thumb1 } { "*" } { "" } } */
 /* { dg-options "-g -fcompare-debug -O2 -march=armv7-a -mtune=cortex-a9 -mfpu=vfpv3-d16 -mfloat-abi=hard" } */
+/* { dg-skip-if "need hardfp abi" { *-*-* } { "-mfloat-abi=soft" } { "" } } */
 
 extern void *f1 (unsigned long, unsigned long);
 extern const struct line_map *f2 (void *, int, unsigned int, const char *, unsigned int);
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/arm/pr64208.c
@@ -0,0 +1,25 @@
+/* { dg-do compile } */
+/* { dg-skip-if "Test is specific to the iWMMXt" { arm*-*-* } { "-mcpu=*" } { "-mcpu=iwmmxt" } } */
+/* { dg-skip-if "Test is specific to the iWMMXt" { arm*-*-* } { "-mabi=*" } { "-mabi=iwmmxt" } } */
+/* { dg-skip-if "Test is specific to the iWMMXt" { arm*-*-* } { "-march=*" } { "-march=iwmmxt" } } */
+/* { dg-skip-if "Test is specific to ARM mode" { arm*-*-* } { "-mthumb" } { "" } } */
+/* { dg-require-effective-target arm32 } */
+/* { dg-require-effective-target arm_iwmmxt_ok } */
+/* { dg-options "-O1 -mcpu=iwmmxt" } */
+
+long long x6(void);
+void x7(long long, long long);
+void x8(long long);
+
+int x0;
+long long *x1;
+
+void x2(void) {
+  long long *x3 = x1;
+  while (x1) {
+    long long x4 = x0, x5 = x6();
+    x7(x4, x5);
+    x8(x5);
+    *x3 = 0;
+  }
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/arm/pr64616.c
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-rtl-cprop2" } */
+
+int f (int);
+unsigned int glob;
+
+void
+g ()
+{
+  while (f (glob));
+  glob = 5;
+}
+
+/* { dg-final { scan-rtl-dump "GLOBAL COPY-PROP" "cprop2" } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/arm/pr64744-1.c
@@ -0,0 +1,40 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target naked_functions } */
+/* { dg-options "-O0" } */
+
+__attribute__((naked))
+void foo1 ()
+{
+  int aa = 0;
+  int ab = {0};
+}
+
+__attribute__((naked))
+void foo2() {
+  char aa [ ] = {}; /* { dg-error "cannot allocate stack for variable" } */
+  char ab [1] = {};
+  char ac [2] = {}; /* { dg-error "cannot allocate stack for variable" } */
+  char ad [3] = {}; /* { dg-error "cannot allocate stack for variable" } */
+}
+
+__attribute__((naked))
+void foo3() {
+  char aa [1] = {0};
+  char ab [2] = {0}; /* { dg-error "cannot allocate stack for variable" } */
+  char ac [3] = {0}; /* { dg-error "cannot allocate stack for variable" } */
+  char ad [4] = {0}; /* { dg-error "cannot allocate stack for variable" } */
+}
+
+__attribute__((naked))
+void foo4() {
+  char aa [2] = {0,0}; /* { dg-error "cannot allocate stack for variable" } */
+}
+__attribute__((naked))
+void foo5() {
+  char aa [3] = {0,0,0}; /* { dg-error "cannot allocate stack for variable" } */
+}
+
+__attribute__((naked))
+void foo6() {
+  char aa [4] = {0,0,0,0}; /* { dg-error "cannot allocate stack for variable" } */
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/arm/pr64744-2.c
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target naked_functions } */
+/* { dg-options "-O0" } */
+
+struct s {
+  char a;
+    int b;
+};
+
+__attribute__((naked))
+void foo () {
+  struct s x = {}; /* { dg-error "cannot allocate stack for variable" } */
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/arm/pr64818.c
@@ -0,0 +1,30 @@
+/* { dg-do compile } */
+/* { dg-options "-O1" } */
+
+char temp[16];
+extern int foo1 (void);
+
+void foo (void)
+{
+  int i;
+  int len;
+
+  while (1)
+  {
+    len = foo1 ();
+    register int a asm ("r0") = 5;
+    register char *b asm ("r1") = temp;
+    register int c asm ("r2") = len;
+    asm volatile ("mov %[r0], %[r0]\n  mov %[r1], %[r1]\n  mov %[r2], %[r2]\n"
+		   : "+m"(*b)
+		   : [r0]"r"(a), [r1]"r"(b), [r2]"r"(c));
+
+    for (i = 0; i < len; i++)
+    {
+      if (temp[i] == 10)
+      return;
+    }
+  }
+}
+
+/* { dg-final { scan-assembler "\[\\t \]+mov\ r1,\ r1" } } */
--- a/src/gcc/testsuite/gcc.target/arm/pr65067.c
+++ b/src/gcc/testsuite/gcc.target/arm/pr65067.c
@@ -1,4 +1,5 @@
 /* { dg-do compile } */
+/* { dg-require-effective-target arm_thumb2_ok } */
 /* { dg-options "-mthumb -mcpu=cortex-m3 -O2" } */
 
 struct tmp {
--- a/src/gcc/testsuite/gcc.target/arm/pr65647.c
+++ b/src/gcc/testsuite/gcc.target/arm/pr65647.c
@@ -1,4 +1,6 @@
 /* { dg-do compile } */
+/* { dg-require-effective-target arm_arch_v6m_ok } */
+/* { dg-skip-if "do not override -mfloat-abi" { *-*-* } { "-mfloat-abi=*" } {"-mfloat-abi=soft" } } */
 /* { dg-options "-march=armv6-m -mthumb -O3 -w -mfloat-abi=soft" } */
 
 a, b, c, e, g = &e, h, i = 7, l = 1, m, n, o, q = &m, r, s = &r, u, w = 9, x,
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/arm/pr65710.c
@@ -0,0 +1,120 @@
+/* { dg-do compile } */
+/* { dg-skip-if "do not override -mfloat-abi" { *-*-* } { "-mfloat-abi=*" } {"-mfloat-abi=soft" } } */
+/* { dg-options "-mthumb -O2 -mfloat-abi=soft -w" } */
+/* { dg-skip-if "" { ! { arm_thumb1_ok || arm_thumb2_ok } } } */
+
+struct ST {
+  char *buffer;
+  int used;
+};
+
+struct ST *h;
+
+enum { no_op, duplicate, pop_failure_jump, dummy_failure_jump };
+
+typedef struct {
+  unsigned pointer;
+} byte_fail_stack_elt_t;
+
+typedef struct { unsigned avail; } byte_fail_stack_type;
+
+typedef union {
+  byte_fail_stack_elt_t word;
+  struct {
+    unsigned match_null_string_p : 2;
+    unsigned is_active : 1;
+    unsigned ever_matched_something : 1;
+  } bits;
+} byte_register_info_type;
+
+static int a;
+int b = 0;
+int c, e, f;
+int *d, *g;
+
+int
+byte_re_match_2_internal_size2(const int p2, int p3, const int p4) {
+  int i, p;
+  char *j;
+  char k, l, m, n = h;
+  byte_fail_stack_type o;
+  byte_fail_stack_elt_t *q;
+  unsigned int s = (unsigned int)h;
+  long t, u;
+  char **v, *w, **x, **y, **t1;
+  byte_register_info_type *z, *t2 = __builtin_alloca(s);
+  x = __builtin_alloca(s);
+  y = __builtin_alloca(s);
+  z = __builtin_alloca(sizeof(byte_register_info_type));
+  k = p4 + byte_re_match_2_internal_size2;
+  if (p3)
+    f = p4;
+  for (;;) {
+    if (h == h->used) {
+      g = f;
+      if (o.avail) {
+        b = 1;
+        for (; i < s; i++)
+          t1[i] = w;
+        goto fail;
+      }
+      e = 30 > s;
+      d = p4;
+      d[s] = 1;
+      return;
+    }
+    switch (*h->buffer++) {
+    case no_op:
+      while (m && n ?: *g)
+        ;
+      y[*h->buffer] = z[*h->buffer].bits.match_null_string_p ? w == &a ?: w : w;
+      w = g;
+      if (t) {
+        char r = h;
+        while (r && z[r].bits.is_active)
+          r--;
+        if (r == 0)
+          ;
+        else
+          u = r;
+      }
+      switch (*j++)
+      case dummy_failure_jump:
+      i = j;
+      if (i)
+        if (z[*h->buffer].bits.ever_matched_something) {
+          unsigned r;
+          z[*h->buffer].bits.ever_matched_something = r = *h->buffer;
+          for (; r + *(h->buffer + 1); r++) {
+            v = x[r];
+            w[r] = y[r];
+          }
+        }
+      break;
+    case duplicate: {
+      char *t3 = p2 + p3;
+      if (t3)
+        break;
+    }
+      if ((p3 ?: p4) == k)
+        goto fail;
+    case pop_failure_jump:
+      for (; c; c--)
+        t2[c].word = q[o.avail];
+      char t4;
+      q = t4 = __builtin_allocamemcpy(t4 ?: (p <<= 1));
+    }
+    continue;
+  fail : {
+    unsigned t5;
+    t = q;
+    t5 = u;
+    for (; t5 >= t; t5--)
+      v[t5] = q[--o.avail].pointer;
+    switch (*h->buffer)
+    case pop_failure_jump:
+    goto fail;
+  }
+    m = &l;
+  }
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/arm/pr65729.c
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_hard_vfp_ok } */
+/* { dg-options "-O2 -march=armv7-a -mfloat-abi=hard -mfpu=vfpv3-d16" } */
+
+int foo (void)
+{
+  double x = 0.0;
+  asm volatile ("" : "+gw" (x));
+  return x;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/arm/pr65924.c
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_thumb2_ok } */
+/* { dg-options "-O2 -mthumb" } */
+
+int a, b, c;
+int fn1() {
+  if (b + a < 0)
+    c = 0;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/arm/pr67756.c
@@ -0,0 +1,64 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_hard_vfp_ok } */
+/* { dg-options "-O2 -mapcs -march=armv7-a -mfloat-abi=hard -mfpu=vfpv3-d16" } */
+
+int inode_permission (), try_break_deleg ();
+int mutex_lock (), mutex_unlock ();
+struct mutex
+{
+};
+struct dentry
+{
+  struct inode *d_inode;
+};
+struct inode
+{
+  const struct inode_operations *i_op;
+  struct super_block *i_sb;
+    union
+    {
+      const unsigned int i_nlink;
+    };
+  unsigned long i_state;
+  struct mutex i_mutex;
+};
+struct super_block
+{
+  unsigned int s_max_links;
+};
+struct inode_operations
+{
+  int (*link) (struct dentry *, struct inode *, struct dentry *);
+} __attribute__ ((__aligned__ ((1 << 6))));
+static inline __attribute__ ((always_inline))
+__attribute__ ((no_instrument_function))
+int may_create (struct inode *dir, struct dentry *child)
+{
+  if (child->d_inode)
+    return -17;
+  return inode_permission (dir, 0x00000002 | 0x00000001);
+}
+
+int
+vfs_link (struct dentry *old_dentry, struct inode *dir,
+	  struct dentry *new_dentry, struct inode **delegated_inode)
+{
+  struct inode *inode = old_dentry->d_inode;
+  unsigned max_links = dir->i_sb->s_max_links;
+  int error;
+  error = may_create (dir, new_dentry);
+  if (error)
+    return error;
+  mutex_lock (&inode->i_mutex);
+  if (inode->i_nlink == 0 && !(inode->i_state & (1 << 10)))
+    error = -2;
+  else if (max_links && inode->i_nlink >= max_links)
+    error = -31;
+  else
+    {
+      error = try_break_deleg (inode, delegated_inode);
+      error = dir->i_op->link (old_dentry, dir, new_dentry);
+    }
+  mutex_unlock (&inode->i_mutex);
+  return error;
+}
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/arm/pragma_attribute.c
@@ -0,0 +1,35 @@
+/* Test for #prama target macros.  */
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_thumb1_ok } */
+
+#pragma GCC target ("thumb")
+
+#ifndef __thumb__
+#error "__thumb__ is not defined"
+#endif
+
+#ifdef __thumb2__
+#ifndef __ARM_32BIT_STATE
+#error  "__ARM_32BIT_STATE is not defined"
+#endif
+#else /* thumb1 */
+#ifdef __ARM_32BIT_STATE
+#error  "__ARM_32BIT_STATE is defined"
+#endif
+#endif /* thumb1 */
+
+#pragma GCC target ("arm")
+
+#ifdef __thumb__
+#error "__thumb__ is defined"
+#endif
+
+#if defined (__thumb2__) || defined (__thumb1__)
+#error "thumb is defined"
+#endif 
+
+#ifndef __ARM_32BIT_STATE
+#error  "__ARM_32BIT_STATE is not defined"
+#endif
+
+#pragma GCC reset_options
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/arm/reg_equal_test.c
@@ -0,0 +1,24 @@
+/* { dg-do compile } */
+/* { dg-options "-O1 -fdump-rtl-expand" } */
+
+extern void abort (void);
+unsigned int a = 1;
+
+int
+main (void)
+{
+  unsigned int b, c, d;
+
+  if (sizeof (int) != 4 || (int) 0xc7d24b5e > 0)
+    return 0;
+
+  c = 0xc7d24b5e;
+  d = a | -2;
+  b = (d == 0) ? c : (c % d);
+  if (b != c)
+    abort ();
+
+  return 0;
+}
+
+/* { dg-final { scan-rtl-dump "expr_list:REG_EQUAL \\(const_int -942519458" "expand" } } */
--- a/src/gcc/testsuite/gcc.target/arm/scd42-1.c
+++ b/src/gcc/testsuite/gcc.target/arm/scd42-1.c
@@ -1,7 +1,8 @@
 /* Verify that mov is preferred on XScale for loading a 1 byte constant. */
 /* { dg-do compile } */
 /* { dg-skip-if "incompatible options" { arm*-*-* } { "-march=*" } { "" } } */
-/* { dg-options "-mcpu=xscale -O" } */
+/* { dg-skip-if "do not override -mfloat-abi" { *-*-* } { "-mfloat-abi=*" } { "-mfloat-abi=softfp" } } */
+/* { dg-options "-mcpu=xscale -O -mfloat-abi=softfp" } */
 
 unsigned load1(void) __attribute__ ((naked));
 unsigned load1(void)
--- a/src/gcc/testsuite/gcc.target/arm/scd42-3.c
+++ b/src/gcc/testsuite/gcc.target/arm/scd42-3.c
@@ -2,7 +2,8 @@
 /* { dg-do compile } */
 /* { dg-skip-if "Test is specific to Xscale" { arm*-*-* } { "-march=*" } { "-march=xscale" } } */
 /* { dg-skip-if "Test is specific to Xscale" { arm*-*-* } { "-mcpu=*" } { "-mcpu=xscale" } } */
-/* { dg-options "-mcpu=xscale -O" } */
+/* { dg-skip-if "do not override -mfloat-abi" { *-*-* } { "-mfloat-abi=*" } { "-mfloat-abi=softfp" } } */
+/* { dg-options "-mcpu=xscale -O -mfloat-abi=softfp" } */
 
 unsigned load4(void) __attribute__ ((naked));
 unsigned load4(void)
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/arm/short-it-ifcvt-1.c
@@ -0,0 +1,23 @@
+/* Test that ifcvt is not being too aggressive when -mrestrict-it.  */
+/* { dg-do compile } */
+/* { dg-options "-O2 -mrestrict-it" } */
+/* { dg-require-effective-target arm_thumb2_ok } */
+
+int
+f1(int x, int y, int z)
+{
+  if (x > 100)
+    {
+      x++;
+      z = -z;
+    }
+  else
+    {
+      x = -x;
+      y = -y;
+      z = 1;
+    }
+  return x + y + z;
+}
+
+/* { dg-final { scan-assembler "b(gt|le)" } } */
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/arm/short-it-ifcvt-2.c
@@ -0,0 +1,21 @@
+/* Test that ifcvt is not being too aggressive when -mrestrict-it.  */
+/* { dg-do compile } */
+/* { dg-options "-O2 -mrestrict-it" } */
+/* { dg-require-effective-target arm_thumb2_ok } */
+
+int
+f1(int x, int y, int z)
+{
+  if (x > 100)
+    {
+      x++;
+      z = -z;
+    }
+  else
+    {
+      x = -x;
+      y = -y;
+    }
+  return x + y + z;
+}
+/* { dg-final { scan-assembler "b(gt|le)" } } */
--- a/src/gcc/testsuite/gcc.target/arm/sibcall-2.c
+++ b/src/gcc/testsuite/gcc.target/arm/sibcall-2.c
@@ -1,5 +1,5 @@
-/* { dg-require-effective-target arm_eabi } */
 /* { dg-do compile } */
+/* { dg-require-effective-target arm_eabi } */
 /* { dg-options "-O2 -mabi=aapcs" } */
 
 
--- a/src/gcc/testsuite/gcc.target/arm/simd/neon-vrndx_f32_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/neon-vrndx_f32_1.c
@@ -14,4 +14,3 @@ test_vrndx_f32 (float32x2_t in)
 }
 
 /* { dg-final { scan-assembler "vrintx\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/neon-vrndxq_f32_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/neon-vrndxq_f32_1.c
@@ -14,4 +14,3 @@ test_vrndxq_f32 (float32x4_t in)
 }
 
 /* { dg-final { scan-assembler "vrintx\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/simd.exp
+++ b/src/gcc/testsuite/gcc.target/arm/simd/simd.exp
@@ -27,9 +27,22 @@ load_lib gcc-dg.exp
 # Initialize `dg'.
 dg-init
 
+# If the target hardware supports NEON, the default action is "run", otherwise
+# just "compile".
+global dg-do-what-default
+set save-dg-do-what-default ${dg-do-what-default}
+if {![check_effective_target_arm_neon_ok]} then {
+  return
+} elseif {[is-effective-target arm_neon_hw]} then {
+  set dg-do-what-default run
+} else {
+  set dg-do-what-default compile
+}
+
 # Main loop.
 dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.\[cCS\]]] \
 	"" ""
 
 # All done.
+set dg-do-what-default ${save-dg-do-what-default}
 dg-finish
--- a/src/gcc/testsuite/gcc.target/arm/simd/vextQf32_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vextQf32_1.c
@@ -1,7 +1,5 @@
 /* Test the `vextQf32' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O3 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/extq_f32.x"
 
 /* { dg-final { scan-assembler-times "vext\.32\[ \t\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 3 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vextQp16_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vextQp16_1.c
@@ -1,7 +1,5 @@
 /* Test the `vextQp16' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O3 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/extq_p16.x"
 
 /* { dg-final { scan-assembler-times "vext\.16\[ \t\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 7 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vextQp64_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vextQp64_1.c
@@ -1,6 +1,5 @@
 /* Test the `vextQp64' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
 /* { dg-require-effective-target arm_crypto_ok } */
 /* { dg-options "-save-temps -O3 -fno-inline" } */
 /* { dg-add-options arm_crypto } */
@@ -30,4 +29,3 @@ main (int argc, char **argv)
 }
 
 /* { dg-final { scan-assembler-times "vext\.64\[ \t\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vextQp8_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vextQp8_1.c
@@ -1,7 +1,5 @@
 /* Test the `vextQp8' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O3 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/extq_p8.x"
 
 /* { dg-final { scan-assembler-times "vext\.8\[ \t\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 15 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vextQs16_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vextQs16_1.c
@@ -1,7 +1,5 @@
 /* Test the `vextQs16' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O3 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/extq_s16.x"
 
 /* { dg-final { scan-assembler-times "vext\.16\[ \t\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 7 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vextQs32_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vextQs32_1.c
@@ -1,7 +1,5 @@
 /* Test the `vextQs32' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O3 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/extq_s32.x"
 
 /* { dg-final { scan-assembler-times "vext\.32\[ \t\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 3 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vextQs64_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vextQs64_1.c
@@ -1,7 +1,5 @@
 /* Test the `vextQs64' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O3 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/extq_s64.x"
 
 /* { dg-final { scan-assembler-times "vext\.64\[ \t\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vextQs8_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vextQs8_1.c
@@ -1,7 +1,5 @@
 /* Test the `vextQs8' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O3 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/extq_s8.x"
 
 /* { dg-final { scan-assembler-times "vext\.8\[ \t\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 15 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vextQu16_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vextQu16_1.c
@@ -1,7 +1,5 @@
 /* Test the `vextQu16' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O3 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/extq_u16.x"
 
 /* { dg-final { scan-assembler-times "vext\.16\[ \t\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 7 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vextQu32_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vextQu32_1.c
@@ -1,7 +1,5 @@
 /* Test the `vextQu32' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O3 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/extq_u32.x"
 
 /* { dg-final { scan-assembler-times "vext\.32\[ \t\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 3 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vextQu64_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vextQu64_1.c
@@ -1,7 +1,5 @@
 /* Test the `vextQu64' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O3 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/extq_u64.x"
 
 /* { dg-final { scan-assembler-times "vext\.64\[ \t\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vextQu8_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vextQu8_1.c
@@ -1,7 +1,5 @@
 /* Test the `vextQu8' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O3 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/extq_u8.x"
 
 /* { dg-final { scan-assembler-times "vext\.8\[ \t\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 15 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vextf32_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vextf32_1.c
@@ -1,7 +1,5 @@
 /* Test the `vextf32' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O3 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/ext_f32.x"
 
 /* { dg-final { scan-assembler-times "vext\.32\[ \t\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vextp16_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vextp16_1.c
@@ -1,7 +1,5 @@
 /* Test the `vextp16' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O3 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/ext_p16.x"
 
 /* { dg-final { scan-assembler-times "vext\.16\[ \t\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 3 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vextp64_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vextp64_1.c
@@ -1,6 +1,5 @@
 /* Test the `vextp64' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
 /* { dg-require-effective-target arm_crypto_ok } */
 /* { dg-options "-save-temps -O3 -fno-inline" } */
 /* { dg-add-options arm_crypto } */
@@ -22,5 +21,4 @@ main (int argc, char **argv)
   return 0;
 }
 
-/* Don't scan assembler for vext - it can be optimized into a move from r0.
-/* { dg-final { cleanup-saved-temps } } */
+/* Don't scan assembler for vext - it can be optimized into a move from r0. */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vextp8_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vextp8_1.c
@@ -1,7 +1,5 @@
 /* Test the `vextp8' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O3 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/ext_p8.x"
 
 /* { dg-final { scan-assembler-times "vext\.8\[ \t\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 7 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vexts16_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vexts16_1.c
@@ -1,7 +1,5 @@
 /* Test the `vexts16' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O3 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/ext_s16.x"
 
 /* { dg-final { scan-assembler-times "vext\.16\[ \t\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 3 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vexts32_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vexts32_1.c
@@ -1,7 +1,5 @@
 /* Test the `vexts32' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O3 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/ext_s32.x"
 
 /* { dg-final { scan-assembler-times "vext\.32\[ \t\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vexts64_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vexts64_1.c
@@ -1,7 +1,5 @@
 /* Test the `vexts64' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O3 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -24,4 +22,3 @@ main (int argc, char **argv)
 }
 
 /* Don't scan assembler for vext - it can be optimized into a move from r0.  */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vexts8_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vexts8_1.c
@@ -1,7 +1,5 @@
 /* Test the `vexts8' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O3 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/ext_s8.x"
 
 /* { dg-final { scan-assembler-times "vext\.8\[ \t\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 7 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vextu16_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vextu16_1.c
@@ -1,7 +1,5 @@
 /* Test the `vextu16' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O3 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/ext_u16.x"
 
 /* { dg-final { scan-assembler-times "vext\.16\[ \t\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 3 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vextu32_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vextu32_1.c
@@ -1,7 +1,5 @@
 /* Test the `vextu32' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O3 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/ext_u32.x"
 
 /* { dg-final { scan-assembler-times "vext\.32\[ \t\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vextu64_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vextu64_1.c
@@ -1,7 +1,5 @@
 /* Test the `vextu64' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O3 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -24,4 +22,3 @@ main (int argc, char **argv)
 }
 
 /* Don't scan assembler for vext - it can be optimized into a move from r0.  */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vextu8_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vextu8_1.c
@@ -1,7 +1,5 @@
 /* Test the `vextu8' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O3 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/ext_u8.x"
 
 /* { dg-final { scan-assembler-times "vext\.8\[ \t\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 7 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vrev16p8_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vrev16p8_1.c
@@ -1,7 +1,5 @@
 /* Test the `vrev16p8' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vrev16p8.x"
 
 /* { dg-final { scan-assembler "vrev16\.8\[ \t\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vrev16qp8_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vrev16qp8_1.c
@@ -1,7 +1,5 @@
 /* Test the `vrev16q_p8' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vrev16qp8.x"
 
 /* { dg-final { scan-assembler "vrev16\.8\[ \t\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vrev16qs8_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vrev16qs8_1.c
@@ -1,7 +1,5 @@
 /* Test the `vrev16q_s8' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vrev16qs8.x"
 
 /* { dg-final { scan-assembler "vrev16\.8\[ \t\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vrev16qu8_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vrev16qu8_1.c
@@ -1,7 +1,5 @@
 /* Test the `vrev16q_u8' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vrev16qu8.x"
 
 /* { dg-final { scan-assembler "vrev16\.8\[ \t\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vrev16s8_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vrev16s8_1.c
@@ -1,7 +1,5 @@
 /* Test the `vrev16s8' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vrev16s8.x"
 
 /* { dg-final { scan-assembler "vrev16\.8\[ \t\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vrev16u8_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vrev16u8_1.c
@@ -1,7 +1,5 @@
 /* Test the `vrev16u8' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vrev16u8.x"
 
 /* { dg-final { scan-assembler "vrev16\.8\[ \t\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vrev32p16_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vrev32p16_1.c
@@ -1,7 +1,5 @@
 /* Test the `vrev32p16' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vrev32p16.x"
 
 /* { dg-final { scan-assembler "vrev32\.16\[ \t\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vrev32p8_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vrev32p8_1.c
@@ -1,7 +1,5 @@
 /* Test the `vrev32p8' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vrev32p8.x"
 
 /* { dg-final { scan-assembler "vrev32\.8\[ \t\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vrev32qp16_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vrev32qp16_1.c
@@ -1,7 +1,5 @@
 /* Test the `vrev32q_p16' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vrev32qp16.x"
 
 /* { dg-final { scan-assembler "vrev32\.16\[ \t\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vrev32qp8_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vrev32qp8_1.c
@@ -1,7 +1,5 @@
 /* Test the `vrev32q_p8' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vrev32qp8.x"
 
 /* { dg-final { scan-assembler "vrev32\.8\[ \t\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vrev32qs16_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vrev32qs16_1.c
@@ -1,7 +1,5 @@
 /* Test the `vrev32q_s16' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vrev32qs16.x"
 
 /* { dg-final { scan-assembler "vrev32\.16\[ \t\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vrev32qs8_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vrev32qs8_1.c
@@ -1,7 +1,5 @@
 /* Test the `vrev32q_s8' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vrev32qs8.x"
 
 /* { dg-final { scan-assembler "vrev32\.8\[ \t\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vrev32qu16_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vrev32qu16_1.c
@@ -1,7 +1,5 @@
 /* Test the `vrev32q_u16' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vrev32qu16.x"
 
 /* { dg-final { scan-assembler "vrev32\.16\[ \t\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vrev32qu8_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vrev32qu8_1.c
@@ -1,7 +1,5 @@
 /* Test the `vrev32q_u8' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vrev32qu8.x"
 
 /* { dg-final { scan-assembler "vrev32\.8\[ \t\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vrev32s16_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vrev32s16_1.c
@@ -1,7 +1,5 @@
 /* Test the `vrev32s16' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vrev32s16.x"
 
 /* { dg-final { scan-assembler "vrev32\.16\[ \t\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vrev32s8_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vrev32s8_1.c
@@ -1,7 +1,5 @@
 /* Test the `vrev32s8' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vrev32s8.x"
 
 /* { dg-final { scan-assembler "vrev32\.8\[ \t\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vrev32u16_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vrev32u16_1.c
@@ -1,7 +1,5 @@
 /* Test the `vrev32u16' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vrev32u16.x"
 
 /* { dg-final { scan-assembler "vrev32\.16\[ \t\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vrev32u8_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vrev32u8_1.c
@@ -1,7 +1,5 @@
 /* Test the `vrev32u8' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vrev32u8.x"
 
 /* { dg-final { scan-assembler "vrev32\.8\[ \t\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vrev64f32_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vrev64f32_1.c
@@ -1,7 +1,5 @@
 /* Test the `vrev64f32' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vrev64f32.x"
 
 /* { dg-final { scan-assembler "vrev64\.32\[ \t\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vrev64p16_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vrev64p16_1.c
@@ -1,7 +1,5 @@
 /* Test the `vrev64p16' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vrev64p16.x"
 
 /* { dg-final { scan-assembler "vrev64\.16\[ \t\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vrev64p8_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vrev64p8_1.c
@@ -1,7 +1,5 @@
 /* Test the `vrev64p8' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vrev64p8.x"
 
 /* { dg-final { scan-assembler "vrev64\.8\[ \t\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vrev64qf32_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vrev64qf32_1.c
@@ -1,7 +1,5 @@
 /* Test the `vrev64q_f32' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vrev64qf32.x"
 
 /* { dg-final { scan-assembler "vrev64\.32\[ \t\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vrev64qp16_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vrev64qp16_1.c
@@ -1,7 +1,5 @@
 /* Test the `vrev64q_p16' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vrev64qp16.x"
 
 /* { dg-final { scan-assembler "vrev64\.16\[ \t\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vrev64qp8_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vrev64qp8_1.c
@@ -1,7 +1,5 @@
 /* Test the `vrev64q_p8' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vrev64qp8.x"
 
 /* { dg-final { scan-assembler "vrev64\.8\[ \t\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vrev64qs16_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vrev64qs16_1.c
@@ -1,7 +1,5 @@
 /* Test the `vrev64q_s16' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vrev64qs16.x"
 
 /* { dg-final { scan-assembler "vrev64\.16\[ \t\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vrev64qs32_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vrev64qs32_1.c
@@ -1,7 +1,5 @@
 /* Test the `vrev64q_s32' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vrev64qs32.x"
 
 /* { dg-final { scan-assembler "vrev64\.32\[ \t\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vrev64qs8_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vrev64qs8_1.c
@@ -1,7 +1,5 @@
 /* Test the `vrev64q_s8' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vrev64qs8.x"
 
 /* { dg-final { scan-assembler "vrev64\.8\[ \t\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vrev64qu16_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vrev64qu16_1.c
@@ -1,7 +1,5 @@
 /* Test the `vrev64q_u16' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vrev64qu16.x"
 
 /* { dg-final { scan-assembler "vrev64\.16\[ \t\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vrev64qu32_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vrev64qu32_1.c
@@ -1,7 +1,5 @@
 /* Test the `vrev64q_u32' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vrev64qu32.x"
 
 /* { dg-final { scan-assembler "vrev64\.32\[ \t\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vrev64qu8_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vrev64qu8_1.c
@@ -1,7 +1,5 @@
 /* Test the `vrev64q_u8' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vrev64qu8.x"
 
 /* { dg-final { scan-assembler "vrev64\.8\[ \t\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vrev64s16_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vrev64s16_1.c
@@ -1,7 +1,5 @@
 /* Test the `vrev64s16' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vrev64s16.x"
 
 /* { dg-final { scan-assembler "vrev64\.16\[ \t\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vrev64s32_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vrev64s32_1.c
@@ -1,7 +1,5 @@
 /* Test the `vrev64s32' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vrev64s32.x"
 
 /* { dg-final { scan-assembler "vrev64\.32\[ \t\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vrev64s8_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vrev64s8_1.c
@@ -1,7 +1,5 @@
 /* Test the `vrev64s8' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vrev64s8.x"
 
 /* { dg-final { scan-assembler "vrev64\.8\[ \t\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vrev64u16_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vrev64u16_1.c
@@ -1,7 +1,5 @@
 /* Test the `vrev64u16' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vrev64u16.x"
 
 /* { dg-final { scan-assembler "vrev64\.16\[ \t\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vrev64u32_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vrev64u32_1.c
@@ -1,7 +1,5 @@
 /* Test the `vrev64u32' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vrev64u32.x"
 
 /* { dg-final { scan-assembler "vrev64\.32\[ \t\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vrev64u8_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vrev64u8_1.c
@@ -1,7 +1,5 @@
 /* Test the `vrev64u8' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vrev64u8.x"
 
 /* { dg-final { scan-assembler "vrev64\.8\[ \t\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vtrnf32_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vtrnf32_1.c
@@ -1,7 +1,5 @@
 /* Test the `vtrnf32' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O1 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vtrnf32.x"
 
 /* { dg-final { scan-assembler-times "vuzp\.32\[ \t\]+\[dD\]\[0-9\]+, ?\[dD\]\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vtrnp16_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vtrnp16_1.c
@@ -1,7 +1,5 @@
 /* Test the `vtrnp16' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O1 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vtrnp16.x"
 
 /* { dg-final { scan-assembler-times "vtrn\.16\[ \t\]+\[dD\]\[0-9\]+, ?\[dD\]\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vtrnp8_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vtrnp8_1.c
@@ -1,7 +1,5 @@
 /* Test the `vtrnp8' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O1 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vtrnp8.x"
 
 /* { dg-final { scan-assembler-times "vtrn\.8\[ \t\]+\[dD\]\[0-9\]+, ?\[dD\]\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vtrnqf32_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vtrnqf32_1.c
@@ -1,7 +1,5 @@
 /* Test the `vtrnQf32' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O1 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vtrnqf32.x"
 
 /* { dg-final { scan-assembler-times "vtrn\.32\[ \t\]+\[qQ\]\[0-9\]+, ?\[qQ\]\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vtrnqp16_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vtrnqp16_1.c
@@ -1,7 +1,5 @@
 /* Test the `vtrnQp16' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O1 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vtrnqp16.x"
 
 /* { dg-final { scan-assembler-times "vtrn\.16\[ \t\]+\[qQ\]\[0-9\]+, ?\[qQ\]\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vtrnqp8_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vtrnqp8_1.c
@@ -1,7 +1,5 @@
 /* Test the `vtrnQp8' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O1 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vtrnqp8.x"
 
 /* { dg-final { scan-assembler-times "vtrn\.8\[ \t\]+\[qQ\]\[0-9\]+, ?\[qQ\]\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vtrnqs16_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vtrnqs16_1.c
@@ -1,7 +1,5 @@
 /* Test the `vtrnQs16' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O1 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vtrnqs16.x"
 
 /* { dg-final { scan-assembler-times "vtrn\.16\[ \t\]+\[qQ\]\[0-9\]+, ?\[qQ\]\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vtrnqs32_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vtrnqs32_1.c
@@ -1,7 +1,5 @@
 /* Test the `vtrnQs32' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O1 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vtrnqs32.x"
 
 /* { dg-final { scan-assembler-times "vtrn\.32\[ \t\]+\[qQ\]\[0-9\]+, ?\[qQ\]\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vtrnqs8_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vtrnqs8_1.c
@@ -1,7 +1,5 @@
 /* Test the `vtrnQs8' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O1 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vtrnqs8.x"
 
 /* { dg-final { scan-assembler-times "vtrn\.8\[ \t\]+\[qQ\]\[0-9\]+, ?\[qQ\]\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vtrnqu16_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vtrnqu16_1.c
@@ -1,7 +1,5 @@
 /* Test the `vtrnQu16' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O1 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vtrnqu16.x"
 
 /* { dg-final { scan-assembler-times "vtrn\.16\[ \t\]+\[qQ\]\[0-9\]+, ?\[qQ\]\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vtrnqu32_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vtrnqu32_1.c
@@ -1,7 +1,5 @@
 /* Test the `vtrnQu32' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O1 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vtrnqu32.x"
 
 /* { dg-final { scan-assembler-times "vtrn\.32\[ \t\]+\[qQ\]\[0-9\]+, ?\[qQ\]\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vtrnqu8_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vtrnqu8_1.c
@@ -1,7 +1,5 @@
 /* Test the `vtrnQu8' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O1 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vtrnqu8.x"
 
 /* { dg-final { scan-assembler-times "vtrn\.8\[ \t\]+\[qQ\]\[0-9\]+, ?\[qQ\]\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vtrns16_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vtrns16_1.c
@@ -1,7 +1,5 @@
 /* Test the `vtrns16' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O1 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vtrns16.x"
 
 /* { dg-final { scan-assembler-times "vtrn\.16\[ \t\]+\[dD\]\[0-9\]+, ?\[dD\]\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vtrns32_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vtrns32_1.c
@@ -1,7 +1,5 @@
 /* Test the `vtrns32' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O1 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vtrns32.x"
 
 /* { dg-final { scan-assembler-times "vuzp\.32\[ \t\]+\[dD\]\[0-9\]+, ?\[dD\]\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vtrns8_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vtrns8_1.c
@@ -1,7 +1,5 @@
 /* Test the `vtrns8' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O1 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vtrns8.x"
 
 /* { dg-final { scan-assembler-times "vtrn\.8\[ \t\]+\[dD\]\[0-9\]+, ?\[dD\]\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vtrnu16_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vtrnu16_1.c
@@ -1,7 +1,5 @@
 /* Test the `vtrnu16' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O1 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vtrnu16.x"
 
 /* { dg-final { scan-assembler-times "vtrn\.16\[ \t\]+\[dD\]\[0-9\]+, ?\[dD\]\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vtrnu32_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vtrnu32_1.c
@@ -1,7 +1,5 @@
 /* Test the `vtrnu32' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O1 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vtrnu32.x"
 
 /* { dg-final { scan-assembler-times "vuzp\.32\[ \t\]+\[dD\]\[0-9\]+, ?\[dD\]\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vtrnu8_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vtrnu8_1.c
@@ -1,7 +1,5 @@
 /* Test the `vtrnu8' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O1 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vtrnu8.x"
 
 /* { dg-final { scan-assembler-times "vtrn\.8\[ \t\]+\[dD\]\[0-9\]+, ?\[dD\]\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vuzpf32_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vuzpf32_1.c
@@ -1,7 +1,5 @@
 /* Test the `vuzpf32' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O1 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vuzpf32.x"
 
 /* { dg-final { scan-assembler-times "vuzp\.32\[ \t\]+\[dD\]\[0-9\]+, ?\[dD\]\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vuzpp16_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vuzpp16_1.c
@@ -1,7 +1,5 @@
 /* Test the `vuzpp16' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O1 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vuzpp16.x"
 
 /* { dg-final { scan-assembler-times "vuzp\.16\[ \t\]+\[dD\]\[0-9\]+, ?\[dD\]\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vuzpp8_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vuzpp8_1.c
@@ -1,7 +1,5 @@
 /* Test the `vuzpp8' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O1 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vuzpp8.x"
 
 /* { dg-final { scan-assembler-times "vuzp\.8\[ \t\]+\[dD\]\[0-9\]+, ?\[dD\]\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vuzpqf32_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vuzpqf32_1.c
@@ -1,7 +1,5 @@
 /* Test the `vuzpQf32' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O1 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vuzpqf32.x"
 
 /* { dg-final { scan-assembler-times "vuzp\.32\[ \t\]+\[qQ\]\[0-9\]+, ?\[qQ\]\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vuzpqp16_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vuzpqp16_1.c
@@ -1,7 +1,5 @@
 /* Test the `vuzpQp16' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O1 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vuzpqp16.x"
 
 /* { dg-final { scan-assembler-times "vuzp\.16\[ \t\]+\[qQ\]\[0-9\]+, ?\[qQ\]\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vuzpqp8_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vuzpqp8_1.c
@@ -1,7 +1,5 @@
 /* Test the `vuzpQp8' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O1 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vuzpqp8.x"
 
 /* { dg-final { scan-assembler-times "vuzp\.8\[ \t\]+\[qQ\]\[0-9\]+, ?\[qQ\]\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vuzpqs16_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vuzpqs16_1.c
@@ -1,7 +1,5 @@
 /* Test the `vuzpQs16' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O1 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vuzpqs16.x"
 
 /* { dg-final { scan-assembler-times "vuzp\.16\[ \t\]+\[qQ\]\[0-9\]+, ?\[qQ\]\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vuzpqs32_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vuzpqs32_1.c
@@ -1,7 +1,5 @@
 /* Test the `vuzpQs32' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O1 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vuzpqs32.x"
 
 /* { dg-final { scan-assembler-times "vuzp\.32\[ \t\]+\[qQ\]\[0-9\]+, ?\[qQ\]\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vuzpqs8_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vuzpqs8_1.c
@@ -1,7 +1,5 @@
 /* Test the `vuzpQs8' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O1 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vuzpqs8.x"
 
 /* { dg-final { scan-assembler-times "vuzp\.8\[ \t\]+\[qQ\]\[0-9\]+, ?\[qQ\]\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vuzpqu16_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vuzpqu16_1.c
@@ -1,7 +1,5 @@
 /* Test the `vuzpQu16' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O1 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vuzpqu16.x"
 
 /* { dg-final { scan-assembler-times "vuzp\.16\[ \t\]+\[qQ\]\[0-9\]+, ?\[qQ\]\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vuzpqu32_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vuzpqu32_1.c
@@ -1,7 +1,5 @@
 /* Test the `vuzpQu32' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O1 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vuzpqu32.x"
 
 /* { dg-final { scan-assembler-times "vuzp\.32\[ \t\]+\[qQ\]\[0-9\]+, ?\[qQ\]\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vuzpqu8_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vuzpqu8_1.c
@@ -1,7 +1,5 @@
 /* Test the `vuzpQu8' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O1 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vuzpqu8.x"
 
 /* { dg-final { scan-assembler-times "vuzp\.8\[ \t\]+\[qQ\]\[0-9\]+, ?\[qQ\]\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vuzps16_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vuzps16_1.c
@@ -1,7 +1,5 @@
 /* Test the `vuzps16' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O1 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vuzps16.x"
 
 /* { dg-final { scan-assembler-times "vuzp\.16\[ \t\]+\[dD\]\[0-9\]+, ?\[dD\]\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vuzps32_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vuzps32_1.c
@@ -1,7 +1,5 @@
 /* Test the `vuzps32' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O1 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vuzps32.x"
 
 /* { dg-final { scan-assembler-times "vuzp\.32\[ \t\]+\[dD\]\[0-9\]+, ?\[dD\]\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vuzps8_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vuzps8_1.c
@@ -1,7 +1,5 @@
 /* Test the `vuzps8' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O1 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vuzps8.x"
 
 /* { dg-final { scan-assembler-times "vuzp\.8\[ \t\]+\[dD\]\[0-9\]+, ?\[dD\]\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vuzpu16_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vuzpu16_1.c
@@ -1,7 +1,5 @@
 /* Test the `vuzpu16' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O1 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vuzpu16.x"
 
 /* { dg-final { scan-assembler-times "vuzp\.16\[ \t\]+\[dD\]\[0-9\]+, ?\[dD\]\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vuzpu32_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vuzpu32_1.c
@@ -1,7 +1,5 @@
 /* Test the `vuzpu32' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O1 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vuzpu32.x"
 
 /* { dg-final { scan-assembler-times "vuzp\.32\[ \t\]+\[dD\]\[0-9\]+, ?\[dD\]\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vuzpu8_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vuzpu8_1.c
@@ -1,7 +1,5 @@
 /* Test the `vuzpu8' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O1 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vuzpu8.x"
 
 /* { dg-final { scan-assembler-times "vuzp\.8\[ \t\]+\[dD\]\[0-9\]+, ?\[dD\]\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vzipf32_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vzipf32_1.c
@@ -1,7 +1,5 @@
 /* Test the `vzipf32' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O1 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vzipf32.x"
 
 /* { dg-final { scan-assembler-times "vuzp\.32\[ \t\]+\[dD\]\[0-9\]+, ?\[dD\]\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vzipp16_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vzipp16_1.c
@@ -1,7 +1,5 @@
 /* Test the `vzipp16' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O1 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vzipp16.x"
 
 /* { dg-final { scan-assembler-times "vzip\.16\[ \t\]+\[dD\]\[0-9\]+, ?\[dD\]\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vzipp8_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vzipp8_1.c
@@ -1,7 +1,5 @@
 /* Test the `vzipp8' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O1 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vzipp8.x"
 
 /* { dg-final { scan-assembler-times "vzip\.8\[ \t\]+\[dD\]\[0-9\]+, ?\[dD\]\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vzipqf32_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vzipqf32_1.c
@@ -1,7 +1,5 @@
 /* Test the `vzipQf32' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O1 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vzipqf32.x"
 
 /* { dg-final { scan-assembler-times "vzip\.32\[ \t\]+\[qQ\]\[0-9\]+, ?\[qQ\]\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vzipqp16_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vzipqp16_1.c
@@ -1,7 +1,5 @@
 /* Test the `vzipQp16' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O1 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vzipqp16.x"
 
 /* { dg-final { scan-assembler-times "vzip\.16\[ \t\]+\[qQ\]\[0-9\]+, ?\[qQ\]\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vzipqp8_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vzipqp8_1.c
@@ -1,7 +1,5 @@
 /* Test the `vzipQp8' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O1 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vzipqp8.x"
 
 /* { dg-final { scan-assembler-times "vzip\.8\[ \t\]+\[qQ\]\[0-9\]+, ?\[qQ\]\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vzipqs16_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vzipqs16_1.c
@@ -1,7 +1,5 @@
 /* Test the `vzipQs16' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O1 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vzipqs16.x"
 
 /* { dg-final { scan-assembler-times "vzip\.16\[ \t\]+\[qQ\]\[0-9\]+, ?\[qQ\]\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vzipqs32_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vzipqs32_1.c
@@ -1,7 +1,5 @@
 /* Test the `vzipQs32' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O1 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vzipqs32.x"
 
 /* { dg-final { scan-assembler-times "vzip\.32\[ \t\]+\[qQ\]\[0-9\]+, ?\[qQ\]\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vzipqs8_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vzipqs8_1.c
@@ -1,7 +1,5 @@
 /* Test the `vzipQs8' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O1 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vzipqs8.x"
 
 /* { dg-final { scan-assembler-times "vzip\.8\[ \t\]+\[qQ\]\[0-9\]+, ?\[qQ\]\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vzipqu16_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vzipqu16_1.c
@@ -1,7 +1,5 @@
 /* Test the `vzipQu16' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O1 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vzipqu16.x"
 
 /* { dg-final { scan-assembler-times "vzip\.16\[ \t\]+\[qQ\]\[0-9\]+, ?\[qQ\]\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vzipqu32_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vzipqu32_1.c
@@ -1,7 +1,5 @@
 /* Test the `vzipQu32' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O1 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vzipqu32.x"
 
 /* { dg-final { scan-assembler-times "vzip\.32\[ \t\]+\[qQ\]\[0-9\]+, ?\[qQ\]\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vzipqu8_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vzipqu8_1.c
@@ -1,7 +1,5 @@
 /* Test the `vzipQu8' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O1 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vzipqu8.x"
 
 /* { dg-final { scan-assembler-times "vzip\.8\[ \t\]+\[qQ\]\[0-9\]+, ?\[qQ\]\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vzips16_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vzips16_1.c
@@ -1,7 +1,5 @@
 /* Test the `vzips16' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O1 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vzips16.x"
 
 /* { dg-final { scan-assembler-times "vzip\.16\[ \t\]+\[dD\]\[0-9\]+, ?\[dD\]\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vzips32_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vzips32_1.c
@@ -1,7 +1,5 @@
 /* Test the `vzips32' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O1 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vzips32.x"
 
 /* { dg-final { scan-assembler-times "vuzp\.32\[ \t\]+\[dD\]\[0-9\]+, ?\[dD\]\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vzips8_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vzips8_1.c
@@ -1,7 +1,5 @@
 /* Test the `vzips8' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O1 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vzips8.x"
 
 /* { dg-final { scan-assembler-times "vzip\.8\[ \t\]+\[dD\]\[0-9\]+, ?\[dD\]\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vzipu16_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vzipu16_1.c
@@ -1,7 +1,5 @@
 /* Test the `vzipu16' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O1 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vzipu16.x"
 
 /* { dg-final { scan-assembler-times "vzip\.16\[ \t\]+\[dD\]\[0-9\]+, ?\[dD\]\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vzipu32_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vzipu32_1.c
@@ -1,7 +1,5 @@
 /* Test the `vzipu32' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O1 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vzipu32.x"
 
 /* { dg-final { scan-assembler-times "vuzp\.32\[ \t\]+\[dD\]\[0-9\]+, ?\[dD\]\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/simd/vzipu8_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/simd/vzipu8_1.c
@@ -1,7 +1,5 @@
 /* Test the `vzipu8' ARM Neon intrinsic.  */
 
-/* { dg-do run } */
-/* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-save-temps -O1 -fno-inline" } */
 /* { dg-add-options arm_neon } */
 
@@ -9,4 +7,3 @@
 #include "../../aarch64/simd/vzipu8.x"
 
 /* { dg-final { scan-assembler-times "vzip\.8\[ \t\]+\[dD\]\[0-9\]+, ?\[dD\]\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/arm/split-live-ranges-for-shrink-wrap.c
+++ b/src/gcc/testsuite/gcc.target/arm/split-live-ranges-for-shrink-wrap.c
@@ -13,4 +13,3 @@ int test (int d, char * out, char *in, int len)
 }
 /* { dg-final { object-size text <= 20 } } */
 /* { dg-final { scan-rtl-dump-not "Split live-range of register" "ira" } } */
-/* { dg-final { cleanup-rtl-dump "ira" } } */
--- a/src/gcc/testsuite/gcc.target/arm/thumb-ifcvt.c
+++ b/src/gcc/testsuite/gcc.target/arm/thumb-ifcvt.c
@@ -1,7 +1,7 @@
 /* Check that Thumb 16-bit shifts can be if-converted.  */
 /* { dg-do compile } */
 /* { dg-require-effective-target arm_thumb2_ok } */
-/* { dg-options "-O2 -mthumb" } */
+/* { dg-options "-O2 -mthumb -mno-restrict-it" } */
 
 int
 foo (int a, int b)
--- a/src/gcc/testsuite/gcc.target/arm/thumb1-Os-mult.c
+++ b/src/gcc/testsuite/gcc.target/arm/thumb1-Os-mult.c
@@ -1,5 +1,5 @@
-/* { dg-require-effective-target arm_thumb1_ok } */
 /* { dg-do compile } */
+/* { dg-require-effective-target arm_thumb1_ok } */
 /* { dg-options "-Os" } */
 /* { dg-skip-if "" { ! { arm_thumb1 } } } */
 
--- a/src/gcc/testsuite/gcc.target/arm/thumb1-load-64bit-constant-1.c
+++ b/src/gcc/testsuite/gcc.target/arm/thumb1-load-64bit-constant-1.c
@@ -1,5 +1,5 @@
-/* { dg-require-effective-target arm_thumb1_ok } */
 /* { dg-do compile } */
+/* { dg-require-effective-target arm_thumb1_ok } */
 /* { dg-options "-Os" } */
 /* { dg-skip-if "" { ! { arm_thumb1 } } } */
 
--- a/src/gcc/testsuite/gcc.target/arm/thumb1-load-64bit-constant-2.c
+++ b/src/gcc/testsuite/gcc.target/arm/thumb1-load-64bit-constant-2.c
@@ -1,5 +1,5 @@
-/* { dg-require-effective-target arm_thumb1_ok } */
 /* { dg-do compile } */
+/* { dg-require-effective-target arm_thumb1_ok } */
 /* { dg-options "-O2" } */
 /* { dg-skip-if "" { ! { arm_thumb1 } } } */
 
--- a/src/gcc/testsuite/gcc.target/arm/thumb1-load-64bit-constant-3.c
+++ b/src/gcc/testsuite/gcc.target/arm/thumb1-load-64bit-constant-3.c
@@ -1,5 +1,5 @@
-/* { dg-require-effective-target arm_thumb1_ok } */
 /* { dg-do compile } */
+/* { dg-require-effective-target arm_thumb1_ok } */
 /* { dg-options "-Os" } */
 /* { dg-skip-if "" { ! { arm_thumb1 } } } */
 
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/arm/unsigned-float.c
@@ -0,0 +1,21 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_vfp_ok } */
+/* { dg-skip-if "need fp instructions" { *-*-* } { "-mfloat-abi=soft" } { "" } } */
+/* { dg-options "-march=armv7-a -O1" } */
+/* { dg-additional-options "-mfloat-abi=softfp" { target { ! { arm_hf_eabi } } } } */
+
+#include <stdint.h>
+
+double
+f1 (uint16_t x)
+{
+  return (double)(float)x;
+}
+
+float
+f2 (uint16_t x)
+{
+  return (float)(double)x;
+}
+
+/* { dg-final { scan-assembler-not "vcvt.(f32.f64|f64.f32)" } } */
--- a/src/gcc/testsuite/gcc.target/arm/vect-copysignf.c
+++ b/src/gcc/testsuite/gcc.target/arm/vect-copysignf.c
@@ -33,4 +33,3 @@ main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.target/arm/vect-lceilf_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/vect-lceilf_1.c
@@ -18,4 +18,3 @@ foo ()
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.target/arm/vect-lfloorf_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/vect-lfloorf_1.c
@@ -18,4 +18,3 @@ foo ()
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.target/arm/vect-lroundf_1.c
+++ b/src/gcc/testsuite/gcc.target/arm/vect-lroundf_1.c
@@ -18,4 +18,3 @@ foo ()
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.target/arm/vect-rounding-btruncf.c
+++ b/src/gcc/testsuite/gcc.target/arm/vect-rounding-btruncf.c
@@ -18,4 +18,3 @@ foo ()
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_call_btruncf } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.target/arm/vect-rounding-ceilf.c
+++ b/src/gcc/testsuite/gcc.target/arm/vect-rounding-ceilf.c
@@ -18,4 +18,3 @@ foo ()
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_call_ceilf } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.target/arm/vect-rounding-floorf.c
+++ b/src/gcc/testsuite/gcc.target/arm/vect-rounding-floorf.c
@@ -18,4 +18,3 @@ foo ()
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_call_floorf } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.target/arm/vect-rounding-roundf.c
+++ b/src/gcc/testsuite/gcc.target/arm/vect-rounding-roundf.c
@@ -18,4 +18,3 @@ foo ()
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_call_roundf } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.target/arm/vfp-1.c
+++ b/src/gcc/testsuite/gcc.target/arm/vfp-1.c
@@ -1,6 +1,7 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mfpu=vfp -mfloat-abi=softfp" } */
+/* { dg-options "-O2 -mfpu=vfp -mfloat-abi=softfp -ffp-contract=off" } */
 /* { dg-require-effective-target arm_vfp_ok } */
+/* { dg-skip-if "need fp instructions" { *-*-* } { "-mfloat-abi=soft" } { "" } } */
 
 extern float fabsf (float);
 extern float sqrtf (float);
--- a/src/gcc/testsuite/gcc.target/arm/volatile-bitfields-1.c
+++ b/src/gcc/testsuite/gcc.target/arm/volatile-bitfields-1.c
@@ -1,5 +1,5 @@
-/* { dg-require-effective-target arm_eabi } */
 /* { dg-do compile } */
+/* { dg-require-effective-target arm_eabi } */
 /* { dg-options "-O2" } */
 
 typedef struct {
--- a/src/gcc/testsuite/gcc.target/arm/volatile-bitfields-2.c
+++ b/src/gcc/testsuite/gcc.target/arm/volatile-bitfields-2.c
@@ -1,5 +1,5 @@
-/* { dg-require-effective-target arm_eabi } */
 /* { dg-do compile } */
+/* { dg-require-effective-target arm_eabi } */
 /* { dg-options "-O2" } */
 
 typedef struct {
--- a/src/gcc/testsuite/gcc.target/arm/volatile-bitfields-3.c
+++ b/src/gcc/testsuite/gcc.target/arm/volatile-bitfields-3.c
@@ -1,5 +1,5 @@
-/* { dg-require-effective-target arm_eabi } */
 /* { dg-do compile } */
+/* { dg-require-effective-target arm_eabi } */
 /* { dg-options "-O2" } */
 
 typedef struct {
--- a/src/gcc/testsuite/gcc.target/arm/volatile-bitfields-4.c
+++ b/src/gcc/testsuite/gcc.target/arm/volatile-bitfields-4.c
@@ -1,5 +1,5 @@
-/* { dg-require-effective-target arm_eabi } */
 /* { dg-do compile } */
+/* { dg-require-effective-target arm_eabi } */
 /* { dg-options "-O2" } */
 /* { dg-final { scan-assembler-times "ldr\[\\t \]+\[^\n\]*,\[\\t \]*\\\[\[^\n\]*\\\]" 2 } } */
 /* { dg-final { scan-assembler-times "str\[\\t \]+\[^\n\]*,\[\\t \]*\\\[\[^\n\]*\\\]" 2 } } */
--- a/src/gcc/testsuite/gcc.target/i386/avx-cvt-2.c
+++ b/src/gcc/testsuite/gcc.target/i386/avx-cvt-2.c
@@ -10,4 +10,3 @@
 /* { dg-final { scan-assembler "vcvttps2dq\[^\n\r\]*ymm" } } */
 /* { dg-final { scan-assembler "vcvtdq2pd\[^\n\r\]*(%xmm\[^\n\r\]*%ymm|ymm\[^\n\r\]*xmm)" } } */
 /* { dg-final { scan-assembler "vcvtpd2ps(y\[^\n\r\]*%xmm|\[^\n\r\]*xmm\[^\n\r\]*YMMWORD PTR)" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.target/i386/avx-cvt-3.c
+++ b/src/gcc/testsuite/gcc.target/i386/avx-cvt-3.c
@@ -10,4 +10,3 @@
 /* { dg-final { scan-assembler "vcvttps2dq\[^\n\r\]*xmm" } } */
 /* { dg-final { scan-assembler "vcvtdq2pd\[^\n\r\]*xmm\[^\n\r\]*xmm" } } */
 /* { dg-final { scan-assembler "vcvtpd2ps(x\[^\n\r\]*%xmm|\[^\n\r\]*xmm\[^\n\r\]*XMMWORD PTR)" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.target/i386/avx2-cvt-2.c
+++ b/src/gcc/testsuite/gcc.target/i386/avx2-cvt-2.c
@@ -10,4 +10,3 @@
 /* { dg-final { scan-assembler "vcvttps2dq\[^\n\r\]*ymm" } } */
 /* { dg-final { scan-assembler "vcvtdq2pd\[^\n\r\]*(%xmm\[^\n\r\]*%ymm|ymm\[^\n\r\]*xmm)" } } */
 /* { dg-final { scan-assembler "vcvtpd2ps(y\[^\n\r\]*%xmm|\[^\n\r\]*xmm\[^\n\r\]*YMMWORD PTR)" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.target/i386/avx2-gather-2.c
+++ b/src/gcc/testsuite/gcc.target/i386/avx2-gather-2.c
@@ -4,4 +4,3 @@
 #include "avx2-gather-1.c"
 
 /* { dg-final { scan-tree-dump-times "note: vectorized 1 loops in function" 16 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.target/i386/avx2-gather-6.c
+++ b/src/gcc/testsuite/gcc.target/i386/avx2-gather-6.c
@@ -4,4 +4,3 @@
 #include "avx2-gather-5.c"
 
 /* { dg-final { scan-tree-dump-times "note: vectorized 1 loops in function" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.target/i386/avx2-vect-aggressive-1.c
+++ b/src/gcc/testsuite/gcc.target/i386/avx2-vect-aggressive-1.c
@@ -30,4 +30,3 @@ void foo()
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.target/i386/avx2-vect-aggressive.c
+++ b/src/gcc/testsuite/gcc.target/i386/avx2-vect-aggressive.c
@@ -45,5 +45,4 @@ avx2_test (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
--- a/src/gcc/testsuite/gcc.target/i386/avx2-vpaddb-3.c
+++ b/src/gcc/testsuite/gcc.target/i386/avx2-vpaddb-3.c
@@ -9,4 +9,3 @@
 #include "avx2-vpop-check.h"
 
 /* { dg-final { scan-assembler-times "vpaddb\[ \\t\]+\[^\n\]*%ymm\[0-9\]" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/i386/avx2-vpaddd-3.c
+++ b/src/gcc/testsuite/gcc.target/i386/avx2-vpaddd-3.c
@@ -9,4 +9,3 @@
 #include "avx2-vpop-check.h"
 
 /* { dg-final { scan-assembler-times "vpaddd\[ \\t\]+\[^\n\]*%ymm\[0-9\]" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/i386/avx2-vpaddq-3.c
+++ b/src/gcc/testsuite/gcc.target/i386/avx2-vpaddq-3.c
@@ -9,4 +9,3 @@
 #include "avx2-vpop-check.h"
 
 /* { dg-final { scan-assembler-times "vpaddq\[ \\t\]+\[^\n\]*%ymm\[0-9\]" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/i386/avx2-vpaddw-3.c
+++ b/src/gcc/testsuite/gcc.target/i386/avx2-vpaddw-3.c
@@ -9,4 +9,3 @@
 #include "avx2-vpop-check.h"
 
 /* { dg-final { scan-assembler-times "vpaddw\[ \\t\]+\[^\n\]*%ymm\[0-9\]" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/i386/avx2-vpand-3.c
+++ b/src/gcc/testsuite/gcc.target/i386/avx2-vpand-3.c
@@ -9,4 +9,3 @@
 #include "avx2-vpop-check.h"
 
 /* { dg-final { scan-assembler-times "vpand\[ \\t\]+\[^\n\]*%ymm\[0-9\]" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/i386/avx2-vpmulld-3.c
+++ b/src/gcc/testsuite/gcc.target/i386/avx2-vpmulld-3.c
@@ -9,4 +9,3 @@
 #include "avx2-vpop-check.h"
 
 /* { dg-final { scan-assembler-times "vpmulld\[ \\t\]+\[^\n\]*%ymm\[0-9\]" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/i386/avx2-vpmullw-3.c
+++ b/src/gcc/testsuite/gcc.target/i386/avx2-vpmullw-3.c
@@ -9,4 +9,3 @@
 #include "avx2-vpop-check.h"
 
 /* { dg-final { scan-assembler-times "vpmullw\[ \\t\]+\[^\n\]*%ymm\[0-9\]" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/i386/avx2-vpsrad-3.c
+++ b/src/gcc/testsuite/gcc.target/i386/avx2-vpsrad-3.c
@@ -9,4 +9,3 @@
 #include "avx2-vpop-check.h"
 
 /* { dg-final { scan-assembler-times "vpsrld\[ \\t\]+\[^\n\]*%ymm\[0-9\]" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/i386/avx2-vpsraw-3.c
+++ b/src/gcc/testsuite/gcc.target/i386/avx2-vpsraw-3.c
@@ -9,4 +9,3 @@
 #include "avx2-vpop-check.h"
 
 /* { dg-final { scan-assembler-times "vpsraw\[ \\t\]+\[^\n\]*%ymm\[0-9\]" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/i386/avx2-vpsrld-3.c
+++ b/src/gcc/testsuite/gcc.target/i386/avx2-vpsrld-3.c
@@ -9,4 +9,3 @@
 #include "avx2-vpop-check.h"
 
 /* { dg-final { scan-assembler-times "vpsrld\[ \\t\]+\[^\n\]*%ymm\[0-9\]" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/i386/avx2-vpsrlw-3.c
+++ b/src/gcc/testsuite/gcc.target/i386/avx2-vpsrlw-3.c
@@ -9,4 +9,3 @@
 #include "avx2-vpop-check.h"
 
 /* { dg-final { scan-assembler-times "vpsrlw\[ \\t\]+\[^\n\]*%ymm\[0-9\]" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/i386/avx2-vpsubb-3.c
+++ b/src/gcc/testsuite/gcc.target/i386/avx2-vpsubb-3.c
@@ -9,4 +9,3 @@
 #include "avx2-vpop-check.h"
 
 /* { dg-final { scan-assembler-times "vpsubb\[ \\t\]+\[^\n\]*%ymm\[0-9\]" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/i386/avx2-vpsubd-3.c
+++ b/src/gcc/testsuite/gcc.target/i386/avx2-vpsubd-3.c
@@ -9,4 +9,3 @@
 #include "avx2-vpop-check.h"
 
 /* { dg-final { scan-assembler-times "vpsubd\[ \\t\]+\[^\n\]*%ymm\[0-9\]" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/i386/avx2-vpsubq-3.c
+++ b/src/gcc/testsuite/gcc.target/i386/avx2-vpsubq-3.c
@@ -9,4 +9,3 @@
 #include "avx2-vpop-check.h"
 
 /* { dg-final { scan-assembler-times "vpsubq\[ \\t\]+\[^\n\]*%ymm\[0-9\]" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/i386/avx2-vpsubw-3.c
+++ b/src/gcc/testsuite/gcc.target/i386/avx2-vpsubw-3.c
@@ -9,4 +9,3 @@
 #include "avx2-vpop-check.h"
 
 /* { dg-final { scan-assembler-times "vpsubw\[ \\t\]+\[^\n\]*%ymm\[0-9\]" 1 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/i386/avx512f-gather-2.c
+++ b/src/gcc/testsuite/gcc.target/i386/avx512f-gather-2.c
@@ -8,4 +8,3 @@
 /* { dg-final { scan-assembler-not "gather\[^\n\]*ymm\[^\n\]*xmm" } } */
 /* { dg-final { scan-assembler-not "gather\[^\n\]*xmm\[^\n\]*xmm" } } */
 /* { dg-final { scan-tree-dump-times "note: vectorized 1 loops in function" 16 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.target/i386/branch-cost1.c
+++ b/src/gcc/testsuite/gcc.target/i386/branch-cost1.c
@@ -13,4 +13,3 @@ foo (int a, int b)
 
 /* { dg-final { scan-tree-dump-times "if " 2 "gimple" } } */
 /* { dg-final { scan-tree-dump-not " & " "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.target/i386/branch-cost2.c
+++ b/src/gcc/testsuite/gcc.target/i386/branch-cost2.c
@@ -13,4 +13,3 @@ foo (int a, int b)
 
 /* { dg-final { scan-tree-dump-times "if " 1 "gimple" } } */
 /* { dg-final { scan-tree-dump-times " & " 1 "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.target/i386/branch-cost3.c
+++ b/src/gcc/testsuite/gcc.target/i386/branch-cost3.c
@@ -13,4 +13,3 @@ foo (_Bool a, _Bool b)
 
 /* { dg-final { scan-tree-dump-times "if " 1 "gimple" } } */
 /* { dg-final { scan-tree-dump-times " & " 1 "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.target/i386/branch-cost4.c
+++ b/src/gcc/testsuite/gcc.target/i386/branch-cost4.c
@@ -13,4 +13,3 @@ foo (_Bool a, _Bool b)
 
 /* { dg-final { scan-tree-dump-times "if " 2 "gimple" } } */
 /* { dg-final { scan-tree-dump-not " & " "gimple" } } */
-/* { dg-final { cleanup-tree-dump "gimple" } } */
--- a/src/gcc/testsuite/gcc.target/i386/chkp-bndret.c
+++ b/src/gcc/testsuite/gcc.target/i386/chkp-bndret.c
@@ -2,7 +2,6 @@
 /* { dg-require-effective-target mpx } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-chkp" } */
 /* { dg-final { scan-tree-dump-not "bndret" "chkp" } } */
-/* { dg-final { cleanup-tree-dump "chkp" } } */
 
 #include "string.h"
 
--- a/src/gcc/testsuite/gcc.target/i386/chkp-builtins-1.c
+++ b/src/gcc/testsuite/gcc.target/i386/chkp-builtins-1.c
@@ -2,7 +2,6 @@
 /* { dg-require-effective-target mpx } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -fdump-tree-chkp" } */
 /* { dg-final { scan-tree-dump-not "bnd_init_ptr_bounds" "chkp" } } */
-/* { dg-final { cleanup-tree-dump "chkp" } } */
 
 void *
 chkp_test (void *p)
--- a/src/gcc/testsuite/gcc.target/i386/chkp-builtins-2.c
+++ b/src/gcc/testsuite/gcc.target/i386/chkp-builtins-2.c
@@ -2,7 +2,6 @@
 /* { dg-require-effective-target mpx } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -fdump-tree-chkp" } */
 /* { dg-final { scan-tree-dump-not "bnd_copy_ptr_bounds" "chkp" } } */
-/* { dg-final { cleanup-tree-dump "chkp" } } */
 
 void *
 chkp_test (void *p, void *q)
--- a/src/gcc/testsuite/gcc.target/i386/chkp-builtins-3.c
+++ b/src/gcc/testsuite/gcc.target/i386/chkp-builtins-3.c
@@ -2,7 +2,6 @@
 /* { dg-require-effective-target mpx } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -fdump-tree-chkp" } */
 /* { dg-final { scan-tree-dump-not "bnd_set_ptr_bounds" "chkp" } } */
-/* { dg-final { cleanup-tree-dump "chkp" } } */
 
 void *
 chkp_test (void *p)
--- a/src/gcc/testsuite/gcc.target/i386/chkp-builtins-4.c
+++ b/src/gcc/testsuite/gcc.target/i386/chkp-builtins-4.c
@@ -2,7 +2,6 @@
 /* { dg-require-effective-target mpx } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -fdump-tree-chkp" } */
 /* { dg-final { scan-tree-dump-not "bnd_null_ptr_bounds" "chkp" } } */
-/* { dg-final { cleanup-tree-dump "chkp" } } */
 
 void *
 chkp_test (void *p)
--- a/src/gcc/testsuite/gcc.target/i386/chkp-const-check-1.c
+++ b/src/gcc/testsuite/gcc.target/i386/chkp-const-check-1.c
@@ -3,7 +3,6 @@
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-chkpopt" } */
 /* { dg-final { scan-tree-dump-not "bndcl" "chkpopt" } } */
 /* { dg-final { scan-tree-dump-not "bndcu" "chkpopt" } } */
-/* { dg-final { cleanup-tree-dump "chkpopt" } } */
 
 int test (int *p)
 {
--- a/src/gcc/testsuite/gcc.target/i386/chkp-lifetime-1.c
+++ b/src/gcc/testsuite/gcc.target/i386/chkp-lifetime-1.c
@@ -2,7 +2,6 @@
 /* { dg-require-effective-target mpx } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-chkpopt-details" } */
 /* { dg-final { scan-tree-dump "Moving creation of \[^ \]+ down to its use" "chkpopt" } } */
-/* { dg-final { cleanup-tree-dump "chkpopt" } } */
 
 extern int arr[];
 
--- a/src/gcc/testsuite/gcc.target/i386/chkp-narrow-bounds.c
+++ b/src/gcc/testsuite/gcc.target/i386/chkp-narrow-bounds.c
@@ -3,7 +3,6 @@
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-chkp" } */
 /* { dg-final { scan-tree-dump "bndcl" "chkp" } } */
 /* { dg-final { scan-tree-dump "bndcu" "chkp" } } */
-/* { dg-final { cleanup-tree-dump "chkp" } } */
 
 int
 test (int *p)
--- a/src/gcc/testsuite/gcc.target/i386/chkp-remove-bndint-1.c
+++ b/src/gcc/testsuite/gcc.target/i386/chkp-remove-bndint-1.c
@@ -2,7 +2,6 @@
 /* { dg-require-effective-target mpx } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-optimized" } */
 /* { dg-final { scan-tree-dump-not "bndint" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
 struct S
 {
--- a/src/gcc/testsuite/gcc.target/i386/chkp-remove-bndint-2.c
+++ b/src/gcc/testsuite/gcc.target/i386/chkp-remove-bndint-2.c
@@ -2,7 +2,6 @@
 /* { dg-require-effective-target mpx } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-optimized -Wchkp" } */
 /* { dg-final { scan-tree-dump-not "bndint" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
 struct S
 {
--- a/src/gcc/testsuite/gcc.target/i386/chkp-strlen-1.c
+++ b/src/gcc/testsuite/gcc.target/i386/chkp-strlen-1.c
@@ -2,7 +2,6 @@
 /* { dg-require-effective-target mpx } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-strlen" } */
 /* { dg-final { scan-tree-dump "memcpy.chkp" "strlen" } } */
-/* { dg-final { cleanup-tree-dump "strlen" } } */
 
 #include "string.h"
 
--- a/src/gcc/testsuite/gcc.target/i386/chkp-strlen-2.c
+++ b/src/gcc/testsuite/gcc.target/i386/chkp-strlen-2.c
@@ -3,7 +3,6 @@
 /* { dg-require-effective-target stpcpy } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-strlen" } */
 /* { dg-final { scan-tree-dump-not "strlen" "strlen" } } */
-/* { dg-final { cleanup-tree-dump "strlen" } } */
 
 #include "string.h"
 
--- a/src/gcc/testsuite/gcc.target/i386/chkp-strlen-3.c
+++ b/src/gcc/testsuite/gcc.target/i386/chkp-strlen-3.c
@@ -2,7 +2,6 @@
 /* { dg-require-effective-target mpx } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-strlen" } */
 /* { dg-final { scan-tree-dump-times "strlen" 1 "strlen" } } */
-/* { dg-final { cleanup-tree-dump "strlen" } } */
 
 #include "string.h"
 
--- a/src/gcc/testsuite/gcc.target/i386/chkp-strlen-4.c
+++ b/src/gcc/testsuite/gcc.target/i386/chkp-strlen-4.c
@@ -3,7 +3,6 @@
 /* { dg-require-effective-target mempcpy } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-strlen -D_GNU_SOURCE" } */
 /* { dg-final { scan-tree-dump-times "strlen" 1 "strlen" } } */
-/* { dg-final { cleanup-tree-dump "strlen" } } */
 
 #include "string.h"
 
--- a/src/gcc/testsuite/gcc.target/i386/chkp-strlen-5.c
+++ b/src/gcc/testsuite/gcc.target/i386/chkp-strlen-5.c
@@ -3,7 +3,6 @@
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-strlen" } */
 /* { dg-final { scan-tree-dump-times "strlen" 2 "strlen" } } */
 /* { dg-final { scan-tree-dump "memcpy" "strlen" } } */
-/* { dg-final { cleanup-tree-dump "strlen" } } */
 
 #include "string.h"
 
--- a/src/gcc/testsuite/gcc.target/i386/chkp-stropt-1.c
+++ b/src/gcc/testsuite/gcc.target/i386/chkp-stropt-1.c
@@ -2,7 +2,6 @@
 /* { dg-require-effective-target mpx } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-chkpopt -fchkp-use-nochk-string-functions" } */
 /* { dg-final { scan-tree-dump "memcpy_nochk" "chkpopt" } } */
-/* { dg-final { cleanup-tree-dump "chkpopt" } } */
 
 #include "string.h"
 
--- a/src/gcc/testsuite/gcc.target/i386/chkp-stropt-10.c
+++ b/src/gcc/testsuite/gcc.target/i386/chkp-stropt-10.c
@@ -2,7 +2,6 @@
 /* { dg-require-effective-target mpx } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-chkpopt -fchkp-use-fast-string-functions" } */
 /* { dg-final { scan-tree-dump-not "memset_nobnd" "chkpopt" } } */
-/* { dg-final { cleanup-tree-dump "chkpopt" } } */
 
 #include "string.h"
 
--- a/src/gcc/testsuite/gcc.target/i386/chkp-stropt-11.c
+++ b/src/gcc/testsuite/gcc.target/i386/chkp-stropt-11.c
@@ -2,7 +2,6 @@
 /* { dg-require-effective-target mpx } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-chkpopt -fchkp-use-fast-string-functions" } */
 /* { dg-final { scan-tree-dump-not "memmove_nobnd" "chkpopt" } } */
-/* { dg-final { cleanup-tree-dump "chkpopt" } } */
 
 #include "string.h"
 
--- a/src/gcc/testsuite/gcc.target/i386/chkp-stropt-12.c
+++ b/src/gcc/testsuite/gcc.target/i386/chkp-stropt-12.c
@@ -3,7 +3,6 @@
 /* { dg-require-effective-target mempcpy } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-chkpopt -fchkp-use-fast-string-functions -D_GNU_SOURCE" } */
 /* { dg-final { scan-tree-dump-not "mempcpy_nobnd" "chkpopt" } } */
-/* { dg-final { cleanup-tree-dump "chkpopt" } } */
 
 #include "string.h"
 
--- a/src/gcc/testsuite/gcc.target/i386/chkp-stropt-13.c
+++ b/src/gcc/testsuite/gcc.target/i386/chkp-stropt-13.c
@@ -2,7 +2,6 @@
 /* { dg-require-effective-target mpx } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-chkpopt -fchkp-use-nochk-string-functions -fchkp-use-fast-string-functions" } */
 /* { dg-final { scan-tree-dump "memcpy_nobnd_nochk" "chkpopt" } } */
-/* { dg-final { cleanup-tree-dump "chkpopt" } } */
 
 #include "string.h"
 
--- a/src/gcc/testsuite/gcc.target/i386/chkp-stropt-14.c
+++ b/src/gcc/testsuite/gcc.target/i386/chkp-stropt-14.c
@@ -2,7 +2,6 @@
 /* { dg-require-effective-target mpx } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-chkpopt -fchkp-use-nochk-string-functions -fchkp-use-fast-string-functions" } */
 /* { dg-final { scan-tree-dump "memset_nobnd_nochk" "chkpopt" } } */
-/* { dg-final { cleanup-tree-dump "chkpopt" } } */
 
 #include "string.h"
 
--- a/src/gcc/testsuite/gcc.target/i386/chkp-stropt-15.c
+++ b/src/gcc/testsuite/gcc.target/i386/chkp-stropt-15.c
@@ -2,7 +2,6 @@
 /* { dg-require-effective-target mpx } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-chkpopt -fchkp-use-nochk-string-functions -fchkp-use-fast-string-functions" } */
 /* { dg-final { scan-tree-dump "memmove_nobnd_nochk" "chkpopt" } } */
-/* { dg-final { cleanup-tree-dump "chkpopt" } } */
 
 #include "string.h"
 
--- a/src/gcc/testsuite/gcc.target/i386/chkp-stropt-16.c
+++ b/src/gcc/testsuite/gcc.target/i386/chkp-stropt-16.c
@@ -3,7 +3,6 @@
 /* { dg-require-effective-target mempcpy } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-chkpopt -fchkp-use-nochk-string-functions -fchkp-use-fast-string-functions -D_GNU_SOURCE" } */
 /* { dg-final { scan-tree-dump "mempcpy_nobnd_nochk" "chkpopt" } } */
-/* { dg-final { cleanup-tree-dump "chkpopt" } } */
 
 #include "string.h"
 
--- a/src/gcc/testsuite/gcc.target/i386/chkp-stropt-2.c
+++ b/src/gcc/testsuite/gcc.target/i386/chkp-stropt-2.c
@@ -2,7 +2,6 @@
 /* { dg-require-effective-target mpx } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-chkpopt -fchkp-use-nochk-string-functions" } */
 /* { dg-final { scan-tree-dump "memset_nochk" "chkpopt" } } */
-/* { dg-final { cleanup-tree-dump "chkpopt" } } */
 
 #include "string.h"
 
--- a/src/gcc/testsuite/gcc.target/i386/chkp-stropt-3.c
+++ b/src/gcc/testsuite/gcc.target/i386/chkp-stropt-3.c
@@ -2,7 +2,6 @@
 /* { dg-require-effective-target mpx } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-chkpopt -fchkp-use-nochk-string-functions" } */
 /* { dg-final { scan-tree-dump "memmove_nochk" "chkpopt" } } */
-/* { dg-final { cleanup-tree-dump "chkpopt" } } */
 
 #include "string.h"
 
--- a/src/gcc/testsuite/gcc.target/i386/chkp-stropt-4.c
+++ b/src/gcc/testsuite/gcc.target/i386/chkp-stropt-4.c
@@ -3,7 +3,6 @@
 /* { dg-require-effective-target mempcpy } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-chkpopt -fchkp-use-nochk-string-functions -D_GNU_SOURCE" } */
 /* { dg-final { scan-tree-dump "mempcpy_nochk" "chkpopt" } } */
-/* { dg-final { cleanup-tree-dump "chkpopt" } } */
 
 #include "string.h"
 
--- a/src/gcc/testsuite/gcc.target/i386/chkp-stropt-5.c
+++ b/src/gcc/testsuite/gcc.target/i386/chkp-stropt-5.c
@@ -2,7 +2,6 @@
 /* { dg-require-effective-target mpx } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-chkpopt -fchkp-use-fast-string-functions" } */
 /* { dg-final { scan-tree-dump "memcpy_nobnd" "chkpopt" } } */
-/* { dg-final { cleanup-tree-dump "chkpopt" } } */
 
 #include "string.h"
 
--- a/src/gcc/testsuite/gcc.target/i386/chkp-stropt-6.c
+++ b/src/gcc/testsuite/gcc.target/i386/chkp-stropt-6.c
@@ -2,7 +2,6 @@
 /* { dg-require-effective-target mpx } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-chkpopt -fchkp-use-fast-string-functions" } */
 /* { dg-final { scan-tree-dump "memset_nobnd" "chkpopt" } } */
-/* { dg-final { cleanup-tree-dump "chkpopt" } } */
 
 #include "string.h"
 
--- a/src/gcc/testsuite/gcc.target/i386/chkp-stropt-7.c
+++ b/src/gcc/testsuite/gcc.target/i386/chkp-stropt-7.c
@@ -2,7 +2,6 @@
 /* { dg-require-effective-target mpx } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-chkpopt -fchkp-use-fast-string-functions" } */
 /* { dg-final { scan-tree-dump "memmove_nobnd" "chkpopt" } } */
-/* { dg-final { cleanup-tree-dump "chkpopt" } } */
 
 #include "string.h"
 
--- a/src/gcc/testsuite/gcc.target/i386/chkp-stropt-8.c
+++ b/src/gcc/testsuite/gcc.target/i386/chkp-stropt-8.c
@@ -3,7 +3,6 @@
 /* { dg-require-effective-target mempcpy } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-chkpopt -fchkp-use-fast-string-functions -D_GNU_SOURCE" } */
 /* { dg-final { scan-tree-dump "mempcpy_nobnd" "chkpopt" } } */
-/* { dg-final { cleanup-tree-dump "chkpopt" } } */
 
 #include "string.h"
 
--- a/src/gcc/testsuite/gcc.target/i386/chkp-stropt-9.c
+++ b/src/gcc/testsuite/gcc.target/i386/chkp-stropt-9.c
@@ -2,7 +2,6 @@
 /* { dg-require-effective-target mpx } */
 /* { dg-options "-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-chkpopt -fchkp-use-fast-string-functions" } */
 /* { dg-final { scan-tree-dump-not "memcpy_nobnd" "chkpopt" } } */
-/* { dg-final { cleanup-tree-dump "chkpopt" } } */
 
 #include "string.h"
 
--- a/src/gcc/testsuite/gcc.target/i386/intrinsics_opt-2.c
+++ b/src/gcc/testsuite/gcc.target/i386/intrinsics_opt-2.c
@@ -13,4 +13,3 @@ int f(__m128d x){
 }
 
 /* { dg-final { scan-tree-dump "return 1;" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.target/i386/mcount_pic.c
+++ b/src/gcc/testsuite/gcc.target/i386/mcount_pic.c
@@ -12,5 +12,4 @@ int main ()
 
 /* { dg-final { scan-assembler "mcount" } } */
 /* { dg-final { scan-assembler "get_pc_thunk" { xfail { *-*-solaris* && { ! gld } } } } } */
-/* { dg-final { cleanup-saved-temps } } */
 /* { dg-final { cleanup-profile-file } } */
--- a/src/gcc/testsuite/gcc.target/i386/nrv1.c
+++ b/src/gcc/testsuite/gcc.target/i386/nrv1.c
@@ -9,4 +9,3 @@ _Complex double foo (_Complex double x)
 }
 
 /* { dg-final { scan-tree-dump-times "return slot optimization" 1 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.target/i386/pr20020-1.c
+++ b/src/gcc/testsuite/gcc.target/i386/pr20020-1.c
@@ -24,4 +24,3 @@ sptr_result (void)
 }
 /* { dg-final { scan-rtl-dump "\\\(set \\\(reg:TI \[0-9\]* \\\[ <retval> \\\]\\\)" "expand" } } */
 /* { dg-final { scan-rtl-dump "\\\(set \\\(reg/i:TI 0 ax\\\)" "expand" } } */
-/* { dg-final { cleanup-rtl-dump "expand" } } */
--- a/src/gcc/testsuite/gcc.target/i386/pr20020-2.c
+++ b/src/gcc/testsuite/gcc.target/i386/pr20020-2.c
@@ -22,4 +22,3 @@ copy_sptr (sptr_t *dest, sptr_t src)
 }
 
 /* { dg-final { scan-rtl-dump "\\\(set \\\(reg:TI \[0-9\]*" "expand" } } */
-/* { dg-final { cleanup-rtl-dump "expand" } } */
--- a/src/gcc/testsuite/gcc.target/i386/pr20020-3.c
+++ b/src/gcc/testsuite/gcc.target/i386/pr20020-3.c
@@ -25,4 +25,3 @@ copy_sptr (void)
 
 /* { dg-final { scan-rtl-dump "\\\(set \\\(reg:TI \[0-9\]*" "expand" } } */
 /* { dg-final { scan-rtl-dump "\\\(set \\\(mem/c:TI" "expand" } } */
-/* { dg-final { cleanup-rtl-dump "expand" } } */
--- a/src/gcc/testsuite/gcc.target/i386/pr24178.c
+++ b/src/gcc/testsuite/gcc.target/i386/pr24178.c
@@ -13,4 +13,3 @@ unsigned long f(unsigned char *p10) {
 /* The p->c memory access should have alignment of 4 bytes.  */
 
 /* { dg-final { scan-rtl-dump "MEM\[^\\n\]*A32" "expand" } } */
-/* { dg-final { cleanup-rtl-dump "expand" } } */
--- a/src/gcc/testsuite/gcc.target/i386/pr37248-1.c
+++ b/src/gcc/testsuite/gcc.target/i386/pr37248-1.c
@@ -17,4 +17,3 @@ foo (struct S x)
 
 /* { dg-final { scan-tree-dump "& 7;" "optimized" } } */
 /* { dg-final { scan-tree-dump "== 7;" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.target/i386/pr37248-2.c
+++ b/src/gcc/testsuite/gcc.target/i386/pr37248-2.c
@@ -21,4 +21,3 @@ foo (struct S x)
 
 /* { dg-final { scan-tree-dump "& (3758096391|0x0e0000007);" "optimized" } } */
 /* { dg-final { scan-tree-dump "== (3758096391|0x0e0000007);" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.target/i386/pr37248-3.c
+++ b/src/gcc/testsuite/gcc.target/i386/pr37248-3.c
@@ -23,4 +23,3 @@ foo (struct S x)
 
 /* { dg-final { scan-tree-dump "& (3766484487|0x0e07ffe07);" "optimized" } } */
 /* { dg-final { scan-tree-dump "== (3758163463|0x0e0010607);" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.target/i386/pr45830.c
+++ b/src/gcc/testsuite/gcc.target/i386/pr45830.c
@@ -28,4 +28,3 @@ foo (int *a)
 
 /* { dg-final { scan-tree-dump "expanding as bit test is preferable" "switchconv" } } */
 /* { dg-final { scan-assembler-not "CSWTCH" } } */
-/* { dg-final { cleanup-tree-dump "switchconv" } } */
--- a/src/gcc/testsuite/gcc.target/i386/pr46865-2.c
+++ b/src/gcc/testsuite/gcc.target/i386/pr46865-2.c
@@ -29,4 +29,3 @@ bar (void)
 }
 
 /* { dg-final { scan-assembler-times "asmnop" 2 } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/i386/pr53397-1.c
+++ b/src/gcc/testsuite/gcc.target/i386/pr53397-1.c
@@ -25,4 +25,3 @@ void prefetch_when_non_constant_step_is_invariant(int step, int n)
 /* { dg-final { scan-tree-dump "Issued prefetch" "aprefetch" } } */
 /* { dg-final { scan-assembler "prefetcht0" } } */
 
-/* { dg-final { cleanup-tree-dump "aprefetch" } } */
--- a/src/gcc/testsuite/gcc.target/i386/pr53397-2.c
+++ b/src/gcc/testsuite/gcc.target/i386/pr53397-2.c
@@ -24,5 +24,4 @@ void donot_prefetch_when_non_constant_step_is_variant(int step, int n)
 /* { dg-final { scan-tree-dump "Not prefetching" "aprefetch" } } */
 /* { dg-final { scan-tree-dump "loop variant step" "aprefetch" } } */
 
-/* { dg-final { cleanup-tree-dump "aprefetch" } } */
 
--- a/src/gcc/testsuite/gcc.target/i386/pr53623.c
+++ b/src/gcc/testsuite/gcc.target/i386/pr53623.c
@@ -21,5 +21,4 @@ int main(void) {
 }
 
 /* { dg-final { scan-rtl-dump "copy needed" "ree" } } */
-/* { dg-final { cleanup-rtl-dump "ree" } } */
 
--- a/src/gcc/testsuite/gcc.target/i386/pr56564-1.c
+++ b/src/gcc/testsuite/gcc.target/i386/pr56564-1.c
@@ -23,4 +23,3 @@ bar (void)
 /* { dg-final { scan-tree-dump-times "return 0" 1 "optimized" } } */
 /* { dg-final { scan-assembler ".align\[ \t]*16\[^:]*\[\n\r]s:" { target { *-*-linux* } } } } */
 /* { dg-final { scan-assembler ".align\[ \t]*16\[^:]*\[\n\r]t:" { target { *-*-linux* } } } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.target/i386/pr56564-2.c
+++ b/src/gcc/testsuite/gcc.target/i386/pr56564-2.c
@@ -22,4 +22,3 @@ bar (void)
 /* { dg-final { scan-tree-dump-times "return 0" 2 "optimized" } } */
 /* { dg-final { scan-assembler ".align\[ \t]*16\[^:]*\[\n\r]s:" { target { *-*-linux* } } } } */
 /* { dg-final { scan-assembler ".align\[ \t]*16\[^:]*\[\n\r]t:" { target { *-*-linux* } } } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.target/i386/pr56564-3.c
+++ b/src/gcc/testsuite/gcc.target/i386/pr56564-3.c
@@ -26,4 +26,3 @@ bar (void)
 /* { dg-final { scan-tree-dump-times "return 0" 0 "optimized" } } */
 /* { dg-final { scan-assembler-not ".align\[ \t]*16\[^:]*\[\n\r]s:" { target { *-*-linux* } } } } */
 /* { dg-final { scan-assembler ".align\[ \t]*16\[^:]*\[\n\r]t:" { target { *-*-linux* } } } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.target/i386/pr56564-4.c
+++ b/src/gcc/testsuite/gcc.target/i386/pr56564-4.c
@@ -19,4 +19,3 @@ bar (void)
 
 /* { dg-final { scan-assembler-not ".align\[ \t]*16\[^:]*\[\n\r]s:" { target { *-*-linux* } } } } */
 /* { dg-final { scan-assembler ".align\[ \t]*16\[^:]*\[\n\r]t:" { target { *-*-linux* } } } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.target/i386/pr58066.c
+++ b/src/gcc/testsuite/gcc.target/i386/pr58066.c
@@ -19,4 +19,3 @@ void* goo()
 
 /* { dg-final { scan-rtl-dump "Function foo.*set\[^\r\n\]*sp\\)\[\r\n\]\[^\r\n\]*plus\[^\r\n\]*sp\\)\[\r\n\]\[^\r\n\]*const_int -8.*UNSPEC_TLS.*Function goo" "final" } } */
 /* { dg-final { scan-rtl-dump "Function goo.*set\[^\r\n\]*sp\\)\[\r\n\]\[^\r\n\]*plus\[^\r\n\]*sp\\)\[\r\n\]\[^\r\n\]*const_int -8.*UNSPEC_TLS" "final" } } */
-/* { dg-final { cleanup-rtl-dump "final" } } */
--- a/src/gcc/testsuite/gcc.target/i386/pr59544.c
+++ b/src/gcc/testsuite/gcc.target/i386/pr59544.c
@@ -10,4 +10,3 @@ void test1(short * __restrict__ x, short * __restrict__ y, short * __restrict__
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.target/i386/reload-1.c
+++ b/src/gcc/testsuite/gcc.target/i386/reload-1.c
@@ -112,4 +112,3 @@ long foo (job *j )
 }
 
 /* { dg-final { scan-rtl-dump-not "deleted 1 dead insns" "csa" } } */
-/* { dg-final { cleanup-rtl-dump "csa" } } */
--- a/src/gcc/testsuite/gcc.target/i386/rotate-3.c
+++ b/src/gcc/testsuite/gcc.target/i386/rotate-3.c
@@ -2,7 +2,6 @@
 /* { dg-require-effective-target avx2 } */
 /* { dg-options "-O3 -mavx2 -fdump-tree-vect-details" } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
 unsigned int a[1024] __attribute__((aligned (32)));
 
--- a/src/gcc/testsuite/gcc.target/i386/rotate-4.c
+++ b/src/gcc/testsuite/gcc.target/i386/rotate-4.c
@@ -2,7 +2,6 @@
 /* { dg-require-effective-target avx } */
 /* { dg-options "-O3 -mavx -fdump-tree-vect-details" } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
 unsigned int a[1024] __attribute__((aligned (32)));
 
--- a/src/gcc/testsuite/gcc.target/i386/rotate-5.c
+++ b/src/gcc/testsuite/gcc.target/i386/rotate-5.c
@@ -2,7 +2,6 @@
 /* { dg-require-effective-target avx } */
 /* { dg-options "-O3 -mavx -fdump-tree-vect-details" } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
 
 unsigned int a[1024] __attribute__((aligned (32)));
 
--- a/src/gcc/testsuite/gcc.target/i386/shrink_wrap_1.c
+++ b/src/gcc/testsuite/gcc.target/i386/shrink_wrap_1.c
@@ -46,4 +46,3 @@ builtin_memset_gen_str (void *data, long offset __attribute__ ((__unused__)),
 }
 
 /* { dg-final { scan-rtl-dump "Performing shrink-wrapping" "pro_and_epilogue"  } } */
-/* { dg-final { cleanup-rtl-dump "pro_and_epilogue" } } */
--- a/src/gcc/testsuite/gcc.target/i386/sse2-cvt-2.c
+++ b/src/gcc/testsuite/gcc.target/i386/sse2-cvt-2.c
@@ -10,4 +10,3 @@
 /* { dg-final { scan-assembler "cvttps2dq" } } */
 /* { dg-final { scan-assembler "cvtdq2pd" } } */
 /* { dg-final { scan-assembler "cvtpd2ps" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.target/i386/sw-1.c
+++ b/src/gcc/testsuite/gcc.target/i386/sw-1.c
@@ -16,4 +16,3 @@ __attribute__((regparm(1))) void foo (int a, int b)
  }
 
 /* { dg-final { scan-rtl-dump "Performing shrink-wrapping" "pro_and_epilogue" } } */
-/* { dg-final { cleanup-rtl-dump "pro_and_epilogue" } } */
--- a/src/gcc/testsuite/gcc.target/i386/thunk-retbnd.c
+++ b/src/gcc/testsuite/gcc.target/i386/thunk-retbnd.c
@@ -2,7 +2,6 @@
 /* { dg-require-effective-target mpx } */
 /* { dg-options "-O2 -fcheck-pointer-bounds -mmpx -fdump-tree-optimized" } */
 /* { dg-final { scan-tree-dump-times "return &glob," 2 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
 
 int glob;
 
--- a/src/gcc/testsuite/gcc.target/i386/vect-abs-s16.c
+++ b/src/gcc/testsuite/gcc.target/i386/vect-abs-s16.c
@@ -12,4 +12,3 @@ void test (short* a, short* b)
 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.target/i386/vect-abs-s32.c
+++ b/src/gcc/testsuite/gcc.target/i386/vect-abs-s32.c
@@ -12,4 +12,3 @@ void test (int* a, int* b)
 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.target/i386/vect-abs-s8.c
+++ b/src/gcc/testsuite/gcc.target/i386/vect-abs-s8.c
@@ -12,4 +12,3 @@ void test (char* a, char* b)
 
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.target/i386/vect-cond-1.c
+++ b/src/gcc/testsuite/gcc.target/i386/vect-cond-1.c
@@ -18,4 +18,3 @@ foo (int *p)
     }
 }
 
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.target/i386/vect-double-1.c
+++ b/src/gcc/testsuite/gcc.target/i386/vect-double-1.c
@@ -34,4 +34,3 @@ sse2_test (void)
 }
 
 /* { dg-final { scan-tree-dump-times "Vectorized loops: 1" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.target/i386/vect-double-2.c
+++ b/src/gcc/testsuite/gcc.target/i386/vect-double-2.c
@@ -32,4 +32,3 @@ sse2_test (void)
 }
 
 /* { dg-final { scan-tree-dump-not "vectorized 1 loops" "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.target/i386/vectorize1.c
+++ b/src/gcc/testsuite/gcc.target/i386/vectorize1.c
@@ -18,4 +18,3 @@ int set_names (void)
 }
 
 /* { dg-final { scan-tree-dump "vect_cst" "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.target/mips/octeon-pipe-1.c
+++ b/src/gcc/testsuite/gcc.target/mips/octeon-pipe-1.c
@@ -9,4 +9,3 @@ NOMIPS16 int f (int a, int b)
 }
 
 /* { dg-final { scan-rtl-dump "octeon_mult\\*71" "sched2" } }  */
-/* { dg-final { cleanup-rtl-dump "sched2" } }  */
--- a/src/gcc/testsuite/gcc.target/mips/octeon2-pipe-1.c
+++ b/src/gcc/testsuite/gcc.target/mips/octeon2-pipe-1.c
@@ -9,4 +9,3 @@ NOMIPS16 int f (int a, int b)
 }
 
 /* { dg-final { scan-rtl-dump "octeon_mult\\*17" "sched2" } }  */
-/* { dg-final { cleanup-rtl-dump "sched2" } }  */
--- a/src/gcc/testsuite/gcc.target/mips/octeon3-pipe-1.c
+++ b/src/gcc/testsuite/gcc.target/mips/octeon3-pipe-1.c
@@ -9,4 +9,3 @@ NOMIPS16 int f (int a, int b)
 }
 
 /* { dg-final { scan-rtl-dump "octeon_mult\\*17" "sched2" } }  */
-/* { dg-final { cleanup-rtl-dump "sched2" } }  */
--- a/src/gcc/testsuite/gcc.target/mips/pr54240.c
+++ b/src/gcc/testsuite/gcc.target/mips/pr54240.c
@@ -25,4 +25,3 @@ NOMIPS16 int foo(S *s)
 }
 
 /* { dg-final { scan-tree-dump "Hoisting adjacent loads" "phiopt1" } } */
-/* { dg-final { cleanup-tree-dump "phiopt1" } } */
--- a/src/gcc/testsuite/gcc.target/nios2/custom-fp-lto.c
+++ b/src/gcc/testsuite/gcc.target/nios2/custom-fp-lto.c
@@ -26,4 +26,3 @@ main (int argc, char *argv[])
 }
 
 /* { dg-final { scan-lto-assembler "custom\\t224, " } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/powerpc/altivec-16.c
+++ b/src/gcc/testsuite/gcc.target/powerpc/altivec-16.c
@@ -19,4 +19,3 @@ vector_float f1 = { 1.0, 2.0, 3.0, 4.0 };
 vector_float_foo = { 3.0, 4.0, 5.0, 6.0 };
 vector_float_bar_eq { 8.0, 7.0, 6.0, 5.0 };
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/powerpc/altivec-29.c
+++ b/src/gcc/testsuite/gcc.target/powerpc/altivec-29.c
@@ -20,4 +20,3 @@ int *baz (int *vector __attribute__((unused)))
   return vector;
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/powerpc/dfmode_off.c
+++ b/src/gcc/testsuite/gcc.target/powerpc/dfmode_off.c
@@ -44,4 +44,3 @@ double r19 (void *x) { return *(double *) (x + 32749); }
 double r20 (void *x) { return *(double *) (x + 32748); }
 
 /* { dg-final { object-size text == 320 } } */
-/* { dg-final { cleanup-saved-temps "dfmode_off" } } */
--- a/src/gcc/testsuite/gcc.target/powerpc/dimode_off.c
+++ b/src/gcc/testsuite/gcc.target/powerpc/dimode_off.c
@@ -47,4 +47,3 @@ long long r20 (void *x) { return *(long long *) (x + 32748); }
 /* 32-bit test should really be == 512 bytes, see pr54110 */
 /* { dg-final { object-size text <= 640 { target { ilp32 } } } } */
 /* { dg-final { scan-assembler-not "(st|l)fd" } } */
-/* { dg-final { cleanup-saved-temps "dimode_off" } } */
--- a/src/gcc/testsuite/gcc.target/powerpc/e500-ord-1.c
+++ b/src/gcc/testsuite/gcc.target/powerpc/e500-ord-1.c
@@ -26,4 +26,3 @@ int islessequal (float f1, float f2)
 }
 
 /* { dg-final { scan-rtl-dump-not "__unordsf2" "final" } } */
-/* { dg-final { cleanup-rtl-dump "final" } } */
--- a/src/gcc/testsuite/gcc.target/powerpc/e500-ord-2.c
+++ b/src/gcc/testsuite/gcc.target/powerpc/e500-ord-2.c
@@ -26,4 +26,3 @@ int islessequal (float f1, float f2)
 }
 
 /* { dg-final { scan-rtl-dump-not "__unordsf2" "final" } } */
-/* { dg-final { cleanup-rtl-dump "final" } } */
--- a/src/gcc/testsuite/gcc.target/powerpc/e500-unord-1.c
+++ b/src/gcc/testsuite/gcc.target/powerpc/e500-unord-1.c
@@ -26,4 +26,3 @@ int islessequal (float f1, float f2)
 }
 
 /* { dg-final { scan-rtl-dump-times "__unordsf2" 4 "final" } } */
-/* { dg-final { cleanup-rtl-dump "final" } } */
--- a/src/gcc/testsuite/gcc.target/powerpc/e500-unord-2.c
+++ b/src/gcc/testsuite/gcc.target/powerpc/e500-unord-2.c
@@ -26,4 +26,3 @@ int islessequal (float f1, float f2)
 }
 
 /* { dg-final { scan-rtl-dump-not "__unordsf2" "final" } } */
-/* { dg-final { cleanup-rtl-dump "final" } } */
--- a/src/gcc/testsuite/gcc.target/powerpc/htm-builtin-1.c
+++ b/src/gcc/testsuite/gcc.target/powerpc/htm-builtin-1.c
@@ -51,4 +51,3 @@ void use_builtins (long *p, char code, long *a, long *b)
   __builtin_set_tfhar (a[22]);
   __builtin_set_tfiar (a[23]);
 }
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/powerpc/outofline_rnreg.c
+++ b/src/gcc/testsuite/gcc.target/powerpc/outofline_rnreg.c
@@ -6,7 +6,6 @@
 /* { dg-options "-Os -frename-registers -fdump-rtl-rnreg" } */
 /* "* renamed" or "* no available better choice" results are not acceptable */
 /* { dg-final { scan-rtl-dump-not "Register 11 in insn *" "rnreg" { target powerpc*-*-linux* } } } */
-/* { dg-final { cleanup-rtl-dump "rnreg" } } */
 int
 calc (int j)
 {
--- a/src/gcc/testsuite/gcc.target/powerpc/pr54240.c
+++ b/src/gcc/testsuite/gcc.target/powerpc/pr54240.c
@@ -24,4 +24,3 @@ int foo(S *s)
 }
 
 /* { dg-final { scan-tree-dump "Hoisting adjacent loads" "phiopt1" } } */
-/* { dg-final { cleanup-tree-dump "phiopt1" } } */
--- a/src/gcc/testsuite/gcc.target/powerpc/pr56605.c
+++ b/src/gcc/testsuite/gcc.target/powerpc/pr56605.c
@@ -11,4 +11,3 @@ void foo (short* __restrict sb, int* __restrict ia)
 }
 
 /* { dg-final { scan-rtl-dump-times "\\\(compare:CC \\\(subreg:SI \\\(reg:DI" 1 "loop2_doloop" } } */
-/* { dg-final { cleanup-rtl-dump "loop2_doloop" } } */
--- a/src/gcc/testsuite/gcc.target/powerpc/tfmode_off.c
+++ b/src/gcc/testsuite/gcc.target/powerpc/tfmode_off.c
@@ -49,4 +49,3 @@ TFmode r19 (void *x) { return *(TFmode *) (x + 32749); }
 TFmode r20 (void *x) { return *(TFmode *) (x + 32748); }
 
 /* { dg-final { object-size text == 544 } } */
-/* { dg-final { cleanup-saved-temps "tfmode_off" } } */
--- a/src/gcc/testsuite/gcc.target/powerpc/timode_off.c
+++ b/src/gcc/testsuite/gcc.target/powerpc/timode_off.c
@@ -55,4 +55,3 @@ TImode r20 (void *x) { return *(TImode *) (x + 32748); }
 
 /* { dg-final { object-size text <= 700 } } */
 /* { dg-final { scan-assembler-not "(st|l)fd" } } */
-/* { dg-final { cleanup-saved-temps "timode_off" } } */
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-vectorize-1.c
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-vectorize-1.c
@@ -52,4 +52,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-vectorize-2.c
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-vectorize-2.c
@@ -62,4 +62,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" {xfail { {! vect_hw_misalign } || powerpc*-*-* } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 0 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 4 "vect" {xfail { {! vect_hw_misalign } || powerpc*-*-* } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-vectorize-3.c
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-vectorize-3.c
@@ -58,4 +58,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 0 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-vectorize-4.c
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-vectorize-4.c
@@ -58,4 +58,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" {xfail { {! vect_hw_misalign } || powerpc*-*-* } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 0 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 3 "vect" {xfail { {! vect_hw_misalign } || powerpc*-*-* } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-vectorize-5.c
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-vectorize-5.c
@@ -58,4 +58,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 0 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-vectorize-6.c
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-vectorize-6.c
@@ -62,4 +62,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" {xfail { {! vect_hw_misalign } || powerpc*-*-* } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 0 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 4 "vect" {xfail { {! vect_hw_misalign } || powerpc*-*-* } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-vectorize-7.c
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-vectorize-7.c
@@ -62,4 +62,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" {xfail { {! vect_hw_misalign } || powerpc*-*-* } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 0 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 4 "vect" {xfail { {! vect_hw_misalign } || powerpc*-*-* } } } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-vectorize-8.c
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-vectorize-8.c
@@ -62,4 +62,3 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 2 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" } } */
-/* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.target/s390/htm-nofloat-1.c
+++ b/src/gcc/testsuite/gcc.target/s390/htm-nofloat-1.c
@@ -48,4 +48,3 @@ int main(void)
 /* Make sure no FPR saves/restores are emitted.  */
 /* { dg-final { scan-assembler-not "\tstd\t" } } */
 /* { dg-final { scan-assembler-not "\tld\t" } } */
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/s390/vector/vec-abi-vararg-1.c
+++ b/src/gcc/testsuite/gcc.target/s390/vector/vec-abi-vararg-1.c
@@ -16,7 +16,6 @@
 /* { dg-final { scan-assembler "vl\t%v\[0-9\]*,232\\(%r15\\)" { target ilp32 } } } */
 /* { dg-final { scan-assembler "ld\t%v\[0-9\]*,248\\(%r15\\)" { target ilp32 } } } */
 
-/* { dg-final { cleanup-saved-temps } } */
 
 #include <stdarg.h>
 
--- a/src/gcc/testsuite/gcc.target/s390/vector/vec-dbl-math-compile-1.c
+++ b/src/gcc/testsuite/gcc.target/s390/vector/vec-dbl-math-compile-1.c
@@ -45,4 +45,3 @@ fmsdbl (v2df a, v2df b, v2df c)
 }
 /* { dg-final { scan-assembler-times "vfms" 1 } } */
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/s390/vector/vec-genbytemask-1.c
+++ b/src/gcc/testsuite/gcc.target/s390/vector/vec-genbytemask-1.c
@@ -80,4 +80,3 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/s390/vector/vec-genmask-1.c
+++ b/src/gcc/testsuite/gcc.target/s390/vector/vec-genmask-1.c
@@ -67,4 +67,3 @@ main ()
   return 0;
 }
 
-/* { dg-final { cleanup-saved-temps } } */
--- a/src/gcc/testsuite/gcc.target/s390/zvector/vec-dbl-math-compile-1.c
+++ b/src/gcc/testsuite/gcc.target/s390/zvector/vec-dbl-math-compile-1.c
@@ -8,7 +8,6 @@
 /* { dg-final { scan-assembler-times "vfcedbs\t" 2 } } */
 /* { dg-final { scan-assembler-times "vfchdbs\t" 2 } } */
 
-/* { dg-final { cleanup-saved-temps } } */
 
 #include <vecintrin.h>
 
--- a/src/gcc/testsuite/gcc.target/sparc/fexpand-2.c
+++ b/src/gcc/testsuite/gcc.target/sparc/fexpand-2.c
@@ -9,4 +9,3 @@ vec16 foo () {
 }
 
 /* { dg-final { scan-tree-dump "{ 16, 32, 64, 128 }" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.target/sparc/fpmerge-2.c
+++ b/src/gcc/testsuite/gcc.target/sparc/fpmerge-2.c
@@ -13,4 +13,3 @@ pixel foo () {
 
 /* { dg-final { scan-assembler-not "fpmerge\t%" } } */
 /* { dg-final { scan-tree-dump "{ 1, 2, 3, 4, 5, 6, 7, 8 }" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.target/sparc/fpmul-2.c
+++ b/src/gcc/testsuite/gcc.target/sparc/fpmul-2.c
@@ -45,4 +45,3 @@ vec16 foo3 () {
 }
 /* { dg-final { scan-assembler-not "fmul8x16al\t%" } } */
 /* { dg-final { scan-tree-dump "{ 2, 4, 6, 8 }" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.target/sparc/pdist-2.c
+++ b/src/gcc/testsuite/gcc.target/sparc/pdist-2.c
@@ -16,4 +16,3 @@ int64_t foo () {
 
 /* { dg-final { scan-assembler-not "pdist\t%" } } */
 /* { dg-final { scan-tree-dump "return 475" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gcc.target/sparc/pdistn-2.c
+++ b/src/gcc/testsuite/gcc.target/sparc/pdistn-2.c
@@ -13,4 +13,3 @@ long foo () {
 
 /* { dg-final { scan-assembler-not "pdistn\t%" } } */
 /* { dg-final { scan-tree-dump "return 473" "optimized" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gfortran.dg/PR40660.f90
+++ b/src/gcc/testsuite/gfortran.dg/PR40660.f90
@@ -11,5 +11,4 @@ PROGRAM test
 end program test
 
 ! { dg-final { scan-tree-dump-times ": 3\] _gfortran" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
 
--- a/src/gcc/testsuite/gfortran.dg/alloc_comp_auto_array_2.f90
+++ b/src/gcc/testsuite/gfortran.dg/alloc_comp_auto_array_2.f90
@@ -37,4 +37,3 @@ end module grid_io
   use grid_io
   call read_grid_header
 end
-! { dg-final { cleanup-tree-dump "grid_io" } }
--- a/src/gcc/testsuite/gfortran.dg/alloc_comp_basics_1.f90
+++ b/src/gcc/testsuite/gfortran.dg/alloc_comp_basics_1.f90
@@ -142,4 +142,3 @@ contains
 
 end program alloc
 ! { dg-final { scan-tree-dump-times "builtin_free" 18 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/alloc_comp_constructor_1.f90
+++ b/src/gcc/testsuite/gfortran.dg/alloc_comp_constructor_1.f90
@@ -108,4 +108,3 @@ contains
 
 end program test_constructor
 ! { dg-final { scan-tree-dump-times "builtin_free" 19 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/allocatable_function_1.f90
+++ b/src/gcc/testsuite/gfortran.dg/allocatable_function_1.f90
@@ -108,4 +108,3 @@ contains
 
 end program alloc_fun
 ! { dg-final { scan-tree-dump-times "free" 10 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/allocatable_function_4.f90
+++ b/src/gcc/testsuite/gfortran.dg/allocatable_function_4.f90
@@ -52,5 +52,4 @@ function unique_A (x, sorted) result (x_unique)
 end function unique_A
 
 ! { dg-final { scan-tree-dump-times "__builtin_free" 5 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
 
--- a/src/gcc/testsuite/gfortran.dg/allocatable_scalar_13.f90
+++ b/src/gcc/testsuite/gfortran.dg/allocatable_scalar_13.f90
@@ -69,4 +69,3 @@ contains
 end
 ! { dg-final { scan-tree-dump-times "builtin_malloc" 15 "original" } }
 ! { dg-final { scan-tree-dump-times "builtin_free" 17 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/allocatable_scalar_9.f90
+++ b/src/gcc/testsuite/gfortran.dg/allocatable_scalar_9.f90
@@ -53,4 +53,3 @@ end block
 end
 
 ! { dg-final { scan-tree-dump-times "__builtin_free" 32 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/array_constructor_14.f90
+++ b/src/gcc/testsuite/gfortran.dg/array_constructor_14.f90
@@ -12,4 +12,3 @@ subroutine bar(x)
 end subroutine
 
 ! { dg-final { scan-tree-dump-times "data" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/array_constructor_15.f90
+++ b/src/gcc/testsuite/gfortran.dg/array_constructor_15.f90
@@ -4,4 +4,3 @@
   if (any(x(:,:) .ne. reshape ((/ 3, 1, 4, 1 /), (/ 2, 2 /)))) call abort ()
 end
 ! { dg-final { scan-tree-dump-times "atmp" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/array_constructor_40.f90
+++ b/src/gcc/testsuite/gfortran.dg/array_constructor_40.f90
@@ -49,4 +49,3 @@ program main
   if (abs(res - 8.1) > 1e-5) call abort
 end program main
 ! { dg-final { scan-tree-dump-times "while" 5 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/array_constructor_41.f90
+++ b/src/gcc/testsuite/gfortran.dg/array_constructor_41.f90
@@ -30,4 +30,3 @@ PROGRAM TEST
 END
 
 ! { dg-final { scan-tree-dump-times "realloc" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/array_constructor_43.f90
+++ b/src/gcc/testsuite/gfortran.dg/array_constructor_43.f90
@@ -10,4 +10,3 @@ program main
   if (any ([a,b,c,d] < 0.2)) print *,"foo"
 end program main
 ! { dg-final { scan-tree-dump-times "\\\|\\\|" 3 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/array_constructor_46.f90
+++ b/src/gcc/testsuite/gfortran.dg/array_constructor_46.f90
@@ -12,4 +12,3 @@ program main
   if (abs (product([[11._dp, thirteen], a]) - 30030._dp) > 1e-8) call abort
 end program main
 ! { dg-final { scan-tree-dump-times "while" 2 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/array_constructor_47.f90
+++ b/src/gcc/testsuite/gfortran.dg/array_constructor_47.f90
@@ -20,5 +20,4 @@ program main
   end function eleven_ones
 end program main
 ! { dg-final { scan-tree-dump-times "while" 4 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
 
--- a/src/gcc/testsuite/gfortran.dg/array_constructor_49.f90
+++ b/src/gcc/testsuite/gfortran.dg/array_constructor_49.f90
@@ -10,4 +10,3 @@ program t
   if (line /= ' 3 4 5 6') call abort
 end program t
 ! { dg-final { scan-tree-dump-times "__var" 3 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/array_memcpy_1.f90
+++ b/src/gcc/testsuite/gfortran.dg/array_memcpy_1.f90
@@ -25,4 +25,3 @@ subroutine testl(a,b)
 end subroutine
 
 ! { dg-final { scan-tree-dump-times "memcpy" 4 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/array_memcpy_2.f90
+++ b/src/gcc/testsuite/gfortran.dg/array_memcpy_2.f90
@@ -17,4 +17,3 @@
   z = y
 end
 ! { dg-final { scan-tree-dump-times "memcpy" 2 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/array_memcpy_3.f90
+++ b/src/gcc/testsuite/gfortran.dg/array_memcpy_3.f90
@@ -12,4 +12,3 @@ subroutine bar(x)
 end subroutine
 
 ! { dg-final { scan-tree-dump-times "memcpy|ref-all\[^\\n\]*ref-all" 2 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/array_memcpy_4.f90
+++ b/src/gcc/testsuite/gfortran.dg/array_memcpy_4.f90
@@ -10,4 +10,3 @@
   d = s
 end
 ! { dg-final { scan-tree-dump-times "memcpy" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/array_memset_1.f90
+++ b/src/gcc/testsuite/gfortran.dg/array_memset_1.f90
@@ -61,4 +61,3 @@ subroutine l3(a)
 end subroutine
 
 ! { dg-final { scan-tree-dump-times "memset" 12 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/array_memset_2.f90
+++ b/src/gcc/testsuite/gfortran.dg/array_memset_2.f90
@@ -34,4 +34,3 @@ program test
 end program
 
 ! { dg-final { scan-tree-dump-times "= {}" 2 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/array_section_2.f90
+++ b/src/gcc/testsuite/gfortran.dg/array_section_2.f90
@@ -13,4 +13,3 @@ program test
    temp(1:size(a)) = a
 end program
 ! { dg-final { scan-tree-dump-times "MAX_EXPR\[^\n\t\]+ubound\[^\n\t\]+lbound" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/assign_10.f90
+++ b/src/gcc/testsuite/gfortran.dg/assign_10.f90
@@ -25,4 +25,3 @@ end
 !
 ! { dg-final { scan-tree-dump-times "parm" 18 "original" } }
 ! { dg-final { scan-tree-dump-times "atmp" 18 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/associate_11.f90
+++ b/src/gcc/testsuite/gfortran.dg/associate_11.f90
@@ -22,4 +22,3 @@ contains
 end program bug
 
 ! { dg-final { scan-tree-dump-times "foo ..integer.kind=4..0:. . restrict. a.data.;" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/associate_6.f03
+++ b/src/gcc/testsuite/gfortran.dg/associate_6.f03
@@ -35,4 +35,3 @@ PROGRAM main
   END ASSOCIATE
 END PROGRAM main
 ! { dg-final { scan-tree-dump-times "func" 2 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/associative_1.f90
+++ b/src/gcc/testsuite/gfortran.dg/associative_1.f90
@@ -7,4 +7,3 @@ SUBROUTINE S1(a)
  a=1+a-1
 END SUBROUTINE S1
 ! { dg-final { scan-tree-dump-times " \\\+ " 0 "optimized" } }
-! { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/gfortran.dg/assumed_charlen_substring_1.f90
+++ b/src/gcc/testsuite/gfortran.dg/assumed_charlen_substring_1.f90
@@ -7,4 +7,3 @@ subroutine foo(a,b)
   if (a(1:) /= a(1:)) call do_not_use
 end subroutine foo
 ! { dg-final { scan-tree-dump-times "do_not_use" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/assumed_rank_10.f90
+++ b/src/gcc/testsuite/gfortran.dg/assumed_rank_10.f90
@@ -103,4 +103,3 @@ end program test
 ! { dg-final { scan-tree-dump-times "iia = .integer.kind=4. .. desc.\[0-9\]+.data;" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "jjp = .struct t .. desc.\[0-9\]+.data;" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "jja = .struct t .. desc.\[0-9\]+.data;" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/assumed_rank_12.f90
+++ b/src/gcc/testsuite/gfortran.dg/assumed_rank_12.f90
@@ -17,5 +17,4 @@ end function f
 end
 
 ! { dg-final { scan-tree-dump " = f \\(\\);.*desc.0.dtype = .*;.*desc.0.data = .void .. D.*;.*sub \\(&desc.0\\);.*D.*= .integer.kind=4. .. desc.0.data;" "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
 
--- a/src/gcc/testsuite/gfortran.dg/assumed_type_2.f90
+++ b/src/gcc/testsuite/gfortran.dg/assumed_type_2.f90
@@ -175,4 +175,3 @@ end
 ! { dg-final { scan-tree-dump-times "sub_array_shape \\(&array_class_t1_alloc._data," 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_array_shape \\(&array_class_t1_ptr._data," 1 "original" } }
 
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/auto_dealloc_1.f90
+++ b/src/gcc/testsuite/gfortran.dg/auto_dealloc_1.f90
@@ -54,4 +54,3 @@ end module
 
 
 ! { dg-final { scan-tree-dump-times "__builtin_free" 4 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/auto_dealloc_2.f90
+++ b/src/gcc/testsuite/gfortran.dg/auto_dealloc_2.f90
@@ -28,4 +28,3 @@ end program
 
 ! { dg-final { scan-tree-dump-times "__builtin_free" 4 "original" } }
 ! { dg-final { scan-tree-dump-times "x->_vptr->_final \\(" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/auto_save_2.f90
+++ b/src/gcc/testsuite/gfortran.dg/auto_save_2.f90
@@ -81,4 +81,3 @@ end
 
 ! { dg-final { scan-tree-dump-times "  static integer\\\(kind=4\\\) a = 0;" 2 "original" } }
 ! { dg-final { scan-tree-dump-times "  b = 0;" 2 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/bind_c_array_params_2.f90
+++ b/src/gcc/testsuite/gfortran.dg/bind_c_array_params_2.f90
@@ -19,4 +19,3 @@ end
 ! { dg-final { scan-assembler-times "\[ \t\]\[$,_0-9\]*myBindC" 1 { target { ! { hppa*-*-* } } } } }
 ! { dg-final { scan-assembler-times "myBindC,%r2" 1 { target { hppa*-*-* } } } }
 ! { dg-final { scan-tree-dump-times "test \\\(&parm\\." 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/bind_c_usage_13.f03
+++ b/src/gcc/testsuite/gfortran.dg/bind_c_usage_13.f03
@@ -148,4 +148,3 @@ end program test
 ! { dg-final { scan-tree-dump "subiso_val .121.;" "original" } }
 ! { dg-final { scan-tree-dump "subiso2_val ..z..;" "original" } }
 !
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/bind_c_usage_14.f03
+++ b/src/gcc/testsuite/gfortran.dg/bind_c_usage_14.f03
@@ -112,4 +112,3 @@ end subroutine sub6NoIso
 ! { dg-final { scan-tree-dump "master.3.sub6noiso .0, 0B, 0B, 0B, b, a, 0, 0, 1, 1\\);" "original" } }
 ! { dg-final { scan-tree-dump "master.3.sub6noiso .1, z, y, x, 0B, 0B, 1, 1, 0, 0\\);" "original" } }
 
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/block_2.f08
+++ b/src/gcc/testsuite/gfortran.dg/block_2.f08
@@ -36,4 +36,3 @@ PROGRAM main
   END BLOCK
 END PROGRAM main
 ! { dg-final { scan-tree-dump-times "free \\(\\(void \\*\\) alloc_arr\\.data" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/bound_simplification_3.f90
+++ b/src/gcc/testsuite/gfortran.dg/bound_simplification_3.f90
@@ -20,4 +20,3 @@ end program testit
 
 ! { dg-final { scan-tree-dump-times "bound" 0 "original" } }
 ! { dg-final { scan-tree-dump-times "abort" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/c_f_pointer_tests_3.f90
+++ b/src/gcc/testsuite/gfortran.dg/c_f_pointer_tests_3.f90
@@ -39,4 +39,3 @@ end program test
 ! Check c_f_procpointer
 ! { dg-final { scan-tree-dump-times "  fprocptr = .integer.kind=4. .\\*<.*>. ... cfunptr;" 1 "original" } }
 !
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/c_funloc_tests_7.f90
+++ b/src/gcc/testsuite/gfortran.dg/c_funloc_tests_7.f90
@@ -18,5 +18,4 @@ end
 
 ! { dg-final { scan-tree-dump-times "cfp =\[^;\]+ nocsub;" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "fint =\[^;\]+ cfp;" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
 
--- a/src/gcc/testsuite/gfortran.dg/c_loc_test_22.f90
+++ b/src/gcc/testsuite/gfortran.dg/c_loc_test_22.f90
@@ -21,4 +21,3 @@ end
 ! { dg-final { scan-tree-dump-times "parm.\[0-9\]+.data = \\(void .\\) &\\(.yyy.\[0-9\]+\\)\\\[D.\[0-9\]+ \\* 4\\\];" 1 "original" } }
 
 ! { dg-final { scan-tree-dump-times "D.\[0-9\]+ = parm.\[0-9\]+.data;\[^;]+ptr\[1-4\] = D.\[0-9\]+;" 4 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/c_ptr_tests_14.f90
+++ b/src/gcc/testsuite/gfortran.dg/c_ptr_tests_14.f90
@@ -49,4 +49,3 @@ end program test
 
 ! { dg-final { scan-tree-dump-times "bbb =" 0 "original" } }
 
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/c_ptr_tests_15.f90
+++ b/src/gcc/testsuite/gfortran.dg/c_ptr_tests_15.f90
@@ -51,4 +51,3 @@ end program test
 
 ! { dg-final { scan-tree-dump-times "bbb =" 0 "original" } }
 
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/c_ptr_tests_16.f90
+++ b/src/gcc/testsuite/gfortran.dg/c_ptr_tests_16.f90
@@ -59,4 +59,3 @@ function fun()
 end function fun 
 
 ! { dg-final { scan-tree-dump-times "i_do_not_exist" 0 "optimized" } }
-! { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/gfortran.dg/char_cast_1.f90
+++ b/src/gcc/testsuite/gfortran.dg/char_cast_1.f90
@@ -28,4 +28,3 @@ end
 ! The sign that all is well is that [S.6][1] appears twice.
 ! Platform dependent variations are [S$6][1], [__S_6][1], [S___6][1]
 ! { dg-final { scan-tree-dump-times "6\\\]\\\[1\\\]" 2 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/char_cast_2.f90
+++ b/src/gcc/testsuite/gfortran.dg/char_cast_2.f90
@@ -23,4 +23,3 @@ end
 ! Platform dependent variations are [S$5][1], [__S_5][1], [S___5][1]
 ! so we count the occurrences of 5][1].
 ! { dg-final { scan-tree-dump-times "5\\\]\\\[1\\\]" 2 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/char_eoshift_5.f90
+++ b/src/gcc/testsuite/gfortran.dg/char_eoshift_5.f90
@@ -22,4 +22,3 @@ END
 
 ! Check that _gfortran_eoshift* is called with 8 arguments:
 ! { dg-final { scan-tree-dump "_gfortran_eoshift\[0-9_\]+char \\(\[&a-zA-Z0-9._\]*, \[&a-zA-Z0-9._\]*, \[&a-zA-Z0-9._\]*, \[&a-zA-Z0-9._\]*, \[&a-zA-Z0-9._\]*, \[&a-zA-Z0-9._\]*, \[&a-zA-Z0-9._\]*, \[&a-zA-Z0-9._\]*\\)" "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/char_length_17.f90
+++ b/src/gcc/testsuite/gfortran.dg/char_length_17.f90
@@ -12,4 +12,3 @@ program main
   if (c(i+1:i+1) /= 'b') call abort ()
 end program main
 ! { dg-final { scan-tree-dump-times "gfortran_compare_string" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/character_comparison_1.f90
+++ b/src/gcc/testsuite/gfortran.dg/character_comparison_1.f90
@@ -33,5 +33,4 @@ subroutine yes
 end subroutine yes
 
 ! { dg-final { scan-tree-dump-times "gfortran_compare_string" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
 
--- a/src/gcc/testsuite/gfortran.dg/character_comparison_2.f90
+++ b/src/gcc/testsuite/gfortran.dg/character_comparison_2.f90
@@ -36,5 +36,4 @@ subroutine yes
 end subroutine yes
 
 ! { dg-final { scan-tree-dump-times "gfortran_compare_string" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
 
--- a/src/gcc/testsuite/gfortran.dg/character_comparison_3.f90
+++ b/src/gcc/testsuite/gfortran.dg/character_comparison_3.f90
@@ -27,5 +27,4 @@ end program main
 
 ! { dg-final { scan-tree-dump-times "gfortran_compare_string" 6 "original" } }
 ! { dg-final { scan-tree-dump-times "__builtin_memcmp" 2 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
 
--- a/src/gcc/testsuite/gfortran.dg/character_comparison_4.f90
+++ b/src/gcc/testsuite/gfortran.dg/character_comparison_4.f90
@@ -35,5 +35,4 @@ subroutine yes
 end subroutine yes
 
 ! { dg-final { scan-tree-dump-times "gfortran_compare_string" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
 
--- a/src/gcc/testsuite/gfortran.dg/character_comparison_5.f90
+++ b/src/gcc/testsuite/gfortran.dg/character_comparison_5.f90
@@ -17,5 +17,4 @@ end program main
 
 ! { dg-final { scan-tree-dump-times "gfortran_concat_string" 0 "original" } }
 ! { dg-final { scan-tree-dump-times "__builtin_memcmp" 2 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
 
--- a/src/gcc/testsuite/gfortran.dg/character_comparison_6.f90
+++ b/src/gcc/testsuite/gfortran.dg/character_comparison_6.f90
@@ -16,5 +16,4 @@ end program main
 
 ! { dg-final { scan-tree-dump-times "gfortran_concat_string" 4 "original" } }
 ! { dg-final { scan-tree-dump-times "gfortran_compare_string" 2 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
 
--- a/src/gcc/testsuite/gfortran.dg/character_comparison_7.f90
+++ b/src/gcc/testsuite/gfortran.dg/character_comparison_7.f90
@@ -22,5 +22,4 @@ subroutine no(a)
 end subroutine no
 
 ! { dg-final { scan-tree-dump-times "gfortran_compare_string" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
 
--- a/src/gcc/testsuite/gfortran.dg/character_comparison_8.f90
+++ b/src/gcc/testsuite/gfortran.dg/character_comparison_8.f90
@@ -10,5 +10,4 @@ program main
   if (LGT(a,a)) call abort
 end program main
 ! { dg-final { scan-tree-dump-times "gfortran_compare_string" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
 
--- a/src/gcc/testsuite/gfortran.dg/character_comparison_9.f90
+++ b/src/gcc/testsuite/gfortran.dg/character_comparison_9.f90
@@ -13,4 +13,3 @@ program main
 end program main
 ! { dg-final { scan-tree-dump-times "_gfortran_compare_string_char4" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "__builtin_memcmp" 2 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/chmod_1.f90
+++ b/src/gcc/testsuite/gfortran.dg/chmod_1.f90
@@ -2,7 +2,7 @@
 ! { dg-options "-std=gnu" }
 ! See PR38956.  Test fails on cygwin when user has Administrator rights
   implicit none
-  character(len=*), parameter :: n = "foobar_file"
+  character(len=*), parameter :: n = "foobar_file_chmod_1"
   integer :: i
 
   open (10,file=n)
--- a/src/gcc/testsuite/gfortran.dg/chmod_2.f90
+++ b/src/gcc/testsuite/gfortran.dg/chmod_2.f90
@@ -2,7 +2,7 @@
 ! { dg-options "-std=gnu" }
 ! See PR38956.  Test fails on cygwin when user has Administrator rights
   implicit none
-  character(len=*), parameter :: n = "foobar_file"
+  character(len=*), parameter :: n = "foobar_file_chmod_2"
   integer :: i
 
   open (10,file=n)
--- a/src/gcc/testsuite/gfortran.dg/chmod_3.f90
+++ b/src/gcc/testsuite/gfortran.dg/chmod_3.f90
@@ -2,7 +2,7 @@
 ! { dg-options "-std=gnu -fdefault-integer-8" }
 ! See PR38956.  Test fails on cygwin when user has Administrator rights
   implicit none
-  character(len=*), parameter :: n = "foobar_file"
+  character(len=*), parameter :: n = "foobar_file_chmod_3"
   integer :: i
 
   open (10,file=n)
--- a/src/gcc/testsuite/gfortran.dg/class_19.f03
+++ b/src/gcc/testsuite/gfortran.dg/class_19.f03
@@ -40,4 +40,3 @@ program main
 end program main
 
 ! { dg-final { scan-tree-dump-times "__builtin_free" 12 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/class_51.f90
+++ b/src/gcc/testsuite/gfortran.dg/class_51.f90
@@ -22,4 +22,3 @@
   End Program
 
 ! { dg-final { scan-tree-dump-times "sub \\(&class" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/class_alias.f90
+++ b/src/gcc/testsuite/gfortran.dg/class_alias.f90
@@ -92,4 +92,3 @@ use test_module
   deallocate (var_a)
   deallocate (var_p)
 end
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/class_allocate_14.f90
+++ b/src/gcc/testsuite/gfortran.dg/class_allocate_14.f90
@@ -27,5 +27,4 @@ end
 
 ! { dg-final { scan-tree-dump-times "static struct __class_m_T_1_0a b = {._data={.data=0B}, ._vptr=&__vtab_m_T};" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "static struct __class_m_T_a y = {._data=0B, ._vptr=&__vtab_m_T};" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
 
--- a/src/gcc/testsuite/gfortran.dg/class_allocate_15.f90
+++ b/src/gcc/testsuite/gfortran.dg/class_allocate_15.f90
@@ -25,4 +25,3 @@ contains
   end
 end
 ! { dg-final { scan-tree-dump-times "__builtin_free" 2 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/class_allocate_16.f90
+++ b/src/gcc/testsuite/gfortran.dg/class_allocate_16.f90
@@ -25,4 +25,3 @@
 end
 
 ! { dg-final { scan-tree-dump-times "__builtin_free" 4 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/class_allocate_17.f90
+++ b/src/gcc/testsuite/gfortran.dg/class_allocate_17.f90
@@ -29,4 +29,3 @@ contains
 end
 
 ! { dg-final { scan-tree-dump-times "fini_coarray" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/class_array_15.f03
+++ b/src/gcc/testsuite/gfortran.dg/class_array_15.f03
@@ -116,4 +116,3 @@ subroutine pr54992  ! This test remains as the original.
   if (loc (b) .ne. loc(bh%hostNode)) call abort
 end
 ! { dg-final { scan-tree-dump-times "builtin_free" 12 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/class_array_16.f90
+++ b/src/gcc/testsuite/gfortran.dg/class_array_16.f90
@@ -68,4 +68,3 @@ end
 
 ! { dg-final { scan-tree-dump-times "__builtin_free" 5 "original" } }
 ! { dg-final { scan-tree-dump-times "finally" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/class_array_17.f90
+++ b/src/gcc/testsuite/gfortran.dg/class_array_17.f90
@@ -31,4 +31,3 @@ program test
 end
 
 ! { dg-final { scan-tree-dump-times "__builtin_malloc \\(40\\);" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/coarray_11.f90
+++ b/src/gcc/testsuite/gfortran.dg/coarray_11.f90
@@ -61,4 +61,3 @@ subroutine boundsTest()
 end subroutine boundsTest
 
 ! { dg-final { scan-tree-dump-times "not_existing" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/coarray_12.f90
+++ b/src/gcc/testsuite/gfortran.dg/coarray_12.f90
@@ -74,4 +74,3 @@ end subroutine testAlloc5
 ! { dg-final { scan-tree-dump-times "yyy.dim.4..lbound = .*ooo;" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "yyy.dim.4..ubound"          0 "original" } }
 
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/coarray_30.f90
+++ b/src/gcc/testsuite/gfortran.dg/coarray_30.f90
@@ -12,4 +12,3 @@ program main
 end
 
 ! { dg-final { scan-tree-dump-times "greeting.data = \\(void . restrict\\) __builtin_malloc \\(25\\);" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/coarray_31.f90
+++ b/src/gcc/testsuite/gfortran.dg/coarray_31.f90
@@ -19,4 +19,3 @@ end
 ! { dg-final { scan-tree-dump "a.y.x.data = D.\[0-9\]+.y.x.data;" "original" } }
 ! { dg-final { scan-tree-dump "a.y.z._data.data = D.\[0-9\]+.y.z._data.data;" "original" } }
 ! { dg-final { scan-tree-dump "a.y.d._data.data = D.\[0-9\]+.y.d._data.data;" "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/coarray_32.f90
+++ b/src/gcc/testsuite/gfortran.dg/coarray_32.f90
@@ -14,5 +14,4 @@ end
 
 ! { dg-final { scan-tree-dump-times "ubound.. = " 1 "original" } }
 ! { dg-final { scan-tree-dump-times "size.. = " 2 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
 
--- a/src/gcc/testsuite/gfortran.dg/coarray_atomic_4.f90
+++ b/src/gcc/testsuite/gfortran.dg/coarray_atomic_4.f90
@@ -66,4 +66,3 @@ end
 ! All calls should have a stat=0
 ! { dg-final { scan-tree-dump-times "stat = 0;" 14 "original" } }
 
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/coarray_atomic_5.f90
+++ b/src/gcc/testsuite/gfortran.dg/coarray_atomic_5.f90
@@ -23,4 +23,3 @@ end program
 ! { dg-final { scan-tree-dump-times "_gfortran_caf_atomic_define \\(caf_token.0, 0, 1, &value.., 0B, 1, 4\\);" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "_gfortran_caf_atomic_op \\(1, caf_token.0, 0, 1, &me, 0B, 0B, 1, 4\\);" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "_gfortran_caf_atomic_ref \\(caf_token.0, 0, 1, &me, 0B, 1, 4\\);" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/coarray_collectives_11.f90
+++ b/src/gcc/testsuite/gfortran.dg/coarray_collectives_11.f90
@@ -12,4 +12,3 @@ program test
 end program test
 
 ! { dg-final { scan-tree-dump-times "stat1 = 0;" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/coarray_collectives_12.f90
+++ b/src/gcc/testsuite/gfortran.dg/coarray_collectives_12.f90
@@ -23,4 +23,3 @@ end program test
 ! { dg-final { scan-tree-dump-times "_gfortran_caf_co_broadcast \\(&desc.., _gfortran_caf_num_images \\(0, -1\\), &stat1, errmesg1, 6\\);" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "_gfortran_caf_co_broadcast \\(&val2, 4, &stat2, errmesg2, 7\\);" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "_gfortran_caf_co_broadcast \\(&desc.., res, &stat3, errmesg3, 8\\);" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/coarray_collectives_15.f90
+++ b/src/gcc/testsuite/gfortran.dg/coarray_collectives_15.f90
@@ -17,4 +17,3 @@ contains
 end program test
 
 ! { dg-final { scan-tree-dump-times "stat1 = 0;" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/coarray_collectives_16.f90
+++ b/src/gcc/testsuite/gfortran.dg/coarray_collectives_16.f90
@@ -36,4 +36,3 @@ end program test
 ! { dg-final { scan-tree-dump-times "_gfortran_caf_co_reduce \\(&desc.., fr, 4, _gfortran_caf_num_images \\(0, -1\\), &stat1, errmesg1, 0, 6\\);" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "_gfortran_caf_co_reduce \\(&val2, gz, 0, 4, &stat2, errmesg2, 0, 7\\);" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "_gfortran_caf_co_reduce \\(&desc.., hc, 1, res, &stat3, errmesg3, 99, 8\\);" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/coarray_collectives_4.f90
+++ b/src/gcc/testsuite/gfortran.dg/coarray_collectives_4.f90
@@ -16,5 +16,4 @@ end program test
 ! { dg-final { scan-tree-dump-times "stat1 = 0;" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "stat2 = 0;" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "stat3 = 0;" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
 
--- a/src/gcc/testsuite/gfortran.dg/coarray_collectives_5.f90
+++ b/src/gcc/testsuite/gfortran.dg/coarray_collectives_5.f90
@@ -16,4 +16,3 @@ end program test
 ! { dg-final { scan-tree-dump-times "_gfortran_caf_co_max \\(&desc.., 0, &stat1, 0B, 0, 0\\);" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "_gfortran_caf_co_min \\(&desc.., 0, &stat2, 0B, 0, 0\\);" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "_gfortran_caf_co_sum \\(&desc.., 0, &stat3, 0B, 0\\);" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/coarray_collectives_6.f90
+++ b/src/gcc/testsuite/gfortran.dg/coarray_collectives_6.f90
@@ -23,4 +23,3 @@ end program test
 ! { dg-final { scan-tree-dump-times "_gfortran_caf_co_max \\(&desc.., 0, &stat1, errmesg1, 0, 6\\);" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "_gfortran_caf_co_sum \\(&val2, 4, &stat2, errmesg2, 7\\);" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "_gfortran_caf_co_min \\(&desc.., res, &stat3, errmesg3, 99, 8\\);" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/coarray_lib_alloc_1.f90
+++ b/src/gcc/testsuite/gfortran.dg/coarray_lib_alloc_1.f90
@@ -19,4 +19,3 @@
 ! { dg-final { scan-tree-dump-times "_gfortran_caf_deregister .&yy.token, &stat.., &errmsg, 200.;" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "_gfortran_caf_deregister .&yy.token, 0B, 0B, 0.;" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "_gfortran_caf_deregister .&xx.token, 0B, 0B, 0.;" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/coarray_lib_alloc_2.f90
+++ b/src/gcc/testsuite/gfortran.dg/coarray_lib_alloc_2.f90
@@ -21,4 +21,3 @@
 ! { dg-final { scan-tree-dump-times "_gfortran_caf_deregister .&yy._data.token, &stat.., &errmsg, 200.;" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "_gfortran_caf_deregister .&yy._data.token, 0B, 0B, 0.;" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "_gfortran_caf_deregister .&xx._data.token, 0B, 0B, 0.;" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/coarray_lib_alloc_3.f90
+++ b/src/gcc/testsuite/gfortran.dg/coarray_lib_alloc_3.f90
@@ -22,4 +22,3 @@ subroutine test
 ! { dg-final { scan-tree-dump-times "_gfortran_caf_deregister .&yy._data.token, &stat.., &errmsg, 200.;" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "_gfortran_caf_deregister .&yy._data.token, 0B, 0B, 0.;" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "_gfortran_caf_deregister .&xx._data.token, 0B, 0B, 0.;" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/coarray_lib_comm_1.f90
+++ b/src/gcc/testsuite/gfortran.dg/coarray_lib_comm_1.f90
@@ -44,4 +44,3 @@ end
 ! { dg-final { scan-tree-dump-times "_gfortran_caf_get \\\(caf_token.1, \\\(integer\\\(kind=\[48\]\\\)\\\) parm.\[0-9\]+.data - \\\(integer\\\(kind=\[48\]\\\)\\\) b, 1, &parm.\[0-9\]+, 0B, &p, 4, 4, 0\\\);" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "_gfortran_caf_sendget \\\(caf_token.0, \\\(integer\\\(kind=\[48\]\\\)\\\) parm.\[0-9\]+.data - \\\(integer\\\(kind=\[48\]\\\)\\\) a, 1, &parm.\[0-9\]+, 0B, caf_token.0, \\\(integer\\\(kind=\[48\]\\\)\\\) parm.\[0-9\]+.data - \\\(integer\\\(kind=\[48\]\\\)\\\) a, 1, &parm.\[0-9\]+, 0B, 4, 4, 0\\\);" 1 "original" } }
 
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/coarray_lib_move_alloc_1.f90
+++ b/src/gcc/testsuite/gfortran.dg/coarray_lib_move_alloc_1.f90
@@ -20,4 +20,3 @@ end
 ! { dg-final { scan-tree-dump-times "_gfortran_caf_deregister" 2 "original" } }
 ! { dg-final { scan-tree-dump-times "\\*bb = \\*aa" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "\\*dd = \\*cc" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/coarray_lib_realloc_1.f90
+++ b/src/gcc/testsuite/gfortran.dg/coarray_lib_realloc_1.f90
@@ -32,4 +32,3 @@ end
 ! But copy "ii" and "CAF":
 ! { dg-final { scan-tree-dump-times "__builtin_memcpy|= MEM" 2 "original" } }
 
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/coarray_lib_this_image_1.f90
+++ b/src/gcc/testsuite/gfortran.dg/coarray_lib_this_image_1.f90
@@ -24,4 +24,3 @@ end
 ! { dg-final { scan-tree-dump-times "mythis_image = _gfortran_caf_this_image \\(0\\);" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "bar \\(x, caf_token.., 0\\);" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "_gfortran_caf_init \\(&argc, &argv\\);" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/coarray_lib_this_image_2.f90
+++ b/src/gcc/testsuite/gfortran.dg/coarray_lib_this_image_2.f90
@@ -24,4 +24,3 @@ end
 ! { dg-final { scan-tree-dump-times "mythis_image = _gfortran_caf_this_image \\(0\\);" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "bar \\(&parm.\[0-9\]+, caf_token.\[0-9\]+, \\(integer\\(kind=\[48\]\\)\\) parm.\[0-9\]+.data - \\(integer\\(kind=\[48\]\\)\\) x\\);" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "_gfortran_caf_init \\(&argc, &argv\\);" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/coarray_lib_token_1.f90
+++ b/src/gcc/testsuite/gfortran.dg/coarray_lib_token_1.f90
@@ -85,4 +85,3 @@ end program main
 !
 ! { dg-final { scan-tree-dump-times "sub_opt \\(.integer.kind=4. .. caf, caf_token.\[0-9\]+, 0\\)" 1 "original" } }
 !
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/coarray_lib_token_2.f90
+++ b/src/gcc/testsuite/gfortran.dg/coarray_lib_token_2.f90
@@ -112,4 +112,3 @@ end program main
 !
 ! { dg-final { scan-tree-dump-times "sub_opt \\(.integer.kind=4. .. caf.data, caf.token, 0\\)" 1 "original" } }
 !
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/coarray_lib_token_3.f90
+++ b/src/gcc/testsuite/gfortran.dg/coarray_lib_token_3.f90
@@ -10,4 +10,3 @@ end
 
 ! { dg-final { scan-tree-dump-times "caf.data = \\(void . restrict\\) _gfortran_caf_register \\(4, 1, &caf.token, 0B, 0B, 0\\);" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "caf_scalar.data = \\(void . restrict\\) _gfortran_caf_register \\(4, 1, &caf_scalar.token, 0B, 0B, 0\\);" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/coarray_lib_token_4.f90
+++ b/src/gcc/testsuite/gfortran.dg/coarray_lib_token_4.f90
@@ -49,4 +49,3 @@ end program test_caf
 !
 ! { dg-final { scan-tree-dump-times "foo \\(&parm.\[0-9\]+, &a, &C.\[0-9\]+, caf_token.\[0-9\]+, \\(integer\\(kind=.\\)\\) parm.\[0-9\]+.data - \\(integer\\(kind=.\\)\\) b, a.token, 0\\);" 1 "original" } }
 !
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/coarray_lock_7.f90
+++ b/src/gcc/testsuite/gfortran.dg/coarray_lock_7.f90
@@ -44,4 +44,3 @@ end
 ! { dg-final { scan-tree-dump-times "_gfortran_caf_lock \\(four.token, 1 - \\(integer\\(kind=4\\)\\) four.dim\\\[0\\\].lbound, 7 - \\(integer\\(kind=4\\)\\) four.dim\\\[1\\\].lbound, &acquired.., &ii, 0B, 0\\);|_gfortran_caf_lock \\(four.token, 1 - four.dim\\\[0\\\].lbound, 7 - four.dim\\\[1\\\].lbound, &acquired.., &ii, 0B, 0\\);" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "_gfortran_caf_unlock \\(four.token, 2 - \\(integer\\(kind=4\\)\\) four.dim\\\[0\\\].lbound, 8 - \\(integer\\(kind=4\\)\\) four.dim\\\[1\\\].lbound, 0B, 0B, 0\\);|_gfortran_caf_unlock \\(four.token, 2 - four.dim\\\[0\\\].lbound, 8 - four.dim\\\[1\\\].lbound, 0B, 0B, 0\\);" 1 "original" } }
 
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/coarray_poly_4.f90
+++ b/src/gcc/testsuite/gfortran.dg/coarray_poly_4.f90
@@ -20,4 +20,3 @@ call sub(var%x)
 end subroutine test
 
 ! { dg-final { scan-tree-dump-times "sub \\(\\(real\\(kind=4\\) \\*\\) var.x.data, var.x.token, 0\\);" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/coarray_poly_5.f90
+++ b/src/gcc/testsuite/gfortran.dg/coarray_poly_5.f90
@@ -11,4 +11,3 @@ allocate(x%x[*])
 end subroutine test
 
 ! { dg-final { scan-tree-dump-times "x->_data->x.data = _gfortran_caf_register \\(4, 1, &x->_data->x.token, 0B, 0B, 0\\);" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/coarray_poly_6.f90
+++ b/src/gcc/testsuite/gfortran.dg/coarray_poly_6.f90
@@ -19,4 +19,3 @@ end
 ! { dg-final { scan-tree-dump-times "bar \\(struct __class_MAIN___T_0_1t \\* x, void \\* restrict caf_token.., integer\\(kind=\[48\]\\) caf_offset..\\)" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "bar \\(0B, 0B, 0\\);" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "foo \\(&class.., y._data._data.token, \\(integer\\(kind=\[48\]\\)\\) class..._data.data - \\(integer\\(kind=\[48\]\\)\\) y._data._data.data\\);" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/coarray_poly_7.f90
+++ b/src/gcc/testsuite/gfortran.dg/coarray_poly_7.f90
@@ -19,4 +19,3 @@ end
 ! { dg-final { scan-tree-dump-times "bar \\(struct __class_MAIN___T_1_1t \\* x, void \\* restrict caf_token.., integer\\(kind=\[48\]\\) caf_offset..\\)" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "bar \\(0B, 0B, 0\\);" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "foo \\(&class.., y._data._data.token, \\(integer\\(kind=\[48\]\\)\\) class..._data.data - \\(integer\\(kind=\[48\]\\)\\) y._data._data.data\\);" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/coarray_poly_8.f90
+++ b/src/gcc/testsuite/gfortran.dg/coarray_poly_8.f90
@@ -19,4 +19,3 @@ end
 ! { dg-final { scan-tree-dump-times "bar \\(struct __class_MAIN___T_1_1t \\* x, void \\* restrict caf_token.., integer\\(kind=\[48\]\\) caf_offset..\\)" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "bar \\(0B, 0B, 0\\);" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "foo \\(&class.., y._data._data.token, \\(integer\\(kind=\[48\]\\)\\) class..._data.data - \\(integer\\(kind=\[48\]\\)\\) y._data._data.data\\);" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/coarray_sync_memory.f90
+++ b/src/gcc/testsuite/gfortran.dg/coarray_sync_memory.f90
@@ -16,4 +16,3 @@ end
 ! { dg-final { scan-tree-dump-times "_gfortran_caf_sync_memory \\(&stat, 0B, 0\\);" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "_gfortran_caf_sync_memory \\(0B, &&msg, 42\\);" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "_gfortran_caf_sync_memory \\(&stat, &&msg, 42\\);" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/coarray_this_image_1.f90
+++ b/src/gcc/testsuite/gfortran.dg/coarray_this_image_1.f90
@@ -17,4 +17,3 @@ end
 ! { dg-final { scan-tree-dump-times "k3 = 1;" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "k4 = 0;" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "k5 = 1;" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/coarray_this_image_2.f90
+++ b/src/gcc/testsuite/gfortran.dg/coarray_this_image_2.f90
@@ -17,4 +17,3 @@ end
 ! { dg-final { scan-tree-dump-times "k3 = _gfortran_caf_num_images \\(7, -1\\);" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "k4 = _gfortran_caf_num_images \\(8, 1\\);" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "k5 = _gfortran_caf_num_images \\(0, 0\\);" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/complex_intrinsic_7.f90
+++ b/src/gcc/testsuite/gfortran.dg/complex_intrinsic_7.f90
@@ -41,4 +41,3 @@ if (abs(tanh(z81_1) - cmplx(1.0839233273386946_8,0.27175258531951174_8,8)) > eps
 
 end
 ! { dg-final { scan-tree-dump-times "abort" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/constructor_2.f90
+++ b/src/gcc/testsuite/gfortran.dg/constructor_2.f90
@@ -70,4 +70,3 @@ program main
   if (b%bar /= 4) call abort ()
 end program main
 
-! { dg-final { cleanup-tree-dump "foo_module bar_module" } }
--- a/src/gcc/testsuite/gfortran.dg/contiguous_3.f90
+++ b/src/gcc/testsuite/gfortran.dg/contiguous_3.f90
@@ -62,4 +62,3 @@ end subroutine test3
 ! { dg-final { scan-tree-dump-times "_gfortran_internal_unpack .&parm" 2 "original" } }
 
 
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/default_format_2.f90
+++ b/src/gcc/testsuite/gfortran.dg/default_format_2.f90
@@ -1,5 +1,5 @@
-! { dg-require-effective-target fortran_large_real }
 ! { dg-do run { xfail powerpc*-apple-darwin* powerpc*-*-linux* } }
+! { dg-require-effective-target fortran_large_real }
 ! Test XFAILed on these platforms because the system's printf() lacks
 ! proper support for denormalized long doubles. See PR24685
 !
--- a/src/gcc/testsuite/gfortran.dg/default_format_denormal_2.f90
+++ b/src/gcc/testsuite/gfortran.dg/default_format_denormal_2.f90
@@ -1,5 +1,5 @@
-! { dg-require-effective-target fortran_large_real }
 ! { dg-do run { xfail powerpc*-apple-darwin* } }
+! { dg-require-effective-target fortran_large_real }
 ! Test XFAILed on this platform because the system's printf() lacks
 ! proper support for denormalized long doubles. See PR24685
 !
--- a/src/gcc/testsuite/gfortran.dg/default_initialization_5.f90
+++ b/src/gcc/testsuite/gfortran.dg/default_initialization_5.f90
@@ -62,4 +62,3 @@ end program
 
 ! { dg-final { scan-tree-dump-times "my_data.head = 0B" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "my_data.head = &tgt" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/default_numeric_type_1.f90
+++ b/src/gcc/testsuite/gfortran.dg/default_numeric_type_1.f90
@@ -16,4 +16,3 @@ end subroutine
 program testprog
   call mysub1((/1.,2./),(/1.,2.,3./),-2, 3.2)
 end
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/dependency_10.f90
+++ b/src/gcc/testsuite/gfortran.dg/dependency_10.f90
@@ -10,4 +10,3 @@ subroutine foo(a)
   endwhere
 end subroutine
 ! { dg-final { scan-tree-dump-times "malloc" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/dependency_11.f90
+++ b/src/gcc/testsuite/gfortran.dg/dependency_11.f90
@@ -10,4 +10,3 @@ subroutine foo(a)
   endwhere
 end subroutine
 ! { dg-final { scan-tree-dump-times "malloc" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/dependency_12.f90
+++ b/src/gcc/testsuite/gfortran.dg/dependency_12.f90
@@ -9,4 +9,3 @@ subroutine foo(a,b)
   endwhere
 end subroutine
 ! { dg-final { scan-tree-dump-times "malloc" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/dependency_13.f90
+++ b/src/gcc/testsuite/gfortran.dg/dependency_13.f90
@@ -10,4 +10,3 @@
    end where
    end
 ! { dg-final { scan-tree-dump-times "temp" 3 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/dependency_14.f90
+++ b/src/gcc/testsuite/gfortran.dg/dependency_14.f90
@@ -9,4 +9,3 @@ subroutine foo(a,i)
   endwhere
 end subroutine
 ! { dg-final { scan-tree-dump-times "malloc" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/dependency_15.f90
+++ b/src/gcc/testsuite/gfortran.dg/dependency_15.f90
@@ -9,4 +9,3 @@ subroutine foo(a,i)
   endwhere
 end subroutine
 ! { dg-final { scan-tree-dump-times "malloc" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/dependency_16.f90
+++ b/src/gcc/testsuite/gfortran.dg/dependency_16.f90
@@ -9,4 +9,3 @@ subroutine foo(a,i)
   endwhere
 end subroutine
 ! { dg-final { scan-tree-dump-times "malloc" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/dependency_17.f90
+++ b/src/gcc/testsuite/gfortran.dg/dependency_17.f90
@@ -9,4 +9,3 @@ subroutine foo(a,i)
   endwhere
 end subroutine
 ! { dg-final { scan-tree-dump-times "malloc" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/dependency_18.f90
+++ b/src/gcc/testsuite/gfortran.dg/dependency_18.f90
@@ -17,4 +17,3 @@ subroutine foo(a,i,j,k)
   a(k:k+2) = a(k+1:k+3)
 end subroutine
 ! { dg-final { scan-tree-dump-times "malloc" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/dependency_20.f90
+++ b/src/gcc/testsuite/gfortran.dg/dependency_20.f90
@@ -7,4 +7,3 @@
   endwhere
 end
 ! { dg-final { scan-tree-dump-times "temp" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/dependency_26.f90
+++ b/src/gcc/testsuite/gfortran.dg/dependency_26.f90
@@ -49,4 +49,3 @@ END MODULE M1
 end
 ! { dg-final { scan-tree-dump-times "&a" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "pack" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/dependency_4.f90
+++ b/src/gcc/testsuite/gfortran.dg/dependency_4.f90
@@ -8,4 +8,3 @@ subroutine foo(a)
   endwhere
 end subroutine
 ! { dg-final { scan-tree-dump-times "malloc" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/dependency_5.f90
+++ b/src/gcc/testsuite/gfortran.dg/dependency_5.f90
@@ -8,4 +8,3 @@ subroutine foo(a)
   endwhere
 end subroutine
 ! { dg-final { scan-tree-dump-times "malloc" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/dependency_6.f90
+++ b/src/gcc/testsuite/gfortran.dg/dependency_6.f90
@@ -8,4 +8,3 @@ subroutine foo(a)
   endwhere
 end subroutine
 ! { dg-final { scan-tree-dump-times "malloc" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/dependency_7.f90
+++ b/src/gcc/testsuite/gfortran.dg/dependency_7.f90
@@ -8,4 +8,3 @@ subroutine foo(a)
   endwhere
 end subroutine
 ! { dg-final { scan-tree-dump-times "malloc" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/dependency_8.f90
+++ b/src/gcc/testsuite/gfortran.dg/dependency_8.f90
@@ -10,4 +10,3 @@ subroutine foo(a,i,j)
   endwhere
 end subroutine
 ! { dg-final { scan-tree-dump-times "temp" 3 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/dependency_9.f90
+++ b/src/gcc/testsuite/gfortran.dg/dependency_9.f90
@@ -10,4 +10,3 @@ subroutine foo(a,i,j)
   endwhere
 end subroutine
 ! { dg-final { scan-tree-dump-times "malloc" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/derived_array_intrinisics_1.f90
+++ b/src/gcc/testsuite/gfortran.dg/derived_array_intrinisics_1.f90
@@ -28,4 +28,3 @@
     j = total
   end
 ! { dg-final { scan-tree-dump-times "j = 50" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/derived_constructor_char_1.f90
+++ b/src/gcc/testsuite/gfortran.dg/derived_constructor_char_1.f90
@@ -47,4 +47,3 @@ end subroutine
 ! { dg-final { scan-tree-dump-times "four = ..txt=..ABC  ., .ZYX  ...;" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "five = ..txt=..AbCdE., .ZyXwV...;" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "six = ..txt=..aBcDe., .zYxWv...;" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/direct_io_8.f90
+++ b/src/gcc/testsuite/gfortran.dg/direct_io_8.f90
@@ -7,7 +7,7 @@ program main
   i=44
   ir = -42
 
-  open(11,file="foo.dat")
+  open(11,file="foo_direct_io_8.dat")
   ! Try a direct access read on a formatted sequential rile
   READ (11, REC = I, ERR = 99) TEMP_CHANGES
   call abort
--- a/src/gcc/testsuite/gfortran.dg/dot_product_2.f90
+++ b/src/gcc/testsuite/gfortran.dg/dot_product_2.f90
@@ -35,4 +35,3 @@ end
 
 
 ! { dg-final { scan-tree-dump-not "abort" "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/dot_product_3.f90
+++ b/src/gcc/testsuite/gfortran.dg/dot_product_3.f90
@@ -12,4 +12,3 @@ program main
    stop
 end program main
 ! { dg-final { scan-tree-dump-times "8\\.0e\\+0" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/elemental_dependency_1.f90
+++ b/src/gcc/testsuite/gfortran.dg/elemental_dependency_1.f90
@@ -80,4 +80,3 @@ CONTAINS
 END PROGRAM main
 
 ! { dg-final { scan-tree-dump-times "_gfortran_internal_unpack" 3 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/elemental_dependency_3.f90
+++ b/src/gcc/testsuite/gfortran.dg/elemental_dependency_3.f90
@@ -25,4 +25,3 @@ program gfcbu84_main
   end subroutine tq_tvgh
 end program gfcbu84_main
 ! { dg-final { scan-tree-dump-times "atmp" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/elemental_dependency_4.f90
+++ b/src/gcc/testsuite/gfortran.dg/elemental_dependency_4.f90
@@ -164,4 +164,3 @@ CONTAINS
     END FUNCTION Romeo
 END PROGRAM Main
 
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/extends_11.f03
+++ b/src/gcc/testsuite/gfortran.dg/extends_11.f03
@@ -38,4 +38,3 @@
 end
 
 ! { dg-final { scan-tree-dump-times " +recruit\\.service\\.education\\.person\\.ss =" 8 "original"} }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/extends_14.f03
+++ b/src/gcc/testsuite/gfortran.dg/extends_14.f03
@@ -26,4 +26,3 @@ program evolve_aflow
 end program 
 
 ! { dg-final { scan-tree-dump-times "__builtin_free" 3 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/extends_type_of_3.f90
+++ b/src/gcc/testsuite/gfortran.dg/extends_type_of_3.f90
@@ -108,4 +108,3 @@ end
 
 ! { dg-final { scan-tree-dump-times "abort" 13 "original" } }
 ! { dg-final { scan-tree-dump-times "should_not_exist" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/f2003_inquire_1.f03
+++ b/src/gcc/testsuite/gfortran.dg/f2003_inquire_1.f03
@@ -4,7 +4,7 @@ character(25) :: sround, ssign, sasynchronous, sdecimal, sencoding
 integer :: vsize, vid
 logical :: vpending
 
-open(10, file='mydata', asynchronous="yes", blank="null", &
+open(10, file='mydata_f2003_inquire_1', asynchronous="yes", blank="null", &
 & decimal="comma", encoding="utf-8", sign="plus")
 
 inquire(unit=10, round=sround, sign=ssign, size=vsize, id=vid, &
--- a/src/gcc/testsuite/gfortran.dg/f2003_io_1.f03
+++ b/src/gcc/testsuite/gfortran.dg/f2003_io_1.f03
@@ -8,7 +8,7 @@ character(25) :: msg
 
 a = 23.45
 b = 0.0
-open(10, file='mydata', asynchronous="yes", blank="null")
+open(10, file='mydata_f2003_io_1', asynchronous="yes", blank="null")
 
 write(10,'(10f8.3)', asynchronous="yes", decimal="comma", id=j) a
 rewind(10)
--- a/src/gcc/testsuite/gfortran.dg/f2003_io_2.f03
+++ b/src/gcc/testsuite/gfortran.dg/f2003_io_2.f03
@@ -7,7 +7,7 @@ character(25) :: msg
 real, dimension(10) :: a, b
 
 a = 43.21
-open(10, file='mydata', asynchronous="yes")
+open(10, file='mydata_f2003_io_2', asynchronous="yes")
 write(10,'(10f8.3)', asynchronous="yes", decimal="comma") a
 rewind(10)
 read(10,'(10f8.3)', asynchronous="yes", decimal="comma", id=idvar) b
--- a/src/gcc/testsuite/gfortran.dg/f2003_io_8.f03
+++ b/src/gcc/testsuite/gfortran.dg/f2003_io_8.f03
@@ -6,7 +6,7 @@ real :: c
 integer :: istat, j
 character(25) :: msg
 
-open(10, file='mydata', asynchronous="yes", blank="null")
+open(10, file='mydata_f2003_io_8', asynchronous="yes", blank="null")
 write(10,'(10f8.3)', asynchronous='no', decimal="comma", id=j) a ! { dg-error "must be with ASYNCHRONOUS=" }
 read(10,'(10f8.3)', id=j, decimal="comma", blank="zero") b ! { dg-error "must be with ASYNCHRONOUS=" }
 read(10,'(10f8.3)', asynchronous=msg, decimal="comma", blank="zero") b ! { dg-error "must be an initialization expression" }
--- a/src/gcc/testsuite/gfortran.dg/finalize_10.f90
+++ b/src/gcc/testsuite/gfortran.dg/finalize_10.f90
@@ -36,4 +36,3 @@ end subroutine foo
 ! { dg-final { scan-tree-dump-times "desc.\[0-9\]+.data = \\(void \\* restrict\\) bb;" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "__final_m_T2 \\(&desc.\[0-9\]+, 0, 0\\);" 1 "original" } }
 
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/finalize_18.f90
+++ b/src/gcc/testsuite/gfortran.dg/finalize_18.f90
@@ -44,4 +44,3 @@ end
 ! { dg-final { scan-tree-dump "y.cc._vptr->_final \\(&desc.\[0-9\]+, (\\(integer\\(kind=8\\)\\) )?y.cc._vptr->_size, 1\\);" "original" } }
 ! { dg-final { scan-tree-dump "y.dd._vptr->_final \\(&y.dd._data, (\\(integer\\(kind=8\\)\\) )?y.dd._vptr->_size, 1\\);" "original" } }
 
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/finalize_21.f90
+++ b/src/gcc/testsuite/gfortran.dg/finalize_21.f90
@@ -9,4 +9,3 @@ class(*), allocatable :: var
 end
 
 ! { dg-final { scan-tree-dump "static struct __vtype__STAR __vtab__STAR = {._hash=0, ._size=., ._extends=0B, ._def_init=0B, ._copy=0B, ._final=0B};" "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/finalize_28.f90
+++ b/src/gcc/testsuite/gfortran.dg/finalize_28.f90
@@ -22,4 +22,3 @@ contains
   end subroutine coo_dump_edges
 end module coo_graphs
 ! { dg-final { scan-tree-dump-times "__builtin_free" 3 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/fmt_en.f90
+++ b/src/gcc/testsuite/gfortran.dg/fmt_en.f90
@@ -183,4 +183,3 @@ contains
     end subroutine
 end program
 ! { dg-final { scan-file fmt_en.res "All kinds rounded to nearest" { xfail hppa*-*-hpux* } } }
-! { dg-final { cleanup-saved-temps } }
--- a/src/gcc/testsuite/gfortran.dg/forall_15.f90
+++ b/src/gcc/testsuite/gfortran.dg/forall_15.f90
@@ -23,4 +23,3 @@ program test
 end program test
 ! { dg-final { scan-tree-dump-times "__builtin_cos" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "__builtin_sin" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/forall_8.f90
+++ b/src/gcc/testsuite/gfortran.dg/forall_8.f90
@@ -6,4 +6,3 @@
   end forall
   end
 ! { dg-final { scan-tree-dump-times "temp" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/forall_9.f90
+++ b/src/gcc/testsuite/gfortran.dg/forall_9.f90
@@ -6,4 +6,3 @@
   end forall
   end
 ! { dg-final { scan-tree-dump-times "temp" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/function_optimize_1.f90
+++ b/src/gcc/testsuite/gfortran.dg/function_optimize_1.f90
@@ -44,4 +44,3 @@ end program main
 ! { dg-final { scan-tree-dump-times "element" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "mypure" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "elem_impure" 2 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/function_optimize_2.f90
+++ b/src/gcc/testsuite/gfortran.dg/function_optimize_2.f90
@@ -44,4 +44,3 @@ end program main
 ! { dg-final { scan-tree-dump-times "element" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "mypure" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "elem_impure" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/function_optimize_6.f90
+++ b/src/gcc/testsuite/gfortran.dg/function_optimize_6.f90
@@ -11,6 +11,5 @@ program main
   ENDDO
 END program main
 ! { dg-final { scan-tree-dump-times "mypure" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
 
 
--- a/src/gcc/testsuite/gfortran.dg/function_optimize_7.f90
+++ b/src/gcc/testsuite/gfortran.dg/function_optimize_7.f90
@@ -44,4 +44,3 @@ end subroutine xx
 ! { dg-final { scan-tree-dump-times "mypure" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "elem_impure" 2 "original" } }
 ! { dg-final { scan-tree-dump-times "sum_r4" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/function_optimize_8.f90
+++ b/src/gcc/testsuite/gfortran.dg/function_optimize_8.f90
@@ -32,4 +32,3 @@ program main
 end program main
 ! { dg-final { scan-tree-dump-times "myfunc" 2 "original" } }
 ! { dg-final { scan-tree-dump-times "mychar" 2 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/function_optimize_9.f90
+++ b/src/gcc/testsuite/gfortran.dg/function_optimize_9.f90
@@ -20,4 +20,3 @@ program main
   print *,a
 end program main
 ! { dg-final { scan-tree-dump-times "purefunc" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/generic_18.f90
+++ b/src/gcc/testsuite/gfortran.dg/generic_18.f90
@@ -50,4 +50,3 @@ PROGRAM MakeAChoice
 END PROGRAM MakeAChoice
 ! { dg-final { scan-tree-dump-times "specproc" 3 "original" } }
 ! { dg-final { scan-tree-dump-times "elemproc" 3 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/goacc/acc_on_device-1.f95
+++ b/src/gcc/testsuite/gfortran.dg/goacc/acc_on_device-1.f95
@@ -19,4 +19,3 @@ end function f
 ! Unsuitable to be handled as a builtin, so we're expecting four calls.
 ! { dg-final { scan-rtl-dump-times "\\\(call \[^\\n\]* acc_on_device" 4 "expand" } }
 
-! { dg-final { cleanup-rtl-dump "expand" } }
--- a/src/gcc/testsuite/gfortran.dg/goacc/acc_on_device-2-off.f95
+++ b/src/gcc/testsuite/gfortran.dg/goacc/acc_on_device-2-off.f95
@@ -36,4 +36,3 @@ end function f
 ! Without -fopenacc, we're expecting one call.
 ! { dg-final { scan-rtl-dump-times "\\\(call \[^\\n\]* acc_on_device" 1 "expand" } }
 
-! { dg-final { cleanup-rtl-dump "expand" } }
--- a/src/gcc/testsuite/gfortran.dg/goacc/acc_on_device-2.f95
+++ b/src/gcc/testsuite/gfortran.dg/goacc/acc_on_device-2.f95
@@ -37,4 +37,3 @@ end function f
 ! TODO: not working.
 ! { dg-final { scan-rtl-dump-times "\\\(call \[^\\n\]* acc_on_device" 0 "expand" { xfail *-*-* } } }
 
-! { dg-final { cleanup-rtl-dump "expand" } }
--- a/src/gcc/testsuite/gfortran.dg/goacc/data-tree.f95
+++ b/src/gcc/testsuite/gfortran.dg/goacc/data-tree.f95
@@ -27,4 +27,3 @@ end program test
 ! { dg-final { scan-tree-dump-times "map\\(alloc:t\\)" 1 "original" } } 
 
 ! { dg-final { scan-tree-dump-times "map\\(force_deviceptr:u\\)" 1 "original" } } 
-! { dg-final { cleanup-tree-dump "original" } } 
--- a/src/gcc/testsuite/gfortran.dg/goacc/declare-1.f95
+++ b/src/gcc/testsuite/gfortran.dg/goacc/declare-1.f95
@@ -17,4 +17,3 @@ contains
 end program test
 ! { dg-prune-output "unimplemented" }
 ! { dg-final { scan-tree-dump-times "pragma acc declare map\\(force_tofrom:i\\)" 2 "original" } } 
-! { dg-final { cleanup-tree-dump "original" } } 
--- a/src/gcc/testsuite/gfortran.dg/goacc/host_data-tree.f95
+++ b/src/gcc/testsuite/gfortran.dg/goacc/host_data-tree.f95
@@ -10,4 +10,3 @@ program test
 end program test
 ! { dg-prune-output "unimplemented" }
 ! { dg-final { scan-tree-dump-times "pragma acc host_data use_device\\(i\\)" 1 "original" } } 
-! { dg-final { cleanup-tree-dump "original" } } 
--- a/src/gcc/testsuite/gfortran.dg/goacc/kernels-tree.f95
+++ b/src/gcc/testsuite/gfortran.dg/goacc/kernels-tree.f95
@@ -29,4 +29,3 @@ end program test
 ! { dg-final { scan-tree-dump-times "map\\(alloc:t\\)" 1 "original" } } 
 
 ! { dg-final { scan-tree-dump-times "map\\(force_deviceptr:u\\)" 1 "original" } } 
-! { dg-final { cleanup-tree-dump "original" } } 
--- a/src/gcc/testsuite/gfortran.dg/goacc/loop-tree-1.f90
+++ b/src/gcc/testsuite/gfortran.dg/goacc/loop-tree-1.f90
@@ -45,4 +45,3 @@ end program test
 
 ! { dg-final { scan-tree-dump-times "private\\(m\\)" 1 "original" } } 
 ! { dg-final { scan-tree-dump-times "reduction\\(\\+:sum\\)" 1 "original" } } 
-! { dg-final { cleanup-tree-dump "original" } } 
--- a/src/gcc/testsuite/gfortran.dg/goacc/parallel-tree.f95
+++ b/src/gcc/testsuite/gfortran.dg/goacc/parallel-tree.f95
@@ -38,4 +38,3 @@ end program test
 ! { dg-final { scan-tree-dump-times "map\\(force_deviceptr:u\\)" 1 "original" } } 
 ! { dg-final { scan-tree-dump-times "private\\(v\\)" 1 "original" } } 
 ! { dg-final { scan-tree-dump-times "firstprivate\\(w\\)" 1 "original" } } 
-! { dg-final { cleanup-tree-dump "original" } } 
--- a/src/gcc/testsuite/gfortran.dg/goacc/private-1.f95
+++ b/src/gcc/testsuite/gfortran.dg/goacc/private-1.f95
@@ -35,4 +35,3 @@ end program test
 ! { dg-final { scan-tree-dump-times "private\\(i\\)" 3 "omplower" } }
 ! { dg-final { scan-tree-dump-times "private\\(j\\)" 2 "omplower" } }
 ! { dg-final { scan-tree-dump-times "private\\(k\\)" 1 "omplower" } }
-! { dg-final { cleanup-tree-dump "omplower" } }
--- a/src/gcc/testsuite/gfortran.dg/gomp/do-1.f90
+++ b/src/gcc/testsuite/gfortran.dg/gomp/do-1.f90
@@ -23,4 +23,3 @@ end subroutine bar
 
 ! { dg-final { scan-tree-dump-times "GOMP_parallel_loop_dynamic_start" 2 "omplower" { xfail *-*-* } } }
 ! { dg-final { scan-tree-dump-times "GOMP_parallel_loop_guided_start" 2 "omplower" { xfail *-*-* } } }
-! { dg-final { cleanup-tree-dump "omplower" } }
--- a/src/gcc/testsuite/gfortran.dg/gomp/omp_parse1.f90
+++ b/src/gcc/testsuite/gfortran.dg/gomp/omp_parse1.f90
@@ -17,4 +17,3 @@ call bar
 end
 
 ! { dg-final { scan-tree-dump-times "pragma omp parallel" 3 "omplower" } }
-! { dg-final { cleanup-tree-dump "omplower" } }
--- a/src/gcc/testsuite/gfortran.dg/gomp/omp_parse2.f
+++ b/src/gcc/testsuite/gfortran.dg/gomp/omp_parse2.f
@@ -11,4 +11,3 @@ C$omp 	 	p
       end
 
 ! { dg-final { scan-tree-dump-times "pragma omp parallel" 2 "omplower" } }
-! { dg-final { cleanup-tree-dump "omplower" } }
--- a/src/gcc/testsuite/gfortran.dg/gomp/openmp-simd-1.f90
+++ b/src/gcc/testsuite/gfortran.dg/gomp/openmp-simd-1.f90
@@ -134,4 +134,3 @@ end
 ! { dg-final { scan-tree-dump-times "pragma omp simd" 6 "original" } }
 ! { dg-final { scan-tree-dump-times "pragma omp" 6 "original" } }
 ! { dg-final { scan-tree-dump-times "__builtin_GOMP" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/gomp/openmp-simd-2.f90
+++ b/src/gcc/testsuite/gfortran.dg/gomp/openmp-simd-2.f90
@@ -25,4 +25,3 @@ include 'openmp-simd-1.f90'
 ! { dg-final { scan-tree-dump-times "__builtin_GOMP_cancel" 2 "original" } }
 ! { dg-final { scan-tree-dump-times "__builtin_GOMP_taskyield" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "__builtin_GOMP_taskwait" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/gomp/openmp-simd-3.f90
+++ b/src/gcc/testsuite/gfortran.dg/gomp/openmp-simd-3.f90
@@ -25,4 +25,3 @@ include 'openmp-simd-1.f90'
 ! { dg-final { scan-tree-dump-times "__builtin_GOMP_cancel" 2 "original" } }
 ! { dg-final { scan-tree-dump-times "__builtin_GOMP_taskyield" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "__builtin_GOMP_taskwait" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/gomp/workshare2.f90
+++ b/src/gcc/testsuite/gfortran.dg/gomp/workshare2.f90
@@ -50,4 +50,3 @@ program foo
 
 end program foo
 ! { dg-final { scan-tree-dump-times "__var" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/gomp/workshare3.f90
+++ b/src/gcc/testsuite/gfortran.dg/gomp/workshare3.f90
@@ -36,4 +36,3 @@ program foo
 
 end program foo
 ! { dg-final { scan-tree-dump-times "__builtin_cosf" 2 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/graphite/block-1.f90
+++ b/src/gcc/testsuite/gfortran.dg/graphite/block-1.f90
@@ -9,5 +9,4 @@ end subroutine matrix_multiply
 
 ! { dg-final { scan-tree-dump-times "number of SCoPs: 1" 1 "graphite" { xfail *-*-* } } }
 ! { dg-final { scan-tree-dump-times "will be loop blocked" 1 "graphite" { xfail *-*-* } } }
-! { dg-final { cleanup-tree-dump "graphite" } }
 
--- a/src/gcc/testsuite/gfortran.dg/graphite/block-2.f
+++ b/src/gcc/testsuite/gfortran.dg/graphite/block-2.f
@@ -18,4 +18,3 @@
 
 ! { dg-final { scan-tree-dump-times "number of SCoPs: 2" 1 "graphite" { xfail *-*-* } } }
 ! { dg-final { scan-tree-dump-times "will be loop blocked" 2 "graphite" { xfail *-*-* } } }
-! { dg-final { cleanup-tree-dump "graphite" } }
--- a/src/gcc/testsuite/gfortran.dg/graphite/block-3.f90
+++ b/src/gcc/testsuite/gfortran.dg/graphite/block-3.f90
@@ -14,5 +14,4 @@ end subroutine matrix_multiply
 
 ! { dg-final { scan-tree-dump-times "number of SCoPs: 1" 1 "graphite" { xfail *-*-* } } }
 ! { dg-final { scan-tree-dump-times "will be loop blocked" 1 "graphite" { xfail *-*-* } } }
-! { dg-final { cleanup-tree-dump "graphite" } }
 
--- a/src/gcc/testsuite/gfortran.dg/graphite/block-4.f90
+++ b/src/gcc/testsuite/gfortran.dg/graphite/block-4.f90
@@ -17,5 +17,4 @@ end subroutine matrix_multiply
 
 ! { dg-final { scan-tree-dump-times "number of SCoPs: 1" 1 "graphite" { xfail *-*-* } } }
 ! { dg-final { scan-tree-dump-times "will be loop blocked" 1 "graphite" { xfail *-*-* } } }
-! { dg-final { cleanup-tree-dump "graphite" } }
 
--- a/src/gcc/testsuite/gfortran.dg/graphite/interchange-1.f
+++ b/src/gcc/testsuite/gfortran.dg/graphite/interchange-1.f
@@ -42,4 +42,3 @@
 ! kernel from bwaves.
 
 ! { dg-final { scan-tree-dump-times "will be interchanged" 1 "graphite" { xfail *-*-* } } }
-! { dg-final { cleanup-tree-dump "graphite" } }
--- a/src/gcc/testsuite/gfortran.dg/graphite/interchange-2.f
+++ b/src/gcc/testsuite/gfortran.dg/graphite/interchange-2.f
@@ -40,4 +40,3 @@
 ! as the number of iterations for f4 is not known.
 
 ! { dg-final { scan-tree-dump-times "will be interchanged" 0 "graphite" } }
-! { dg-final { cleanup-tree-dump "graphite" } }
--- a/src/gcc/testsuite/gfortran.dg/graphite/interchange-3.f90
+++ b/src/gcc/testsuite/gfortran.dg/graphite/interchange-3.f90
@@ -25,4 +25,3 @@ Program FOO
 end Program FOO
 
 ! { dg-final { scan-tree-dump-times "will be interchanged" 1 "graphite" } }
-! { dg-final { cleanup-tree-dump "graphite" } }
--- a/src/gcc/testsuite/gfortran.dg/graphite/interchange-4.f
+++ b/src/gcc/testsuite/gfortran.dg/graphite/interchange-4.f
@@ -26,4 +26,3 @@ c
       end
 
 ! { dg-final { scan-tree-dump-times "will be interchanged" 1 "graphite" { xfail *-*-* } } }
-! { dg-final { cleanup-tree-dump "graphite" } }
--- a/src/gcc/testsuite/gfortran.dg/graphite/interchange-5.f
+++ b/src/gcc/testsuite/gfortran.dg/graphite/interchange-5.f
@@ -27,4 +27,3 @@ c
       end
 
 ! { dg-final { scan-tree-dump-times "will be interchanged" 1 "graphite" { xfail *-*-* } } }
-! { dg-final { cleanup-tree-dump "graphite" } }
--- a/src/gcc/testsuite/gfortran.dg/graphite/pr14741.f90
+++ b/src/gcc/testsuite/gfortran.dg/graphite/pr14741.f90
@@ -26,4 +26,3 @@ END SUBROUTINE mult
 
 ! { dg-final { scan-tree-dump-times "number of SCoPs: 1" 1 "graphite" { xfail *-*-* } } }
 ! { dg-final { scan-tree-dump-times "will be loop blocked" 1 "graphite" { xfail *-*-* } } }
-! { dg-final { cleanup-tree-dump "graphite" } }
--- a/src/gcc/testsuite/gfortran.dg/graphite/scop-1.f
+++ b/src/gcc/testsuite/gfortran.dg/graphite/scop-1.f
@@ -10,4 +10,3 @@
       end
 
 ! { dg-final { scan-tree-dump-times "number of SCoPs: 1" 1 "graphite" { xfail *-*-* } } } 
-! { dg-final { cleanup-tree-dump "graphite" } } 
--- a/src/gcc/testsuite/gfortran.dg/graphite/vect-pr40979.f90
+++ b/src/gcc/testsuite/gfortran.dg/graphite/vect-pr40979.f90
@@ -24,4 +24,3 @@ contains
 end module mqc_m
 
 ! { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } }
-! { dg-final { cleanup-tree-dump "vect" } }
--- a/src/gcc/testsuite/gfortran.dg/implicit_pure_3.f90
+++ b/src/gcc/testsuite/gfortran.dg/implicit_pure_3.f90
@@ -106,4 +106,3 @@ END MODULE
 
 ! { dg-final { scan-module-absence "parallel_rng_types" "IMPLICIT_PURE" } }
 ! { dg-final { scan-tree-dump-times "rn32 \\(rng_stream" 3 "optimized" } }
-! { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/gfortran.dg/index_2.f90
+++ b/src/gcc/testsuite/gfortran.dg/index_2.f90
@@ -53,4 +53,3 @@
 
 ! { dg-final { scan-tree-dump-times "if ..integer.kind=1.. _gfortran_string_index" 6 "original" } }
 ! { dg-final { scan-tree-dump-times "if ..integer.kind=1.. _gfortran_string_scan" 6 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/inline_product_1.f90
+++ b/src/gcc/testsuite/gfortran.dg/inline_product_1.f90
@@ -29,4 +29,3 @@ end
 ! { dg-final { scan-tree-dump-times "struct array._integer\\(kind=4\\) atmp" 0 "original" } }
 ! { dg-final { scan-tree-dump-times "struct array\[^\\n\]*atmp" 0 "original" } }
 ! { dg-final { scan-tree-dump-times "_gfortran_product_" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/inline_sum_1.f90
+++ b/src/gcc/testsuite/gfortran.dg/inline_sum_1.f90
@@ -191,4 +191,3 @@ end
 ! { dg-final { scan-tree-dump-times "struct array._integer\\(kind=4\\) atmp" 13 "original" } }
 ! { dg-final { scan-tree-dump-times "struct array\[^\\n\]*atmp" 13 "original" } }
 ! { dg-final { scan-tree-dump-times "_gfortran_sum_" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/inline_transpose_1.f90
+++ b/src/gcc/testsuite/gfortran.dg/inline_transpose_1.f90
@@ -234,5 +234,3 @@ end subroutine titi
 ! { # Commented out as failing at -O0: dg-final { scan-tree-dump-times "_gfortran_abort" 37 "optimized" } }
 !
 ! cleanup
-! { dg-final { cleanup-tree-dump "original" } }
-! { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/gfortran.dg/inquire_size.f90
+++ b/src/gcc/testsuite/gfortran.dg/inquire_size.f90
@@ -4,7 +4,7 @@ integer :: i
 character(30) :: aname = "noname"
 logical :: is_named
 
-open(25, file="testfile", status="replace", access="stream", form="unformatted")
+open(25, file="testfile_inquire_size", status="replace", access="stream", form="unformatted")
 do i=1,100
   write(25) i, "abcdefghijklmnopqrstuvwxyz"
 enddo
@@ -14,16 +14,16 @@ enddo
 
 inquire(unit=25, named=is_named, name=aname, size=i)
 if (.not.is_named) call abort
-if (aname /= "testfile") call abort
+if (aname /= "testfile_inquire_size") call abort
 if (i /= 3000) call abort
 
-inquire(file="testfile", size=i)
+inquire(file="testfile_inquire_size", size=i)
 if (.not.is_named) call abort
-if (aname /= "testfile") call abort
+if (aname /= "testfile_inquire_size") call abort
 if (i /= 3000) call abort
 
 close(25, status="delete")
-inquire(file="testfile", size=i)
+inquire(file="testfile_inquire_size", size=i)
 if (i /= -1)  call abort
 end
 
--- a/src/gcc/testsuite/gfortran.dg/intent_optimize_1.f90
+++ b/src/gcc/testsuite/gfortran.dg/intent_optimize_1.f90
@@ -21,4 +21,3 @@ if (y /= 5) call does_not_exist ()
 end
 
 ! { dg-final { scan-tree-dump-times "does_not_exist" 0 "optimized" } }
-! { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/gfortran.dg/internal_pack_11.f90
+++ b/src/gcc/testsuite/gfortran.dg/internal_pack_11.f90
@@ -15,4 +15,3 @@
   call foo (ot(0:time_steps)) ! Was an unnecessary temporary
   end
 ! { dg-final { scan-tree-dump-times "unpack" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/internal_pack_12.f90
+++ b/src/gcc/testsuite/gfortran.dg/internal_pack_12.f90
@@ -56,4 +56,3 @@ subroutine bar(x)
   if (any (x(1:3) /= [1,3,5])) call abort ()
 end subroutine bar
 ! { dg-final { scan-tree-dump-times "unpack" 4 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/internal_pack_4.f90
+++ b/src/gcc/testsuite/gfortran.dg/internal_pack_4.f90
@@ -28,4 +28,3 @@ END
 
 ! { dg-final { scan-tree-dump-times "a != 0B \\? \\\(.*\\\) _gfortran_internal_pack" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "if \\(a != 0B &&" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/internal_pack_5.f90
+++ b/src/gcc/testsuite/gfortran.dg/internal_pack_5.f90
@@ -18,4 +18,3 @@ end program test
 
 ! { dg-final { scan-tree-dump-times "_gfortran_internal_pack" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "_gfortran_internal_unpack" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/internal_pack_6.f90
+++ b/src/gcc/testsuite/gfortran.dg/internal_pack_6.f90
@@ -55,4 +55,3 @@ END SUBROUTINE S2
  call s2
 end
 ! { dg-final { scan-tree-dump-times "_gfortran_internal_pack" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/internal_pack_7.f90
+++ b/src/gcc/testsuite/gfortran.dg/internal_pack_7.f90
@@ -31,4 +31,3 @@ CONTAINS
   END FUNCTION S2
 END MODULE M1
 ! { dg-final { scan-tree-dump-times "pack" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/internal_pack_9.f90
+++ b/src/gcc/testsuite/gfortran.dg/internal_pack_9.f90
@@ -38,4 +38,3 @@ subroutine foobar
   call foo(A(:,3:7:-1)) ! temporary(3) OK because of stride
 end
 ! { dg-final { scan-tree-dump-times "unpack" 3 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/intrinsic_optional_char_arg_1.f90
+++ b/src/gcc/testsuite/gfortran.dg/intrinsic_optional_char_arg_1.f90
@@ -29,4 +29,3 @@ END PROGRAM main
 ! { dg-final { scan-tree-dump "_eoshift\[0-9_\]+char \\(\[&a-zA-Z0-9._, \]+, 1, 0\\)" "original" } }
 ! { dg-final { scan-tree-dump "_reshape\[0-9_\]+char \\(\[&a-zA-Z0-9._, \]+, 1, 0\\)" "original" } }
 ! { dg-final { scan-tree-dump "_pack\[0-9_\]+char \\(\[&a-zA-Z0-9._, \]+, 1, 0\\)" "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/intrinsic_size_3.f90
+++ b/src/gcc/testsuite/gfortran.dg/intrinsic_size_3.f90
@@ -23,4 +23,3 @@ program bug
 end program bug
 
 ! { dg-final { scan-tree-dump-times "iszs = \\(integer\\(kind=2\\)\\) MAX_EXPR <\\(D.\[0-9\]+->dim.0..ubound - D.\[0-9\]+->dim.0..lbound\\) \\+ 1, 0>;" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/intrinsic_std_6.f90
+++ b/src/gcc/testsuite/gfortran.dg/intrinsic_std_6.f90
@@ -38,4 +38,3 @@ END SUBROUTINE implicit_type
 ! { dg-final { scan-tree-dump " abort " "original" } }
 ! { dg-final { scan-tree-dump " asinh " "original" } }
 ! { dg-final { scan-tree-dump " acosh " "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/ipcp-array-1.f90
+++ b/src/gcc/testsuite/gfortran.dg/ipcp-array-1.f90
@@ -13,7 +13,5 @@ end
 
 ! { dg-final { scan-ipa-dump "Creating a specialized node of foo" "cp" } }
 ! { dg-final { scan-ipa-dump-times "Aggregate replacements\[^=\]*=\[^=\]*=\[^=\]*=\[^=\]*=\[^=\]*=\[^=\]*=\[^=\]*=\[^=\]*=" 2 "cp" } }
-! { dg-final { cleanup-ipa-dump "cp" } }
 ! { dg-final { scan-tree-dump-not "stride;" "optimized" } }
 ! { dg-final { scan-tree-dump-not "lbound;" "optimized" } }
-! { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/gfortran.dg/ishft_4.f90
+++ b/src/gcc/testsuite/gfortran.dg/ishft_4.f90
@@ -37,4 +37,3 @@ end program
 !
 ! { dg-final { scan-tree-dump-times "foo *\\\(\\\)" 5 "original" } }
 ! { dg-final { scan-tree-dump-times "bar *\\\(\\\)" 5 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/iso_c_binding_param_2.f90
+++ b/src/gcc/testsuite/gfortran.dg/iso_c_binding_param_2.f90
@@ -17,4 +17,3 @@ if (c_float128_complex >= 0 .and. c_float128_complex /= 16) call unreachable()
 end
 
 ! { dg-final { scan-tree-dump-times "unreachable" 0 "optimized" } }
-! { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/gfortran.dg/iso_fortran_env_5.f90
+++ b/src/gcc/testsuite/gfortran.dg/iso_fortran_env_5.f90
@@ -23,5 +23,4 @@ if (STAT_LOCKED == STAT_UNLOCKED) call abort()
 end
 
 ! { dg-final { scan-tree-dump-times "abort" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
 
--- a/src/gcc/testsuite/gfortran.dg/ldist-1.f90
+++ b/src/gcc/testsuite/gfortran.dg/ldist-1.f90
@@ -33,4 +33,3 @@ end Subroutine PADEC
 ! locality heuristic, this loop should not be split.
 
 ! { dg-final { scan-tree-dump-not "distributed: split to" "ldist" } }
-! { dg-final { cleanup-tree-dump "ldist" } }
--- a/src/gcc/testsuite/gfortran.dg/ldist-pr45199.f
+++ b/src/gcc/testsuite/gfortran.dg/ldist-pr45199.f
@@ -24,4 +24,3 @@
 
 ! { dg-final { scan-tree-dump "distributed: split to 0 loops and 9 library calls" "ldist" } }
 ! { dg-final { scan-tree-dump-times "generated memset zero" 9 "ldist" } }
-! { dg-final { cleanup-tree-dump "ldist" } }
--- a/src/gcc/testsuite/gfortran.dg/leadz_trailz_3.f90
+++ b/src/gcc/testsuite/gfortran.dg/leadz_trailz_3.f90
@@ -27,4 +27,3 @@ end program
 !   -- plus as many times as the function is called
 !
 ! { dg-final { scan-tree-dump-times "foo *\\\(\\\)" 7 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/matmul_9.f90
+++ b/src/gcc/testsuite/gfortran.dg/matmul_9.f90
@@ -43,5 +43,4 @@ program name
 end program name
 
 ! { dg-final { scan-tree-dump-times "matmul" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
 
--- a/src/gcc/testsuite/gfortran.dg/merge_init_expr_2.f90
+++ b/src/gcc/testsuite/gfortran.dg/merge_init_expr_2.f90
@@ -55,4 +55,3 @@ end subroutine test
 ! { dg-final { scan-tree-dump-times "check1 = 1275069467;" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "check2 = 1;" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "__builtin_memmove ..void .. &three, .void .. &one, 3.;" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/missing_optional_dummy_4.f90
+++ b/src/gcc/testsuite/gfortran.dg/missing_optional_dummy_4.f90
@@ -23,4 +23,3 @@ contains
 end module krmod
 
 ! { dg-final { scan-tree-dump " tm_doit \\(0B, 0\\);" "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/missing_optional_dummy_5.f90
+++ b/src/gcc/testsuite/gfortran.dg/missing_optional_dummy_5.f90
@@ -24,4 +24,3 @@ contains
 end module krmod
 
 ! { dg-final { scan-tree-dump " tm_doit \\(&parm\.., 0B, 0\\);" "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/missing_optional_dummy_6.f90
+++ b/src/gcc/testsuite/gfortran.dg/missing_optional_dummy_6.f90
@@ -57,4 +57,3 @@ end program test
 ! { dg-final { scan-tree-dump-times "assumed_shape2 \\(as1" 0 "original" } }
 ! { dg-final { scan-tree-dump-times "explicit_shape2 \\(as1" 0 "original" } }
 
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/move_alloc_4.f90
+++ b/src/gcc/testsuite/gfortran.dg/move_alloc_4.f90
@@ -21,4 +21,3 @@ program testmv3
 end program testmv3 
 
 ! { dg-final { scan-tree-dump-times "__builtin_free" 9 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/namelist_66.f90
+++ b/src/gcc/testsuite/gfortran.dg/namelist_66.f90
@@ -17,7 +17,7 @@ end type qptracer
 type(qptracer) , dimension(3) :: qtracer
 namelist/naml2/  qtracer
 
-open (99, file='nml.dat', status="replace")
+open (99, file='nml_66.dat', status="replace")
 write(99,*) "&naml1"
 write(99,*) "   tracer(1)   = 'aa', .true."
 write(99,*) "   tracer(2)   = 'bb', .true."
--- a/src/gcc/testsuite/gfortran.dg/namelist_82.f90
+++ b/src/gcc/testsuite/gfortran.dg/namelist_82.f90
@@ -10,7 +10,7 @@ namelist/naml1/  tracer
 
 tracer(:) = ptracer('XXX', .false.)
 
-open (99, file='nml.dat', status="replace")
+open (99, file='nml_82.dat', status="replace")
 write(99,*) "&naml1"
 !write(99,*) "   tracer(2)   = 'bb' , .true."
 write(99,*) "   tracer(:)   = 'aa' , .true."
--- a/src/gcc/testsuite/gfortran.dg/no_arg_check_2.f90
+++ b/src/gcc/testsuite/gfortran.dg/no_arg_check_2.f90
@@ -150,4 +150,3 @@ end
 ! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(struct t1.0:. . restrict\\) array_class_t1_alloc._data.data\\);" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(struct t1.0:. .\\) array_class_t1_ptr._data.data\\);" 1 "original" } }
 
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/open_negative_unit_1.f90
+++ b/src/gcc/testsuite/gfortran.dg/open_negative_unit_1.f90
@@ -9,7 +9,7 @@ program nutest
     logical l
     integer id, ios
 
-    open(newunit=id, file="foo.txt", iostat=ios)
+    open(newunit=id, file="foo_open_negative_unit_1.txt", iostat=ios)
     if (ios /= 0) call abort
 
     open(id, file="bar.txt", iostat=ios)
@@ -17,14 +17,14 @@ program nutest
 
     close(id, status="delete")
 
-    open(unit=10, file="foo.txt", status="old", iostat=ios)
+    open(unit=10, file="foo_open_negative_unit_1.txt", status="old", iostat=ios)
     if (ios /= 0) call abort
 
     close(10, status="delete")
 
-    open(-10, file="foo.txt", iostat=ios)
+    open(-10, file="foo_open_negative_unit_1.txt", iostat=ios)
     if (ios == 0) call abort
 
-    inquire(file="foo.txt", exist=l)
+    inquire(file="foo_open_negative_unit_1.txt", exist=l)
     if (l) call abort
 end program nutest
--- a/src/gcc/testsuite/gfortran.dg/open_new.f90
+++ b/src/gcc/testsuite/gfortran.dg/open_new.f90
@@ -3,9 +3,9 @@
 !            status="new" is an error
 program main
   nout = 10
-  open(nout, file="foo.dat", status="replace")     ! make sure foo.dat exists
+  open(nout, file="foo_open_new.dat", status="replace")     ! make sure foo_open_new.dat exists
   close(nout)
-  open(nout, file="foo.dat", status="new",err=100)
+  open(nout, file="foo_open_new.dat", status="new",err=100)
   call abort                 ! This should never happen
-100 call unlink ("foo.dat")
+100 call unlink ("foo_open_new.dat")
 end program main
--- a/src/gcc/testsuite/gfortran.dg/parameter_array_element_1.f90
+++ b/src/gcc/testsuite/gfortran.dg/parameter_array_element_1.f90
@@ -15,5 +15,4 @@
 END
 ! Scan for the 105 in the declaration real8 out_val[105];
 ! { dg-final { scan-tree-dump-times "105" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
 
--- a/src/gcc/testsuite/gfortran.dg/power_3.f90
+++ b/src/gcc/testsuite/gfortran.dg/power_3.f90
@@ -35,4 +35,3 @@ program main
 
 end program main
 ! { dg-final { scan-tree-dump-times "_gfortran_pow_i4_i4" 4 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/power_4.f90
+++ b/src/gcc/testsuite/gfortran.dg/power_4.f90
@@ -26,4 +26,3 @@ program main
   if (any(d /= e)) call abort
 end program main
 ! { dg-final { scan-tree-dump-times "_gfortran_pow_i4_i4" 3 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/power_5.f90
+++ b/src/gcc/testsuite/gfortran.dg/power_5.f90
@@ -33,4 +33,3 @@ program main
 
 end program main
 ! { dg-final { scan-tree-dump-times "_gfortran_pow_i4_i4" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/power_6.f90
+++ b/src/gcc/testsuite/gfortran.dg/power_6.f90
@@ -12,4 +12,3 @@ end
 ! { dg-final { scan-tree-dump-not "__builtin_powif"  "optimized" } }
 ! { dg-final { scan-tree-dump "powi_cond_\[0-9\] = k_\[0-9\]\\(D\\) & 1;"  "optimized" } }
 ! { dg-final { scan-tree-dump "powi_\[0-9\] = powi_cond_\[0-9\] \\? -1.0e\\+0 : 1.0e\\+0;"  "optimized" } }
-! { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/gfortran.dg/pr26246_1.f90
+++ b/src/gcc/testsuite/gfortran.dg/pr26246_1.f90
@@ -15,4 +15,3 @@ module pr26246_1
 end module pr26246_1
 
 ! { dg-final { scan-tree-dump-times "static int" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/pr26246_2.f90
+++ b/src/gcc/testsuite/gfortran.dg/pr26246_2.f90
@@ -10,4 +10,3 @@ subroutine foo(string, n)
 end subroutine foo
 
 ! { dg-final { scan-tree-dump-times "static int" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/pr32921.f
+++ b/src/gcc/testsuite/gfortran.dg/pr32921.f
@@ -46,4 +46,3 @@
       RETURN
       END
 ! { dg-final { scan-tree-dump-times "stride" 4 "lim1" } }
-! { dg-final { cleanup-tree-dump "lim1" } }
--- a/src/gcc/testsuite/gfortran.dg/pr34163.f90
+++ b/src/gcc/testsuite/gfortran.dg/pr34163.f90
@@ -13,4 +13,3 @@ do i = i1+1 , i2
 enddo
 end subroutine trisolve2
 ! { dg-final { scan-tree-dump "Executing predictive commoning" "pcom" } }
-! { dg-final { cleanup-tree-dump "pcom" } }
--- a/src/gcc/testsuite/gfortran.dg/pr38868.f
+++ b/src/gcc/testsuite/gfortran.dg/pr38868.f
@@ -14,4 +14,3 @@
       END
 
 ! { dg-final { scan-rtl-dump-times "line\\\+80" 0 "expand" } }
-! { dg-final { cleanup-rtl-dump "expand" } } */
--- a/src/gcc/testsuite/gfortran.dg/pr42108.f90
+++ b/src/gcc/testsuite/gfortran.dg/pr42108.f90
@@ -25,5 +25,3 @@ end subroutine eval
 ! { dg-final { scan-tree-dump "in all uses of countm1\[^\n\]* / " "pre" } }
 ! There should be only one load from n left
 ! { dg-final { scan-tree-dump-times "\\*n_" 1 "fre1" } }
-! { dg-final { cleanup-tree-dump "fre1" } }
-! { dg-final { cleanup-tree-dump "pre" } }
--- a/src/gcc/testsuite/gfortran.dg/pr43984.f90
+++ b/src/gcc/testsuite/gfortran.dg/pr43984.f90
@@ -53,4 +53,3 @@ end
 ! There should be three loads from iyz.data, not four.
 
 ! { dg-final { scan-tree-dump-times "= iyz.data" 3 "pre" } }
-! { dg-final { cleanup-tree-dump "pre" } }
--- a/src/gcc/testsuite/gfortran.dg/pr45636.f90
+++ b/src/gcc/testsuite/gfortran.dg/pr45636.f90
@@ -13,4 +13,3 @@ end program main
 ! This test will fail on targets which prefer memcpy/memset over
 ! move_by_pieces/store_by_pieces.
 ! { dg-final { scan-tree-dump-times "memset" 0 "forwprop2" { xfail { { hppa*-*-* && { ! lp64 } } || { { mips*-*-* && { ! nomips16 } } || { aarch64*-*-* } } } } } }
-! { dg-final { cleanup-tree-dump "forwprop2" } }
--- a/src/gcc/testsuite/gfortran.dg/pr48636-2.f90
+++ b/src/gcc/testsuite/gfortran.dg/pr48636-2.f90
@@ -35,4 +35,3 @@ end program main
 
 ! { dg-final { scan-ipa-dump "Creating a specialized node of \[^\n\r\]*bar/\[0-9\]*\\." "cp" } }
 ! { dg-final { scan-ipa-dump-times "Aggregate replacements\[^=\]*=\[^=\]*=\[^=\]*=\[^=\]*=\[^=\]*=\[^=\]*=\[^=\]*=\[^=\]*=\[^=\]*=" 2 "cp" } }
-! { dg-final { cleanup-ipa-dump "cp" } }
--- a/src/gcc/testsuite/gfortran.dg/pr48636.f90
+++ b/src/gcc/testsuite/gfortran.dg/pr48636.f90
@@ -36,4 +36,3 @@ end program main
 ! { dg-final { scan-ipa-dump "bar\[^\\n\]*inline copy in MAIN" "inline" } }
 ! { dg-final { scan-ipa-dump-times "phi predicate:" 5 "inline" } }
 ! { dg-final { scan-ipa-dump "inline hints: loop_iterations" "inline" } }
-! { dg-final { cleanup-ipa-dump "inline" } }
--- a/src/gcc/testsuite/gfortran.dg/pr52835.f90
+++ b/src/gcc/testsuite/gfortran.dg/pr52835.f90
@@ -13,4 +13,3 @@ subroutine foo (x, y, z, n)
 end subroutine
 
 ! { dg-final { scan-tree-dump "bar\[ _\]" "optimized" } }
-! { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/gfortran.dg/pr53787.f90
+++ b/src/gcc/testsuite/gfortran.dg/pr53787.f90
@@ -18,4 +18,3 @@ end subroutine init
 
 ! { dg-final { scan-ipa-dump "Creating a specialized node of init" "cp" } }
 ! { dg-final { scan-ipa-dump-times "Aggregate replacements" 2 "cp" } }
-! { dg-final { cleanup-ipa-dump "cp" } }
--- a/src/gcc/testsuite/gfortran.dg/pr57987.f90
+++ b/src/gcc/testsuite/gfortran.dg/pr57987.f90
@@ -21,4 +21,3 @@ contains
 end program test
 
 ! { dg-final { scan-ipa-dump-not "redefined extern inline functions are not considered for inlining" "inline" } }
-! { dg-final { cleanup-ipa-dump "inline" } }
--- a/src/gcc/testsuite/gfortran.dg/proc_decl_23.f90
+++ b/src/gcc/testsuite/gfortran.dg/proc_decl_23.f90
@@ -40,4 +40,3 @@ end module m_string
   print *, t%char3 (["g","h","i"])
   print *, char1 (["j","k","l"])
 end
-! { dg-final { cleanup-tree-dump "m_string" } }
--- a/src/gcc/testsuite/gfortran.dg/promotion_2.f90
+++ b/src/gcc/testsuite/gfortran.dg/promotion_2.f90
@@ -13,4 +13,3 @@ end program test
 
 ! { dg-final { scan-tree-dump-times "sgemm_" 0 "original" } }
 ! { dg-final { scan-tree-dump-times "dgemm_" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/rank_4.f90
+++ b/src/gcc/testsuite/gfortran.dg/rank_4.f90
@@ -16,4 +16,3 @@ program test_rank
 end program test_rank
 
 ! { dg-final { scan-tree-dump-times "not_existing" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/realloc_on_assign_18.f90
+++ b/src/gcc/testsuite/gfortran.dg/realloc_on_assign_18.f90
@@ -17,4 +17,3 @@ end
 
 ! { dg-final { scan-tree-dump "x = \\(struct t .\\) __builtin_malloc \\(1\\);" "original" } }
 ! { dg-final { scan-tree-dump "y.data = \\(void . restrict\\) __builtin_malloc \\(1\\);" "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/realloc_on_assign_19.f90
+++ b/src/gcc/testsuite/gfortran.dg/realloc_on_assign_19.f90
@@ -18,4 +18,3 @@ contains
   end subroutine bar
 end module foo
 ! { dg-final { scan-tree-dump-times "alloc" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/reassoc_1.f90
+++ b/src/gcc/testsuite/gfortran.dg/reassoc_1.f90
@@ -10,4 +10,3 @@ end
 ! We need an explicit +5 and -5, and an intermediate ((bla)) expression
 ! (the reassoc barrier).  Make use of "." matching lineends.
 ! { dg-final { scan-tree-dump "\\\+ 5.*\\\)\\\).* - 5" "optimized" } }
-! { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/gfortran.dg/reassoc_10.f
+++ b/src/gcc/testsuite/gfortran.dg/reassoc_10.f
@@ -14,4 +14,3 @@
 ! and power expansion.
 
 ! { dg-final { scan-tree-dump-times " \\\* " 5 "optimized" } }
-! { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/gfortran.dg/reassoc_2.f90
+++ b/src/gcc/testsuite/gfortran.dg/reassoc_2.f90
@@ -13,4 +13,3 @@ function test(a)
 end
 
 ! { dg-final { scan-tree-dump "- 5" "optimized" } }
-! { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/gfortran.dg/reassoc_3.f90
+++ b/src/gcc/testsuite/gfortran.dg/reassoc_3.f90
@@ -16,5 +16,3 @@ end
 ! { dg-final { scan-tree-dump "b = 5" "original" } }
 ! { dg-final { scan-tree-dump "c_. = .a" "optimized" } }
 ! { dg-final { scan-tree-dump "return c_.;" "optimized" } }
-! { dg-final { cleanup-tree-dump "original" } }
-! { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/gfortran.dg/reassoc_4.f
+++ b/src/gcc/testsuite/gfortran.dg/reassoc_4.f
@@ -41,4 +41,3 @@
 ! unrolled loops.
 
 ! { dg-final { scan-tree-dump-times "\[0-9\] \\\* " 22 "reassoc1" } }
-! { dg-final { cleanup-tree-dump "reassoc1" } }
--- a/src/gcc/testsuite/gfortran.dg/reassoc_5.f90
+++ b/src/gcc/testsuite/gfortran.dg/reassoc_5.f90
@@ -16,4 +16,3 @@ end
 ! We need an explicit +5 and -5, and an intermediate ((bla)) expression
 ! (the reassoc barrier).  Make use of "." matching lineends.
 ! { dg-final { scan-tree-dump-times "\\\+ 5.*\\\)\\\).* - 5" 0 "optimized" } }
-! { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/gfortran.dg/reassoc_6.f
+++ b/src/gcc/testsuite/gfortran.dg/reassoc_6.f
@@ -19,4 +19,3 @@
 ! While we understand to combine x + ~x IVOPTs now messes things
 ! up by hiding that operation in casts to unsigned.
 ! { dg-final { scan-tree-dump-not "~" "optimized" { xfail *-*-* } } }
-! { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/gfortran.dg/reassoc_7.f
+++ b/src/gcc/testsuite/gfortran.dg/reassoc_7.f
@@ -13,4 +13,3 @@
 ! There should be two multiplies following un-distribution.
 
 ! { dg-final { scan-tree-dump-times " \\\* " 2 "optimized" } }
-! { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/gfortran.dg/reassoc_8.f
+++ b/src/gcc/testsuite/gfortran.dg/reassoc_8.f
@@ -14,4 +14,3 @@
 ! and power expansion.
 
 ! { dg-final { scan-tree-dump-times " \\\* " 3 "optimized" } }
-! { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/gfortran.dg/reassoc_9.f
+++ b/src/gcc/testsuite/gfortran.dg/reassoc_9.f
@@ -14,4 +14,3 @@
 ! and power expansion.
 
 ! { dg-final { scan-tree-dump-times " \\\* " 3 "optimized" } }
-! { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/gfortran.dg/reshape_empty_1.f03
+++ b/src/gcc/testsuite/gfortran.dg/reshape_empty_1.f03
@@ -17,4 +17,3 @@ if (K /= i) call abort
 end
 
 ! { dg-final { scan-tree-dump-times "\\\{1, 2, 2, 2, 1, 2, 2, 2, 1\\\}" 2 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/scan_2.f90
+++ b/src/gcc/testsuite/gfortran.dg/scan_2.f90
@@ -32,4 +32,3 @@ end program p1
 
 ! { dg-final { scan-tree-dump-times "iscan = _gfortran_string_scan \\(2," 1 "original" } }
 ! { dg-final { scan-tree-dump-times "iverify = _gfortran_string_verify \\(2," 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/select_char_2.f90
+++ b/src/gcc/testsuite/gfortran.dg/select_char_2.f90
@@ -42,4 +42,3 @@ contains
 end
 
 ! { dg-final { scan-tree-dump-not "_gfortran_select_string" "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/shape_7.f90
+++ b/src/gcc/testsuite/gfortran.dg/shape_7.f90
@@ -28,5 +28,4 @@ Program Main
 End Program Main
 
 ! { dg-final { scan-tree-dump-times "abort" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
 
--- a/src/gcc/testsuite/gfortran.dg/single_char_string.f90
+++ b/src/gcc/testsuite/gfortran.dg/single_char_string.f90
@@ -33,4 +33,3 @@ end
 ! { dg-final { scan-tree-dump-times "_gfortran_compare_string" 0 "original" } }
 ! { dg-final { scan-tree-dump-times "_gfortran_copy_string" 0 "original" } }
 
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/size_kind_2.f90
+++ b/src/gcc/testsuite/gfortran.dg/size_kind_2.f90
@@ -14,4 +14,3 @@ end
 ! { dg-final { scan-tree-dump "static integer.kind=8. A..\\\[2\\\] = \\\{2147483650, 2\\\};" "original" } }
 ! { dg-final { scan-tree-dump "var2 = 4294967300;" "original" } }
 ! { dg-final { scan-tree-dump "var3 = 2147483650;" "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/sizeof_3.f90
+++ b/src/gcc/testsuite/gfortran.dg/sizeof_3.f90
@@ -42,4 +42,3 @@ end
 ! { dg-final { scan-tree-dump-times "m2test = 1;" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "iii = 100;" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "jjj = 160;" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/spread_size_limit.f90
+++ b/src/gcc/testsuite/gfortran.dg/spread_size_limit.f90
@@ -11,5 +11,4 @@ ZLON_MASK(:,:)= SPREAD( (/ (JLON , JLON=1,720) /) , DIM=2, NCOPIES=360 )
 print *, zlon_mask(100,100)
 END
 ! { dg-final { scan-tree-dump-times "_gfortran_spread" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
 
--- a/src/gcc/testsuite/gfortran.dg/stat_1.f90
+++ b/src/gcc/testsuite/gfortran.dg/stat_1.f90
@@ -1,7 +1,7 @@
 ! { dg-do run }
 ! { dg-skip-if "" { *-*-mingw* spu-*-* } { "*" } { "" } }
 ! { dg-options "-std=gnu" }
-  character(len=*), parameter :: f = "testfile"
+  character(len=*), parameter :: f = "testfile_stat_1"
   integer :: s1(13), r1, s2(13), r2, s3(13), r3, d(13), rd
   
   open (10,file=f)
--- a/src/gcc/testsuite/gfortran.dg/stat_2.f90
+++ b/src/gcc/testsuite/gfortran.dg/stat_2.f90
@@ -1,7 +1,7 @@
 ! { dg-do run }
 ! { dg-skip-if "" { *-*-mingw* spu-*-* } { "*" } { "" } }
 ! { dg-options "-std=gnu" }
-  character(len=*), parameter :: f = "testfile"
+  character(len=*), parameter :: f = "testfile_stat_2"
   integer :: s1(13), r1, s2(13), r2, s3(13), r3, d(13), rd
   
   open (10,file=f)
--- a/src/gcc/testsuite/gfortran.dg/storage_size_4.f90
+++ b/src/gcc/testsuite/gfortran.dg/storage_size_4.f90
@@ -20,4 +20,3 @@ subroutine S ( A )
 end
 
 ! { dg-final { scan-tree-dump-not "abort" "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/storage_size_5.f90
+++ b/src/gcc/testsuite/gfortran.dg/storage_size_5.f90
@@ -41,4 +41,3 @@ end subroutine test2
 
 ! { dg-final { scan-tree-dump-times "k1 = \\(integer\\(kind=1\\)\\)" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "k2 = \\(integer\\(kind=2\\)\\)" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/streamio_10.f90
+++ b/src/gcc/testsuite/gfortran.dg/streamio_10.f90
@@ -8,7 +8,7 @@ program stream_io_10
   integer(kind=8) :: thepos
   a = (/ 1, 2, 3, 4 /)
   b = a
-  open(10, file="teststream", access="stream")
+  open(10, file="teststream_streamio_10", access="stream")
   write(10) a
   inquire(10, pos=thepos)
   if (thepos.ne.17) call abort()
--- a/src/gcc/testsuite/gfortran.dg/streamio_12.f90
+++ b/src/gcc/testsuite/gfortran.dg/streamio_12.f90
@@ -6,7 +6,7 @@ program streamtest
   character(1)   :: tchar
   integer        :: i,j,k
   real(kind=4), dimension(100,100) :: anarray
-  open(10, file="teststream", access="stream", form="unformatted")
+  open(10, file="teststream_streamio_12", access="stream", form="unformatted")
   anarray = 3.14159
   write(10) anarray
   write(10, pos=1) ! This is a way to position an unformatted file
--- a/src/gcc/testsuite/gfortran.dg/streamio_15.f90
+++ b/src/gcc/testsuite/gfortran.dg/streamio_15.f90
@@ -13,7 +13,7 @@ program main
   if (newline_length < 1 .or. newline_length > 2) call abort
   close(20)
 
-  open(20,file="foo.txt",form="formatted",access="stream")
+  open(20,file="foo_streamio_15.txt",form="formatted",access="stream")
   write(20,'(A)') '123456'
   write(20,'(A)') 'abcdef'
   write(20,'(A)') 'qwerty'
--- a/src/gcc/testsuite/gfortran.dg/streamio_4.f90
+++ b/src/gcc/testsuite/gfortran.dg/streamio_4.f90
@@ -9,7 +9,7 @@ program streamtest
   integer        :: i,j,k
   integer, parameter :: lines = 5231
    
-  open(10, file="teststream", access="stream", form="formatted")
+  open(10, file="teststream_streamio_4", access="stream", form="formatted")
   
   do i=1,lines
     do j=0,9
@@ -19,7 +19,7 @@ program streamtest
   
   close(10)
   
-  open(10, file="teststream", access="stream",&
+  open(10, file="teststream_streamio_4", access="stream",&
   &form="formatted", position="append")
   do i=1,lines
     do j=0,9
--- a/src/gcc/testsuite/gfortran.dg/streamio_5.f90
+++ b/src/gcc/testsuite/gfortran.dg/streamio_5.f90
@@ -7,7 +7,7 @@ program streamtest5
   character(1)   :: tchar
   integer        :: i,j,k
    
-  open(10, file="teststream", access="stream", form="unformatted")
+  open(10, file="teststream_streamio_5", access="stream", form="unformatted")
   
   do i=1,1229
     do j=0,9
@@ -18,7 +18,7 @@ program streamtest5
   
   close(10)
   
-  open(10, file="teststream", access="stream", form="unformatted")
+  open(10, file="teststream_streamio_5", access="stream", form="unformatted")
   
   do i=1,1229
     do j=0,9
--- a/src/gcc/testsuite/gfortran.dg/streamio_6.f90
+++ b/src/gcc/testsuite/gfortran.dg/streamio_6.f90
@@ -15,7 +15,7 @@ program streamio_6
   &    72, 81, 59, 24, 37, 43, 21, 54, 68, 31, 19, 79, 63, 41,&
   &    42, 12, 10, 62, 43, 9, 30, 9, 54, 35, 4, 5, 55, 3, 94 /
 
-  open(unit=15,file="teststream",access="stream",form="unformatted")
+  open(unit=15,file="teststream_streamio_6",access="stream",form="unformatted")
   do i=1,100
     k = a(i)
     write(unit=15, pos=k) achar(k)
--- a/src/gcc/testsuite/gfortran.dg/streamio_7.f90
+++ b/src/gcc/testsuite/gfortran.dg/streamio_7.f90
@@ -7,7 +7,7 @@ program streamtest
   character(1)   :: tchar
   integer        :: i,j,k
   real(kind=4), dimension(100,100) :: anarray
-  open(10, file="teststream", access="stream", form="unformatted")
+  open(10, file="teststream_streamio_7", access="stream", form="unformatted")
   anarray = 3.14159
   write(10) anarray
   anarray = 0.0
--- a/src/gcc/testsuite/gfortran.dg/string_assign_1.f90
+++ b/src/gcc/testsuite/gfortran.dg/string_assign_1.f90
@@ -8,4 +8,3 @@ program main
   print *,c
 end program main
 ! { dg-final { scan-tree-dump-times "memcpy" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/string_compare_4.f90
+++ b/src/gcc/testsuite/gfortran.dg/string_compare_4.f90
@@ -20,4 +20,3 @@ contains
   end subroutine foo
 end program main
 ! { dg-final { scan-tree-dump-times "_gfortran_string_len_trim" 4 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/string_length_2.f90
+++ b/src/gcc/testsuite/gfortran.dg/string_length_2.f90
@@ -29,4 +29,3 @@ program main
   if (len(c(  (i-2)*(i-3)     :   (i-3)*(i-2)    )) /= 1)       call abort ! Case 18
 end program main
 ! { dg-final { scan-tree-dump-times "_abort" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/structure_constructor_11.f90
+++ b/src/gcc/testsuite/gfortran.dg/structure_constructor_11.f90
@@ -93,4 +93,3 @@ end program ala
 ! { dg-final { scan-tree-dump-times "this->_data->a.cleanup = \\*cleanup;" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "ext_ptr.\[0-9\]+.init = this->_data->a.init;" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "ext_ptr.\[0-9\]+.cleanup = this->_data->a.cleanup;" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/transfer_intrinsic_1.f90
+++ b/src/gcc/testsuite/gfortran.dg/transfer_intrinsic_1.f90
@@ -15,4 +15,3 @@ subroutine BytesToString(bytes, string)
     string = transfer(bytes, string)
   end subroutine
 ! { dg-final { scan-tree-dump-times "MIN_EXPR" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/transfer_intrinsic_6.f90
+++ b/src/gcc/testsuite/gfortran.dg/transfer_intrinsic_6.f90
@@ -17,4 +17,3 @@
 end
 
 ! { dg-final { scan-tree-dump-times "__builtin_free" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/transfer_resolve_3.f90
+++ b/src/gcc/testsuite/gfortran.dg/transfer_resolve_3.f90
@@ -16,5 +16,4 @@ intg = transfer (para%ptr, intg)
 end
 
 ! { dg-final { scan-tree-dump-times "intg = 0;" 2 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
 
--- a/src/gcc/testsuite/gfortran.dg/transpose_optimization_1.f90
+++ b/src/gcc/testsuite/gfortran.dg/transpose_optimization_1.f90
@@ -103,4 +103,3 @@ contains
 end module foo
 
 ! { dg-final { scan-tree-dump-times "struct\[^\\n\]*atmp" 4 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/transpose_optimization_2.f90
+++ b/src/gcc/testsuite/gfortran.dg/transpose_optimization_2.f90
@@ -62,4 +62,3 @@ end
 !
 ! { dg-final { scan-tree-dump-times "parm" 66 "original" } }
 ! { dg-final { scan-tree-dump-times "atmp" 12 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/trim_optimize_1.f90
+++ b/src/gcc/testsuite/gfortran.dg/trim_optimize_1.f90
@@ -13,4 +13,3 @@ end program main
 
 ! { dg-final { scan-tree-dump-times "memmove" 3 "original" } }
 ! { dg-final { scan-tree-dump-times "string_trim" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/trim_optimize_2.f90
+++ b/src/gcc/testsuite/gfortran.dg/trim_optimize_2.f90
@@ -34,4 +34,3 @@ end program main
 
 ! { dg-final { scan-tree-dump-times "memmove" 6 "original" } }
 ! { dg-final { scan-tree-dump-times "string_trim" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/trim_optimize_3.f90
+++ b/src/gcc/testsuite/gfortran.dg/trim_optimize_3.f90
@@ -13,4 +13,3 @@ program main
   if (b4 /= 4_'bcdx') call abort
 end
 ! { dg-final { scan-tree-dump-times "string_len_trim" 2 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/trim_optimize_5.f90
+++ b/src/gcc/testsuite/gfortran.dg/trim_optimize_5.f90
@@ -17,4 +17,3 @@ program main
   if (line /= 'abY       ') call abort
 end program main
 ! { dg-final { scan-tree-dump-times "string_len_trim" 2 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/trim_optimize_7.f90
+++ b/src/gcc/testsuite/gfortran.dg/trim_optimize_7.f90
@@ -16,4 +16,3 @@ program main
   if (d /= 'a b a c ') call abort
 end
 ! { dg-final { scan-tree-dump-times "string_len_trim" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/trim_optimize_8.f90
+++ b/src/gcc/testsuite/gfortran.dg/trim_optimize_8.f90
@@ -11,4 +11,3 @@ program main
   if (trim (trim(a) // trim(b)) /= 'ab ') call abort
 end
 ! { dg-final { scan-tree-dump-times "string_len_trim" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/typebound_assignment_5.f03
+++ b/src/gcc/testsuite/gfortran.dg/typebound_assignment_5.f03
@@ -41,4 +41,3 @@
 
 ! { dg-final { scan-tree-dump-not "_gfortran_internal_pack" "original" } }
 ! { dg-final { scan-tree-dump-not "_gfortran_internal_unpack" "original" } }
-! { dg-final { cleanup-tree-dump "original"} }
--- a/src/gcc/testsuite/gfortran.dg/typebound_assignment_6.f03
+++ b/src/gcc/testsuite/gfortran.dg/typebound_assignment_6.f03
@@ -39,5 +39,4 @@
 
 ! { dg-final { scan-tree-dump-times "_gfortran_internal_pack" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "_gfortran_internal_unpack" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
 
--- a/src/gcc/testsuite/gfortran.dg/typebound_call_21.f03
+++ b/src/gcc/testsuite/gfortran.dg/typebound_call_21.f03
@@ -34,4 +34,3 @@ end module m
 end
 
 ! { dg-final { scan-tree-dump-times "_vptr->" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/typebound_call_22.f03
+++ b/src/gcc/testsuite/gfortran.dg/typebound_call_22.f03
@@ -27,4 +27,3 @@ program test
 end program
 
 ! { dg-final { scan-tree-dump-times "base \\(\\);" 1 "optimized" } }
-! { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/gfortran.dg/typebound_operator_14.f90
+++ b/src/gcc/testsuite/gfortran.dg/typebound_operator_14.f90
@@ -39,4 +39,3 @@ contains
   end function gt_cmp_int
 end module
 
-! { dg-final { cleanup-tree-dump "m_sort test" } }
--- a/src/gcc/testsuite/gfortran.dg/typebound_proc_27.f03
+++ b/src/gcc/testsuite/gfortran.dg/typebound_proc_27.f03
@@ -88,5 +88,4 @@ end program prog
 ! take the realloc path after the first assignment, so don't count as a malloc.
 ! { dg-final { scan-tree-dump-times "__builtin_free" 7 "original" } }
 !
-! { dg-final { cleanup-tree-dump "original" } }
 
--- a/src/gcc/testsuite/gfortran.dg/unf_read_corrupted_1.f90
+++ b/src/gcc/testsuite/gfortran.dg/unf_read_corrupted_1.f90
@@ -10,13 +10,13 @@ program main
   ! Write out a truncated unformatted sequential file by
   ! using unformatted stream.
 
-  open (10, form="unformatted", access="stream", file="foo.dat", &
+  open (10, form="unformatted", access="stream", file="foo_unf_read_corrupted_1.dat", &
   status="unknown")
   write (10) 16_4, 1_4
   close (10, status="keep")
 
   ! Try to read
-  open (10, file="foo.dat", form="unformatted", access="sequential")
+  open (10, file="foo_unf_read_corrupted_1.dat", form="unformatted", access="sequential")
   i1 = 0
   i2 = 0
   read (10, iostat=ios, iomsg=msg) i1, i2
--- a/src/gcc/testsuite/gfortran.dg/unlimited_polymorphic_11.f90
+++ b/src/gcc/testsuite/gfortran.dg/unlimited_polymorphic_11.f90
@@ -11,4 +11,3 @@
 end
 
 ! { dg-final { scan-tree-dump "\\(struct __vtype__STAR \\*\\) c._vptr = \\(struct __vtype__STAR \\*\\) a._vptr;" "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/unlimited_polymorphic_8.f90
+++ b/src/gcc/testsuite/gfortran.dg/unlimited_polymorphic_8.f90
@@ -17,4 +17,3 @@ end
 
 ! { dg-final { scan-tree-dump-times "foo.0.x._data = 0B;" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "foo.0.x._vptr = .* &__vtab__STAR;" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/use_rename_6.f90
+++ b/src/gcc/testsuite/gfortran.dg/use_rename_6.f90
@@ -37,4 +37,3 @@ subroutine four()
 end subroutine four
 
 ! { dg-final { scan-tree-dump-times "shall_not_be_there" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/vect/O3-pr36119.f90
+++ b/src/gcc/testsuite/gfortran.dg/vect/O3-pr36119.f90
@@ -25,4 +25,3 @@ SUBROUTINE check_dnucint_ana (dcore)
   END IF
 END SUBROUTINE check_dnucint_ana
 
-! { dg-final { cleanup-tree-dump "vect" } } 
--- a/src/gcc/testsuite/gfortran.dg/vect/O3-pr39595.f
+++ b/src/gcc/testsuite/gfortran.dg/vect/O3-pr39595.f
@@ -13,5 +13,4 @@
       end do
       end
 
-! { dg-final { cleanup-tree-dump "vect" } }
 
--- a/src/gcc/testsuite/gfortran.dg/vect/O3-pr49957.f
+++ b/src/gcc/testsuite/gfortran.dg/vect/O3-pr49957.f
@@ -14,4 +14,3 @@
       return
       end
 ! { dg-final { scan-tree-dump "vectorized 1 loops" "vect" { xfail vect_no_align } } }
-! { dg-final { cleanup-tree-dump "vect" } }
--- a/src/gcc/testsuite/gfortran.dg/vect/Ofast-pr50414.f90
+++ b/src/gcc/testsuite/gfortran.dg/vect/Ofast-pr50414.f90
@@ -8,4 +8,3 @@
       CALL PROUND(YMA)
       END
 
-! { dg-final { cleanup-tree-dump "vect" } }
--- a/src/gcc/testsuite/gfortran.dg/vect/cost-model-pr34445.f
+++ b/src/gcc/testsuite/gfortran.dg/vect/cost-model-pr34445.f
@@ -6,4 +6,3 @@ c { dg-do compile }
         Alpha = 1.2
       End Do
       End
-c { dg-final { cleanup-tree-dump "vect" } }
--- a/src/gcc/testsuite/gfortran.dg/vect/cost-model-pr34445a.f
+++ b/src/gcc/testsuite/gfortran.dg/vect/cost-model-pr34445a.f
@@ -26,4 +26,3 @@ c
   130 continue
       return
       end
-c { dg-final { cleanup-tree-dump "vect" } }
--- a/src/gcc/testsuite/gfortran.dg/vect/fast-math-mgrid-resid.f
+++ b/src/gcc/testsuite/gfortran.dg/vect/fast-math-mgrid-resid.f
@@ -43,5 +43,3 @@ C
 ! { dg-final { scan-tree-dump-times "Executing predictive commoning without unrolling" 1 "pcom" { target lp64 } } }
 ! { dg-final { scan-tree-dump-times "Executing predictive commoning without unrolling" 2 "pcom" { target ia32 } } }
 ! { dg-final { scan-tree-dump-times "Predictive commoning failed: no suitable chains" 0 "pcom" } }
-! { dg-final { cleanup-tree-dump "vect" } }
-! { dg-final { cleanup-tree-dump "pcom" } }
--- a/src/gcc/testsuite/gfortran.dg/vect/fast-math-pr33299.f90
+++ b/src/gcc/testsuite/gfortran.dg/vect/fast-math-pr33299.f90
@@ -14,4 +14,3 @@ FUNCTION f( x, dist ) RESULT(s)
   IF( x < 0 ) s = -s
 END FUNCTION f
 
-! { dg-final { cleanup-tree-dump "vect" } }
--- a/src/gcc/testsuite/gfortran.dg/vect/fast-math-pr37021.f90
+++ b/src/gcc/testsuite/gfortran.dg/vect/fast-math-pr37021.f90
@@ -15,4 +15,3 @@ subroutine to_product_of(self,a,b,a1,a2)
 end subroutine
 
 ! { dg-final { scan-tree-dump "vectorized 1 loops" "vect" } }
-! { dg-final { cleanup-tree-dump "vect" } }
--- a/src/gcc/testsuite/gfortran.dg/vect/fast-math-pr38968.f90
+++ b/src/gcc/testsuite/gfortran.dg/vect/fast-math-pr38968.f90
@@ -25,4 +25,3 @@ program mymatmul
 end program mymatmul
 
 ! { dg-final { scan-tree-dump "vectorized 1 loops" "vect" } }
-! { dg-final { cleanup-tree-dump "vect" } }
--- a/src/gcc/testsuite/gfortran.dg/vect/fast-math-real8-pr40801.f90
+++ b/src/gcc/testsuite/gfortran.dg/vect/fast-math-real8-pr40801.f90
@@ -34,4 +34,3 @@ IF (ITOP < KLEV+1) THEN
 ENDIF
 END SUBROUTINE ACCONV
 
-! { dg-final { cleanup-tree-dump "vect" } }
--- a/src/gcc/testsuite/gfortran.dg/vect/fast-math-rnflow-trs2a2.f90
+++ b/src/gcc/testsuite/gfortran.dg/vect/fast-math-rnflow-trs2a2.f90
@@ -30,4 +30,3 @@
       end function trs2a2
 
 ! { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  } }
-! { dg-final { cleanup-tree-dump "vect" } }
--- a/src/gcc/testsuite/gfortran.dg/vect/fast-math-vect-8.f90
+++ b/src/gcc/testsuite/gfortran.dg/vect/fast-math-vect-8.f90
@@ -91,4 +91,3 @@ end module solv_cap
 
 
 ! { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_intfloat_cvt } } }
-! { dg-final { cleanup-tree-dump "vect" } } 
--- a/src/gcc/testsuite/gfortran.dg/vect/no-fre-no-copy-prop-O3-pr51704.f90
+++ b/src/gcc/testsuite/gfortran.dg/vect/no-fre-no-copy-prop-O3-pr51704.f90
@@ -53,5 +53,4 @@ contains
   end subroutine tes
 end
 
-! { dg-final { cleanup-tree-dump "vect" } }
 
--- a/src/gcc/testsuite/gfortran.dg/vect/no-vfa-pr32377.f90
+++ b/src/gcc/testsuite/gfortran.dg/vect/no-vfa-pr32377.f90
@@ -12,5 +12,4 @@ real t1,t2,chksum,ctime,dtime,cs1d
 end
 
 ! { dg-final { scan-tree-dump-times "vectorized 2 loops" 1 "vect"   } }
-! { dg-final { cleanup-tree-dump "vect" } }
 
--- a/src/gcc/testsuite/gfortran.dg/vect/no-vfa-pr32457.f90
+++ b/src/gcc/testsuite/gfortran.dg/vect/no-vfa-pr32457.f90
@@ -12,4 +12,3 @@ SUBROUTINE KEEL(RBOUND)
 END SUBROUTINE KEEL
 
 ! { dg-final { scan-tree-dump-times "vectorized 0 loops" 1 "vect" } }
-! { dg-final { cleanup-tree-dump "vect" } }
--- a/src/gcc/testsuite/gfortran.dg/vect/pr19049.f90
+++ b/src/gcc/testsuite/gfortran.dg/vect/pr19049.f90
@@ -21,5 +21,4 @@ subroutine s111 (ntimes,ld,n,ctime,dtime,a,b,c,d,e,aa,bb,cc)
 ! { dg-final { scan-tree-dump-times "vectorized 1 loops" 0 "vect" } }
 ! { dg-final { scan-tree-dump-times "complicated access pattern" 1 "vect" { xfail vect_multiple_sizes } } }
 ! { dg-final { scan-tree-dump-times "complicated access pattern" 2 "vect" { target vect_multiple_sizes } } }
-! { dg-final { cleanup-tree-dump "vect" } }
 
--- a/src/gcc/testsuite/gfortran.dg/vect/pr32377.f90
+++ b/src/gcc/testsuite/gfortran.dg/vect/pr32377.f90
@@ -12,4 +12,3 @@ subroutine s243(ntimes,ld,n,ctime,dtime,a,b,c,d,e,aa,bb,cc)
 end subroutine s243
 
 ! { dg-final { scan-tree-dump-times "vectorized 2 loops" 1 "vect" } }
-! { dg-final { cleanup-tree-dump "vect" } }
--- a/src/gcc/testsuite/gfortran.dg/vect/pr32380.f
+++ b/src/gcc/testsuite/gfortran.dg/vect/pr32380.f
@@ -262,4 +262,3 @@ c
 ! { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { ! vect_element_align } } } }
 ! { dg-final { scan-tree-dump-times "vectorized 5 loops" 1 "vect" { target { vect_element_align && { ! vect_call_sqrtf } } } } }
 ! { dg-final { scan-tree-dump-times "vectorized 6 loops" 1 "vect" { target { vect_element_align && vect_call_sqrtf } } } }
-! { dg-final { cleanup-tree-dump "vect" } }
--- a/src/gcc/testsuite/gfortran.dg/vect/pr33301.f
+++ b/src/gcc/testsuite/gfortran.dg/vect/pr33301.f
@@ -11,4 +11,3 @@ c     It is present in original lapack source
    20       CONTINUE
       END
 
-c { dg-final { cleanup-tree-dump "vect" } }
--- a/src/gcc/testsuite/gfortran.dg/vect/pr39318.f90
+++ b/src/gcc/testsuite/gfortran.dg/vect/pr39318.f90
@@ -17,5 +17,4 @@
       return
       end
 
-! { dg-final { cleanup-tree-dump "vect" } }
 
--- a/src/gcc/testsuite/gfortran.dg/vect/pr45714-a.f
+++ b/src/gcc/testsuite/gfortran.dg/vect/pr45714-a.f
@@ -24,4 +24,3 @@
       enddo
       end
 
-! { dg-final { cleanup-tree-dump "vect" } }
--- a/src/gcc/testsuite/gfortran.dg/vect/pr45714-b.f
+++ b/src/gcc/testsuite/gfortran.dg/vect/pr45714-b.f
@@ -24,4 +24,3 @@
       enddo
       end
 
-! { dg-final { cleanup-tree-dump "vect" } }
--- a/src/gcc/testsuite/gfortran.dg/vect/pr46213.f90
+++ b/src/gcc/testsuite/gfortran.dg/vect/pr46213.f90
@@ -22,4 +22,3 @@ contains
   end function get_d
 end program test
 
-! { dg-final { cleanup-tree-dump "vect" } }
--- a/src/gcc/testsuite/gfortran.dg/vect/pr48329.f90
+++ b/src/gcc/testsuite/gfortran.dg/vect/pr48329.f90
@@ -26,4 +26,3 @@ program calcpi
 end program calcpi
 
 ! { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } }
-! { dg-final { cleanup-tree-dump "vect" } }
--- a/src/gcc/testsuite/gfortran.dg/vect/pr50178.f90
+++ b/src/gcc/testsuite/gfortran.dg/vect/pr50178.f90
@@ -26,4 +26,3 @@ subroutine suedyn
 
 end subroutine suedyn
 
-! { dg-final { cleanup-tree-dump "vect" } }
--- a/src/gcc/testsuite/gfortran.dg/vect/pr50412.f90
+++ b/src/gcc/testsuite/gfortran.dg/vect/pr50412.f90
@@ -9,4 +9,3 @@
    20 CONTINUE
       END
 
-! { dg-final { cleanup-tree-dump "vect" } }
--- a/src/gcc/testsuite/gfortran.dg/vect/pr51058-2.f90
+++ b/src/gcc/testsuite/gfortran.dg/vect/pr51058-2.f90
@@ -17,4 +17,3 @@ subroutine pr51058(n, u, v, w, z)
   end do
 end subroutine
 
-! { dg-final { cleanup-tree-dump "vect" } }
--- a/src/gcc/testsuite/gfortran.dg/vect/pr51058.f90
+++ b/src/gcc/testsuite/gfortran.dg/vect/pr51058.f90
@@ -15,5 +15,4 @@
          ENDDO
       END
 
-! { dg-final { cleanup-tree-dump "vect" } }
 
--- a/src/gcc/testsuite/gfortran.dg/vect/pr51285.f90
+++ b/src/gcc/testsuite/gfortran.dg/vect/pr51285.f90
@@ -33,4 +33,3 @@
     ENDDO
  END SUBROUTINE
 
-! { dg-final { cleanup-tree-dump "vect" } }
--- a/src/gcc/testsuite/gfortran.dg/vect/pr52580.f
+++ b/src/gcc/testsuite/gfortran.dg/vect/pr52580.f
@@ -30,4 +30,3 @@
       RETURN
       END
 ! { dg-final { scan-tree-dump-times "LOOP VECTORIZED" 1 "vect" } }
-! { dg-final { cleanup-tree-dump "vect" } }
--- a/src/gcc/testsuite/gfortran.dg/vect/pr62283.f
+++ b/src/gcc/testsuite/gfortran.dg/vect/pr62283.f
@@ -14,4 +14,3 @@ C { dg-additional-options "-fvect-cost-model=dynamic" }
       y=y+beta*x
       end
 C { dg-final { scan-tree-dump-times "vectorized 1 loops" 2 "vect" { target { vect_hw_misalign } } } }
-C { dg-final { cleanup-tree-dump "vect" } }
--- a/src/gcc/testsuite/gfortran.dg/vect/vect-1.f90
+++ b/src/gcc/testsuite/gfortran.dg/vect/vect-1.f90
@@ -8,4 +8,3 @@ PRINT*, C(500000)
 END
 
 ! { dg-final { scan-tree-dump-times "vectorized 3 loops" 1 "vect" } }
-! { dg-final { cleanup-tree-dump "vect" } }
--- a/src/gcc/testsuite/gfortran.dg/vect/vect-2.f90
+++ b/src/gcc/testsuite/gfortran.dg/vect/vect-2.f90
@@ -19,4 +19,3 @@ END
 ! { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 2 "vect" { target { { vect_no_align && { ! vect_hw_misalign } } && { ! vector_alignment_reachable } } } } }
 ! { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } }
 ! { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 3 "vect" {target { { vect_no_align && { ! vect_hw_misalign } } || { { ! vector_alignment_reachable  } && { ! vect_hw_misalign } } } } } }
-! { dg-final { cleanup-tree-dump "vect" } }
--- a/src/gcc/testsuite/gfortran.dg/vect/vect-3.f90
+++ b/src/gcc/testsuite/gfortran.dg/vect/vect-3.f90
@@ -12,4 +12,3 @@ END
 ! { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { xfail { { vect_no_align && { ! vect_hw_misalign } } || {! vector_alignment_reachable}} } } }
 ! { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail { { vect_no_align && { ! vect_hw_misalign } } || { ! vector_alignment_reachable} } } } }
 
-! { dg-final { cleanup-tree-dump "vect" } }
--- a/src/gcc/testsuite/gfortran.dg/vect/vect-4.f90
+++ b/src/gcc/testsuite/gfortran.dg/vect/vect-4.f90
@@ -14,4 +14,3 @@ END
 ! { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail { { vect_no_align && { ! vect_hw_misalign } } || {! vector_alignment_reachable} } } } }
 ! { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { target { {! vector_alignment_reachable} && {! vect_hw_misalign} } } } }
 ! { dg-final { scan-tree-dump-times "accesses have the same alignment." 1 "vect" } }
-! { dg-final { cleanup-tree-dump "vect" } }
--- a/src/gcc/testsuite/gfortran.dg/vect/vect-5.f90
+++ b/src/gcc/testsuite/gfortran.dg/vect/vect-5.f90
@@ -40,4 +40,3 @@
 ! { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail { vect_no_align && { ! vect_hw_misalign } } } } }
 ! { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 2 "vect" { target { vect_no_align && { ! vect_hw_misalign } } } } }
 ! { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 1 "vect" { target { {! vector_alignment_reachable} && {! vect_hw_misalign} } } } }
-! { dg-final { cleanup-tree-dump "vect" } }
--- a/src/gcc/testsuite/gfortran.dg/vect/vect-6.f
+++ b/src/gcc/testsuite/gfortran.dg/vect/vect-6.f
@@ -21,5 +21,4 @@
   150    CONTINUE
       END
 
-! { dg-final { cleanup-tree-dump "vect" } }
 
--- a/src/gcc/testsuite/gfortran.dg/vect/vect-7.f90
+++ b/src/gcc/testsuite/gfortran.dg/vect/vect-7.f90
@@ -12,5 +12,4 @@ subroutine foo (x,nnd)
 end subroutine foo 
 
 ! { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { vect_unpack  && vect_intfloat_cvt } } } } 
-! { dg-final { cleanup-tree-dump "vect" } } 
 
--- a/src/gcc/testsuite/gfortran.dg/vect/vect-8.f90
+++ b/src/gcc/testsuite/gfortran.dg/vect/vect-8.f90
@@ -704,4 +704,3 @@ RETURN
 END SUBROUTINE kernel
 
 ! { dg-final { scan-tree-dump-times "vectorized 19 loops" 1 "vect" } }
-! { dg-final { cleanup-tree-dump "vect" } }
--- a/src/gcc/testsuite/gfortran.dg/vect/vect-do-concurrent-1.f90
+++ b/src/gcc/testsuite/gfortran.dg/vect/vect-do-concurrent-1.f90
@@ -13,4 +13,3 @@ end subroutine test
 
 ! { dg-message "loop vectorized" "" { target *-*-* } 0 }
 ! { dg-bogus " version\[^\n\r]* alias" "" { target *-*-* } 0 }
-! { dg-final { cleanup-tree-dump "vect" } }
--- a/src/gcc/testsuite/gfortran.dg/vect/vect-gems.f90
+++ b/src/gcc/testsuite/gfortran.dg/vect/vect-gems.f90
@@ -54,4 +54,3 @@ END SUBROUTINE UPMLupdateE
 END MODULE UPML_mod
 
 ! { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  } }
-! { dg-final { cleanup-tree-dump "vect" } }
--- a/src/gcc/testsuite/gfortran.dg/vector_subscript_4.f90
+++ b/src/gcc/testsuite/gfortran.dg/vector_subscript_4.f90
@@ -10,4 +10,3 @@
       k = j((/1,1,1/)+i)
       end
 ! { dg-final { scan-tree-dump-times "A\.2\\\[3\\\]" 1 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/vector_subscript_6.f90
+++ b/src/gcc/testsuite/gfortran.dg/vector_subscript_6.f90
@@ -30,4 +30,3 @@ subroutine test3(esss,Ix,Iyz, e_x, ii_ivec)
 end subroutine
 
 ! { dg-final { scan-tree-dump-not "malloc" "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gfortran.dg/volatile10.f90
+++ b/src/gcc/testsuite/gfortran.dg/volatile10.f90
@@ -145,4 +145,3 @@ end program main
 ! { dg-final { scan-tree-dump      "main_test2_2" "optimized" } }
 ! TODO: dg-final { scan-tree-dump-not  "main_test2_3" "optimized" } 
 ! { dg-final { scan-tree-dump      "main_test2_4" "optimized" } }
-! { dg-final { cleanup-tree-dump  "optimized" } }
--- a/src/gcc/testsuite/gfortran.dg/volatile11.f90
+++ b/src/gcc/testsuite/gfortran.dg/volatile11.f90
@@ -37,4 +37,3 @@ end subroutine
 ! { dg-final { scan-tree-dump "NotOptimizedAway1" "optimized" } } */
 ! { dg-final { scan-tree-dump "NotOptimizedAway2" "optimized" } } */
 ! { dg-final { scan-tree-dump-not "IsOptimizedAway" "optimized" } } */
-! { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gfortran.dg/volatile12.f90
+++ b/src/gcc/testsuite/gfortran.dg/volatile12.f90
@@ -12,5 +12,4 @@ end
 ! { dg-final { scan-tree-dump "integer.kind=.. . volatile arg" "optimized" } }
 ! { dg-final { scan-tree-dump-times " =.v. arg;" 2 "optimized" } }
 ! { dg-final { scan-tree-dump "i_dont_exist" "optimized" } }
-! { dg-final { cleanup-tree-dump "optimized" } }
 
--- a/src/gcc/testsuite/gfortran.dg/volatile4.f90
+++ b/src/gcc/testsuite/gfortran.dg/volatile4.f90
@@ -15,4 +15,3 @@ end do
 end
 ! { dg-final { scan-tree-dump "VolatileNotOptimizedAway" "optimized" } } */
 ! { dg-final { scan-tree-dump-not "NonVolatileNotOptimizedAway" "optimized" } } */
-! { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/gcc/testsuite/gfortran.dg/volatile5.f90
+++ b/src/gcc/testsuite/gfortran.dg/volatile5.f90
@@ -39,4 +39,3 @@ end program main
 ! { dg-final { scan-tree-dump "bStillPresent" "optimized" } }
 ! { dg-final { scan-tree-dump-not "cPresent" "optimized" } }
 ! { dg-final { scan-tree-dump-not "cStillPresent" "optimized" } }
-! { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/gfortran.dg/volatile6.f90
+++ b/src/gcc/testsuite/gfortran.dg/volatile6.f90
@@ -23,4 +23,3 @@ end
 ! { dg-final { scan-tree-dump "VolatileNotOptimizedAway2" "optimized" } }
 ! { dg-final { scan-tree-dump-not "NonVolatileNotOptimizedAway1" "optimized" } }
 ! { dg-final { scan-tree-dump-not "NonVolatileNotOptimizedAway2" "optimized" } }
-! { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/gfortran.dg/volatile7.f90
+++ b/src/gcc/testsuite/gfortran.dg/volatile7.f90
@@ -13,4 +13,3 @@ if(associated(t2)) print *, 'NonVolatileNotOptimizedAway'
 end
 ! { dg-final { scan-tree-dump "VolatileNotOptimizedAway" "optimized" } }
 ! { dg-final { scan-tree-dump-not "NonVolatileNotOptimizedAway" "optimized" } } 
-! { dg-final { cleanup-tree-dump "optimized" } } 
--- a/src/gcc/testsuite/gfortran.dg/whole_file_5.f90
+++ b/src/gcc/testsuite/gfortran.dg/whole_file_5.f90
@@ -17,4 +17,3 @@ PROGRAM main
 END PROGRAM
 
 ! { dg-final { scan-tree-dump-times "= f \\(\\)" 0 "optimized" } }
-! { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/gfortran.dg/whole_file_6.f90
+++ b/src/gcc/testsuite/gfortran.dg/whole_file_6.f90
@@ -17,4 +17,3 @@ INTEGER FUNCTION f()
 END FUNCTION
 
 ! { dg-final { scan-tree-dump-times "= f \\(\\)" 0 "optimized" } }
-! { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/gfortran.dg/widechar_7.f90
+++ b/src/gcc/testsuite/gfortran.dg/widechar_7.f90
@@ -16,4 +16,3 @@ program test
 end program test
 
 ! { dg-final { scan-tree-dump-times "memmove" 0 "original" } }
-! { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gnat.dg/aggr12.adb
+++ b/src/gcc/testsuite/gnat.dg/aggr12.adb
@@ -17,4 +17,3 @@ package body Aggr12 is
 end Aggr12;
 
 -- { dg-final { scan-tree-dump-not "{.i1=0, .i2=2}" "original" } }
--- { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gnat.dg/aggr13.adb
+++ b/src/gcc/testsuite/gnat.dg/aggr13.adb
@@ -20,4 +20,3 @@ begin
 end;
 
 -- { dg-final { scan-tree-dump-not "= {}" "gimple" } }
--- { dg-final { cleanup-tree-dump "gimple" } }
--- a/src/gcc/testsuite/gnat.dg/aliasing1.adb
+++ b/src/gcc/testsuite/gnat.dg/aliasing1.adb
@@ -19,4 +19,3 @@ package body Aliasing1 is
 end Aliasing1;
 
 -- { dg-final { scan-tree-dump-not "gnat_rcheck" "optimized" } }
--- { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/gnat.dg/aliasing2.adb
+++ b/src/gcc/testsuite/gnat.dg/aliasing2.adb
@@ -19,4 +19,3 @@ package body Aliasing2 is
 end Aliasing2;
 
 -- { dg-final { scan-tree-dump-not "gnat_rcheck" "optimized" } }
--- { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/gnat.dg/alignment4.adb
+++ b/src/gcc/testsuite/gnat.dg/alignment4.adb
@@ -12,4 +12,3 @@ begin
 end;
 
 -- { dg-final { scan-tree-dump-not ".\F" "gimple" } }
--- { dg-final { cleanup-tree-dump "gimple" } }
--- a/src/gcc/testsuite/gnat.dg/alignment5.adb
+++ b/src/gcc/testsuite/gnat.dg/alignment5.adb
@@ -28,4 +28,3 @@ begin
 end;
 
 -- { dg-final { scan-tree-dump-not "\.F" "gimple" } }
--- { dg-final { cleanup-tree-dump "gimple" } }
--- a/src/gcc/testsuite/gnat.dg/alignment6.adb
+++ b/src/gcc/testsuite/gnat.dg/alignment6.adb
@@ -29,4 +29,3 @@ begin
 end;
 
 -- { dg-final { scan-tree-dump-not "VIEW_CONVERT_EXPR" "gimple" } }
--- { dg-final { cleanup-tree-dump "gimple" } }
--- a/src/gcc/testsuite/gnat.dg/array16.adb
+++ b/src/gcc/testsuite/gnat.dg/array16.adb
@@ -25,4 +25,3 @@ package body Array16 is
 end Array16;
 
 -- { dg-final { scan-tree-dump-not "secondary_stack" "optimized" } }
--- { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/gnat.dg/array7.adb
+++ b/src/gcc/testsuite/gnat.dg/array7.adb
@@ -20,4 +20,3 @@ package body Array7 is
 end Array7;
 
 -- { dg-final { scan-tree-dump-not "MAX_EXPR" "optimized" } }
--- { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/gnat.dg/atomic1.adb
+++ b/src/gcc/testsuite/gnat.dg/atomic1.adb
@@ -15,4 +15,3 @@ end;
 
 -- { dg-final { scan-tree-dump-times "v_16" 1 "gimple"} }
 -- { dg-final { scan-tree-dump-times "v_32" 1 "gimple"} }
--- { dg-final { cleanup-tree-dump "gimple" } }
--- a/src/gcc/testsuite/gnat.dg/atomic6_1.adb
+++ b/src/gcc/testsuite/gnat.dg/atomic6_1.adb
@@ -36,4 +36,3 @@ end;
 -- { dg-final { scan-tree-dump-times "atomic_store\[^\n\r\]*&temp" 0 "gimple"} }
 -- { dg-final { scan-tree-dump-times "atomic_store\[^\n\r\]*ptr" 0 "gimple"} }
 
--- { dg-final { cleanup-tree-dump "gimple" } }
--- a/src/gcc/testsuite/gnat.dg/atomic6_2.adb
+++ b/src/gcc/testsuite/gnat.dg/atomic6_2.adb
@@ -42,4 +42,3 @@ end;
 -- { dg-final { scan-tree-dump-times "atomic_store\[^\n\r\]*&temp" 0 "gimple"} }
 -- { dg-final { scan-tree-dump-times "atomic_store\[^\n\r\]*ptr" 0 "gimple"} }
 
--- { dg-final { cleanup-tree-dump "gimple" } }
--- a/src/gcc/testsuite/gnat.dg/atomic6_3.adb
+++ b/src/gcc/testsuite/gnat.dg/atomic6_3.adb
@@ -55,4 +55,3 @@ end;
 -- { dg-final { scan-tree-dump-times "atomic_store\[^\n\r\]*&temp" 0 "gimple"} }
 -- { dg-final { scan-tree-dump-times "atomic_store\[^\n\r\]*ptr" 0 "gimple"} }
 
--- { dg-final { cleanup-tree-dump "gimple" } }
--- a/src/gcc/testsuite/gnat.dg/atomic6_4.adb
+++ b/src/gcc/testsuite/gnat.dg/atomic6_4.adb
@@ -42,4 +42,3 @@ end;
 -- { dg-final { scan-tree-dump-times "atomic_store\[^\n\r\]*&temp" 0 "gimple"} }
 -- { dg-final { scan-tree-dump-times "atomic_store\[^\n\r\]*ptr" 0 "gimple"} }
 
--- { dg-final { cleanup-tree-dump "gimple" } }
--- a/src/gcc/testsuite/gnat.dg/atomic6_5.adb
+++ b/src/gcc/testsuite/gnat.dg/atomic6_5.adb
@@ -35,4 +35,3 @@ end;
 -- { dg-final { scan-tree-dump-times "atomic_store\[^\n\r\]*&temp" 0 "gimple"} }
 -- { dg-final { scan-tree-dump-times "atomic_store\[^\n\r\]*ptr" 0 "gimple"} }
 
--- { dg-final { cleanup-tree-dump "gimple" } }
--- a/src/gcc/testsuite/gnat.dg/atomic6_6.adb
+++ b/src/gcc/testsuite/gnat.dg/atomic6_6.adb
@@ -36,4 +36,3 @@ end;
 -- { dg-final { scan-tree-dump-times "atomic_store\[^\n\r\]*&temp" 0 "gimple"} }
 -- { dg-final { scan-tree-dump-times "atomic_store\[^\n\r\]*ptr" 0 "gimple"} }
 
--- { dg-final { cleanup-tree-dump "gimple" } }
--- a/src/gcc/testsuite/gnat.dg/atomic6_7.adb
+++ b/src/gcc/testsuite/gnat.dg/atomic6_7.adb
@@ -37,4 +37,3 @@ end;
 -- { dg-final { scan-tree-dump-times "atomic_store\[^\n\r\]*&temp" 0 "gimple"} }
 -- { dg-final { scan-tree-dump-times "atomic_store\[^\n\r\]*ptr" 0 "gimple"} }
 
--- { dg-final { cleanup-tree-dump "gimple" } }
--- a/src/gcc/testsuite/gnat.dg/atomic6_8.adb
+++ b/src/gcc/testsuite/gnat.dg/atomic6_8.adb
@@ -34,4 +34,3 @@ end;
 -- { dg-final { scan-tree-dump-times "atomic_store\[^\n\r\]*&temp" 0 "gimple"} }
 -- { dg-final { scan-tree-dump-times "atomic_store\[^\n\r\]*ptr" 3 "gimple"} }
 
--- { dg-final { cleanup-tree-dump "gimple" } }
--- a/src/gcc/testsuite/gnat.dg/derived_type1.adb
+++ b/src/gcc/testsuite/gnat.dg/derived_type1.adb
@@ -25,4 +25,3 @@ end;
 
 -- { dg-final { scan-tree-dump-not "VIEW_CONVERT_EXPR<struct derived_type1__root>" "original" } }
 -- { dg-final { scan-tree-dump-not "VIEW_CONVERT_EXPR<struct derived_type1__derived1>" "original" } }
--- { dg-final { cleanup-tree-dump "original" } }
--- a/src/gcc/testsuite/gnat.dg/loop_optimization6.adb
+++ b/src/gcc/testsuite/gnat.dg/loop_optimization6.adb
@@ -23,4 +23,3 @@ package body Loop_Optimization6 is
 end Loop_Optimization6;
 
 -- { dg-final { scan-tree-dump-not "goto" "optimized"} }
--- { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/gnat.dg/noinline2.adb
+++ b/src/gcc/testsuite/gnat.dg/noinline2.adb
@@ -19,4 +19,3 @@ package body Noinline2 is
 end Noinline2;
 
 -- { dg-final { scan-tree-dump-times "noinline2.inner" 2 "optimized"  } }
--- { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/gnat.dg/opt15.adb
+++ b/src/gcc/testsuite/gnat.dg/opt15.adb
@@ -9,4 +9,3 @@ begin
 end;
 
 -- { dg-final { scan-tree-dump-not "trace_inlined" "optimized" } }
--- { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/gnat.dg/opt34.adb
+++ b/src/gcc/testsuite/gnat.dg/opt34.adb
@@ -26,4 +26,3 @@ begin
 end;
 
 -- { dg-final { scan-tree-dump "Created a replacement for result" "esra" } }
--- { dg-final { cleanup-tree-dump "esra" } }
--- a/src/gcc/testsuite/gnat.dg/opt37.adb
+++ b/src/gcc/testsuite/gnat.dg/opt37.adb
@@ -39,4 +39,3 @@ package body Opt37 is
 end Opt37;
 
 -- { dg-final { scan-tree-dump-not "alloca" "optimized" } }
--- { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/gnat.dg/opt39.adb
+++ b/src/gcc/testsuite/gnat.dg/opt39.adb
@@ -28,4 +28,3 @@ begin
 end;
 
 -- { dg-final { scan-tree-dump-times "MEM" 1 "optimized" } }
--- { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/gnat.dg/opt40.adb
+++ b/src/gcc/testsuite/gnat.dg/opt40.adb
@@ -14,4 +14,3 @@ begin
 end;
 
 -- { dg-final { scan-tree-dump-not "gnat_rcheck" "optimized" } }
--- { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/gnat.dg/pack9.adb
+++ b/src/gcc/testsuite/gnat.dg/pack9.adb
@@ -16,4 +16,3 @@ package body Pack9 is
 end Pack9;
 
 -- { dg-final { scan-tree-dump-not "gnat_rcheck" "optimized" } }
--- { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/gnat.dg/renaming5.adb
+++ b/src/gcc/testsuite/gnat.dg/renaming5.adb
@@ -27,4 +27,3 @@ package body Renaming5 is
 end Renaming5;
 
 -- { dg-final { scan-tree-dump-times "goto" 2 "optimized" } }
--- { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/gnat.dg/specs/noinline3.ads
+++ b/src/gcc/testsuite/gnat.dg/specs/noinline3.ads
@@ -6,4 +6,3 @@ with Noinline3_Pkg;
 package Noinline3 is new Noinline3_Pkg (0);
 
 -- { dg-final { scan-tree-dump-times "noinline3.inner" 2 "optimized"  } }
--- { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/gnat.dg/unchecked_convert9.adb
+++ b/src/gcc/testsuite/gnat.dg/unchecked_convert9.adb
@@ -12,4 +12,3 @@ package body Unchecked_Convert9 is
 end Unchecked_Convert9;
 
 -- { dg-final { scan-rtl-dump-times "set \\(mem/v" 1 "final" } }
--- { dg-final { cleanup-rtl-dump "final" } }
--- a/src/gcc/testsuite/gnat.dg/vect1.adb
+++ b/src/gcc/testsuite/gnat.dg/vect1.adb
@@ -125,4 +125,3 @@ package body Vect1 is
 end Vect1;
 
 -- { dg-final { scan-tree-dump-times "vectorized 1 loops" 15 "vect"  } }
--- { dg-final { cleanup-tree-dump "vect" } }
--- a/src/gcc/testsuite/gnat.dg/vect11.adb
+++ b/src/gcc/testsuite/gnat.dg/vect11.adb
@@ -30,4 +30,3 @@ package body Vect11 is
 end Vect11;
 
 -- { dg-final { scan-tree-dump-not "goto" "optimized" } }
--- { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/gnat.dg/vect12.adb
+++ b/src/gcc/testsuite/gnat.dg/vect12.adb
@@ -24,4 +24,3 @@ package body Vect12 is
 end Vect12;
 
 -- { dg-final { scan-tree-dump-not "vectorized 1 loops" "vect"  } }
--- { dg-final { cleanup-tree-dump "vect" } }
--- a/src/gcc/testsuite/gnat.dg/vect13.adb
+++ b/src/gcc/testsuite/gnat.dg/vect13.adb
@@ -24,4 +24,3 @@ package body Vect13 is
 end Vect13;
 
 -- { dg-final { scan-tree-dump-times "vectorized 1 loops" 2 "vect"  } }
--- { dg-final { cleanup-tree-dump "vect" } }
--- a/src/gcc/testsuite/gnat.dg/vect14.adb
+++ b/src/gcc/testsuite/gnat.dg/vect14.adb
@@ -22,4 +22,3 @@ begin
 end;
 
 -- { dg-final { scan-tree-dump-not "VIEW_CONVERT_EXPR" "optimized" } }
--- { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/gnat.dg/vect2.adb
+++ b/src/gcc/testsuite/gnat.dg/vect2.adb
@@ -125,4 +125,3 @@ package body Vect2 is
 end Vect2;
 
 -- { dg-final { scan-tree-dump-times "vectorized 1 loops" 15 "vect"  } }
--- { dg-final { cleanup-tree-dump "vect" } }
--- a/src/gcc/testsuite/gnat.dg/vect3.adb
+++ b/src/gcc/testsuite/gnat.dg/vect3.adb
@@ -125,4 +125,3 @@ package body Vect3 is
 end Vect3;
 
 -- { dg-final { scan-tree-dump-times "vectorized 1 loops" 15 "vect"  } }
--- { dg-final { cleanup-tree-dump "vect" } }
--- a/src/gcc/testsuite/gnat.dg/vect4.adb
+++ b/src/gcc/testsuite/gnat.dg/vect4.adb
@@ -125,4 +125,3 @@ package body Vect4 is
 end Vect4;
 
 -- { dg-final { scan-tree-dump-times "vectorized 1 loops" 15 "vect"  } }
--- { dg-final { cleanup-tree-dump "vect" } }
--- a/src/gcc/testsuite/gnat.dg/vect5.adb
+++ b/src/gcc/testsuite/gnat.dg/vect5.adb
@@ -125,4 +125,3 @@ package body Vect5 is
 end Vect5;
 
 -- { dg-final { scan-tree-dump-times "vectorized 1 loops" 15 "vect"  } }
--- { dg-final { cleanup-tree-dump "vect" } }
--- a/src/gcc/testsuite/gnat.dg/vect6.adb
+++ b/src/gcc/testsuite/gnat.dg/vect6.adb
@@ -125,4 +125,3 @@ package body Vect6 is
 end Vect6;
 
 -- { dg-final { scan-tree-dump-times "vectorized 1 loops" 15 "vect"  } }
--- { dg-final { cleanup-tree-dump "vect" } }
--- a/src/gcc/testsuite/gnat.dg/volatile6.adb
+++ b/src/gcc/testsuite/gnat.dg/volatile6.adb
@@ -17,4 +17,3 @@ begin
 end;
 
 -- { dg-final { scan-tree-dump "goto" "optimized" } }
--- { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/gnat.dg/volatile7.adb
+++ b/src/gcc/testsuite/gnat.dg/volatile7.adb
@@ -21,4 +21,3 @@ begin
 end;
 
 -- { dg-final { scan-tree-dump "goto" "optimized" } }
--- { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/gnat.dg/volatile8.adb
+++ b/src/gcc/testsuite/gnat.dg/volatile8.adb
@@ -19,4 +19,3 @@ begin
 end;
 
 -- { dg-final { scan-tree-dump "goto" "optimized" } }
--- { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/gnat.dg/volatile9.adb
+++ b/src/gcc/testsuite/gnat.dg/volatile9.adb
@@ -17,4 +17,3 @@ begin
 end;
 
 -- { dg-final { scan-tree-dump "goto" "optimized" } }
--- { dg-final { cleanup-tree-dump "optimized" } }
--- a/src/gcc/testsuite/lib/asan-dg.exp
+++ b/src/gcc/testsuite/lib/asan-dg.exp
@@ -138,6 +138,7 @@ proc asan_finish { args } {
     }
     set ld_library_path $asan_saved_library_path
     set_ld_library_path_env_vars
+    clear_effective_target_cache
 }
 
 # Symbolize lines like
--- a/src/gcc/testsuite/lib/atomic-dg.exp
+++ b/src/gcc/testsuite/lib/atomic-dg.exp
@@ -101,4 +101,5 @@ proc atomic_finish { args } {
     } else {
 	unset TEST_ALWAYS_FLAGS
     }
+    clear_effective_target_cache
 }
--- a/src/gcc/testsuite/lib/cilk-plus-dg.exp
+++ b/src/gcc/testsuite/lib/cilk-plus-dg.exp
@@ -101,4 +101,5 @@ proc cilkplus_finish { args } {
     } else {
 	unset TEST_ALWAYS_FLAGS
     }
+    clear_effective_target_cache
 }
--- a/src/gcc/testsuite/lib/clearcap.exp
+++ b/src/gcc/testsuite/lib/clearcap.exp
@@ -55,4 +55,5 @@ proc clearcap-finish { args } {
     } else {
 	unset TEST_ALWAYS_FLAGS
     }
+    clear_effective_target_cache
 }
--- a/src/gcc/testsuite/lib/gcc-dg.exp
+++ b/src/gcc/testsuite/lib/gcc-dg.exp
@@ -105,6 +105,108 @@ if [check_effective_target_lto] {
     }
 }
 
+# Deduce generated files from tool flags, return finalcode string
+proc schedule-cleanups { opts } {
+    global additional_sources
+    set finalcode ""
+    set testcases {}
+    lappend testcases [lindex [testname-for-summary] 0]
+    verbose "Cleanup testcases: $testcases" 4
+    if { [info exists additional_sources] && $additional_sources != "" } {
+	lappend testcases $additional_sources
+	verbose "Cleanup testcases, additional: $additional_sources" 4
+    }
+    verbose "Cleanup all options: $opts" 4
+
+    # First some fixups to transform stuff to something manageable ..
+    # --dump= should translate to -d with joined operand.
+    if [regexp -- {(^|\s+)--dump=[^\s]+(\s+|$)} $opts] {
+	regsub -all -- {--dump=} $opts {-d} opts
+    }
+    # -da and -dx are treated as shorthand for -fdump-rtl-all here
+    if [regexp -- {(^|\s+)-d[ax](\s+|$)} $opts] {
+	verbose "Cleanup -d seen" 4
+	lappend opts "-fdump-rtl-all"
+    }
+    # .. and don't question why there is --dump=? and -d?
+
+    # Then handle options that generate non-dump files
+    # TODO
+    # -fprofile-generate -> cleanup-coverage-files()
+    # -fstack-usage -> cleanup-stack-usage()
+    if [regexp -- {(^|\s+)-fstack-usage(\s+|$)} $opts] {
+	verbose "Cleanup -fstack-usage seen" 4
+#	append finalcode "cleanup-stack-usage\n"
+    }
+    global keep_saved_temps_suffixes
+    if [info exists keep_saved_temps_suffixes ] {
+	verbose "dg-keep-saved-temps ${keep_saved_temps_suffixes}" 2
+    }
+    # -save-temps -> cleanup-saved-temps()
+    if [regexp -- {(^|\s+)-save-temps(\s+|$)} $opts] {
+	verbose "Cleanup -save-temps seen" 4
+	if [info exists keep_saved_temps_suffixes] {
+	    append finalcode "cleanup-saved-temps ${keep_saved_temps_suffixes}\n"
+	} else {
+	    append finalcode "cleanup-saved-temps\n"
+	}
+    } else {
+	if [info exists keep_saved_temps_suffixes ] {
+	    error "dg-keep-saved-temps specified but testcase does not -save-temps"
+	    return
+	}
+    }
+    # Finally see if there are any dumps in opts, otherwise we are done
+    if [regexp -- {(?=(?:^|[ \t]+)?)-fdump-[^ \t]+(?=(?:$|[ \t]+)?)} $opts] {
+        # Ipa, Rtl, Tree for simplicity
+        set ptn "{i,r,t}"
+    } else {
+        return $finalcode
+    }
+    # stem.ext.<passnum><fam>.<passname><pass-instances>
+    # (tree)passes can have multiple instances, thus optional trailing *
+    set ptn "\[0-9\]\[0-9\]\[0-9\]$ptn.*"
+    # Handle ltrans files around -flto
+    if [regexp -- {(^|\s+)-flto(\s+|$)} $opts] {
+	verbose "Cleanup -flto seen" 4
+	set ltrans "{ltrans\[0-9\]*.,}"
+    } else {
+	set ltrans ""
+    }
+    set ptn "$ltrans$ptn"
+    verbose "Cleanup final ptn: $ptn" 4
+    set tfiles {}
+    foreach src $testcases {
+	set basename [file tail $src]
+	if { $ltrans != "" } {
+	    # ??? should we use upvar 1 output_file instead of this (dup ?)
+	    set stem [file rootname $basename]
+	    set basename_ext [file extension $basename]
+	    if {$basename_ext != ""} {
+		regsub -- {^.*\.} $basename_ext {} basename_ext
+	    }
+	    lappend tfiles "$stem.{$basename_ext,exe}"
+	    unset basename_ext
+	} else {
+	    lappend tfiles $basename
+	}
+    }
+    if { [llength $tfiles] > 1 } {
+	set tfiles [join $tfiles ","]
+	set tfiles "{$tfiles}"
+    }
+    verbose "Cleanup final testcases: $tfiles" 4
+    # We have to quote the regex
+    regsub -all {([][$^?+*()|\\{}])} "$tfiles.$ptn" {\\\1} ptn
+    set final ""
+    append final {remove-build-file }
+    append final "\"$ptn\""
+    verbose "Cleanup final: $final" 4
+    append finalcode "$final\n"
+
+    return $finalcode
+}
+
 # Define gcc callbacks for dg.exp.
 
 proc gcc-dg-test-1 { target_compile prog do_what extra_tool_flags } {
@@ -176,6 +278,7 @@ proc gcc-dg-test-1 { target_compile prog do_what extra_tool_flags } {
 	}
     }
 
+    append finalcode [schedule-cleanups "$options $extra_tool_flags"]
     if { $extra_tool_flags != "" } {
 	lappend options "additional_flags=$extra_tool_flags"
     }
@@ -527,27 +630,6 @@ proc cleanup-repo-files { } {
     }
 }
 
-# Remove compiler-generated RTL dump files for the current test.
-#
-# SUFFIX is the filename suffix pattern.
-proc cleanup-rtl-dump { suffix } {
-  cleanup-dump "\[0-9\]\[0-9\]\[0-9\]r.$suffix"
-}
-
-# Remove a specific tree dump file for the current test.
-#
-# SUFFIX is the tree dump file suffix pattern.
-proc cleanup-tree-dump { suffix } {
-  cleanup-dump "\[0-9\]\[0-9\]\[0-9\]t.$suffix"
-}
-
-# Remove a specific ipa dump file for the current test.
-#
-# SUFFIX is the ipa dump file suffix pattern.
-proc cleanup-ipa-dump { suffix } {
-  cleanup-dump "\[0-9\]\[0-9\]\[0-9\]i.$suffix"
-}
-
 # Remove a final insns dump file for the current test.
 proc cleanup-final-insns-dump { } {
     set testcase [testname-for-summary]
@@ -592,30 +674,6 @@ proc cleanup-ada-spec { } {
     }
 }
 
-# Remove all dump files with the provided suffix.
-proc cleanup-dump { suffix } {
-    global additional_sources_used
-    set testcase [testname-for-summary]
-    # The name might include a list of options; extract the file name.
-    set src [file tail [lindex $testcase 0]]
-    remove-build-file "[file tail $src].$suffix"
-    remove-build-file "[file rootname [file tail $src]].exe.$suffix"
-    remove-build-file "[file rootname [file tail $src]].exe.ltrans\[0-9\]*.$suffix"
-    # -fcompare-debug dumps
-    remove-build-file "[file tail $src].gk.$suffix"
-
-    # Clean up dump files for additional source files.
-    if [info exists additional_sources_used] {
-	foreach srcfile $additional_sources_used {
-	    remove-build-file "[file tail $srcfile].$suffix"
-	    remove-build-file "[file rootname [file tail $srcfile]].exe.$suffix"
-	    remove-build-file "[file rootname [file tail $srcfile]].exe.ltrans\[0-9\]*.$suffix"
-	    # -fcompare-debug dumps
-	    remove-build-file "[file tail $srcfile].gk.$suffix"
-	}
-    }
-}
-
 # Remove files kept by --save-temps for the current test.
 #
 # Currently this is only .i, .ii, .s and .o files, but more can be added
@@ -658,6 +716,24 @@ proc cleanup-saved-temps { args } {
     }
 }
 
+
+# Files to be kept after cleanup of --save-temps for the current test.
+# ARGS is a list of suffixes to NOT delete.
+proc dg-keep-saved-temps { args } {
+    global keep_saved_temps_suffixes
+    set keep_saved_temps_suffixes {}
+
+    # add the to-be-kept suffixes
+    foreach suffix {".mii" ".ii" ".i" ".s" ".o" ".gkd" ".res" ".ltrans.out"} {
+	if {[lsearch $args $suffix] >= 0} {
+	    lappend keep_saved_temps_suffixes $suffix
+	}
+    }
+    if { [llength keep_saved_temps_suffixes] < 1 } {
+	error "dg-keep-saved-temps ${args} did not match any known suffix"
+    }
+}
+
 # Scan Fortran modules for a given regexp.
 #
 # Argument 0 is the module name
@@ -760,6 +836,7 @@ if { [info procs saved-dg-test] == [list] } {
 	global shouldfail
 	global testname_with_flags
 	global set_target_env_var
+	global keep_saved_temps_suffixes
 
 	if { [ catch { eval saved-dg-test $args } errmsg ] } {
 	    set saved_info $errorInfo
@@ -785,6 +862,9 @@ if { [info procs saved-dg-test] == [list] } {
 	if [info exists set_target_env_var] {
 	    unset set_target_env_var
 	}
+	if [info exists keep_saved_temps_suffixes] {
+	    unset keep_saved_temps_suffixes
+	}
 	unset_timeout_vars
 	if [info exists compiler_conditional_xfail_data] {
 	    unset compiler_conditional_xfail_data
--- a/src/gcc/testsuite/lib/mpx-dg.exp
+++ b/src/gcc/testsuite/lib/mpx-dg.exp
@@ -142,4 +142,5 @@ proc mpx_finish { args } {
     }
     set ld_library_path $mpx_saved_library_path
     set_ld_library_path_env_vars
+    clear_effective_target_cache
 }
--- a/src/gcc/testsuite/lib/profopt.exp
+++ b/src/gcc/testsuite/lib/profopt.exp
@@ -304,6 +304,9 @@ proc profopt-execute { src } {
 	    return
 	}
 
+	# schedule removal of dump files et al
+	# Do this before the call below destroys additional_sources..
+	append use_final_code [schedule-cleanups "$option $extra_flags"]
         set extra_options [dg-additional-files-options "" "$src"]
 
 	# Remove old profiling data files.  Make sure additional_sources_used is
--- a/src/gcc/testsuite/lib/target-supports.exp
+++ b/src/gcc/testsuite/lib/target-supports.exp
@@ -117,6 +117,7 @@ proc current_target_name { } {
 
 proc check_cached_effective_target { prop args } {
     global et_cache
+    global et_prop_list
 
     set target [current_target_name]
     if {![info exists et_cache($prop,target)]
@@ -124,12 +125,40 @@ proc check_cached_effective_target { prop args } {
 	verbose "check_cached_effective_target $prop: checking $target" 2
 	set et_cache($prop,target) $target
 	set et_cache($prop,value) [uplevel eval $args]
+	if {![info exists et_prop_list]
+	    || [lsearch $et_prop_list $prop] < 0} {
+	    lappend et_prop_list $prop
+	}
+	verbose "check_cached_effective_target cached list is now: $et_prop_list" 2
     }
     set value $et_cache($prop,value)
     verbose "check_cached_effective_target $prop: returning $value for $target" 2
     return $value
 }
 
+# Clear effective-target cache. This is useful after testing
+# effective-target features and overriding TEST_ALWAYS_FLAGS and/or
+# ALWAYS_CXXFLAGS.
+# If one changes ALWAYS_CXXFLAGS or TEST_ALWAYS_FLAGS then they should
+# do a clear_effective_target_cache at the end as the target cache can
+# make decisions based upon the flags, and those decisions need to be
+# redone when the flags change. An example of this is the
+# asan_init/asan_finish pair.
+
+proc clear_effective_target_cache { } {
+    global et_cache
+    global et_prop_list
+
+    if {[info exists et_prop_list]} {
+	verbose "clear_effective_target_cache: $et_prop_list" 2
+	foreach prop $et_prop_list {
+	    unset et_cache($prop,value)
+	    unset et_cache($prop,target)
+	}
+	unset et_prop_list
+    }
+}
+
 # Like check_compile, but delete the output file and return true if the
 # compiler printed no messages.
 proc check_no_compiler_messages_nocache {args} {
@@ -2687,7 +2716,11 @@ proc check_effective_target_arm_neon_fp16_ok_nocache { } {
     set et_arm_neon_fp16_flags ""
     if { [check_effective_target_arm32] } {
 	foreach flags {"" "-mfloat-abi=softfp" "-mfpu=neon-fp16"
-	               "-mfpu=neon-fp16 -mfloat-abi=softfp"} {
+		       "-mfpu=neon-fp16 -mfloat-abi=softfp"
+		       "-mfp16-format=ieee"
+		       "-mfloat-abi=softfp -mfp16-format=ieee"
+		       "-mfpu=neon-fp16 -mfp16-format=ieee"
+		       "-mfpu=neon-fp16 -mfloat-abi=softfp -mfp16-format=ieee"} {
 	    if { [check_no_compiler_messages_nocache arm_neon_fp_16_ok object {
 		#include "arm_neon.h"
 		float16x4_t
@@ -2710,6 +2743,21 @@ proc check_effective_target_arm_neon_fp16_ok { } {
 		check_effective_target_arm_neon_fp16_ok_nocache]
 }
 
+proc check_effective_target_arm_neon_fp16_hw { } {
+    if {! [check_effective_target_arm_neon_fp16_ok] } {
+	return 0
+    }
+    global et_arm_neon_fp16_flags
+    check_runtime_nocache arm_neon_fp16_hw {
+	int
+	main (int argc, char **argv)
+	{
+	  asm ("vcvt.f32.f16 q1, d0");
+	  return 0;
+	}
+    } $et_arm_neon_fp16_flags
+}
+
 proc add_options_for_arm_neon_fp16 { flags } {
     if { ! [check_effective_target_arm_neon_fp16_ok] } {
 	return "$flags"
@@ -4675,6 +4723,27 @@ proc check_effective_target_vect_call_copysignf { } {
     return $et_vect_call_copysignf_saved
 }
 
+# Return 1 if the target supports hardware square root instructions.
+
+proc check_effective_target_sqrt_insn { } {
+    global et_sqrt_insn_saved
+
+    if [info exists et_sqrt_insn_saved] {
+	verbose "check_effective_target_hw_sqrt: using cached result" 2
+    } else {
+	set et_sqrt_insn_saved 0
+	if { [istarget x86_64-*-*]
+	     || [istarget powerpc*-*-*]
+	     || [istarget aarch64*-*-*]
+	     || ([istarget arm*-*-*] && [check_effective_target_arm_vfp_ok]) } {
+	   set et_sqrt_insn_saved 1
+	}
+    }
+
+    verbose "check_effective_target_hw_sqrt: returning et_sqrt_insn_saved" 2
+    return $et_sqrt_insn_saved
+}
+
 # Return 1 if the target supports vector sqrtf calls.
 
 proc check_effective_target_vect_call_sqrtf { } {
--- a/src/gcc/testsuite/lib/tsan-dg.exp
+++ b/src/gcc/testsuite/lib/tsan-dg.exp
@@ -149,4 +149,5 @@ proc tsan_finish { args } {
     }
     set ld_library_path $tsan_saved_library_path
     set_ld_library_path_env_vars
+    clear_effective_target_cache
 }
--- a/src/gcc/testsuite/lib/ubsan-dg.exp
+++ b/src/gcc/testsuite/lib/ubsan-dg.exp
@@ -121,4 +121,5 @@ proc ubsan_finish { args } {
     }
     set ld_library_path $ubsan_saved_library_path
     set_ld_library_path_env_vars
+    clear_effective_target_cache
 }
--- a/src/gcc/testsuite/obj-c++.dg/encode-2.mm
+++ b/src/gcc/testsuite/obj-c++.dg/encode-2.mm
@@ -24,5 +24,4 @@ const char *enc3 = @encode(anonymous);
 
 /* { dg-final { scan-assembler "{Vec<float>=ffi}" } }  */
 /* { dg-final { scan-assembler "{Vec<double>=ddi}" } }  */
-/* { dg-final { scan-file "encode-2.o" "{?={Vec<double>=ddi}{Vec<float>=ffi}fd{Vec<signed char>=cci}i}" } }
-/* { dg-final cleanup-saved-temps } */
+/* { dg-final { scan-file "encode-2.o" "{?={Vec<double>=ddi}{Vec<float>=ffi}fd{Vec<signed char>=cci}i}" } } */
--- a/src/gcc/tree-chrec.c
+++ b/src/gcc/tree-chrec.c
@@ -1178,8 +1178,6 @@ nb_vars_in_chrec (tree chrec)
     }
 }
 
-static tree chrec_convert_1 (tree, tree, gimple, bool);
-
 /* Converts BASE and STEP of affine scev to TYPE.  LOOP is the loop whose iv
    the scev corresponds to.  AT_STMT is the statement at that the scev is
    evaluated.  USE_OVERFLOW_SEMANTICS is true if this function should assume that
@@ -1254,8 +1252,7 @@ convert_affine_scev (struct loop *loop, tree type,
 				use_overflow_semantics))
     return false;
 
-  new_base = chrec_convert_1 (type, *base, at_stmt,
-			      use_overflow_semantics);
+  new_base = chrec_convert (type, *base, at_stmt, use_overflow_semantics);
   /* The step must be sign extended, regardless of the signedness
      of CT and TYPE.  This only needs to be handled specially when
      CT is unsigned -- to avoid e.g. unsigned char [100, +, 255]
@@ -1266,10 +1263,11 @@ convert_affine_scev (struct loop *loop, tree type,
   if (TYPE_PRECISION (step_type) > TYPE_PRECISION (ct) && TYPE_UNSIGNED (ct))
     {
       tree signed_ct = build_nonstandard_integer_type (TYPE_PRECISION (ct), 0);
-      new_step = chrec_convert_1 (signed_ct, new_step, at_stmt,
-                                  use_overflow_semantics);
+      new_step = chrec_convert (signed_ct, new_step, at_stmt,
+                                use_overflow_semantics);
     }
-  new_step = chrec_convert_1 (step_type, new_step, at_stmt, use_overflow_semantics);
+  new_step = chrec_convert (step_type, new_step, at_stmt,
+			    use_overflow_semantics);
 
   if (automatically_generated_chrec_p (new_base)
       || automatically_generated_chrec_p (new_step))
@@ -1306,36 +1304,6 @@ chrec_convert_rhs (tree type, tree chrec, gimple at_stmt)
    determining a more accurate estimation of the number of iterations.
    By default AT_STMT could be safely set to NULL_TREE.
 
-   The following rule is always true: TREE_TYPE (chrec) ==
-   TREE_TYPE (CHREC_LEFT (chrec)) == TREE_TYPE (CHREC_RIGHT (chrec)).
-   An example of what could happen when adding two chrecs and the type
-   of the CHREC_RIGHT is different than CHREC_LEFT is:
-
-   {(uint) 0, +, (uchar) 10} +
-   {(uint) 0, +, (uchar) 250}
-
-   that would produce a wrong result if CHREC_RIGHT is not (uint):
-
-   {(uint) 0, +, (uchar) 4}
-
-   instead of
-
-   {(uint) 0, +, (uint) 260}
-*/
-
-tree
-chrec_convert (tree type, tree chrec, gimple at_stmt)
-{
-  return chrec_convert_1 (type, chrec, at_stmt, true);
-}
-
-/* Convert CHREC to TYPE.  When the analyzer knows the context in
-   which the CHREC is built, it sets AT_STMT to the statement that
-   contains the definition of the analyzed variable, otherwise the
-   conversion is less accurate: the information is used for
-   determining a more accurate estimation of the number of iterations.
-   By default AT_STMT could be safely set to NULL_TREE.
-
    USE_OVERFLOW_SEMANTICS is true if this function should assume that
    the rules for overflow of the given language apply (e.g., that signed
    arithmetics in C does not overflow) -- i.e., to use them to avoid unnecessary
@@ -1420,15 +1388,53 @@ keep_cast:
   return res;
 }
 
+/* Convert CHREC to TYPE.  When the analyzer knows the context in
+   which the CHREC is built, it sets AT_STMT to the statement that
+   contains the definition of the analyzed variable, otherwise the
+   conversion is less accurate: the information is used for
+   determining a more accurate estimation of the number of iterations.
+   By default AT_STMT could be safely set to NULL_TREE.
+
+   The following rule is always true: TREE_TYPE (chrec) ==
+   TREE_TYPE (CHREC_LEFT (chrec)) == TREE_TYPE (CHREC_RIGHT (chrec)).
+   An example of what could happen when adding two chrecs and the type
+   of the CHREC_RIGHT is different than CHREC_LEFT is:
+
+   {(uint) 0, +, (uchar) 10} +
+   {(uint) 0, +, (uchar) 250}
+
+   that would produce a wrong result if CHREC_RIGHT is not (uint):
+
+   {(uint) 0, +, (uchar) 4}
+
+   instead of
+
+   {(uint) 0, +, (uint) 260}
+
+   USE_OVERFLOW_SEMANTICS is true if this function should assume that
+   the rules for overflow of the given language apply (e.g., that signed
+   arithmetics in C does not overflow) -- i.e., to use them to avoid unnecessary
+   tests, but also to enforce that the result follows them.  */
+
+tree
+chrec_convert (tree type, tree chrec, gimple at_stmt,
+	       bool use_overflow_semantics)
+{
+  return chrec_convert_1 (type, chrec, at_stmt, use_overflow_semantics);
+}
+
 /* Convert CHREC to TYPE, without regard to signed overflows.  Returns the new
    chrec if something else than what chrec_convert would do happens, NULL_TREE
-   otherwise.  */
+   otherwise.  This function set TRUE to variable pointed by FOLD_CONVERSIONS
+   if the result chrec may overflow.  */
 
 tree
-chrec_convert_aggressive (tree type, tree chrec)
+chrec_convert_aggressive (tree type, tree chrec, bool *fold_conversions)
 {
   tree inner_type, left, right, lc, rc, rtype;
 
+  gcc_assert (fold_conversions != NULL);
+
   if (automatically_generated_chrec_p (chrec)
       || TREE_CODE (chrec) != POLYNOMIAL_CHREC)
     return NULL_TREE;
@@ -1437,17 +1443,33 @@ chrec_convert_aggressive (tree type, tree chrec)
   if (TYPE_PRECISION (type) > TYPE_PRECISION (inner_type))
     return NULL_TREE;
 
+  if (useless_type_conversion_p (type, inner_type))
+    return NULL_TREE;
+
+  if (!*fold_conversions && evolution_function_is_affine_p (chrec))
+    {
+      tree base, step;
+      struct loop *loop;
+
+      loop = get_chrec_loop (chrec);
+      base = CHREC_LEFT (chrec);
+      step = CHREC_RIGHT (chrec);
+      if (convert_affine_scev (loop, type, &base, &step, NULL, true))
+	return build_polynomial_chrec (loop->num, base, step);
+    }
   rtype = POINTER_TYPE_P (type) ? sizetype : type;
 
   left = CHREC_LEFT (chrec);
   right = CHREC_RIGHT (chrec);
-  lc = chrec_convert_aggressive (type, left);
+  lc = chrec_convert_aggressive (type, left, fold_conversions);
   if (!lc)
     lc = chrec_convert (type, left, NULL);
-  rc = chrec_convert_aggressive (rtype, right);
+  rc = chrec_convert_aggressive (rtype, right, fold_conversions);
   if (!rc)
     rc = chrec_convert (rtype, right, NULL);
 
+  *fold_conversions = true;
+
   return build_polynomial_chrec (CHREC_VARIABLE (chrec), lc, rc);
 }
 
--- a/src/gcc/tree-chrec.h
+++ b/src/gcc/tree-chrec.h
@@ -59,9 +59,9 @@ enum ev_direction scev_direction (const_tree);
 extern tree chrec_fold_plus (tree, tree, tree);
 extern tree chrec_fold_minus (tree, tree, tree);
 extern tree chrec_fold_multiply (tree, tree, tree);
-extern tree chrec_convert (tree, tree, gimple);
+extern tree chrec_convert (tree, tree, gimple, bool = true);
 extern tree chrec_convert_rhs (tree, tree, gimple);
-extern tree chrec_convert_aggressive (tree, tree);
+extern tree chrec_convert_aggressive (tree, tree, bool *);
 
 /* Operations.  */
 extern tree chrec_apply (unsigned, tree, tree);
--- a/src/gcc/tree-pass.h
+++ b/src/gcc/tree-pass.h
@@ -380,6 +380,7 @@ extern gimple_opt_pass *make_pass_loop_prefetch (gcc::context *ctxt);
 extern gimple_opt_pass *make_pass_iv_optimize (gcc::context *ctxt);
 extern gimple_opt_pass *make_pass_tree_loop_done (gcc::context *ctxt);
 extern gimple_opt_pass *make_pass_ch (gcc::context *ctxt);
+extern gimple_opt_pass *make_pass_ch_vect (gcc::context *ctxt);
 extern gimple_opt_pass *make_pass_ccp (gcc::context *ctxt);
 extern gimple_opt_pass *make_pass_phi_only_cprop (gcc::context *ctxt);
 extern gimple_opt_pass *make_pass_build_ssa (gcc::context *ctxt);
--- a/src/gcc/tree-scalar-evolution.c
+++ b/src/gcc/tree-scalar-evolution.c
@@ -2143,7 +2143,7 @@ analyze_scalar_evolution_in_loop (struct loop *wrto_loop, struct loop *use_loop,
   /* We cannot just do
 
      tmp = analyze_scalar_evolution (use_loop, version);
-     ev = resolve_mixers (wrto_loop, tmp);
+     ev = resolve_mixers (wrto_loop, tmp, folded_casts);
 
      as resolve_mixers would query the scalar evolution with respect to
      wrto_loop.  For example, in the situation described in the function
@@ -2152,9 +2152,9 @@ analyze_scalar_evolution_in_loop (struct loop *wrto_loop, struct loop *use_loop,
 
      analyze_scalar_evolution (use_loop, version) = k2
 
-     and resolve_mixers (loop1, k2) finds that the value of k2 in loop 1
-     is 100, which is a wrong result, since we are interested in the
-     value in loop 3.
+     and resolve_mixers (loop1, k2, folded_casts) finds that the value of
+     k2 in loop 1 is 100, which is a wrong result, since we are interested
+     in the value in loop 3.
 
      Instead, we need to proceed from use_loop to wrto_loop loop by loop,
      each time checking that there is no evolution in the inner loop.  */
@@ -2164,10 +2164,7 @@ analyze_scalar_evolution_in_loop (struct loop *wrto_loop, struct loop *use_loop,
   while (1)
     {
       tmp = analyze_scalar_evolution (use_loop, ev);
-      ev = resolve_mixers (use_loop, tmp);
-
-      if (folded_casts && tmp != ev)
-	*folded_casts = true;
+      ev = resolve_mixers (use_loop, tmp, folded_casts);
 
       if (use_loop == wrto_loop)
 	return ev;
@@ -2290,7 +2287,7 @@ loop_closed_phi_def (tree var)
 }
 
 static tree instantiate_scev_r (basic_block, struct loop *, struct loop *,
-				tree, bool, int);
+				tree, bool *, int);
 
 /* Analyze all the parameters of the chrec, between INSTANTIATE_BELOW
    and EVOLUTION_LOOP, that were left under a symbolic form.
@@ -2299,9 +2296,10 @@ static tree instantiate_scev_r (basic_block, struct loop *, struct loop *,
 
    CACHE is the cache of already instantiated values.
 
-   FOLD_CONVERSIONS should be set to true when the conversions that
-   may wrap in signed/pointer type are folded, as long as the value of
-   the chrec is preserved.
+   Variable pointed by FOLD_CONVERSIONS is set to TRUE when the
+   conversions that may wrap in signed/pointer type are folded, as long
+   as the value of the chrec is preserved.  If FOLD_CONVERSIONS is NULL
+   then we don't do such fold.
 
    SIZE_EXPR is used for computing the size of the expression to be
    instantiated, and to stop if it exceeds some limit.  */
@@ -2310,7 +2308,7 @@ static tree
 instantiate_scev_name (basic_block instantiate_below,
 		       struct loop *evolution_loop, struct loop *inner_loop,
 		       tree chrec,
-		       bool fold_conversions,
+		       bool *fold_conversions,
 		       int size_expr)
 {
   tree res;
@@ -2404,9 +2402,10 @@ instantiate_scev_name (basic_block instantiate_below,
 
    CACHE is the cache of already instantiated values.
 
-   FOLD_CONVERSIONS should be set to true when the conversions that
-   may wrap in signed/pointer type are folded, as long as the value of
-   the chrec is preserved.
+   Variable pointed by FOLD_CONVERSIONS is set to TRUE when the
+   conversions that may wrap in signed/pointer type are folded, as long
+   as the value of the chrec is preserved.  If FOLD_CONVERSIONS is NULL
+   then we don't do such fold.
 
    SIZE_EXPR is used for computing the size of the expression to be
    instantiated, and to stop if it exceeds some limit.  */
@@ -2414,7 +2413,7 @@ instantiate_scev_name (basic_block instantiate_below,
 static tree
 instantiate_scev_poly (basic_block instantiate_below,
 		       struct loop *evolution_loop, struct loop *,
-		       tree chrec, bool fold_conversions, int size_expr)
+		       tree chrec, bool *fold_conversions, int size_expr)
 {
   tree op1;
   tree op0 = instantiate_scev_r (instantiate_below, evolution_loop,
@@ -2448,9 +2447,10 @@ instantiate_scev_poly (basic_block instantiate_below,
 
    CACHE is the cache of already instantiated values.
 
-   FOLD_CONVERSIONS should be set to true when the conversions that
-   may wrap in signed/pointer type are folded, as long as the value of
-   the chrec is preserved.
+   Variable pointed by FOLD_CONVERSIONS is set to TRUE when the
+   conversions that may wrap in signed/pointer type are folded, as long
+   as the value of the chrec is preserved.  If FOLD_CONVERSIONS is NULL
+   then we don't do such fold.
 
    SIZE_EXPR is used for computing the size of the expression to be
    instantiated, and to stop if it exceeds some limit.  */
@@ -2460,7 +2460,7 @@ instantiate_scev_binary (basic_block instantiate_below,
 			 struct loop *evolution_loop, struct loop *inner_loop,
 			 tree chrec, enum tree_code code,
 			 tree type, tree c0, tree c1,
-			 bool fold_conversions, int size_expr)
+			 bool *fold_conversions, int size_expr)
 {
   tree op1;
   tree op0 = instantiate_scev_r (instantiate_below, evolution_loop, inner_loop,
@@ -2506,9 +2506,10 @@ instantiate_scev_binary (basic_block instantiate_below,
 
    CACHE is the cache of already instantiated values.
 
-   FOLD_CONVERSIONS should be set to true when the conversions that
-   may wrap in signed/pointer type are folded, as long as the value of
-   the chrec is preserved.
+   Variable pointed by FOLD_CONVERSIONS is set to TRUE when the
+   conversions that may wrap in signed/pointer type are folded, as long
+   as the value of the chrec is preserved.  If FOLD_CONVERSIONS is NULL
+   then we don't do such fold.
 
    SIZE_EXPR is used for computing the size of the expression to be
    instantiated, and to stop if it exceeds some limit.  */
@@ -2516,7 +2517,7 @@ instantiate_scev_binary (basic_block instantiate_below,
 static tree
 instantiate_array_ref (basic_block instantiate_below,
 		       struct loop *evolution_loop, struct loop *inner_loop,
-		       tree chrec, bool fold_conversions, int size_expr)
+		       tree chrec, bool *fold_conversions, int size_expr)
 {
   tree res;
   tree index = TREE_OPERAND (chrec, 1);
@@ -2543,9 +2544,10 @@ instantiate_array_ref (basic_block instantiate_below,
 
    CACHE is the cache of already instantiated values.
 
-   FOLD_CONVERSIONS should be set to true when the conversions that
-   may wrap in signed/pointer type are folded, as long as the value of
-   the chrec is preserved.
+   Variable pointed by FOLD_CONVERSIONS is set to TRUE when the
+   conversions that may wrap in signed/pointer type are folded, as long
+   as the value of the chrec is preserved.  If FOLD_CONVERSIONS is NULL
+   then we don't do such fold.
 
    SIZE_EXPR is used for computing the size of the expression to be
    instantiated, and to stop if it exceeds some limit.  */
@@ -2554,7 +2556,7 @@ static tree
 instantiate_scev_convert (basic_block instantiate_below,
 			  struct loop *evolution_loop, struct loop *inner_loop,
 			  tree chrec, tree type, tree op,
-			  bool fold_conversions, int size_expr)
+			  bool *fold_conversions, int size_expr)
 {
   tree op0 = instantiate_scev_r (instantiate_below, evolution_loop,
 				 inner_loop, op,
@@ -2565,19 +2567,21 @@ instantiate_scev_convert (basic_block instantiate_below,
 
   if (fold_conversions)
     {
-      tree tmp = chrec_convert_aggressive (type, op0);
+      tree tmp = chrec_convert_aggressive (type, op0, fold_conversions);
       if (tmp)
 	return tmp;
-    }
 
-  if (chrec && op0 == op)
-    return chrec;
+      /* If we used chrec_convert_aggressive, we can no longer assume that
+	 signed chrecs do not overflow, as chrec_convert does, so avoid
+	 calling it in that case.  */
+      if (*fold_conversions)
+	{
+	  if (chrec && op0 == op)
+	    return chrec;
 
-  /* If we used chrec_convert_aggressive, we can no longer assume that
-     signed chrecs do not overflow, as chrec_convert does, so avoid
-     calling it in that case.  */
-  if (fold_conversions)
-    return fold_convert (type, op0);
+	  return fold_convert (type, op0);
+	}
+    }
 
   return chrec_convert (type, op0, NULL);
 }
@@ -2591,9 +2595,10 @@ instantiate_scev_convert (basic_block instantiate_below,
 
    CACHE is the cache of already instantiated values.
 
-   FOLD_CONVERSIONS should be set to true when the conversions that
-   may wrap in signed/pointer type are folded, as long as the value of
-   the chrec is preserved.
+   Variable pointed by FOLD_CONVERSIONS is set to TRUE when the
+   conversions that may wrap in signed/pointer type are folded, as long
+   as the value of the chrec is preserved.  If FOLD_CONVERSIONS is NULL
+   then we don't do such fold.
 
    SIZE_EXPR is used for computing the size of the expression to be
    instantiated, and to stop if it exceeds some limit.  */
@@ -2603,7 +2608,7 @@ instantiate_scev_not (basic_block instantiate_below,
 		      struct loop *evolution_loop, struct loop *inner_loop,
 		      tree chrec,
 		      enum tree_code code, tree type, tree op,
-		      bool fold_conversions, int size_expr)
+		      bool *fold_conversions, int size_expr)
 {
   tree op0 = instantiate_scev_r (instantiate_below, evolution_loop,
 				 inner_loop, op,
@@ -2641,9 +2646,10 @@ instantiate_scev_not (basic_block instantiate_below,
 
    CACHE is the cache of already instantiated values.
 
-   FOLD_CONVERSIONS should be set to true when the conversions that
-   may wrap in signed/pointer type are folded, as long as the value of
-   the chrec is preserved.
+   Variable pointed by FOLD_CONVERSIONS is set to TRUE when the
+   conversions that may wrap in signed/pointer type are folded, as long
+   as the value of the chrec is preserved.  If FOLD_CONVERSIONS is NULL
+   then we don't do such fold.
 
    SIZE_EXPR is used for computing the size of the expression to be
    instantiated, and to stop if it exceeds some limit.  */
@@ -2652,7 +2658,7 @@ static tree
 instantiate_scev_3 (basic_block instantiate_below,
 		    struct loop *evolution_loop, struct loop *inner_loop,
 		    tree chrec,
-		    bool fold_conversions, int size_expr)
+		    bool *fold_conversions, int size_expr)
 {
   tree op1, op2;
   tree op0 = instantiate_scev_r (instantiate_below, evolution_loop,
@@ -2689,9 +2695,10 @@ instantiate_scev_3 (basic_block instantiate_below,
 
    CACHE is the cache of already instantiated values.
 
-   FOLD_CONVERSIONS should be set to true when the conversions that
-   may wrap in signed/pointer type are folded, as long as the value of
-   the chrec is preserved.
+   Variable pointed by FOLD_CONVERSIONS is set to TRUE when the
+   conversions that may wrap in signed/pointer type are folded, as long
+   as the value of the chrec is preserved.  If FOLD_CONVERSIONS is NULL
+   then we don't do such fold.
 
    SIZE_EXPR is used for computing the size of the expression to be
    instantiated, and to stop if it exceeds some limit.  */
@@ -2700,7 +2707,7 @@ static tree
 instantiate_scev_2 (basic_block instantiate_below,
 		    struct loop *evolution_loop, struct loop *inner_loop,
 		    tree chrec,
-		    bool fold_conversions, int size_expr)
+		    bool *fold_conversions, int size_expr)
 {
   tree op1;
   tree op0 = instantiate_scev_r (instantiate_below, evolution_loop,
@@ -2729,9 +2736,10 @@ instantiate_scev_2 (basic_block instantiate_below,
 
    CACHE is the cache of already instantiated values.
 
-   FOLD_CONVERSIONS should be set to true when the conversions that
-   may wrap in signed/pointer type are folded, as long as the value of
-   the chrec is preserved.
+   Variable pointed by FOLD_CONVERSIONS is set to TRUE when the
+   conversions that may wrap in signed/pointer type are folded, as long
+   as the value of the chrec is preserved.  If FOLD_CONVERSIONS is NULL
+   then we don't do such fold.
 
    SIZE_EXPR is used for computing the size of the expression to be
    instantiated, and to stop if it exceeds some limit.  */
@@ -2740,7 +2748,7 @@ static tree
 instantiate_scev_1 (basic_block instantiate_below,
 		    struct loop *evolution_loop, struct loop *inner_loop,
 		    tree chrec,
-		    bool fold_conversions, int size_expr)
+		    bool *fold_conversions, int size_expr)
 {
   tree op0 = instantiate_scev_r (instantiate_below, evolution_loop,
 				 inner_loop, TREE_OPERAND (chrec, 0),
@@ -2762,9 +2770,10 @@ instantiate_scev_1 (basic_block instantiate_below,
 
    CACHE is the cache of already instantiated values.
 
-   FOLD_CONVERSIONS should be set to true when the conversions that
-   may wrap in signed/pointer type are folded, as long as the value of
-   the chrec is preserved.
+   Variable pointed by FOLD_CONVERSIONS is set to TRUE when the
+   conversions that may wrap in signed/pointer type are folded, as long
+   as the value of the chrec is preserved.  If FOLD_CONVERSIONS is NULL
+   then we don't do such fold.
 
    SIZE_EXPR is used for computing the size of the expression to be
    instantiated, and to stop if it exceeds some limit.  */
@@ -2773,7 +2782,7 @@ static tree
 instantiate_scev_r (basic_block instantiate_below,
 		    struct loop *evolution_loop, struct loop *inner_loop,
 		    tree chrec,
-		    bool fold_conversions, int size_expr)
+		    bool *fold_conversions, int size_expr)
 {
   /* Give up if the expression is larger than the MAX that we allow.  */
   if (size_expr++ > PARAM_VALUE (PARAM_SCEV_MAX_EXPR_SIZE))
@@ -2898,7 +2907,7 @@ instantiate_scev (basic_block instantiate_below, struct loop *evolution_loop,
     }
 
   res = instantiate_scev_r (instantiate_below, evolution_loop,
-			    NULL, chrec, false, 0);
+			    NULL, chrec, NULL, 0);
 
   if (destr)
     {
@@ -2922,9 +2931,10 @@ instantiate_scev (basic_block instantiate_below, struct loop *evolution_loop,
    of an expression.  */
 
 tree
-resolve_mixers (struct loop *loop, tree chrec)
+resolve_mixers (struct loop *loop, tree chrec, bool *folded_casts)
 {
   bool destr = false;
+  bool fold_conversions = false;
   if (!global_cache)
     {
       global_cache = new instantiate_cache_type;
@@ -2932,7 +2942,10 @@ resolve_mixers (struct loop *loop, tree chrec)
     }
 
   tree ret = instantiate_scev_r (block_before_loop (loop), loop, NULL,
-				 chrec, true, 0);
+				 chrec, &fold_conversions, 0);
+
+  if (folded_casts && !*folded_casts)
+    *folded_casts = fold_conversions;
 
   if (destr)
     {
@@ -3385,7 +3398,8 @@ scev_const_prop (void)
 	      && !INTEGRAL_TYPE_P (type))
 	    continue;
 
-	  ev = resolve_mixers (loop, analyze_scalar_evolution (loop, name));
+	  ev = resolve_mixers (loop, analyze_scalar_evolution (loop, name),
+			       NULL);
 	  if (!is_gimple_min_invariant (ev)
 	      || !may_propagate_copy (name, ev))
 	    continue;
--- a/src/gcc/tree-scalar-evolution.h
+++ b/src/gcc/tree-scalar-evolution.h
@@ -31,7 +31,7 @@ extern void scev_reset_htab (void);
 extern void scev_finalize (void);
 extern tree analyze_scalar_evolution (struct loop *, tree);
 extern tree instantiate_scev (basic_block, struct loop *, tree);
-extern tree resolve_mixers (struct loop *, tree);
+extern tree resolve_mixers (struct loop *, tree, bool *);
 extern void gather_stats_on_scev_database (void);
 extern unsigned int scev_const_prop (void);
 extern bool expression_expensive_p (tree);
--- a/src/gcc/tree-ssa-loop-ch.c
+++ b/src/gcc/tree-ssa-loop-ch.c
@@ -143,12 +143,23 @@ do_while_loop_p (struct loop *loop)
   return true;
 }
 
-/* For all loops, copy the condition at the end of the loop body in front
-   of the loop.  This is beneficial since it increases efficiency of
-   code motion optimizations.  It also saves one jump on entry to the loop.  */
-
 namespace {
 
+/* Common superclass for both header-copying phases.  */
+class ch_base : public gimple_opt_pass
+{
+  protected:
+    ch_base (pass_data data, gcc::context *ctxt)
+      : gimple_opt_pass (data, ctxt)
+    {}
+
+  /* Copies headers of all loops in FUN for which process_loop_p is true.  */
+  unsigned int copy_headers (function *fun);
+
+  /* Return true to copy headers of LOOP or false to skip.  */
+  virtual bool process_loop_p (struct loop *loop) = 0;
+};
+
 const pass_data pass_data_ch =
 {
   GIMPLE_PASS, /* type */
@@ -162,21 +173,68 @@ const pass_data pass_data_ch =
   0, /* todo_flags_finish */
 };
 
-class pass_ch : public gimple_opt_pass
+class pass_ch : public ch_base
 {
 public:
   pass_ch (gcc::context *ctxt)
-    : gimple_opt_pass (pass_data_ch, ctxt)
+    : ch_base (pass_data_ch, ctxt)
   {}
 
   /* opt_pass methods: */
   virtual bool gate (function *) { return flag_tree_ch != 0; }
+  
+  /* Initialize and finalize loop structures, copying headers inbetween.  */
   virtual unsigned int execute (function *);
 
+protected:
+  /* ch_base method: */
+  virtual bool process_loop_p (struct loop *loop);
 }; // class pass_ch
 
+const pass_data pass_data_ch_vect =
+{
+  GIMPLE_PASS, /* type */
+  "ch_vect", /* name */
+  OPTGROUP_LOOP, /* optinfo_flags */
+  TV_TREE_CH, /* tv_id */
+  ( PROP_cfg | PROP_ssa ), /* properties_required */
+  0, /* properties_provided */
+  0, /* properties_destroyed */
+  0, /* todo_flags_start */
+  0, /* todo_flags_finish */
+};
+
+/* This is a more aggressive version of the same pass, designed to run just
+   before if-conversion and vectorization, to put more loops into the form
+   required for those phases.  */
+class pass_ch_vect : public ch_base
+{
+public:
+  pass_ch_vect (gcc::context *ctxt)
+    : ch_base (pass_data_ch_vect, ctxt)
+  {}
+
+  /* opt_pass methods: */
+  virtual bool gate (function *fun)
+  {
+    return flag_tree_ch != 0
+	   && (flag_tree_loop_vectorize != 0 || fun->has_force_vectorize_loops);
+  }
+  
+  /* Just copy headers, no initialization/finalization of loop structures.  */
+  virtual unsigned int execute (function *);
+
+protected:
+  /* ch_base method: */
+  virtual bool process_loop_p (struct loop *loop);
+}; // class pass_ch_vect
+
+/* For all loops, copy the condition at the end of the loop body in front
+   of the loop.  This is beneficial since it increases efficiency of
+   code motion optimizations.  It also saves one jump on entry to the loop.  */
+
 unsigned int
-pass_ch::execute (function *fun)
+ch_base::copy_headers (function *fun)
 {
   struct loop *loop;
   basic_block header;
@@ -186,13 +244,8 @@ pass_ch::execute (function *fun)
   unsigned bbs_size;
   bool changed = false;
 
-  loop_optimizer_init (LOOPS_HAVE_PREHEADERS
-		       | LOOPS_HAVE_SIMPLE_LATCHES);
   if (number_of_loops (fun) <= 1)
-    {
-      loop_optimizer_finalize ();
       return 0;
-    }
 
   bbs = XNEWVEC (basic_block, n_basic_blocks_for_fn (fun));
   copied_bbs = XNEWVEC (basic_block, n_basic_blocks_for_fn (fun));
@@ -209,7 +262,7 @@ pass_ch::execute (function *fun)
 	 written as such, or because jump threading transformed it into one),
 	 we might be in fact peeling the first iteration of the loop.  This
 	 in general is not a good idea.  */
-      if (do_while_loop_p (loop))
+      if (!process_loop_p (loop))
 	continue;
 
       /* Iterate the header copying up to limit; this takes care of the cases
@@ -296,17 +349,88 @@ pass_ch::execute (function *fun)
       changed = true;
     }
 
-  update_ssa (TODO_update_ssa);
+  if (changed)
+    update_ssa (TODO_update_ssa);
   free (bbs);
   free (copied_bbs);
 
-  loop_optimizer_finalize ();
   return changed ? TODO_cleanup_cfg : 0;
 }
 
+/* Initialize the loop structures we need, and finalize after.  */
+
+unsigned int
+pass_ch::execute (function *fun)
+{
+  loop_optimizer_init (LOOPS_HAVE_PREHEADERS
+		       | LOOPS_HAVE_SIMPLE_LATCHES);
+
+  unsigned int res = copy_headers (fun);
+
+  loop_optimizer_finalize ();
+  return res;
+}
+
+/* Assume an earlier phase has already initialized all the loop structures that
+   we need here (and perhaps others too), and that these will be finalized by
+   a later phase.  */
+   
+unsigned int
+pass_ch_vect::execute (function *fun)
+{
+  return copy_headers (fun);
+}
+
+/* Apply header copying according to a very simple test of do-while shape.  */
+
+bool
+pass_ch::process_loop_p (struct loop *loop)
+{
+  return !do_while_loop_p (loop);
+}
+
+/* Apply header-copying to loops where we might enable vectorization.  */
+
+bool
+pass_ch_vect::process_loop_p (struct loop *loop)
+{
+  if (!flag_tree_vectorize && !loop->force_vectorize)
+    return false;
+
+  if (loop->dont_vectorize)
+    return false;
+
+  if (!do_while_loop_p (loop))
+    return true;
+
+ /* The vectorizer won't handle anything with multiple exits, so skip.  */
+  edge exit = single_exit (loop);
+  if (!exit)
+    return false;
+
+  /* Copy headers iff there looks to be code in the loop after the exit block,
+     i.e. the exit block has an edge to another block (besides the latch,
+     which should be empty).  */
+  edge_iterator ei;
+  edge e;
+  FOR_EACH_EDGE (e, ei, exit->src->succs)
+    if (!loop_exit_edge_p (loop, e)
+	&& e->dest != loop->header
+	&& e->dest != loop->latch)
+      return true;
+
+  return false;
+}
+
 } // anon namespace
 
 gimple_opt_pass *
+make_pass_ch_vect (gcc::context *ctxt)
+{
+  return new pass_ch_vect (ctxt);
+}
+
+gimple_opt_pass *
 make_pass_ch (gcc::context *ctxt)
 {
   return new pass_ch (ctxt);
--- a/src/gcc/tree-ssa-loop-ivopts.c
+++ b/src/gcc/tree-ssa-loop-ivopts.c
@@ -171,9 +171,10 @@ struct iv
   tree base_object;	/* A memory object to that the induction variable points.  */
   tree step;		/* Step of the iv (constant only).  */
   tree ssa_name;	/* The ssa name with the value.  */
+  unsigned use_id;	/* The identifier in the use if it is the case.  */
   bool biv_p;		/* Is it a biv?  */
   bool have_use_for;	/* Do we already have a use for it?  */
-  unsigned use_id;	/* The identifier in the use if it is the case.  */
+  bool no_overflow;	/* True if the iv doesn't overflow.  */
 };
 
 /* Per-ssa version information (induction variable descriptions, etc.).  */
@@ -226,6 +227,7 @@ struct cost_pair
 struct iv_use
 {
   unsigned id;		/* The id of the use.  */
+  unsigned sub_id;	/* The id of the sub use.  */
   enum use_type type;	/* Type of the use.  */
   struct iv *iv;	/* The induction variable it is based on.  */
   gimple stmt;		/* Statement in that it occurs.  */
@@ -239,6 +241,11 @@ struct iv_use
 
   struct iv_cand *selected;
 			/* The selected candidate.  */
+
+  struct iv_use *next;	/* The next sub use.  */
+  tree addr_base;	/* Base address with const offset stripped.  */
+  unsigned HOST_WIDE_INT addr_offset;
+			/* Const offset stripped from base address.  */
 };
 
 /* The position where the iv is computed.  */
@@ -509,9 +516,9 @@ single_dom_exit (struct loop *loop)
 /* Dumps information about the induction variable IV to FILE.  */
 
 void
-dump_iv (FILE *file, struct iv *iv)
+dump_iv (FILE *file, struct iv *iv, bool dump_name)
 {
-  if (iv->ssa_name)
+  if (iv->ssa_name && dump_name)
     {
       fprintf (file, "ssa name ");
       print_generic_expr (file, iv->ssa_name, TDF_SLIM);
@@ -555,7 +562,11 @@ dump_iv (FILE *file, struct iv *iv)
 void
 dump_use (FILE *file, struct iv_use *use)
 {
-  fprintf (file, "use %d\n", use->id);
+  fprintf (file, "use %d", use->id);
+  if (use->sub_id)
+    fprintf (file, ".%d", use->sub_id);
+
+  fprintf (file, "\n");
 
   switch (use->type)
     {
@@ -584,7 +595,7 @@ dump_use (FILE *file, struct iv_use *use)
     print_generic_expr (file, *use->op_p, TDF_SLIM);
   fprintf (file, "\n");
 
-  dump_iv (file, use->iv);
+  dump_iv (file, use->iv, false);
 
   if (use->related_cands)
     {
@@ -604,8 +615,12 @@ dump_uses (FILE *file, struct ivopts_data *data)
   for (i = 0; i < n_iv_uses (data); i++)
     {
       use = iv_use (data, i);
-
-      dump_use (file, use);
+      do
+	{
+	  dump_use (file, use);
+	  use = use->next;
+	}
+      while (use);
       fprintf (file, "\n");
     }
 }
@@ -668,7 +683,7 @@ dump_cand (FILE *file, struct iv_cand *cand)
       break;
     }
 
-  dump_iv (file, iv);
+  dump_iv (file, iv, false);
 }
 
 /* Returns the info for ssa version VER.  */
@@ -990,10 +1005,10 @@ contain_complex_addr_expr (tree expr)
 }
 
 /* Allocates an induction variable with given initial value BASE and step STEP
-   for loop LOOP.  */
+   for loop LOOP.  NO_OVERFLOW implies the iv doesn't overflow.  */
 
 static struct iv *
-alloc_iv (tree base, tree step)
+alloc_iv (tree base, tree step, bool no_overflow = false)
 {
   tree expr = base;
   struct iv *iv = XCNEW (struct iv);
@@ -1020,21 +1035,24 @@ alloc_iv (tree base, tree step)
   iv->have_use_for = false;
   iv->use_id = 0;
   iv->ssa_name = NULL_TREE;
+  iv->no_overflow = no_overflow;
 
   return iv;
 }
 
-/* Sets STEP and BASE for induction variable IV.  */
+/* Sets STEP and BASE for induction variable IV.  NO_OVERFLOW implies the IV
+   doesn't overflow.  */
 
 static void
-set_iv (struct ivopts_data *data, tree iv, tree base, tree step)
+set_iv (struct ivopts_data *data, tree iv, tree base, tree step,
+	bool no_overflow)
 {
   struct version_info *info = name_info (data, iv);
 
   gcc_assert (!info->iv);
 
   bitmap_set_bit (data->relevant, SSA_NAME_VERSION (iv));
-  info->iv = alloc_iv (base, step);
+  info->iv = alloc_iv (base, step, no_overflow);
   info->iv->ssa_name = iv;
 }
 
@@ -1056,31 +1074,12 @@ get_iv (struct ivopts_data *data, tree var)
 
       if (!bb
 	  || !flow_bb_inside_loop_p (data->current_loop, bb))
-	set_iv (data, var, var, build_int_cst (type, 0));
+	set_iv (data, var, var, build_int_cst (type, 0), true);
     }
 
   return name_info (data, var)->iv;
 }
 
-/* Determines the step of a biv defined in PHI.  Returns NULL if PHI does
-   not define a simple affine biv with nonzero step.  */
-
-static tree
-determine_biv_step (gphi *phi)
-{
-  struct loop *loop = gimple_bb (phi)->loop_father;
-  tree name = PHI_RESULT (phi);
-  affine_iv iv;
-
-  if (virtual_operand_p (name))
-    return NULL_TREE;
-
-  if (!simple_iv (loop, loop, name, &iv, true))
-    return NULL_TREE;
-
-  return integer_zerop (iv.step) ? NULL_TREE : iv.step;
-}
-
 /* Return the first non-invariant ssa var found in EXPR.  */
 
 static tree
@@ -1114,6 +1113,7 @@ static bool
 find_bivs (struct ivopts_data *data)
 {
   gphi *phi;
+  affine_iv iv;
   tree step, type, base, stop;
   bool found = false;
   struct loop *loop = data->current_loop;
@@ -1126,10 +1126,16 @@ find_bivs (struct ivopts_data *data)
       if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (PHI_RESULT (phi)))
 	continue;
 
-      step = determine_biv_step (phi);
-      if (!step)
+      if (virtual_operand_p (PHI_RESULT (phi)))
 	continue;
 
+      if (!simple_iv (loop, loop, PHI_RESULT (phi), &iv, true))
+	continue;
+
+      if (integer_zerop (iv.step))
+	continue;
+
+      step = iv.step;
       base = PHI_ARG_DEF_FROM_EDGE (phi, loop_preheader_edge (loop));
       /* Stop expanding iv base at the first ssa var referred by iv step.
 	 Ideally we should stop at any ssa var, because that's expensive
@@ -1152,7 +1158,7 @@ find_bivs (struct ivopts_data *data)
 	    step = fold_convert (type, step);
 	}
 
-      set_iv (data, PHI_RESULT (phi), base, step);
+      set_iv (data, PHI_RESULT (phi), base, step, iv.no_overflow);
       found = true;
     }
 
@@ -1255,7 +1261,7 @@ find_givs_in_stmt (struct ivopts_data *data, gimple stmt)
   if (!find_givs_in_stmt_scev (data, stmt, &iv))
     return;
 
-  set_iv (data, gimple_assign_lhs (stmt), iv.base, iv.step);
+  set_iv (data, gimple_assign_lhs (stmt), iv.base, iv.step, iv.no_overflow);
 }
 
 /* Finds general ivs in basic block BB.  */
@@ -1319,36 +1325,83 @@ find_induction_variables (struct ivopts_data *data)
       EXECUTE_IF_SET_IN_BITMAP (data->relevant, 0, i, bi)
 	{
 	  if (ver_info (data, i)->iv)
-	    dump_iv (dump_file, ver_info (data, i)->iv);
+	    dump_iv (dump_file, ver_info (data, i)->iv, true);
 	}
     }
 
   return true;
 }
 
-/* Records a use of type USE_TYPE at *USE_P in STMT whose value is IV.  */
+/* Records a use of type USE_TYPE at *USE_P in STMT whose value is IV.
+   For address type use, ADDR_BASE is the stripped IV base, ADDR_OFFSET
+   is the const offset stripped from IV base.  For uses of other types,
+   ADDR_BASE and ADDR_OFFSET are zero by default.  */
 
 static struct iv_use *
 record_use (struct ivopts_data *data, tree *use_p, struct iv *iv,
-	    gimple stmt, enum use_type use_type)
+	    gimple stmt, enum use_type use_type, tree addr_base = NULL,
+	    unsigned HOST_WIDE_INT addr_offset = 0)
 {
   struct iv_use *use = XCNEW (struct iv_use);
 
   use->id = n_iv_uses (data);
+  use->sub_id = 0;
   use->type = use_type;
   use->iv = iv;
   use->stmt = stmt;
   use->op_p = use_p;
   use->related_cands = BITMAP_ALLOC (NULL);
+  use->next = NULL;
+  use->addr_base = addr_base;
+  use->addr_offset = addr_offset;
 
-  /* To avoid showing ssa name in the dumps, if it was not reset by the
-     caller.  */
-  iv->ssa_name = NULL_TREE;
+  data->iv_uses.safe_push (use);
 
-  if (dump_file && (dump_flags & TDF_DETAILS))
-    dump_use (dump_file, use);
+  return use;
+}
 
-  data->iv_uses.safe_push (use);
+/* Records a sub use of type USE_TYPE at *USE_P in STMT whose value is IV.
+   The sub use is recorded under the one whose use id is ID_GROUP.  */
+
+static struct iv_use *
+record_sub_use (struct ivopts_data *data, tree *use_p,
+		    struct iv *iv, gimple stmt, enum use_type use_type,
+		    tree addr_base, unsigned HOST_WIDE_INT addr_offset,
+		    unsigned int id_group)
+{
+  struct iv_use *use = XCNEW (struct iv_use);
+  struct iv_use *group = iv_use (data, id_group);
+
+  use->id = group->id;
+  use->sub_id = 0;
+  use->type = use_type;
+  use->iv = iv;
+  use->stmt = stmt;
+  use->op_p = use_p;
+  use->related_cands = NULL;
+  use->addr_base = addr_base;
+  use->addr_offset = addr_offset;
+
+  /* Sub use list is maintained in offset ascending order.  */
+  if (addr_offset <= group->addr_offset)
+    {
+      use->related_cands = group->related_cands;
+      group->related_cands = NULL;
+      use->next = group;
+      data->iv_uses[id_group] = use;
+    }
+  else
+    {
+      struct iv_use *pre;
+      do
+	{
+	  pre = group;
+	  group = group->next;
+	}
+      while (group && addr_offset > group->addr_offset);
+      use->next = pre->next;
+      pre->next = use;
+    }
 
   return use;
 }
@@ -1613,6 +1666,7 @@ idx_find_step (tree base, tree *idx, void *data)
 {
   struct ifs_ivopts_data *dta = (struct ifs_ivopts_data *) data;
   struct iv *iv;
+  bool use_overflow_semantics = false;
   tree step, iv_base, iv_step, lbound, off;
   struct loop *loop = dta->ivopts_data->current_loop;
 
@@ -1672,9 +1726,12 @@ idx_find_step (tree base, tree *idx, void *data)
 
   iv_base = iv->base;
   iv_step = iv->step;
+  if (iv->no_overflow && nowrap_type_p (TREE_TYPE (iv_step)))
+    use_overflow_semantics = true;
+
   if (!convert_affine_scev (dta->ivopts_data->current_loop,
 			    sizetype, &iv_base, &iv_step, dta->stmt,
-			    false))
+			    use_overflow_semantics))
     {
       /* The index might wrap.  */
       return false;
@@ -1837,6 +1894,50 @@ may_be_nonaddressable_p (tree expr)
   return false;
 }
 
+static tree
+strip_offset (tree expr, unsigned HOST_WIDE_INT *offset);
+
+/* Record a use of type USE_TYPE at *USE_P in STMT whose value is IV.
+   If there is an existing use which has same stripped iv base and step,
+   this function records this one as a sub use to that; otherwise records
+   it as a normal one.  */
+
+static struct iv_use *
+record_group_use (struct ivopts_data *data, tree *use_p,
+		  struct iv *iv, gimple stmt, enum use_type use_type)
+{
+  unsigned int i;
+  struct iv_use *use;
+  tree addr_base;
+  unsigned HOST_WIDE_INT addr_offset;
+
+  /* Only support sub use for address type uses, that is, with base
+     object.  */
+  if (!iv->base_object)
+    return record_use (data, use_p, iv, stmt, use_type);
+
+  addr_base = strip_offset (iv->base, &addr_offset);
+  for (i = 0; i < n_iv_uses (data); i++)
+    {
+      use = iv_use (data, i);
+      if (use->type != USE_ADDRESS || !use->iv->base_object)
+	continue;
+
+      /* Check if it has the same stripped base and step.  */
+      if (operand_equal_p (iv->base_object, use->iv->base_object, 0)
+	  && operand_equal_p (iv->step, use->iv->step, 0)
+	  && operand_equal_p (addr_base, use->addr_base, 0))
+	break;
+    }
+
+  if (i == n_iv_uses (data))
+    return record_use (data, use_p, iv, stmt,
+		       use_type, addr_base, addr_offset);
+  else
+    return record_sub_use (data, use_p, iv, stmt,
+			   use_type, addr_base, addr_offset, i);
+}
+
 /* Finds addresses in *OP_P inside STMT.  */
 
 static void
@@ -1947,7 +2048,7 @@ find_interesting_uses_address (struct ivopts_data *data, gimple stmt, tree *op_p
     }
 
   civ = alloc_iv (base, step);
-  record_use (data, op_p, civ, stmt, USE_ADDRESS);
+  record_group_use (data, op_p, civ, stmt, USE_ADDRESS);
   return;
 
 fail:
@@ -2133,6 +2234,172 @@ find_interesting_uses (struct ivopts_data *data)
   free (body);
 }
 
+/* Compute maximum offset of [base + offset] addressing mode
+   for memory reference represented by USE.  */
+
+static HOST_WIDE_INT
+compute_max_addr_offset (struct iv_use *use)
+{
+  int width;
+  rtx reg, addr;
+  HOST_WIDE_INT i, off;
+  unsigned list_index, num;
+  addr_space_t as;
+  machine_mode mem_mode, addr_mode;
+  static vec<HOST_WIDE_INT> max_offset_list;
+
+  as = TYPE_ADDR_SPACE (TREE_TYPE (use->iv->base));
+  mem_mode = TYPE_MODE (TREE_TYPE (*use->op_p));
+
+  num = max_offset_list.length ();
+  list_index = (unsigned) as * MAX_MACHINE_MODE + (unsigned) mem_mode;
+  if (list_index >= num)
+    {
+      max_offset_list.safe_grow (list_index + MAX_MACHINE_MODE);
+      for (; num < max_offset_list.length (); num++)
+	max_offset_list[num] = -1;
+    }
+
+  off = max_offset_list[list_index];
+  if (off != -1)
+    return off;
+
+  addr_mode = targetm.addr_space.address_mode (as);
+  reg = gen_raw_REG (addr_mode, LAST_VIRTUAL_REGISTER + 1);
+  addr = gen_rtx_fmt_ee (PLUS, addr_mode, reg, NULL_RTX);
+
+  width = GET_MODE_BITSIZE (addr_mode) - 1;
+  if (width > (HOST_BITS_PER_WIDE_INT - 1))
+    width = HOST_BITS_PER_WIDE_INT - 1;
+
+  for (i = width; i > 0; i--)
+    {
+      off = ((unsigned HOST_WIDE_INT) 1 << i) - 1;
+      XEXP (addr, 1) = gen_int_mode (off, addr_mode);
+      if (memory_address_addr_space_p (mem_mode, addr, as))
+	break;
+
+      /* For some strict-alignment targets, the offset must be naturally
+	 aligned.  Try an aligned offset if mem_mode is not QImode.  */
+      off = ((unsigned HOST_WIDE_INT) 1 << i);
+      if (off > GET_MODE_SIZE (mem_mode) && mem_mode != QImode)
+	{
+	  off -= GET_MODE_SIZE (mem_mode);
+	  XEXP (addr, 1) = gen_int_mode (off, addr_mode);
+	  if (memory_address_addr_space_p (mem_mode, addr, as))
+	    break;
+	}
+    }
+  if (i == 0)
+    off = 0;
+
+  max_offset_list[list_index] = off;
+  return off;
+}
+
+/* Check if all small groups should be split.  Return true if and
+   only if:
+
+     1) At least one groups contain two uses with different offsets.
+     2) No group contains more than two uses with different offsets.
+
+   Return false otherwise.  We want to split such groups because:
+
+     1) Small groups don't have much benefit and may interfer with
+	general candidate selection.
+     2) Size for problem with only small groups is usually small and
+	general algorithm can handle it well.
+
+   TODO -- Above claim may not hold when auto increment is supported.  */
+
+static bool
+split_all_small_groups (struct ivopts_data *data)
+{
+  bool split_p = false;
+  unsigned int i, n, distinct;
+  struct iv_use *pre, *use;
+
+  n = n_iv_uses (data);
+  for (i = 0; i < n; i++)
+    {
+      use = iv_use (data, i);
+      if (!use->next)
+	continue;
+
+      distinct = 1;
+      gcc_assert (use->type == USE_ADDRESS);
+      for (pre = use, use = use->next; use; pre = use, use = use->next)
+	{
+	  if (pre->addr_offset != use->addr_offset)
+	    distinct++;
+
+	  if (distinct > 2)
+	    return false;
+	}
+      if (distinct == 2)
+	split_p = true;
+    }
+
+  return split_p;
+}
+
+/* For each group of address type uses, this function further groups
+   these uses according to the maximum offset supported by target's
+   [base + offset] addressing mode.  */
+
+static void
+group_address_uses (struct ivopts_data *data)
+{
+  HOST_WIDE_INT max_offset = -1;
+  unsigned int i, n, sub_id;
+  struct iv_use *pre, *use;
+  unsigned HOST_WIDE_INT addr_offset_first;
+
+  /* Reset max offset to split all small groups.  */
+  if (split_all_small_groups (data))
+    max_offset = 0;
+
+  n = n_iv_uses (data);
+  for (i = 0; i < n; i++)
+    {
+      use = iv_use (data, i);
+      if (!use->next)
+	continue;
+
+      gcc_assert (use->type == USE_ADDRESS);
+      if (max_offset != 0)
+	max_offset = compute_max_addr_offset (use);
+
+      while (use)
+	{
+	  sub_id = 0;
+	  addr_offset_first = use->addr_offset;
+	  /* Only uses with offset that can fit in offset part against
+	     the first use can be grouped together.  */
+	  for (pre = use, use = use->next;
+	       use && (use->addr_offset - addr_offset_first
+		       <= (unsigned HOST_WIDE_INT) max_offset);
+	       pre = use, use = use->next)
+	    {
+	      use->id = pre->id;
+	      use->sub_id = ++sub_id;
+	    }
+
+	  /* Break the list and create new group.  */
+	  if (use)
+	    {
+	      pre->next = NULL;
+	      use->id = n_iv_uses (data);
+	      use->related_cands = BITMAP_ALLOC (NULL);
+	      data->iv_uses.safe_push (use);
+	    }
+	}
+    }
+
+  if (dump_file && (dump_flags & TDF_DETAILS))
+    dump_uses (dump_file, data);
+}
+
 /* Strips constant offsets from EXPR and stores them to OFFSET.  If INSIDE_ADDR
    is true, assume we are inside an address.  If TOP_COMPREF is true, assume
    we are at the top-level of the processed address.  */
@@ -2550,20 +2817,20 @@ add_autoinc_candidates (struct ivopts_data *data, tree base, tree step,
 
 /* Adds a candidate BASE + STEP * i.  Important field is set to IMPORTANT and
    position to POS.  If USE is not NULL, the candidate is set as related to
-   it.  The candidate computation is scheduled on all available positions.  */
+   it.  The candidate computation is scheduled before exit condition and at
+   the end of loop.  */
 
 static void
 add_candidate (struct ivopts_data *data,
 	       tree base, tree step, bool important, struct iv_use *use)
 {
+  gcc_assert (use == NULL || use->sub_id == 0);
+
   if (ip_normal_pos (data->current_loop))
     add_candidate_1 (data, base, step, important, IP_NORMAL, use, NULL);
   if (ip_end_pos (data->current_loop)
       && allow_ip_end_pos_p (data->current_loop))
     add_candidate_1 (data, base, step, important, IP_END, use, NULL);
-
-  if (use != NULL && use->type == USE_ADDRESS)
-    add_autoinc_candidates (data, base, step, important, use);
 }
 
 /* Adds standard iv candidates.  */
@@ -2592,7 +2859,7 @@ add_standard_iv_candidates (struct ivopts_data *data)
 /* Adds candidates bases on the old induction variable IV.  */
 
 static void
-add_old_iv_candidates (struct ivopts_data *data, struct iv *iv)
+add_iv_candidate_for_biv (struct ivopts_data *data, struct iv *iv)
 {
   gimple phi;
   tree def;
@@ -2632,7 +2899,7 @@ add_old_iv_candidates (struct ivopts_data *data, struct iv *iv)
 /* Adds candidates based on the old induction variables.  */
 
 static void
-add_old_ivs_candidates (struct ivopts_data *data)
+add_iv_candidate_for_bivs (struct ivopts_data *data)
 {
   unsigned i;
   struct iv *iv;
@@ -2642,19 +2909,19 @@ add_old_ivs_candidates (struct ivopts_data *data)
     {
       iv = ver_info (data, i)->iv;
       if (iv && iv->biv_p && !integer_zerop (iv->step))
-	add_old_iv_candidates (data, iv);
+	add_iv_candidate_for_biv (data, iv);
     }
 }
 
-/* Adds candidates based on the value of the induction variable IV and USE.  */
+/* Adds candidates based on the value of USE's iv.  */
 
 static void
-add_iv_value_candidates (struct ivopts_data *data,
-			 struct iv *iv, struct iv_use *use)
+add_iv_candidate_for_use (struct ivopts_data *data, struct iv_use *use)
 {
   unsigned HOST_WIDE_INT offset;
   tree base;
   tree basetype;
+  struct iv *iv = use->iv;
 
   add_candidate (data, iv->base, iv->step, false, use);
 
@@ -2664,21 +2931,25 @@ add_iv_value_candidates (struct ivopts_data *data,
   basetype = TREE_TYPE (iv->base);
   if (POINTER_TYPE_P (basetype))
     basetype = sizetype;
-  add_candidate (data, build_int_cst (basetype, 0),
-		 iv->step, true, use);
+  add_candidate (data, build_int_cst (basetype, 0), iv->step, true, use);
 
   /* Third, try removing the constant offset.  Make sure to even
      add a candidate for &a[0] vs. (T *)&a.  */
   base = strip_offset (iv->base, &offset);
-  if (offset
-      || base != iv->base)
+  if (offset || base != iv->base)
     add_candidate (data, base, iv->step, false, use);
+
+  /* At last, add auto-incremental candidates.  Make such variables
+     important since other iv uses with same base object may be based
+     on it.  */
+  if (use != NULL && use->type == USE_ADDRESS)
+    add_autoinc_candidates (data, iv->base, iv->step, true, use);
 }
 
 /* Adds candidates based on the uses.  */
 
 static void
-add_derived_ivs_candidates (struct ivopts_data *data)
+add_iv_candidate_for_uses (struct ivopts_data *data)
 {
   unsigned i;
 
@@ -2695,7 +2966,7 @@ add_derived_ivs_candidates (struct ivopts_data *data)
 	case USE_COMPARE:
 	case USE_ADDRESS:
 	  /* Just add the ivs based on the value of the iv used here.  */
-	  add_iv_value_candidates (data, use->iv, use);
+	  add_iv_candidate_for_use (data, use);
 	  break;
 
 	default:
@@ -2785,11 +3056,22 @@ new_cost (unsigned runtime, unsigned complexity)
   return cost;
 }
 
+/* Returns true if COST is infinite.  */
+
+static bool
+infinite_cost_p (comp_cost cost)
+{
+  return cost.cost == INFTY;
+}
+
 /* Adds costs COST1 and COST2.  */
 
 static comp_cost
 add_costs (comp_cost cost1, comp_cost cost2)
 {
+  if (infinite_cost_p (cost1) || infinite_cost_p (cost2))
+    return infinite_cost;
+
   cost1.cost += cost2.cost;
   cost1.complexity += cost2.complexity;
 
@@ -2818,14 +3100,6 @@ compare_costs (comp_cost cost1, comp_cost cost2)
   return cost1.cost - cost2.cost;
 }
 
-/* Returns true if COST is infinite.  */
-
-static bool
-infinite_cost_p (comp_cost cost)
-{
-  return cost.cost == INFTY;
-}
-
 /* Sets cost of (USE, CANDIDATE) pair to COST and record that it depends
    on invariants DEPENDS_ON and that the value used in expressing it
    is VALUE, and in case of iv elimination the comparison operator is COMP.  */
@@ -3644,6 +3918,7 @@ get_shiftadd_cost (tree expr, machine_mode mode, comp_cost cost0,
   if (!(m >= 0 && m < maxm))
     return false;
 
+  STRIP_NOPS (op1);
   mult_in_op1 = operand_equal_p (op1, mult, 0);
 
   as_cost = add_cost (speed, mode) + shift_cost (speed, mode, m);
@@ -4300,7 +4575,15 @@ get_computation_cost_at (struct ivopts_data *data,
       cost.cost += add_cost (data->speed, TYPE_MODE (ctype));
     }
 
-  if (inv_expr_id)
+  /* Set of invariants depended on by sub use has already been computed
+     for the first use in the group.  */
+  if (use->sub_id)
+    {
+      cost.cost = 0;
+      if (depends_on && *depends_on)
+	bitmap_clear (*depends_on);
+    }
+  else if (inv_expr_id)
     {
       *inv_expr_id =
           get_loop_invariant_expr_id (data, ubase, cbase, ratio, address_p);
@@ -4429,6 +4712,8 @@ determine_use_iv_cost_address (struct ivopts_data *data,
   bitmap depends_on;
   bool can_autoinc;
   int inv_expr_id = -1;
+  struct iv_use *sub_use;
+  comp_cost sub_cost;
   comp_cost cost = get_computation_cost (data, use, cand, true, &depends_on,
 					 &can_autoinc, &inv_expr_id);
 
@@ -4442,6 +4727,15 @@ determine_use_iv_cost_address (struct ivopts_data *data,
       else if (cand->pos == IP_AFTER_USE || cand->pos == IP_BEFORE_USE)
 	cost = infinite_cost;
     }
+  for (sub_use = use->next;
+       sub_use && !infinite_cost_p (cost);
+       sub_use = sub_use->next)
+    {
+       sub_cost = get_computation_cost (data, sub_use, cand, true, &depends_on,
+					&can_autoinc, &inv_expr_id);
+       cost = add_costs (cost, sub_cost);
+    }
+
   set_use_iv_cost (data, use, cand, cost, depends_on, NULL_TREE, ERROR_MARK,
                    inv_expr_id);
 
@@ -5058,10 +5352,10 @@ find_iv_candidates (struct ivopts_data *data)
   add_standard_iv_candidates (data);
 
   /* Add old induction variables.  */
-  add_old_ivs_candidates (data);
+  add_iv_candidate_for_bivs (data);
 
   /* Add induction variables derived from uses.  */
-  add_derived_ivs_candidates (data);
+  add_iv_candidate_for_uses (data);
 
   set_autoinc_for_original_candidates (data);
 
@@ -6588,8 +6882,8 @@ adjust_iv_update_pos (struct iv_cand *cand, struct iv_use *use)
 /* Rewrites USE (address that is an iv) using candidate CAND.  */
 
 static void
-rewrite_use_address (struct ivopts_data *data,
-		     struct iv_use *use, struct iv_cand *cand)
+rewrite_use_address_1 (struct ivopts_data *data,
+		       struct iv_use *use, struct iv_cand *cand)
 {
   aff_tree aff;
   gimple_stmt_iterator bsi = gsi_for_stmt (use->stmt);
@@ -6624,6 +6918,28 @@ rewrite_use_address (struct ivopts_data *data,
   *use->op_p = ref;
 }
 
+/* Rewrites USE (address that is an iv) using candidate CAND.  If it's the
+   first use of a group, rewrites sub uses in the group too.  */
+
+static void
+rewrite_use_address (struct ivopts_data *data,
+		      struct iv_use *use, struct iv_cand *cand)
+{
+  struct iv_use *next;
+
+  gcc_assert (use->sub_id == 0);
+  rewrite_use_address_1 (data, use, cand);
+  update_stmt (use->stmt);
+
+  for (next = use->next; next != NULL; next = next->next)
+    {
+      rewrite_use_address_1 (data, next, cand);
+      update_stmt (next->stmt);
+    }
+
+  return;
+}
+
 /* Rewrites USE (the condition such that one of the arguments is an iv) using
    candidate CAND.  */
 
@@ -6899,6 +7215,18 @@ free_loop_data (struct ivopts_data *data)
   for (i = 0; i < n_iv_uses (data); i++)
     {
       struct iv_use *use = iv_use (data, i);
+      struct iv_use *pre = use, *sub = use->next;
+
+      while (sub)
+	{
+	  gcc_assert (sub->related_cands == NULL);
+	  gcc_assert (sub->n_map_members == 0 && sub->cost_map == NULL);
+
+	  free (sub->iv);
+	  pre = sub;
+	  sub = sub->next;
+	  free (pre);
+	}
 
       free (use->iv);
       BITMAP_FREE (use->related_cands);
@@ -7025,6 +7353,7 @@ tree_ssa_iv_optimize_loop (struct ivopts_data *data, struct loop *loop)
 
   /* Finds interesting uses (item 1).  */
   find_interesting_uses (data);
+  group_address_uses (data);
   if (n_iv_uses (data) > MAX_CONSIDERED_USES)
     goto finish;
 
--- a/src/gcc/tree-ssa-loop-niter.c
+++ b/src/gcc/tree-ssa-loop-niter.c
@@ -31,6 +31,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "wide-int.h"
 #include "inchash.h"
 #include "tree.h"
+#include "stor-layout.h"
 #include "fold-const.h"
 #include "calls.h"
 #include "hashtab.h"
@@ -148,6 +149,237 @@ split_to_var_and_offset (tree expr, tree *var, mpz_t offset)
     }
 }
 
+/* From condition C0 CMP C1 derives information regarding the value range
+   of VAR, which is of TYPE.  Results are stored in to BELOW and UP.  */
+
+static void
+refine_value_range_using_guard (tree type, tree var,
+				tree c0, enum tree_code cmp, tree c1,
+				mpz_t below, mpz_t up)
+{
+  tree varc0, varc1, ctype;
+  mpz_t offc0, offc1;
+  mpz_t mint, maxt, minc1, maxc1;
+  wide_int minv, maxv;
+  bool no_wrap = nowrap_type_p (type);
+  bool c0_ok, c1_ok;
+  signop sgn = TYPE_SIGN (type);
+
+  switch (cmp)
+    {
+    case LT_EXPR:
+    case LE_EXPR:
+    case GT_EXPR:
+    case GE_EXPR:
+      STRIP_SIGN_NOPS (c0);
+      STRIP_SIGN_NOPS (c1);
+      ctype = TREE_TYPE (c0);
+      if (!useless_type_conversion_p (ctype, type))
+	return;
+
+      break;
+
+    case EQ_EXPR:
+      /* We could derive quite precise information from EQ_EXPR, however,
+	 such a guard is unlikely to appear, so we do not bother with
+	 handling it.  */
+      return;
+
+    case NE_EXPR:
+      /* NE_EXPR comparisons do not contain much of useful information,
+	 except for cases of comparing with bounds.  */
+      if (TREE_CODE (c1) != INTEGER_CST
+	  || !INTEGRAL_TYPE_P (type))
+	return;
+
+      /* Ensure that the condition speaks about an expression in the same
+	 type as X and Y.  */
+      ctype = TREE_TYPE (c0);
+      if (TYPE_PRECISION (ctype) != TYPE_PRECISION (type))
+	return;
+      c0 = fold_convert (type, c0);
+      c1 = fold_convert (type, c1);
+
+      if (operand_equal_p (var, c0, 0))
+	{
+	  mpz_t valc1;
+
+	  /* Case of comparing VAR with its below/up bounds.  */
+	  mpz_init (valc1);
+	  wi::to_mpz (c1, valc1, TYPE_SIGN (type));
+	  if (mpz_cmp (valc1, below) == 0)
+	    cmp = GT_EXPR;
+	  if (mpz_cmp (valc1, up) == 0)
+	    cmp = LT_EXPR;
+
+	  mpz_clear (valc1);
+	}
+      else
+	{
+	  /* Case of comparing with the bounds of the type.  */
+	  wide_int min = wi::min_value (type);
+	  wide_int max = wi::max_value (type);
+
+	  if (wi::eq_p (c1, min))
+	    cmp = GT_EXPR;
+	  if (wi::eq_p (c1, max))
+	    cmp = LT_EXPR;
+	}
+
+      /* Quick return if no useful information.  */
+      if (cmp == NE_EXPR)
+	return;
+
+      break;
+
+    default:
+      return;
+    }
+
+  mpz_init (offc0);
+  mpz_init (offc1);
+  split_to_var_and_offset (expand_simple_operations (c0), &varc0, offc0);
+  split_to_var_and_offset (expand_simple_operations (c1), &varc1, offc1);
+
+  /* We are only interested in comparisons of expressions based on VAR.  */
+  if (operand_equal_p (var, varc1, 0))
+    {
+      std::swap (varc0, varc1);
+      mpz_swap (offc0, offc1);
+      cmp = swap_tree_comparison (cmp);
+    }
+  else if (!operand_equal_p (var, varc0, 0))
+    {
+      mpz_clear (offc0);
+      mpz_clear (offc1);
+      return;
+    }
+
+  mpz_init (mint);
+  mpz_init (maxt);
+  get_type_static_bounds (type, mint, maxt);
+  mpz_init (minc1);
+  mpz_init (maxc1);
+  /* Setup range information for varc1.  */
+  if (integer_zerop (varc1))
+    {
+      wi::to_mpz (integer_zero_node, minc1, TYPE_SIGN (type));
+      wi::to_mpz (integer_zero_node, maxc1, TYPE_SIGN (type));
+    }
+  else if (TREE_CODE (varc1) == SSA_NAME
+	   && INTEGRAL_TYPE_P (type)
+	   && get_range_info (varc1, &minv, &maxv) == VR_RANGE)
+    {
+      gcc_assert (wi::le_p (minv, maxv, sgn));
+      wi::to_mpz (minv, minc1, sgn);
+      wi::to_mpz (maxv, maxc1, sgn);
+    }
+  else
+    {
+      mpz_set (minc1, mint);
+      mpz_set (maxc1, maxt);
+    }
+
+  /* Compute valid range information for varc1 + offc1.  Note nothing
+     useful can be derived if it overflows or underflows.  Overflow or
+     underflow could happen when:
+
+       offc1 > 0 && varc1 + offc1 > MAX_VAL (type)
+       offc1 < 0 && varc1 + offc1 < MIN_VAL (type).  */
+  mpz_add (minc1, minc1, offc1);
+  mpz_add (maxc1, maxc1, offc1);
+  c1_ok = (no_wrap
+	   || mpz_sgn (offc1) == 0
+	   || (mpz_sgn (offc1) < 0 && mpz_cmp (minc1, mint) >= 0)
+	   || (mpz_sgn (offc1) > 0 && mpz_cmp (maxc1, maxt) <= 0));
+  if (!c1_ok)
+    goto end;
+
+  if (mpz_cmp (minc1, mint) < 0)
+    mpz_set (minc1, mint);
+  if (mpz_cmp (maxc1, maxt) > 0)
+    mpz_set (maxc1, maxt);
+
+  if (cmp == LT_EXPR)
+    {
+      cmp = LE_EXPR;
+      mpz_sub_ui (maxc1, maxc1, 1);
+    }
+  if (cmp == GT_EXPR)
+    {
+      cmp = GE_EXPR;
+      mpz_add_ui (minc1, minc1, 1);
+    }
+
+  /* Compute range information for varc0.  If there is no overflow,
+     the condition implied that
+
+       (varc0) cmp (varc1 + offc1 - offc0)
+
+     We can possibly improve the upper bound of varc0 if cmp is LE_EXPR,
+     or the below bound if cmp is GE_EXPR.
+
+     To prove there is no overflow/underflow, we need to check below
+     four cases:
+       1) cmp == LE_EXPR && offc0 > 0
+
+	    (varc0 + offc0) doesn't overflow
+	    && (varc1 + offc1 - offc0) doesn't underflow
+
+       2) cmp == LE_EXPR && offc0 < 0
+
+	    (varc0 + offc0) doesn't underflow
+	    && (varc1 + offc1 - offc0) doesn't overfloe
+
+	  In this case, (varc0 + offc0) will never underflow if we can
+	  prove (varc1 + offc1 - offc0) doesn't overflow.
+
+       3) cmp == GE_EXPR && offc0 < 0
+
+	    (varc0 + offc0) doesn't underflow
+	    && (varc1 + offc1 - offc0) doesn't overflow
+
+       4) cmp == GE_EXPR && offc0 > 0
+
+	    (varc0 + offc0) doesn't overflow
+	    && (varc1 + offc1 - offc0) doesn't underflow
+
+	  In this case, (varc0 + offc0) will never overflow if we can
+	  prove (varc1 + offc1 - offc0) doesn't underflow.
+
+     Note we only handle case 2 and 4 in below code.  */
+
+  mpz_sub (minc1, minc1, offc0);
+  mpz_sub (maxc1, maxc1, offc0);
+  c0_ok = (no_wrap
+	   || mpz_sgn (offc0) == 0
+	   || (cmp == LE_EXPR
+	       && mpz_sgn (offc0) < 0 && mpz_cmp (maxc1, maxt) <= 0)
+	   || (cmp == GE_EXPR
+	       && mpz_sgn (offc0) > 0 && mpz_cmp (minc1, mint) >= 0));
+  if (!c0_ok)
+    goto end;
+
+  if (cmp == LE_EXPR)
+    {
+      if (mpz_cmp (up, maxc1) > 0)
+	mpz_set (up, maxc1);
+    }
+  else
+    {
+      if (mpz_cmp (below, minc1) < 0)
+	mpz_set (below, minc1);
+    }
+
+end:
+  mpz_clear (mint);
+  mpz_clear (maxt);
+  mpz_clear (minc1);
+  mpz_clear (maxc1);
+  mpz_clear (offc0);
+  mpz_clear (offc1);
+}
+
 /* Stores estimate on the minimum/maximum value of the expression VAR + OFF
    in TYPE to MIN and MAX.  */
 
@@ -155,6 +387,9 @@ static void
 determine_value_range (struct loop *loop, tree type, tree var, mpz_t off,
 		       mpz_t min, mpz_t max)
 {
+  int cnt = 0;
+  mpz_t minm, maxm;
+  basic_block bb;
   wide_int minv, maxv;
   enum value_range_type rtype = VR_VARYING;
 
@@ -209,35 +444,69 @@ determine_value_range (struct loop *loop, tree type, tree var, mpz_t off,
 		}
 	    }
 	}
-      if (rtype == VR_RANGE)
+      mpz_init (minm);
+      mpz_init (maxm);
+      if (rtype != VR_RANGE)
+	{
+	  mpz_set (minm, min);
+	  mpz_set (maxm, max);
+	}
+      else
 	{
-	  mpz_t minm, maxm;
 	  gcc_assert (wi::le_p (minv, maxv, sgn));
-	  mpz_init (minm);
-	  mpz_init (maxm);
 	  wi::to_mpz (minv, minm, sgn);
 	  wi::to_mpz (maxv, maxm, sgn);
-	  mpz_add (minm, minm, off);
-	  mpz_add (maxm, maxm, off);
-	  /* If the computation may not wrap or off is zero, then this
-	     is always fine.  If off is negative and minv + off isn't
-	     smaller than type's minimum, or off is positive and
-	     maxv + off isn't bigger than type's maximum, use the more
-	     precise range too.  */
-	  if (nowrap_type_p (type)
-	      || mpz_sgn (off) == 0
-	      || (mpz_sgn (off) < 0 && mpz_cmp (minm, min) >= 0)
-	      || (mpz_sgn (off) > 0 && mpz_cmp (maxm, max) <= 0))
-	    {
-	      mpz_set (min, minm);
-	      mpz_set (max, maxm);
-	      mpz_clear (minm);
-	      mpz_clear (maxm);
-	      return;
-	    }
+	}
+      /* Now walk the dominators of the loop header and use the entry
+	 guards to refine the estimates.  */
+      for (bb = loop->header;
+	   bb != ENTRY_BLOCK_PTR_FOR_FN (cfun) && cnt < MAX_DOMINATORS_TO_WALK;
+	   bb = get_immediate_dominator (CDI_DOMINATORS, bb))
+	{
+	  edge e;
+	  tree c0, c1;
+	  gimple cond;
+	  enum tree_code cmp;
+
+	  if (!single_pred_p (bb))
+	    continue;
+	  e = single_pred_edge (bb);
+
+	  if (!(e->flags & (EDGE_TRUE_VALUE | EDGE_FALSE_VALUE)))
+	    continue;
+
+	  cond = last_stmt (e->src);
+	  c0 = gimple_cond_lhs (cond);
+	  cmp = gimple_cond_code (cond);
+	  c1 = gimple_cond_rhs (cond);
+
+	  if (e->flags & EDGE_FALSE_VALUE)
+	    cmp = invert_tree_comparison (cmp, false);
+
+	  refine_value_range_using_guard (type, var, c0, cmp, c1, minm, maxm);
+	  ++cnt;
+	}
+
+      mpz_add (minm, minm, off);
+      mpz_add (maxm, maxm, off);
+      /* If the computation may not wrap or off is zero, then this
+	 is always fine.  If off is negative and minv + off isn't
+	 smaller than type's minimum, or off is positive and
+	 maxv + off isn't bigger than type's maximum, use the more
+	 precise range too.  */
+      if (nowrap_type_p (type)
+	  || mpz_sgn (off) == 0
+	  || (mpz_sgn (off) < 0 && mpz_cmp (minm, min) >= 0)
+	  || (mpz_sgn (off) > 0 && mpz_cmp (maxm, max) <= 0))
+	{
+	  mpz_set (min, minm);
+	  mpz_set (max, maxm);
 	  mpz_clear (minm);
 	  mpz_clear (maxm);
+	  return;
 	}
+      mpz_clear (minm);
+      mpz_clear (maxm);
     }
 
   /* If the computation may wrap, we know nothing about the value, except for
@@ -1184,6 +1453,7 @@ number_of_iterations_lt (tree type, affine_iv *iv0, affine_iv *iv1,
       niter->niter = delta;
       niter->max = widest_int::from (wi::from_mpz (niter_type, bnds->up, false),
 				     TYPE_SIGN (niter_type));
+      niter->control.no_overflow = true;
       return true;
     }
 
@@ -1840,6 +2110,10 @@ simplify_using_initial_conditions (struct loop *loop, tree expr)
       if (e->flags & EDGE_FALSE_VALUE)
 	cond = invert_truthvalue (cond);
       expr = tree_simplify_using_condition (cond, expr);
+      /* Break if EXPR is simplified to const values.  */
+      if (expr && (integer_zerop (expr) || integer_nonzerop (expr)))
+	break;
+
       ++cnt;
     }
 
@@ -1965,6 +2239,9 @@ number_of_iterations_exit (struct loop *loop, edge exit,
     return false;
 
   niter->assumptions = boolean_false_node;
+  niter->control.base = NULL_TREE;
+  niter->control.step = NULL_TREE;
+  niter->control.no_overflow = false;
   last = last_stmt (exit->src);
   if (!last)
     return false;
@@ -2744,6 +3021,29 @@ record_estimate (struct loop *loop, tree bound, const widest_int &i_bound,
   record_niter_bound (loop, new_i_bound, realistic, upper);
 }
 
+/* Records the control iv analyzed in NITER for LOOP if the iv is valid
+   and doesn't overflow.  */
+
+static void
+record_control_iv (struct loop *loop, struct tree_niter_desc *niter)
+{
+  struct control_iv *iv;
+
+  if (!niter->control.base || !niter->control.step)
+    return;
+
+  if (!integer_onep (niter->assumptions) || !niter->control.no_overflow)
+    return;
+
+  iv = ggc_alloc<control_iv> ();
+  iv->base = niter->control.base;
+  iv->step = niter->control.step;
+  iv->next = loop->control_ivs;
+  loop->control_ivs = iv;
+
+  return;
+}
+
 /* Record the estimate on number of iterations of LOOP based on the fact that
    the induction variable BASE + STEP * i evaluated in STMT does not wrap and
    its values belong to the range <LOW, HIGH>.  REALISTIC is true if the
@@ -3467,6 +3767,7 @@ estimate_numbers_of_iterations_loop (struct loop *loop)
       record_estimate (loop, niter, niter_desc.max,
 		       last_stmt (ex->src),
 		       true, ex == likely_exit, true);
+      record_control_iv (loop, &niter_desc);
     }
   exits.release ();
 
@@ -3773,6 +4074,194 @@ nowrap_type_p (tree type)
   return false;
 }
 
+/* Return true if we can prove LOOP is exited before evolution of induction
+   variabled {BASE, STEP} overflows with respect to its type bound.  */
+
+static bool
+loop_exits_before_overflow (tree base, tree step,
+			    gimple at_stmt, struct loop *loop)
+{
+  widest_int niter;
+  struct control_iv *civ;
+  struct nb_iter_bound *bound;
+  tree e, delta, step_abs, unsigned_base;
+  tree type = TREE_TYPE (step);
+  tree unsigned_type, valid_niter;
+
+  /* Don't issue signed overflow warnings.  */
+  fold_defer_overflow_warnings ();
+
+  /* Compute the number of iterations before we reach the bound of the
+     type, and verify that the loop is exited before this occurs.  */
+  unsigned_type = unsigned_type_for (type);
+  unsigned_base = fold_convert (unsigned_type, base);
+
+  if (tree_int_cst_sign_bit (step))
+    {
+      tree extreme = fold_convert (unsigned_type,
+				   lower_bound_in_type (type, type));
+      delta = fold_build2 (MINUS_EXPR, unsigned_type, unsigned_base, extreme);
+      step_abs = fold_build1 (NEGATE_EXPR, unsigned_type,
+			      fold_convert (unsigned_type, step));
+    }
+  else
+    {
+      tree extreme = fold_convert (unsigned_type,
+				   upper_bound_in_type (type, type));
+      delta = fold_build2 (MINUS_EXPR, unsigned_type, extreme, unsigned_base);
+      step_abs = fold_convert (unsigned_type, step);
+    }
+
+  valid_niter = fold_build2 (FLOOR_DIV_EXPR, unsigned_type, delta, step_abs);
+
+  estimate_numbers_of_iterations_loop (loop);
+
+  if (max_loop_iterations (loop, &niter)
+      && wi::fits_to_tree_p (niter, TREE_TYPE (valid_niter))
+      && (e = fold_binary (GT_EXPR, boolean_type_node, valid_niter,
+			   wide_int_to_tree (TREE_TYPE (valid_niter),
+					     niter))) != NULL
+      && integer_nonzerop (e))
+    {
+      fold_undefer_and_ignore_overflow_warnings ();
+      return true;
+    }
+  if (at_stmt)
+    for (bound = loop->bounds; bound; bound = bound->next)
+      {
+	if (n_of_executions_at_most (at_stmt, bound, valid_niter))
+	  {
+	    fold_undefer_and_ignore_overflow_warnings ();
+	    return true;
+	  }
+      }
+  fold_undefer_and_ignore_overflow_warnings ();
+
+  /* Try to prove loop is exited before {base, step} overflows with the
+     help of analyzed loop control IV.  This is done only for IVs with
+     constant step because otherwise we don't have the information.  */
+  if (TREE_CODE (step) == INTEGER_CST)
+    for (civ = loop->control_ivs; civ; civ = civ->next)
+      {
+	enum tree_code code;
+	tree stepped, extreme, civ_type = TREE_TYPE (civ->step);
+
+	/* Have to consider type difference because operand_equal_p ignores
+	   that for constants.  */
+	if (TYPE_UNSIGNED (type) != TYPE_UNSIGNED (civ_type)
+	    || element_precision (type) != element_precision (civ_type))
+	  continue;
+
+	/* Only consider control IV with same step.  */
+	if (!operand_equal_p (step, civ->step, 0))
+	  continue;
+
+	/* Done proving if this is a no-overflow control IV.  */
+	if (operand_equal_p (base, civ->base, 0))
+	  return true;
+
+	/* If this is a before stepping control IV, in other words, we have
+
+	     {civ_base, step} = {base + step, step}
+
+	   Because civ {base + step, step} doesn't overflow during loop
+	   iterations, {base, step} will not overflow if we can prove the
+	   operation "base + step" does not overflow.  Specifically, we try
+	   to prove below conditions are satisfied:
+
+	     base <= UPPER_BOUND (type) - step  ;;step > 0
+	     base >= LOWER_BOUND (type) - step  ;;step < 0
+
+	   by proving the reverse conditions are false using loop's initial
+	   condition.  */
+	if (POINTER_TYPE_P (TREE_TYPE (base)))
+	  code = POINTER_PLUS_EXPR;
+	else
+	  code = PLUS_EXPR;
+
+	stepped = fold_build2 (code, TREE_TYPE (base), base, step);
+	if (operand_equal_p (stepped, civ->base, 0))
+	  {
+	    if (tree_int_cst_sign_bit (step))
+	      {
+		code = LT_EXPR;
+		extreme = lower_bound_in_type (type, type);
+	      }
+	    else
+	      {
+		code = GT_EXPR;
+		extreme = upper_bound_in_type (type, type);
+	      }
+	    extreme = fold_build2 (MINUS_EXPR, type, extreme, step);
+	    e = fold_build2 (code, boolean_type_node, base, extreme);
+	    e = simplify_using_initial_conditions (loop, e);
+	    if (integer_zerop (e))
+	      return true;
+
+	    continue;
+	  }
+
+	/* Similar to above, only in this case we have:
+
+	     {civ_base, step} = {(signed T)((unsigned T)base + step), step}
+	     && TREE_TYPE (civ_base) = signed T.
+
+	   We prove that below condition is satisfied:
+
+	     (signed T)((unsigned T)base + step)
+	       == (signed T)(unsigned T)base + step
+	       == base + step
+
+	   because of exact the same reason as above.  This also proves
+	   there is no overflow in the operation "base + step", thus the
+	   induction variable {base, step} during loop iterations.
+
+	   This is necessary to handle cases as below:
+
+	     int foo (int *a, signed char s, signed char l)
+	       {
+		 signed char i;
+		 for (i = s; i < l; i++)
+		   a[i] = 0;
+		 return 0;
+	       }
+
+	   The variable I is firstly converted to type unsigned char,
+	   incremented, then converted back to type signed char.  */
+	if (!CONVERT_EXPR_P (civ->base) || TREE_TYPE (civ->base) != type)
+	  continue;
+	e = TREE_OPERAND (civ->base, 0);
+	if (TREE_CODE (e) != PLUS_EXPR
+	    || TREE_CODE (TREE_OPERAND (e, 1)) != INTEGER_CST
+	    || !operand_equal_p (step,
+				 fold_convert (type,
+					       TREE_OPERAND (e, 1)), 0))
+	  continue;
+	e = TREE_OPERAND (e, 0);
+	if (!CONVERT_EXPR_P (e) || !operand_equal_p (e, unsigned_base, 0))
+	  continue;
+	e = TREE_OPERAND (e, 0);
+	gcc_assert (operand_equal_p (e, base, 0));
+	if (tree_int_cst_sign_bit (step))
+	  {
+	    code = LT_EXPR;
+	    extreme = lower_bound_in_type (type, type);
+	  }
+	else
+	  {
+	    code = GT_EXPR;
+	    extreme = upper_bound_in_type (type, type);
+	  }
+	extreme = fold_build2 (MINUS_EXPR, type, extreme, step);
+	e = fold_build2 (code, boolean_type_node, base, extreme);
+	e = simplify_using_initial_conditions (loop, e);
+	if (integer_zerop (e))
+	  return true;
+      }
+
+  return false;
+}
+
 /* Return false only when the induction variable BASE + STEP * I is
    known to not overflow: i.e. when the number of iterations is small
    enough with respect to the step and initial condition in order to
@@ -3788,13 +4277,6 @@ scev_probably_wraps_p (tree base, tree step,
 		       gimple at_stmt, struct loop *loop,
 		       bool use_overflow_semantics)
 {
-  tree delta, step_abs;
-  tree unsigned_type, valid_niter;
-  tree type = TREE_TYPE (step);
-  tree e;
-  widest_int niter;
-  struct nb_iter_bound *bound;
-
   /* FIXME: We really need something like
      http://gcc.gnu.org/ml/gcc-patches/2005-06/msg02025.html.
 
@@ -3828,56 +4310,8 @@ scev_probably_wraps_p (tree base, tree step,
   if (TREE_CODE (step) != INTEGER_CST)
     return true;
 
-  /* Don't issue signed overflow warnings.  */
-  fold_defer_overflow_warnings ();
-
-  /* Otherwise, compute the number of iterations before we reach the
-     bound of the type, and verify that the loop is exited before this
-     occurs.  */
-  unsigned_type = unsigned_type_for (type);
-  base = fold_convert (unsigned_type, base);
-
-  if (tree_int_cst_sign_bit (step))
-    {
-      tree extreme = fold_convert (unsigned_type,
-				   lower_bound_in_type (type, type));
-      delta = fold_build2 (MINUS_EXPR, unsigned_type, base, extreme);
-      step_abs = fold_build1 (NEGATE_EXPR, unsigned_type,
-			      fold_convert (unsigned_type, step));
-    }
-  else
-    {
-      tree extreme = fold_convert (unsigned_type,
-				   upper_bound_in_type (type, type));
-      delta = fold_build2 (MINUS_EXPR, unsigned_type, extreme, base);
-      step_abs = fold_convert (unsigned_type, step);
-    }
-
-  valid_niter = fold_build2 (FLOOR_DIV_EXPR, unsigned_type, delta, step_abs);
-
-  estimate_numbers_of_iterations_loop (loop);
-
-  if (max_loop_iterations (loop, &niter)
-      && wi::fits_to_tree_p (niter, TREE_TYPE (valid_niter))
-      && (e = fold_binary (GT_EXPR, boolean_type_node, valid_niter,
-			   wide_int_to_tree (TREE_TYPE (valid_niter),
-					     niter))) != NULL
-      && integer_nonzerop (e))
-    {
-      fold_undefer_and_ignore_overflow_warnings ();
-      return false;
-    }
-  if (at_stmt)
-    for (bound = loop->bounds; bound; bound = bound->next)
-      {
-	if (n_of_executions_at_most (at_stmt, bound, valid_niter))
-	  {
-	    fold_undefer_and_ignore_overflow_warnings ();
-	    return false;
-	  }
-      }
-
-  fold_undefer_and_ignore_overflow_warnings ();
+  if (loop_exits_before_overflow (base, step, at_stmt, loop))
+    return false;
 
   /* At this point we still don't have a proof that the iv does not
      overflow: give up.  */
@@ -3889,17 +4323,26 @@ scev_probably_wraps_p (tree base, tree step,
 void
 free_numbers_of_iterations_estimates_loop (struct loop *loop)
 {
-  struct nb_iter_bound *bound, *next;
+  struct control_iv *civ;
+  struct nb_iter_bound *bound;
 
   loop->nb_iterations = NULL;
   loop->estimate_state = EST_NOT_COMPUTED;
-  for (bound = loop->bounds; bound; bound = next)
+  for (bound = loop->bounds; bound;)
     {
-      next = bound->next;
+      struct nb_iter_bound *next = bound->next;
       ggc_free (bound);
+      bound = next;
     }
-
   loop->bounds = NULL;
+
+  for (civ = loop->control_ivs; civ;)
+    {
+      struct control_iv *next = civ->next;
+      ggc_free (civ);
+      civ = next;
+    }
+  loop->control_ivs = NULL;
 }
 
 /* Frees the information on upper bounds on numbers of iterations of loops.  */
--- a/src/gcc/tree-ssa-loop-niter.h
+++ b/src/gcc/tree-ssa-loop-niter.h
@@ -41,6 +41,7 @@ extern void estimate_numbers_of_iterations (void);
 extern bool stmt_dominates_stmt_p (gimple, gimple);
 extern bool nowrap_type_p (tree);
 extern bool scev_probably_wraps_p (tree, tree, gimple, struct loop *, bool);
+extern void free_loop_control_ivs (struct loop *);
 extern void free_numbers_of_iterations_estimates_loop (struct loop *);
 extern void free_numbers_of_iterations_estimates (void);
 extern void substitute_in_loop_info (struct loop *, tree, tree);
--- a/src/gcc/tree-ssa-math-opts.c
+++ b/src/gcc/tree-ssa-math-opts.c
@@ -143,6 +143,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "target.h"
 #include "gimple-pretty-print.h"
 #include "builtins.h"
+#include "params.h"
 
 /* FIXME: RTL headers have to be included here for optabs.  */
 #include "rtl.h"		/* Because optabs.h wants enum rtx_code.  */
@@ -1148,6 +1149,357 @@ build_and_insert_cast (gimple_stmt_iterator *gsi, location_t loc,
   return result;
 }
 
+struct pow_synth_sqrt_info
+{
+  bool *factors;
+  unsigned int deepest;
+  unsigned int num_mults;
+};
+
+/* Return true iff the real value C can be represented as a
+   sum of powers of 0.5 up to N.  That is:
+   C == SUM<i from 1..N> (a[i]*(0.5**i)) where a[i] is either 0 or 1.
+   Record in INFO the various parameters of the synthesis algorithm such
+   as the factors a[i], the maximum 0.5 power and the number of
+   multiplications that will be required.  */
+
+bool
+representable_as_half_series_p (REAL_VALUE_TYPE c, unsigned n,
+				 struct pow_synth_sqrt_info *info)
+{
+  REAL_VALUE_TYPE factor = dconsthalf;
+  REAL_VALUE_TYPE remainder = c;
+
+  info->deepest = 0;
+  info->num_mults = 0;
+  memset (info->factors, 0, n * sizeof (bool));
+
+  for (unsigned i = 0; i < n; i++)
+    {
+      REAL_VALUE_TYPE res;
+
+      /* If something inexact happened bail out now.  */
+      if (REAL_ARITHMETIC (res, MINUS_EXPR, remainder, factor))
+	return false;
+
+      /* We have hit zero.  The number is representable as a sum
+         of powers of 0.5.  */
+      if (REAL_VALUES_EQUAL (res, dconst0))
+	{
+	  info->factors[i] = true;
+	  info->deepest = i + 1;
+	  return true;
+	}
+      else if (!REAL_VALUE_NEGATIVE (res))
+	{
+	  remainder = res;
+	  info->factors[i] = true;
+	  info->num_mults++;
+	}
+      else
+	info->factors[i] = false;
+
+      REAL_ARITHMETIC (factor, MULT_EXPR, factor, dconsthalf);
+    }
+  return false;
+}
+
+/* Return the tree corresponding to FN being applied
+   to ARG N times at GSI and LOC.
+   Look up previous results from CACHE if need be.
+   cache[0] should contain just plain ARG i.e. FN applied to ARG 0 times.  */
+
+static tree
+get_fn_chain (tree arg, unsigned int n, gimple_stmt_iterator *gsi,
+	      tree fn, location_t loc, tree *cache)
+{
+  tree res = cache[n];
+  if (!res)
+    {
+      tree prev = get_fn_chain (arg, n - 1, gsi, fn, loc, cache);
+      res = build_and_insert_call (gsi, loc, fn, prev);
+      cache[n] = res;
+    }
+
+  return res;
+}
+
+/* Print to STREAM the repeated application of function FNAME to ARG
+   N times.  So, for FNAME = "foo", ARG = "x", N = 2 it would print:
+   "foo (foo (x))".  */
+
+static void
+print_nested_fn (FILE* stream, const char *fname, const char* arg,
+		 unsigned int n)
+{
+  if (n == 0)
+    fprintf (stream, "%s", arg);
+  else
+    {
+      fprintf (stream, "%s (", fname);
+      print_nested_fn (stream, fname, arg, n - 1);
+      fprintf (stream, ")");
+    }
+}
+
+/* Print to STREAM the fractional sequence of sqrt chains
+   applied to ARG, described by INFO.  Used for the dump file.  */
+
+static void
+dump_fractional_sqrt_sequence (FILE *stream, const char *arg,
+			        struct pow_synth_sqrt_info *info)
+{
+  for (unsigned int i = 0; i < info->deepest; i++)
+    {
+      bool is_set = info->factors[i];
+      if (is_set)
+	{
+	  print_nested_fn (stream, "sqrt", arg, i + 1);
+	  if (i != info->deepest - 1)
+	    fprintf (stream, " * ");
+	}
+    }
+}
+
+/* Print to STREAM a representation of raising ARG to an integer
+   power N.  Used for the dump file.  */
+
+static void
+dump_integer_part (FILE *stream, const char* arg, HOST_WIDE_INT n)
+{
+  if (n > 1)
+    fprintf (stream, "powi (%s, " HOST_WIDE_INT_PRINT_DEC ")", arg, n);
+  else if (n == 1)
+    fprintf (stream, "%s", arg);
+}
+
+/* Attempt to synthesize a POW[F] (ARG0, ARG1) call using chains of
+   square roots.  Place at GSI and LOC.  Limit the maximum depth
+   of the sqrt chains to MAX_DEPTH.  Return the tree holding the
+   result of the expanded sequence or NULL_TREE if the expansion failed.
+
+   This routine assumes that ARG1 is a real number with a fractional part
+   (the integer exponent case will have been handled earlier in
+   gimple_expand_builtin_pow).
+
+   For ARG1 > 0.0:
+   * For ARG1 composed of a whole part WHOLE_PART and a fractional part
+     FRAC_PART i.e. WHOLE_PART == floor (ARG1) and
+                    FRAC_PART == ARG1 - WHOLE_PART:
+     Produce POWI (ARG0, WHOLE_PART) * POW (ARG0, FRAC_PART) where
+     POW (ARG0, FRAC_PART) is expanded as a product of square root chains
+     if it can be expressed as such, that is if FRAC_PART satisfies:
+     FRAC_PART == <SUM from i = 1 until MAX_DEPTH> (a[i] * (0.5**i))
+     where integer a[i] is either 0 or 1.
+
+     Example:
+     POW (x, 3.625) == POWI (x, 3) * POW (x, 0.625)
+       --> POWI (x, 3) * SQRT (x) * SQRT (SQRT (SQRT (x)))
+
+   For ARG1 < 0.0 there are two approaches:
+   * (A) Expand to 1.0 / POW (ARG0, -ARG1) where POW (ARG0, -ARG1)
+         is calculated as above.
+
+     Example:
+     POW (x, -5.625) == 1.0 / POW (x, 5.625)
+       -->  1.0 / (POWI (x, 5) * SQRT (x) * SQRT (SQRT (SQRT (x))))
+
+   * (B) : WHOLE_PART := - ceil (abs (ARG1))
+           FRAC_PART  := ARG1 - WHOLE_PART
+     and expand to POW (x, FRAC_PART) / POWI (x, WHOLE_PART).
+     Example:
+     POW (x, -5.875) == POW (x, 0.125) / POWI (X, 6)
+       --> SQRT (SQRT (SQRT (x))) / (POWI (x, 6))
+
+   For ARG1 < 0.0 we choose between (A) and (B) depending on
+   how many multiplications we'd have to do.
+   So, for the example in (B): POW (x, -5.875), if we were to
+   follow algorithm (A) we would produce:
+   1.0 / POWI (X, 5) * SQRT (X) * SQRT (SQRT (X)) * SQRT (SQRT (SQRT (X)))
+   which contains more multiplications than approach (B).
+
+   Hopefully, this approach will eliminate potentially expensive POW library
+   calls when unsafe floating point math is enabled and allow the compiler to
+   further optimise the multiplies, square roots and divides produced by this
+   function.  */
+
+static tree
+expand_pow_as_sqrts (gimple_stmt_iterator *gsi, location_t loc,
+		     tree arg0, tree arg1, HOST_WIDE_INT max_depth)
+{
+  tree type = TREE_TYPE (arg0);
+  machine_mode mode = TYPE_MODE (type);
+  tree sqrtfn = mathfn_built_in (type, BUILT_IN_SQRT);
+  bool one_over = true;
+
+  if (!sqrtfn)
+    return NULL_TREE;
+
+  if (TREE_CODE (arg1) != REAL_CST)
+    return NULL_TREE;
+
+  REAL_VALUE_TYPE exp_init = TREE_REAL_CST (arg1);
+
+  gcc_assert (max_depth > 0);
+  tree *cache = XALLOCAVEC (tree, max_depth + 1);
+
+  struct pow_synth_sqrt_info synth_info;
+  synth_info.factors = XALLOCAVEC (bool, max_depth + 1);
+  synth_info.deepest = 0;
+  synth_info.num_mults = 0;
+
+  bool neg_exp = REAL_VALUE_NEGATIVE (exp_init);
+  REAL_VALUE_TYPE exp = real_value_abs (&exp_init);
+
+  /* The whole and fractional parts of exp.  */
+  REAL_VALUE_TYPE whole_part;
+  REAL_VALUE_TYPE frac_part;
+
+  real_floor (&whole_part, mode, &exp);
+  REAL_ARITHMETIC (frac_part, MINUS_EXPR, exp, whole_part);
+
+
+  REAL_VALUE_TYPE ceil_whole = dconst0;
+  REAL_VALUE_TYPE ceil_fract = dconst0;
+
+  if (neg_exp)
+    {
+      real_ceil (&ceil_whole, mode, &exp);
+      REAL_ARITHMETIC (ceil_fract, MINUS_EXPR, ceil_whole, exp);
+    }
+
+  if (!representable_as_half_series_p (frac_part, max_depth, &synth_info))
+    return NULL_TREE;
+
+  /* Check whether it's more profitable to not use 1.0 / ...  */
+  if (neg_exp)
+    {
+      struct pow_synth_sqrt_info alt_synth_info;
+      alt_synth_info.factors = XALLOCAVEC (bool, max_depth + 1);
+      alt_synth_info.deepest = 0;
+      alt_synth_info.num_mults = 0;
+
+      if (representable_as_half_series_p (ceil_fract, max_depth,
+					   &alt_synth_info)
+	  && alt_synth_info.deepest <= synth_info.deepest
+	  && alt_synth_info.num_mults < synth_info.num_mults)
+	{
+	  whole_part = ceil_whole;
+	  frac_part = ceil_fract;
+	  synth_info.deepest = alt_synth_info.deepest;
+	  synth_info.num_mults = alt_synth_info.num_mults;
+	  memcpy (synth_info.factors, alt_synth_info.factors,
+		  (max_depth + 1) * sizeof (bool));
+	  one_over = false;
+	}
+    }
+
+  HOST_WIDE_INT n = real_to_integer (&whole_part);
+  REAL_VALUE_TYPE cint;
+  real_from_integer (&cint, VOIDmode, n, SIGNED);
+
+  if (!real_identical (&whole_part, &cint))
+    return NULL_TREE;
+
+  if (powi_cost (n) + synth_info.num_mults > POWI_MAX_MULTS)
+    return NULL_TREE;
+
+  memset (cache, 0, (max_depth + 1) * sizeof (tree));
+
+  tree integer_res = n == 0 ? build_real (type, dconst1) : arg0;
+
+  /* Calculate the integer part of the exponent.  */
+  if (n > 1)
+    {
+      integer_res = gimple_expand_builtin_powi (gsi, loc, arg0, n);
+      if (!integer_res)
+	return NULL_TREE;
+    }
+
+  if (dump_file)
+    {
+      char string[64];
+
+      real_to_decimal (string, &exp_init, sizeof (string), 0, 1);
+      fprintf (dump_file, "synthesizing pow (x, %s) as:\n", string);
+
+      if (neg_exp)
+	{
+	  if (one_over)
+	    {
+	      fprintf (dump_file, "1.0 / (");
+	      dump_integer_part (dump_file, "x", n);
+	      if (n > 0)
+	        fprintf (dump_file, " * ");
+	      dump_fractional_sqrt_sequence (dump_file, "x", &synth_info);
+	      fprintf (dump_file, ")");
+	    }
+	  else
+	    {
+	      dump_fractional_sqrt_sequence (dump_file, "x", &synth_info);
+	      fprintf (dump_file, " / (");
+	      dump_integer_part (dump_file, "x", n);
+	      fprintf (dump_file, ")");
+	    }
+	}
+      else
+	{
+	  dump_fractional_sqrt_sequence (dump_file, "x", &synth_info);
+	  if (n > 0)
+	    fprintf (dump_file, " * ");
+	  dump_integer_part (dump_file, "x", n);
+	}
+
+      fprintf (dump_file, "\ndeepest sqrt chain: %d\n", synth_info.deepest);
+    }
+
+
+  tree fract_res = NULL_TREE;
+  cache[0] = arg0;
+
+  /* Calculate the fractional part of the exponent.  */
+  for (unsigned i = 0; i < synth_info.deepest; i++)
+    {
+      if (synth_info.factors[i])
+	{
+	  tree sqrt_chain = get_fn_chain (arg0, i + 1, gsi, sqrtfn, loc, cache);
+
+	  if (!fract_res)
+	      fract_res = sqrt_chain;
+
+	  else
+	    fract_res = build_and_insert_binop (gsi, loc, "powroot", MULT_EXPR,
+					   fract_res, sqrt_chain);
+	}
+    }
+
+  tree res = NULL_TREE;
+
+  if (neg_exp)
+    {
+      if (one_over)
+	{
+	  if (n > 0)
+	    res = build_and_insert_binop (gsi, loc, "powroot", MULT_EXPR,
+					   fract_res, integer_res);
+	  else
+	    res = fract_res;
+
+	  res = build_and_insert_binop (gsi, loc, "powrootrecip", RDIV_EXPR,
+					  build_real (type, dconst1), res);
+	}
+      else
+	{
+	  res = build_and_insert_binop (gsi, loc, "powroot", RDIV_EXPR,
+					 fract_res, integer_res);
+	}
+    }
+  else
+    res = build_and_insert_binop (gsi, loc, "powroot", MULT_EXPR,
+				   fract_res, integer_res);
+  return res;
+}
+
 /* ARG0 and ARG1 are the two arguments to a pow builtin call in GSI
    with location info LOC.  If possible, create an equivalent and
    less expensive sequence of statements prior to GSI, and return an
@@ -1157,13 +1509,17 @@ static tree
 gimple_expand_builtin_pow (gimple_stmt_iterator *gsi, location_t loc, 
 			   tree arg0, tree arg1)
 {
-  REAL_VALUE_TYPE c, cint, dconst1_4, dconst3_4, dconst1_3, dconst1_6;
+  REAL_VALUE_TYPE c, cint, dconst1_3, dconst1_4, dconst1_6;
   REAL_VALUE_TYPE c2, dconst3;
   HOST_WIDE_INT n;
-  tree type, sqrtfn, cbrtfn, sqrt_arg0, sqrt_sqrt, result, cbrt_x, powi_cbrt_x;
+  tree type, sqrtfn, cbrtfn, sqrt_arg0, result, cbrt_x, powi_cbrt_x;
   machine_mode mode;
+  bool speed_p = optimize_bb_for_speed_p (gsi_bb (*gsi));
   bool hw_sqrt_exists, c_is_int, c2_is_int;
 
+  dconst1_4 = dconst1;
+  SET_REAL_EXP (&dconst1_4, REAL_EXP (&dconst1_4) - 2);
+
   /* If the exponent isn't a constant, there's nothing of interest
      to be done.  */
   if (TREE_CODE (arg1) != REAL_CST)
@@ -1179,7 +1535,7 @@ gimple_expand_builtin_pow (gimple_stmt_iterator *gsi, location_t loc,
   if (c_is_int
       && ((n >= -1 && n <= 2)
 	  || (flag_unsafe_math_optimizations
-	      && optimize_bb_for_speed_p (gsi_bb (*gsi))
+	      && speed_p
 	      && powi_cost (n) <= POWI_MAX_MULTS)))
     return gimple_expand_builtin_powi (gsi, loc, arg0, n);
 
@@ -1196,49 +1552,8 @@ gimple_expand_builtin_pow (gimple_stmt_iterator *gsi, location_t loc,
       && !HONOR_SIGNED_ZEROS (mode))
     return build_and_insert_call (gsi, loc, sqrtfn, arg0);
 
-  /* Optimize pow(x,0.25) = sqrt(sqrt(x)).  Assume on most machines that
-     a builtin sqrt instruction is smaller than a call to pow with 0.25,
-     so do this optimization even if -Os.  Don't do this optimization
-     if we don't have a hardware sqrt insn.  */
-  dconst1_4 = dconst1;
-  SET_REAL_EXP (&dconst1_4, REAL_EXP (&dconst1_4) - 2);
   hw_sqrt_exists = optab_handler (sqrt_optab, mode) != CODE_FOR_nothing;
 
-  if (flag_unsafe_math_optimizations
-      && sqrtfn
-      && REAL_VALUES_EQUAL (c, dconst1_4)
-      && hw_sqrt_exists)
-    {
-      /* sqrt(x)  */
-      sqrt_arg0 = build_and_insert_call (gsi, loc, sqrtfn, arg0);
-
-      /* sqrt(sqrt(x))  */
-      return build_and_insert_call (gsi, loc, sqrtfn, sqrt_arg0);
-    }
-      
-  /* Optimize pow(x,0.75) = sqrt(x) * sqrt(sqrt(x)) unless we are
-     optimizing for space.  Don't do this optimization if we don't have
-     a hardware sqrt insn.  */
-  real_from_integer (&dconst3_4, VOIDmode, 3, SIGNED);
-  SET_REAL_EXP (&dconst3_4, REAL_EXP (&dconst3_4) - 2);
-
-  if (flag_unsafe_math_optimizations
-      && sqrtfn
-      && optimize_function_for_speed_p (cfun)
-      && REAL_VALUES_EQUAL (c, dconst3_4)
-      && hw_sqrt_exists)
-    {
-      /* sqrt(x)  */
-      sqrt_arg0 = build_and_insert_call (gsi, loc, sqrtfn, arg0);
-
-      /* sqrt(sqrt(x))  */
-      sqrt_sqrt = build_and_insert_call (gsi, loc, sqrtfn, sqrt_arg0);
-
-      /* sqrt(x) * sqrt(sqrt(x))  */
-      return build_and_insert_binop (gsi, loc, "powroot", MULT_EXPR,
-				     sqrt_arg0, sqrt_sqrt);
-    }
-
   /* Optimize pow(x,1./3.) = cbrt(x).  This requires unsafe math
      optimizations since 1./3. is not exactly representable.  If x
      is negative and finite, the correct value of pow(x,1./3.) is
@@ -1263,7 +1578,7 @@ gimple_expand_builtin_pow (gimple_stmt_iterator *gsi, location_t loc,
       && sqrtfn
       && cbrtfn
       && (gimple_val_nonnegative_real_p (arg0) || !HONOR_NANS (mode))
-      && optimize_function_for_speed_p (cfun)
+      && speed_p
       && hw_sqrt_exists
       && REAL_VALUES_EQUAL (c, dconst1_6))
     {
@@ -1274,54 +1589,31 @@ gimple_expand_builtin_pow (gimple_stmt_iterator *gsi, location_t loc,
       return build_and_insert_call (gsi, loc, cbrtfn, sqrt_arg0);
     }
 
-  /* Optimize pow(x,c), where n = 2c for some nonzero integer n
-     and c not an integer, into
-
-       sqrt(x) * powi(x, n/2),                n > 0;
-       1.0 / (sqrt(x) * powi(x, abs(n/2))),   n < 0.
-
-     Do not calculate the powi factor when n/2 = 0.  */
-  real_arithmetic (&c2, MULT_EXPR, &c, &dconst2);
-  n = real_to_integer (&c2);
-  real_from_integer (&cint, VOIDmode, n, SIGNED);
-  c2_is_int = real_identical (&c2, &cint);
 
+  /* Attempt to expand the POW as a product of square root chains.
+     Expand the 0.25 case even when otpimising for size.  */
   if (flag_unsafe_math_optimizations
       && sqrtfn
-      && c2_is_int
-      && !c_is_int
-      && optimize_function_for_speed_p (cfun))
+      && hw_sqrt_exists
+      && (speed_p || REAL_VALUES_EQUAL (c, dconst1_4))
+      && !HONOR_SIGNED_ZEROS (mode))
     {
-      tree powi_x_ndiv2 = NULL_TREE;
-
-      /* Attempt to fold powi(arg0, abs(n/2)) into multiplies.  If not
-         possible or profitable, give up.  Skip the degenerate case when
-         n is 1 or -1, where the result is always 1.  */
-      if (absu_hwi (n) != 1)
-	{
-	  powi_x_ndiv2 = gimple_expand_builtin_powi (gsi, loc, arg0,
-						     abs_hwi (n / 2));
-	  if (!powi_x_ndiv2)
-	    return NULL_TREE;
-	}
+      unsigned int max_depth = speed_p
+				? PARAM_VALUE (PARAM_MAX_POW_SQRT_DEPTH)
+				: 2;
 
-      /* Calculate sqrt(x).  When n is not 1 or -1, multiply it by the
-	 result of the optimal multiply sequence just calculated.  */
-      sqrt_arg0 = build_and_insert_call (gsi, loc, sqrtfn, arg0);
+      tree expand_with_sqrts
+	= expand_pow_as_sqrts (gsi, loc, arg0, arg1, max_depth);
 
-      if (absu_hwi (n) == 1)
-	result = sqrt_arg0;
-      else
-	result = build_and_insert_binop (gsi, loc, "powroot", MULT_EXPR,
-					 sqrt_arg0, powi_x_ndiv2);
-
-      /* If n is negative, reciprocate the result.  */
-      if (n < 0)
-	result = build_and_insert_binop (gsi, loc, "powroot", RDIV_EXPR,
-					 build_real (type, dconst1), result);
-      return result;
+      if (expand_with_sqrts)
+	return expand_with_sqrts;
     }
 
+  real_arithmetic (&c2, MULT_EXPR, &c, &dconst2);
+  n = real_to_integer (&c2);
+  real_from_integer (&cint, VOIDmode, n, SIGNED);
+  c2_is_int = real_identical (&c2, &cint);
+
   /* Optimize pow(x,c), where 3c = n for some nonzero integer n, into
 
      powi(x, n/3) * powi(cbrt(x), n%3),                    n > 0;
--- a/src/gcc/tree-ssa-phiopt.c
+++ b/src/gcc/tree-ssa-phiopt.c
@@ -90,6 +90,7 @@ along with GCC; see the file COPYING3.  If not see
 static unsigned int tree_ssa_phiopt_worker (bool, bool);
 static bool conditional_replacement (basic_block, basic_block,
 				     edge, edge, gphi *, tree, tree);
+static bool factor_out_conditional_conversion (edge, edge, gphi *, tree, tree);
 static int value_replacement (basic_block, basic_block,
 			      edge, edge, gimple, tree, tree);
 static bool minmax_replacement (basic_block, basic_block,
@@ -356,6 +357,19 @@ tree_ssa_phiopt_worker (bool do_store_elim, bool do_hoist_loads)
 	     node.  */
 	  gcc_assert (arg0 != NULL && arg1 != NULL);
 
+	  if (factor_out_conditional_conversion (e1, e2, phi, arg0, arg1))
+	    {
+	      /* factor_out_conditional_conversion may create a new PHI in
+		 BB2 and eliminate an existing PHI in BB2.  Recompute values
+		 that may be affected by that change.  */
+	      phis = phi_nodes (bb2);
+	      phi = single_non_singleton_phi_for_edges (phis, e1, e2);
+	      gcc_assert (phi);
+	      arg0 = gimple_phi_arg_def (phi, e1->dest_idx);
+	      arg1 = gimple_phi_arg_def (phi, e2->dest_idx);
+	      gcc_assert (arg0 != NULL && arg1 != NULL);
+	    }
+
 	  /* Do the replacement of conditional if it can be done.  */
 	  if (conditional_replacement (bb, bb1, e1, e2, phi, arg0, arg1))
 	    cfgchanged = true;
@@ -431,6 +445,134 @@ replace_phi_edge_with_variable (basic_block cond_block,
 	      bb->index);
 }
 
+/* PR66726: Factor conversion out of COND_EXPR.  If the arguments of the PHI
+   stmt are CONVERT_STMT, factor out the conversion and perform the conversion
+   to the result of PHI stmt.  */
+
+static bool
+factor_out_conditional_conversion (edge e0, edge e1, gphi *phi,
+				   tree arg0, tree arg1)
+{
+  gimple arg0_def_stmt = NULL, arg1_def_stmt = NULL, new_stmt;
+  tree new_arg0 = NULL_TREE, new_arg1 = NULL_TREE;
+  tree temp, result;
+  gphi *newphi;
+  gimple_stmt_iterator gsi, gsi_for_def;
+  source_location locus = gimple_location (phi);
+  enum tree_code convert_code;
+
+  /* Handle only PHI statements with two arguments.  TODO: If all
+     other arguments to PHI are INTEGER_CST or if their defining
+     statement have the same unary operation, we can handle more
+     than two arguments too.  */
+  if (gimple_phi_num_args (phi) != 2)
+    return false;
+
+  /* First canonicalize to simplify tests.  */
+  if (TREE_CODE (arg0) != SSA_NAME)
+    {
+      std::swap (arg0, arg1);
+      std::swap (e0, e1);
+    }
+
+  if (TREE_CODE (arg0) != SSA_NAME
+      || (TREE_CODE (arg1) != SSA_NAME
+	  && TREE_CODE (arg1) != INTEGER_CST))
+    return false;
+
+  /* Check if arg0 is an SSA_NAME and the stmt which defines arg0 is
+     a conversion.  */
+  arg0_def_stmt = SSA_NAME_DEF_STMT (arg0);
+  if (!is_gimple_assign (arg0_def_stmt)
+      || !gimple_assign_cast_p (arg0_def_stmt))
+    return false;
+
+  /* Use the RHS as new_arg0.  */
+  convert_code = gimple_assign_rhs_code (arg0_def_stmt);
+  new_arg0 = gimple_assign_rhs1 (arg0_def_stmt);
+  if (convert_code == VIEW_CONVERT_EXPR)
+    new_arg0 = TREE_OPERAND (new_arg0, 0);
+
+  if (TREE_CODE (arg1) == SSA_NAME)
+    {
+      /* Check if arg1 is an SSA_NAME and the stmt which defines arg1
+	 is a conversion.  */
+      arg1_def_stmt = SSA_NAME_DEF_STMT (arg1);
+      if (!is_gimple_assign (arg1_def_stmt)
+	  || gimple_assign_rhs_code (arg1_def_stmt) != convert_code)
+	return false;
+
+      /* Use the RHS as new_arg1.  */
+      new_arg1 = gimple_assign_rhs1 (arg1_def_stmt);
+      if (convert_code == VIEW_CONVERT_EXPR)
+	new_arg1 = TREE_OPERAND (new_arg1, 0);
+    }
+  else
+    {
+      /* If arg1 is an INTEGER_CST, fold it to new type.  */
+      if (INTEGRAL_TYPE_P (TREE_TYPE (new_arg0))
+	  && int_fits_type_p (arg1, TREE_TYPE (new_arg0)))
+	{
+	  if (gimple_assign_cast_p (arg0_def_stmt))
+	    new_arg1 = fold_convert (TREE_TYPE (new_arg0), arg1);
+	  else
+	    return false;
+	}
+      else
+	return false;
+    }
+
+  /*  If arg0/arg1 have > 1 use, then this transformation actually increases
+      the number of expressions evaluated at runtime.  */
+  if (!has_single_use (arg0)
+      || (arg1_def_stmt && !has_single_use (arg1)))
+    return false;
+
+  /* If types of new_arg0 and new_arg1 are different bailout.  */
+  if (!types_compatible_p (TREE_TYPE (new_arg0), TREE_TYPE (new_arg1)))
+    return false;
+
+  /* Create a new PHI stmt.  */
+  result = PHI_RESULT (phi);
+  temp = make_ssa_name (TREE_TYPE (new_arg0), NULL);
+  newphi = create_phi_node (temp, gimple_bb (phi));
+
+  if (dump_file && (dump_flags & TDF_DETAILS))
+    {
+      fprintf (dump_file, "PHI ");
+      print_generic_expr (dump_file, gimple_phi_result (phi), 0);
+      fprintf (dump_file,
+	       " changed to factor conversion out from COND_EXPR.\n");
+      fprintf (dump_file, "New stmt with CAST that defines ");
+      print_generic_expr (dump_file, result, 0);
+      fprintf (dump_file, ".\n");
+    }
+
+  /* Remove the old cast(s) that has single use.  */
+  gsi_for_def = gsi_for_stmt (arg0_def_stmt);
+  gsi_remove (&gsi_for_def, true);
+  if (arg1_def_stmt)
+    {
+      gsi_for_def = gsi_for_stmt (arg1_def_stmt);
+      gsi_remove (&gsi_for_def, true);
+    }
+
+  add_phi_arg (newphi, new_arg0, e0, locus);
+  add_phi_arg (newphi, new_arg1, e1, locus);
+
+  /* Create the conversion stmt and insert it.  */
+  if (convert_code == VIEW_CONVERT_EXPR)
+    temp = fold_build1 (VIEW_CONVERT_EXPR, TREE_TYPE (result), temp);
+  new_stmt = gimple_build_assign (result,  convert_code, temp);
+  gsi = gsi_after_labels (gimple_bb (phi));
+  gsi_insert_before (&gsi, new_stmt, GSI_SAME_STMT);
+
+  /* Remove he original PHI stmt.  */
+  gsi = gsi_for_stmt (phi);
+  gsi_remove (&gsi, true);
+  return true;
+}
+
 /*  The function conditional_replacement does the main work of doing the
     conditional replacement.  Return true if the replacement is done.
     Otherwise return false.
@@ -2173,6 +2315,26 @@ gate_hoist_loads (void)
    This pass also performs a fifth transformation of a slightly different
    flavor.
 
+   Factor conversion in COND_EXPR
+   ------------------------------
+
+   This transformation factors the conversion out of COND_EXPR with
+   factor_out_conditional_conversion.
+
+   For example:
+   if (a <= CST) goto <bb 3>; else goto <bb 4>;
+   <bb 3>:
+   tmp = (int) a;
+   <bb 4>:
+   tmp = PHI <tmp, CST>
+
+   Into:
+   if (a <= CST) goto <bb 3>; else goto <bb 4>;
+   <bb 3>:
+   <bb 4>:
+   a = PHI <a, CST>
+   tmp = (int) a;
+
    Adjacent Load Hoisting
    ----------------------
 
--- a/src/gcc/tree-vrp.c
+++ b/src/gcc/tree-vrp.c
@@ -3145,14 +3145,33 @@ extract_range_from_binary_expr_1 (value_range_t *vr,
 		 and all numbers from min to 0 for negative min.  */
 	      cmp = compare_values (vr0.max, zero);
 	      if (cmp == -1)
-		max = zero;
+		{
+		  /* When vr0.max < 0, vr1.min != 0 and value
+		     ranges for dividend and divisor are available.  */
+		  if (vr1.type == VR_RANGE
+		      && !symbolic_range_p (&vr0)
+		      && !symbolic_range_p (&vr1)
+		      && !compare_values (vr1.min, zero))
+		    max = int_const_binop (code, vr0.max, vr1.min);
+		  else
+		    max = zero;
+		}
 	      else if (cmp == 0 || cmp == 1)
 		max = vr0.max;
 	      else
 		type = VR_VARYING;
 	      cmp = compare_values (vr0.min, zero);
 	      if (cmp == 1)
-		min = zero;
+		{
+		  /* For unsigned division when value ranges for dividend
+		     and divisor are available.  */
+		  if (vr1.type == VR_RANGE
+		      && !symbolic_range_p (&vr0)
+		      && !symbolic_range_p (&vr1))
+		    min = int_const_binop (code, vr0.min, vr1.max);
+		  else
+		    min = zero;
+		}
 	      else if (cmp == 0 || cmp == -1)
 		min = vr0.min;
 	      else
@@ -3180,26 +3199,60 @@ extract_range_from_binary_expr_1 (value_range_t *vr,
     }
   else if (code == TRUNC_MOD_EXPR)
     {
-      if (vr1.type != VR_RANGE
-	  || range_includes_zero_p (vr1.min, vr1.max) != 0
-	  || vrp_val_is_min (vr1.min))
+      if (range_is_null (&vr1))
 	{
-	  set_value_range_to_varying (vr);
+	  set_value_range_to_undefined (vr);
 	  return;
 	}
+      /* ABS (A % B) < ABS (B) and either
+	 0 <= A % B <= A or A <= A % B <= 0.  */
       type = VR_RANGE;
-      /* Compute MAX <|vr1.min|, |vr1.max|> - 1.  */
-      max = fold_unary_to_constant (ABS_EXPR, expr_type, vr1.min);
-      if (tree_int_cst_lt (max, vr1.max))
-	max = vr1.max;
-      max = int_const_binop (MINUS_EXPR, max, build_int_cst (TREE_TYPE (max), 1));
-      /* If the dividend is non-negative the modulus will be
-	 non-negative as well.  */
-      if (TYPE_UNSIGNED (expr_type)
-	  || value_range_nonnegative_p (&vr0))
-	min = build_int_cst (TREE_TYPE (max), 0);
+      signop sgn = TYPE_SIGN (expr_type);
+      unsigned int prec = TYPE_PRECISION (expr_type);
+      wide_int wmin, wmax, tmp;
+      wide_int zero = wi::zero (prec);
+      wide_int one = wi::one (prec);
+      if (vr1.type == VR_RANGE && !symbolic_range_p (&vr1))
+	{
+	  wmax = wi::sub (vr1.max, one);
+	  if (sgn == SIGNED)
+	    {
+	      tmp = wi::sub (wi::minus_one (prec), vr1.min);
+	      wmax = wi::smax (wmax, tmp);
+	    }
+	}
       else
-	min = fold_unary_to_constant (NEGATE_EXPR, expr_type, max);
+	{
+	  wmax = wi::max_value (prec, sgn);
+	  /* X % INT_MIN may be INT_MAX.  */
+	  if (sgn == UNSIGNED)
+	    wmax = wmax - one;
+	}
+
+      if (sgn == UNSIGNED)
+	wmin = zero;
+      else
+	{
+	  wmin = -wmax;
+	  if (vr0.type == VR_RANGE && TREE_CODE (vr0.min) == INTEGER_CST)
+	    {
+	      tmp = vr0.min;
+	      if (wi::gts_p (tmp, zero))
+		tmp = zero;
+	      wmin = wi::smax (wmin, tmp);
+	    }
+	}
+
+      if (vr0.type == VR_RANGE && TREE_CODE (vr0.max) == INTEGER_CST)
+	{
+	  tmp = vr0.max;
+	  if (sgn == SIGNED && wi::neg_p (tmp))
+	    tmp = zero;
+	  wmax = wi::min (wmax, tmp, sgn);
+	}
+
+      min = wide_int_to_tree (expr_type, wmin);
+      max = wide_int_to_tree (expr_type, wmax);
     }
   else if (code == BIT_AND_EXPR || code == BIT_IOR_EXPR || code == BIT_XOR_EXPR)
     {
--- a/src/libgcc/config.host
+++ b/src/libgcc/config.host
@@ -382,14 +382,15 @@ arm*-*-netbsdelf*)
 	tmake_file="$tmake_file arm/t-arm arm/t-netbsd t-slibgcc-gld-nover"
 	;;
 arm*-*-linux*)			# ARM GNU/Linux with ELF
-	tmake_file="${tmake_file} arm/t-arm t-fixedpoint-gnu-prefix"
+	tmake_file="${tmake_file} arm/t-arm t-fixedpoint-gnu-prefix t-crtfm"
 	tmake_file="${tmake_file} arm/t-elf arm/t-bpabi arm/t-linux-eabi t-slibgcc-libgcc"
 	tm_file="$tm_file arm/bpabi-lib.h"
 	unwind_header=config/arm/unwind-arm.h
 	tmake_file="$tmake_file t-softfp-sfdf t-softfp-excl arm/t-softfp t-softfp"
+	extra_parts="$extra_parts crtfastmath.o"
 	;;
 arm*-*-uclinux*)		# ARM ucLinux
-	tmake_file="${tmake_file} t-fixedpoint-gnu-prefix"
+	tmake_file="${tmake_file} t-fixedpoint-gnu-prefix t-crtfm"
 	tmake_file="$tmake_file arm/t-arm arm/t-elf t-softfp-sfdf t-softfp-excl arm/t-softfp t-softfp"
 	tmake_file="${tmake_file} arm/t-bpabi"
 	tm_file="$tm_file arm/bpabi-lib.h"
@@ -401,7 +402,7 @@ arm*-*-eabi* | arm*-*-symbianelf* | arm*-*-rtems*)
 	tm_file="$tm_file arm/bpabi-lib.h"
 	case ${host} in
 	arm*-*-eabi* | arm*-*-rtems*)
-	  tmake_file="${tmake_file} arm/t-bpabi"
+	  tmake_file="${tmake_file} arm/t-bpabi t-crtfm"
 	  extra_parts="crtbegin.o crtend.o crti.o crtn.o"
 	  ;;
 	arm*-*-symbianelf*)
--- /dev/null
+++ b/src/libgcc/config/arm/crtfastmath.c
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2014 Free Software Foundation, Inc.
+ *
+ * This file is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 3, or (at your option) any
+ * later version.
+ *
+ * This file is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Under Section 7 of GPL version 3, you are granted additional
+ * permissions described in the GCC Runtime Library Exception, version
+ * 3.1, as published by the Free Software Foundation.
+ *
+ * You should have received a copy of the GNU General Public License and
+ * a copy of the GCC Runtime Library Exception along with this program;
+ * see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+
+/* Enable flush-to-zero support for -ffast-math on VFP targets.  */
+#ifndef __SOFTFP__
+
+#define FPSCR_FZ		(1 << 24)
+
+static void __attribute__((constructor))
+__arm_set_fast_math (void)
+{
+  unsigned int fpscr_save;
+
+  /* Set the FZ (flush-to-zero) bit in FPSCR.  */
+  __asm__("vmrs %0, fpscr" : "=r" (fpscr_save));
+  fpscr_save |= FPSCR_FZ;
+  __asm__("vmsr fpscr, %0" : : "r" (fpscr_save));
+}
+
+#endif /* __SOFTFP__  */
--- a/src/libgcc/config/arm/fp16.c
+++ b/src/libgcc/config/arm/fp16.c
@@ -35,9 +35,12 @@ __gnu_f2h_internal(unsigned int a, int ieee)
     {
       if (!ieee)
 	return sign;
+      if (mantissa == 0)
+	return sign | 0x7c00;	/* Infinity.  */
+      /* Remaining cases are NaNs.  Convert SNaN to QNaN.  */
       return sign | 0x7e00 | (mantissa >> 13);
     }
-  
+
   if (aexp == 0 && mantissa == 0)
     return sign;
 
@@ -49,7 +52,7 @@ __gnu_f2h_internal(unsigned int a, int ieee)
     {
       mask = 0x00ffffff;
       if (aexp >= -25)
-        mask >>= 25 + aexp;
+	mask >>= 25 + aexp;
     }
   else
     mask = 0x00001fff;
--- a/src/libgcc/config/arm/ieee754-df.S
+++ b/src/libgcc/config/arm/ieee754-df.S
@@ -33,8 +33,12 @@
  * Only the default rounding mode is intended for best performances.
  * Exceptions aren't supported yet, but that can be added quite easily
  * if necessary without impacting performances.
+ *
+ * In the CFI related comments, 'previousOffset' refers to the previous offset
+ * from sp used to compute the CFA.
  */
 
+	.cfi_sections .debug_frame
 
 #ifndef __ARMEB__
 #define xl r0
@@ -53,11 +57,13 @@
 
 ARM_FUNC_START negdf2
 ARM_FUNC_ALIAS aeabi_dneg negdf2
+	CFI_START_FUNCTION
 
 	@ flip sign bit
 	eor	xh, xh, #0x80000000
 	RET
 
+	CFI_END_FUNCTION
 	FUNC_END aeabi_dneg
 	FUNC_END negdf2
 
@@ -66,6 +72,7 @@ ARM_FUNC_ALIAS aeabi_dneg negdf2
 #ifdef L_arm_addsubdf3
 
 ARM_FUNC_START aeabi_drsub
+	CFI_START_FUNCTION
 
 	eor	xh, xh, #0x80000000	@ flip sign bit of first arg
 	b	1f	
@@ -81,7 +88,11 @@ ARM_FUNC_ALIAS aeabi_dsub subdf3
 ARM_FUNC_START adddf3
 ARM_FUNC_ALIAS aeabi_dadd adddf3
 
-1:	do_push	{r4, r5, lr}
+1:  do_push {r4, r5, lr}        @ sp -= 12
+	.cfi_adjust_cfa_offset 12   @ CFA is now sp + previousOffset + 12
+	.cfi_rel_offset r4, 0       @ Registers are saved from sp to sp + 8
+	.cfi_rel_offset r5, 4
+	.cfi_rel_offset lr, 8
 
 	@ Look for zeroes, equal values, INF, or NAN.
 	shift1	lsl, r4, xh, #1
@@ -148,6 +159,11 @@ ARM_FUNC_ALIAS aeabi_dadd adddf3
 	@ Since this is not common case, rescale them off line.
 	teq	r4, r5
 	beq	LSYM(Lad_d)
+
+@ CFI note: we're lucky that the branches to Lad_* that appear after this function
+@ have a CFI state that's exactly the same as the one we're in at this
+@ point. Otherwise the CFI would change to a different state after the branch,
+@ which would be disastrous for backtracing.
 LSYM(Lad_x):
 
 	@ Compensate for the exponent overlapping the mantissa MSB added later
@@ -413,6 +429,7 @@ LSYM(Lad_i):
 	orrne	xh, xh, #0x00080000	@ quiet NAN
 	RETLDM	"r4, r5"
 
+	CFI_END_FUNCTION
 	FUNC_END aeabi_dsub
 	FUNC_END subdf3
 	FUNC_END aeabi_dadd
@@ -420,12 +437,19 @@ LSYM(Lad_i):
 
 ARM_FUNC_START floatunsidf
 ARM_FUNC_ALIAS aeabi_ui2d floatunsidf
+	CFI_START_FUNCTION
 
 	teq	r0, #0
 	do_it	eq, t
 	moveq	r1, #0
 	RETc(eq)
-	do_push	{r4, r5, lr}
+
+	do_push {r4, r5, lr}        @ sp -= 12
+	.cfi_adjust_cfa_offset 12   @ CFA is now sp + previousOffset + 12
+	.cfi_rel_offset r4, 0       @ Registers are saved from sp + 0 to sp + 8.
+	.cfi_rel_offset r5, 4
+	.cfi_rel_offset lr, 8
+
 	mov	r4, #0x400		@ initial exponent
 	add	r4, r4, #(52-1 - 1)
 	mov	r5, #0			@ sign bit is 0
@@ -435,17 +459,25 @@ ARM_FUNC_ALIAS aeabi_ui2d floatunsidf
 	mov	xh, #0
 	b	LSYM(Lad_l)
 
+	CFI_END_FUNCTION
 	FUNC_END aeabi_ui2d
 	FUNC_END floatunsidf
 
 ARM_FUNC_START floatsidf
 ARM_FUNC_ALIAS aeabi_i2d floatsidf
+	CFI_START_FUNCTION
 
 	teq	r0, #0
 	do_it	eq, t
 	moveq	r1, #0
 	RETc(eq)
-	do_push	{r4, r5, lr}
+
+	do_push {r4, r5, lr}        @ sp -= 12
+	.cfi_adjust_cfa_offset 12   @ CFA is now sp + previousOffset + 12
+	.cfi_rel_offset r4, 0       @ Registers are saved from sp + 0 to sp + 8.
+	.cfi_rel_offset r5, 4
+	.cfi_rel_offset lr, 8
+
 	mov	r4, #0x400		@ initial exponent
 	add	r4, r4, #(52-1 - 1)
 	ands	r5, r0, #0x80000000	@ sign bit in r5
@@ -457,11 +489,13 @@ ARM_FUNC_ALIAS aeabi_i2d floatsidf
 	mov	xh, #0
 	b	LSYM(Lad_l)
 
+	CFI_END_FUNCTION
 	FUNC_END aeabi_i2d
 	FUNC_END floatsidf
 
 ARM_FUNC_START extendsfdf2
 ARM_FUNC_ALIAS aeabi_f2d extendsfdf2
+	CFI_START_FUNCTION
 
 	movs	r2, r0, lsl #1		@ toss sign bit
 	mov	xh, r2, asr #3		@ stretch exponent
@@ -480,34 +514,54 @@ ARM_FUNC_ALIAS aeabi_f2d extendsfdf2
 
 	@ value was denormalized.  We can normalize it now.
 	do_push	{r4, r5, lr}
+	.cfi_adjust_cfa_offset 12   @ CFA is now sp + previousOffset + 12
+	.cfi_rel_offset r4, 0       @ Registers are saved from sp + 0 to sp + 8.
+	.cfi_rel_offset r5, 4
+	.cfi_rel_offset lr, 8
+
 	mov	r4, #0x380		@ setup corresponding exponent
 	and	r5, xh, #0x80000000	@ move sign bit in r5
 	bic	xh, xh, #0x80000000
 	b	LSYM(Lad_l)
 
+	CFI_END_FUNCTION
 	FUNC_END aeabi_f2d
 	FUNC_END extendsfdf2
 
 ARM_FUNC_START floatundidf
 ARM_FUNC_ALIAS aeabi_ul2d floatundidf
+	CFI_START_FUNCTION
+	.cfi_remember_state        @ Save the current CFA state.
 
 	orrs	r2, r0, r1
 	do_it	eq
 	RETc(eq)
 
-	do_push	{r4, r5, lr}
+	do_push {r4, r5, lr}       @ sp -= 12
+	.cfi_adjust_cfa_offset 12  @ CFA is now sp + previousOffset + 12
+	.cfi_rel_offset r4, 0      @ Registers are saved from sp + 0 to sp + 8
+	.cfi_rel_offset r5, 4
+	.cfi_rel_offset lr, 8
 
 	mov	r5, #0
 	b	2f
 
 ARM_FUNC_START floatdidf
 ARM_FUNC_ALIAS aeabi_l2d floatdidf
+	.cfi_restore_state
+	@ Restore the CFI state we saved above. If we didn't do this then the
+	@ following instructions would have the CFI state that was set by the
+	@ offset adjustments made in floatundidf.
 
 	orrs	r2, r0, r1
 	do_it	eq
 	RETc(eq)
 
-	do_push	{r4, r5, lr}
+	do_push {r4, r5, lr}       @ sp -= 12
+	.cfi_adjust_cfa_offset 12  @ CFA is now sp + previousOffset + 12
+	.cfi_rel_offset r4, 0      @ Registers are saved from sp to sp + 8
+	.cfi_rel_offset r5, 4
+	.cfi_rel_offset lr, 8
 
 	ands	r5, ah, #0x80000000	@ sign bit in r5
 	bpl	2f
@@ -550,6 +604,7 @@ ARM_FUNC_ALIAS aeabi_l2d floatdidf
 	add	r4, r4, r2
 	b	LSYM(Lad_p)
 
+	CFI_END_FUNCTION
 	FUNC_END floatdidf
 	FUNC_END aeabi_l2d
 	FUNC_END floatundidf
@@ -561,7 +616,14 @@ ARM_FUNC_ALIAS aeabi_l2d floatdidf
 
 ARM_FUNC_START muldf3
 ARM_FUNC_ALIAS aeabi_dmul muldf3
-	do_push	{r4, r5, r6, lr}
+	CFI_START_FUNCTION
+
+	do_push {r4, r5, r6, lr}    @ sp -= 16
+	.cfi_adjust_cfa_offset 16   @ CFA is now sp + previousOffset + 16
+	.cfi_rel_offset r4, 0       @ Registers are saved from sp to sp + 12.
+	.cfi_rel_offset r5, 4
+	.cfi_rel_offset r6, 8
+	.cfi_rel_offset lr, 12
 
 	@ Mask out exponents, trap any zero/denormal/INF/NAN.
 	mov	ip, #0xff
@@ -596,7 +658,16 @@ ARM_FUNC_ALIAS aeabi_dmul muldf3
 	and   r6, r6, #0x80000000
 
 	@ Well, no way to make it shorter without the umull instruction.
-	stmfd	sp!, {r6, r7, r8, r9, sl, fp}
+	stmfd   sp!, {r6, r7, r8, r9, sl, fp}   @ sp -= 24
+	.cfi_remember_state         @ Save the current CFI state.
+	.cfi_adjust_cfa_offset 24   @ CFA is now sp + previousOffset + 24.
+	.cfi_rel_offset r6, 0       @ Registers are saved from sp to sp + 20.
+	.cfi_rel_offset r7, 4
+	.cfi_rel_offset r8, 8
+	.cfi_rel_offset r9, 12
+	.cfi_rel_offset sl, 16
+	.cfi_rel_offset fp, 20
+
 	mov	r7, xl, lsr #16
 	mov	r8, yl, lsr #16
 	mov	r9, xh, lsr #16
@@ -648,8 +719,8 @@ ARM_FUNC_ALIAS aeabi_dmul muldf3
 	mul	fp, xh, yh
 	adcs	r5, r5, fp
 	adc	r6, r6, #0
-	ldmfd	sp!, {yl, r7, r8, r9, sl, fp}
-
+	ldmfd   sp!, {yl, r7, r8, r9, sl, fp}   @ sp += 24
+	.cfi_restore_state   @ Restore the previous CFI state.
 #else
 
 	@ Here is the actual multiplication.
@@ -715,7 +786,6 @@ LSYM(Lml_1):
 	orr	xh, xh, #0x00100000
 	mov	lr, #0
 	subs	r4, r4, #1
-
 LSYM(Lml_u):
 	@ Overflow?
 	bgt	LSYM(Lml_o)
@@ -863,13 +933,20 @@ LSYM(Lml_n):
 	orr	xh, xh, #0x00f80000
 	RETLDM	"r4, r5, r6"
 
+	CFI_END_FUNCTION
 	FUNC_END aeabi_dmul
 	FUNC_END muldf3
 
 ARM_FUNC_START divdf3
 ARM_FUNC_ALIAS aeabi_ddiv divdf3
+	CFI_START_FUNCTION
 	
 	do_push	{r4, r5, r6, lr}
+	.cfi_adjust_cfa_offset 16
+	.cfi_rel_offset r4, 0
+	.cfi_rel_offset r5, 4
+	.cfi_rel_offset r6, 8
+	.cfi_rel_offset lr, 12
 
 	@ Mask out exponents, trap any zero/denormal/INF/NAN.
 	mov	ip, #0xff
@@ -1052,6 +1129,7 @@ LSYM(Ldv_s):
 	bne	LSYM(Lml_z)		@ 0 / <non_zero> -> 0
 	b	LSYM(Lml_n)		@ 0 / 0 -> NAN
 
+	CFI_END_FUNCTION
 	FUNC_END aeabi_ddiv
 	FUNC_END divdf3
 
@@ -1063,6 +1141,7 @@ LSYM(Ldv_s):
 
 ARM_FUNC_START gtdf2
 ARM_FUNC_ALIAS gedf2 gtdf2
+	CFI_START_FUNCTION
 	mov	ip, #-1
 	b	1f
 
@@ -1077,6 +1156,10 @@ ARM_FUNC_ALIAS eqdf2 cmpdf2
 	mov	ip, #1			@ how should we specify unordered here?
 
 1:	str	ip, [sp, #-4]!
+	.cfi_adjust_cfa_offset 4        @ CFA is now sp + previousOffset + 4.
+	@ We're not adding CFI for ip as it's pushed into the stack
+	@ only because @ it may be popped off later as a return value
+	@ (i.e. we're not preserving @ it anyways).
 
 	@ Trap any INF/NAN first.
 	mov	ip, xh, lsl #1
@@ -1085,10 +1168,18 @@ ARM_FUNC_ALIAS eqdf2 cmpdf2
 	do_it	ne
 	COND(mvn,s,ne)	ip, ip, asr #21
 	beq	3f
-
-	@ Test for equality.
-	@ Note that 0.0 is equal to -0.0.
+	.cfi_remember_state
+	@ Save the current CFI state. This is done because the branch
+	@ is conditional, @ and if we don't take it we'll issue a
+	@ .cfi_adjust_cfa_offset and return.  @ If we do take it,
+	@ however, the .cfi_adjust_cfa_offset from the non-branch @ code
+	@ will affect the branch code as well. To avoid this we'll
+	@ restore @ the current state before executing the branch code.
+
+	@ Test for equality.  @ Note that 0.0 is equal to -0.0.
 2:	add	sp, sp, #4
+	.cfi_adjust_cfa_offset -4       @ CFA is now sp + previousOffset.
+
 	orrs	ip, xl, xh, lsl #1	@ if x == 0.0 or -0.0
 	do_it	eq, e
 	COND(orr,s,eq)	ip, yl, yh, lsl #1	@ and y == 0.0 or -0.0
@@ -1117,8 +1208,13 @@ ARM_FUNC_ALIAS eqdf2 cmpdf2
 	orr	r0, r0, #1
 	RET
 
-	@ Look for a NAN.
-3:	mov	ip, xh, lsl #1
+3:  @ Look for a NAN.
+
+	@ Restore the previous CFI state (i.e. keep the CFI state as it was
+	@ before the branch).
+	.cfi_restore_state
+
+	mov ip, xh, lsl #1
 	mvns	ip, ip, asr #21
 	bne	4f
 	orrs	ip, xl, xh, lsl #12
@@ -1128,9 +1224,13 @@ ARM_FUNC_ALIAS eqdf2 cmpdf2
 	bne	2b
 	orrs	ip, yl, yh, lsl #12
 	beq	2b			@ y is not NAN
+
 5:	ldr	r0, [sp], #4		@ unordered return code
+	.cfi_adjust_cfa_offset -4       @ CFA is now sp + previousOffset.
+
 	RET
 
+	CFI_END_FUNCTION
 	FUNC_END gedf2
 	FUNC_END gtdf2
 	FUNC_END ledf2
@@ -1140,6 +1240,7 @@ ARM_FUNC_ALIAS eqdf2 cmpdf2
 	FUNC_END cmpdf2
 
 ARM_FUNC_START aeabi_cdrcmple
+	CFI_START_FUNCTION
 
 	mov	ip, r0
 	mov	r0, r2
@@ -1148,13 +1249,17 @@ ARM_FUNC_START aeabi_cdrcmple
 	mov	r1, r3
 	mov	r3, ip
 	b	6f
-	
+
 ARM_FUNC_START aeabi_cdcmpeq
 ARM_FUNC_ALIAS aeabi_cdcmple aeabi_cdcmpeq
 
 	@ The status-returning routines are required to preserve all
 	@ registers except ip, lr, and cpsr.
 6:	do_push	{r0, lr}
+	.cfi_adjust_cfa_offset 8  @ CFA is now sp + previousOffset + 8.
+	.cfi_rel_offset r0, 0     @ Previous r0 is saved at sp.
+	.cfi_rel_offset lr, 4     @ Previous lr is saved at sp + 4.
+
 	ARM_CALL cmpdf2
 	@ Set the Z flag correctly, and the C flag unconditionally.
 	cmp	r0, #0
@@ -1162,59 +1267,86 @@ ARM_FUNC_ALIAS aeabi_cdcmple aeabi_cdcmpeq
 	@ that the first operand was smaller than the second.
 	do_it	mi
 	cmnmi	r0, #0
+
 	RETLDM	"r0"
 
+	CFI_END_FUNCTION
 	FUNC_END aeabi_cdcmple
 	FUNC_END aeabi_cdcmpeq
 	FUNC_END aeabi_cdrcmple
 	
 ARM_FUNC_START	aeabi_dcmpeq
+	CFI_START_FUNCTION
+
+	str lr, [sp, #-8]!        @ sp -= 8
+	.cfi_adjust_cfa_offset 8  @ CFA is now sp + previousOffset + 8
+	.cfi_rel_offset lr, 0     @ lr is at sp
 
-	str	lr, [sp, #-8]!
 	ARM_CALL aeabi_cdcmple
 	do_it	eq, e
 	moveq	r0, #1	@ Equal to.
 	movne	r0, #0	@ Less than, greater than, or unordered.
+
 	RETLDM
 
+	CFI_END_FUNCTION
 	FUNC_END aeabi_dcmpeq
 
 ARM_FUNC_START	aeabi_dcmplt
+	CFI_START_FUNCTION
+
+	str lr, [sp, #-8]!        @ sp -= 8
+	.cfi_adjust_cfa_offset 8  @ CFA is now sp + previousOffset + 8
+	.cfi_rel_offset lr, 0     @ lr is at sp
 
-	str	lr, [sp, #-8]!
 	ARM_CALL aeabi_cdcmple
 	do_it	cc, e
 	movcc	r0, #1	@ Less than.
 	movcs	r0, #0	@ Equal to, greater than, or unordered.
 	RETLDM
 
+	CFI_END_FUNCTION
 	FUNC_END aeabi_dcmplt
 
 ARM_FUNC_START	aeabi_dcmple
+	CFI_START_FUNCTION
+
+	str lr, [sp, #-8]!        @ sp -= 8
+	.cfi_adjust_cfa_offset 8  @ CFA is now sp + previousOffset + 8
+	.cfi_rel_offset lr, 0     @ lr is at sp
 
-	str	lr, [sp, #-8]!
 	ARM_CALL aeabi_cdcmple
 	do_it	ls, e
 	movls	r0, #1  @ Less than or equal to.
 	movhi	r0, #0	@ Greater than or unordered.
 	RETLDM
 
+	CFI_END_FUNCTION
 	FUNC_END aeabi_dcmple
 
 ARM_FUNC_START	aeabi_dcmpge
+	CFI_START_FUNCTION
+
+	str lr, [sp, #-8]!        @ sp -= 8
+	.cfi_adjust_cfa_offset 8  @ CFA is now sp + previousOffset + 8
+	.cfi_rel_offset lr, 0     @ lr is at sp
 
-	str	lr, [sp, #-8]!
 	ARM_CALL aeabi_cdrcmple
 	do_it	ls, e
 	movls	r0, #1	@ Operand 2 is less than or equal to operand 1.
 	movhi	r0, #0	@ Operand 2 greater than operand 1, or unordered.
 	RETLDM
 
+	CFI_END_FUNCTION
 	FUNC_END aeabi_dcmpge
 
 ARM_FUNC_START	aeabi_dcmpgt
+	CFI_START_FUNCTION
+
+	str lr, [sp, #-8]!        @ sp -= 8
+	.cfi_adjust_cfa_offset 8  @ CFA is now sp + previousOffset + 8
+	.cfi_rel_offset lr, 0     @ lr is at sp
 
-	str	lr, [sp, #-8]!
 	ARM_CALL aeabi_cdrcmple
 	do_it	cc, e
 	movcc	r0, #1	@ Operand 2 is less than operand 1.
@@ -1222,6 +1354,7 @@ ARM_FUNC_START	aeabi_dcmpgt
 			@ or they are unordered.
 	RETLDM
 
+	CFI_END_FUNCTION
 	FUNC_END aeabi_dcmpgt
 
 #endif /* L_cmpdf2 */
@@ -1230,6 +1363,7 @@ ARM_FUNC_START	aeabi_dcmpgt
 
 ARM_FUNC_START unorddf2
 ARM_FUNC_ALIAS aeabi_dcmpun unorddf2
+	.cfi_startproc
 
 	mov	ip, xh, lsl #1
 	mvns	ip, ip, asr #21
@@ -1247,6 +1381,7 @@ ARM_FUNC_ALIAS aeabi_dcmpun unorddf2
 3:	mov	r0, #1			@ arguments are unordered.
 	RET
 
+	.cfi_endproc
 	FUNC_END aeabi_dcmpun
 	FUNC_END unorddf2
 
@@ -1256,6 +1391,7 @@ ARM_FUNC_ALIAS aeabi_dcmpun unorddf2
 
 ARM_FUNC_START fixdfsi
 ARM_FUNC_ALIAS aeabi_d2iz fixdfsi
+	CFI_START_FUNCTION
 
 	@ check exponent range.
 	mov	r2, xh, lsl #1
@@ -1289,6 +1425,7 @@ ARM_FUNC_ALIAS aeabi_d2iz fixdfsi
 4:	mov	r0, #0			@ How should we convert NAN?
 	RET
 
+	CFI_END_FUNCTION
 	FUNC_END aeabi_d2iz
 	FUNC_END fixdfsi
 
@@ -1298,6 +1435,7 @@ ARM_FUNC_ALIAS aeabi_d2iz fixdfsi
 
 ARM_FUNC_START fixunsdfsi
 ARM_FUNC_ALIAS aeabi_d2uiz fixunsdfsi
+	CFI_START_FUNCTION
 
 	@ check exponent range.
 	movs	r2, xh, lsl #1
@@ -1327,6 +1465,7 @@ ARM_FUNC_ALIAS aeabi_d2uiz fixunsdfsi
 4:	mov	r0, #0			@ How should we convert NAN?
 	RET
 
+	CFI_END_FUNCTION
 	FUNC_END aeabi_d2uiz
 	FUNC_END fixunsdfsi
 
@@ -1336,6 +1475,7 @@ ARM_FUNC_ALIAS aeabi_d2uiz fixunsdfsi
 
 ARM_FUNC_START truncdfsf2
 ARM_FUNC_ALIAS aeabi_d2f truncdfsf2
+	CFI_START_FUNCTION
 
 	@ check exponent range.
 	mov	r2, xh, lsl #1
@@ -1400,6 +1540,7 @@ ARM_FUNC_ALIAS aeabi_d2f truncdfsf2
 	orr	r0, r0, #0x00800000
 	RET
 
+	CFI_END_FUNCTION
 	FUNC_END aeabi_d2f
 	FUNC_END truncdfsf2
 
--- a/src/libgcc/config/arm/ieee754-sf.S
+++ b/src/libgcc/config/arm/ieee754-sf.S
@@ -31,16 +31,21 @@
  * Only the default rounding mode is intended for best performances.
  * Exceptions aren't supported yet, but that can be added quite easily
  * if necessary without impacting performances.
+ *
+ * In the CFI related comments, 'previousOffset' refers to the previous offset
+ * from sp used to compute the CFA.
  */
 
 #ifdef L_arm_negsf2
 	
 ARM_FUNC_START negsf2
 ARM_FUNC_ALIAS aeabi_fneg negsf2
+	CFI_START_FUNCTION
 
 	eor	r0, r0, #0x80000000	@ flip sign bit
 	RET
 
+	CFI_END_FUNCTION
 	FUNC_END aeabi_fneg
 	FUNC_END negsf2
 
@@ -49,6 +54,7 @@ ARM_FUNC_ALIAS aeabi_fneg negsf2
 #ifdef L_arm_addsubsf3
 
 ARM_FUNC_START aeabi_frsub
+	CFI_START_FUNCTION
 
 	eor	r0, r0, #0x80000000	@ flip sign bit of first arg
 	b	1f
@@ -284,6 +290,7 @@ LSYM(Lad_i):
 	orrne	r0, r0, #0x00400000	@ quiet NAN
 	RET
 
+	CFI_END_FUNCTION
 	FUNC_END aeabi_frsub
 	FUNC_END aeabi_fadd
 	FUNC_END addsf3
@@ -292,6 +299,7 @@ LSYM(Lad_i):
 
 ARM_FUNC_START floatunsisf
 ARM_FUNC_ALIAS aeabi_ui2f floatunsisf
+	CFI_START_FUNCTION
 		
 	mov	r3, #0
 	b	1f
@@ -316,6 +324,7 @@ ARM_FUNC_ALIAS aeabi_i2f floatsisf
 	mov	al, #0
 	b	2f
 
+	CFI_END_FUNCTION
 	FUNC_END aeabi_i2f
 	FUNC_END floatsisf
 	FUNC_END aeabi_ui2f
@@ -323,6 +332,7 @@ ARM_FUNC_ALIAS aeabi_i2f floatsisf
 
 ARM_FUNC_START floatundisf
 ARM_FUNC_ALIAS aeabi_ul2f floatundisf
+	CFI_START_FUNCTION
 
 	orrs	r2, r0, r1
 	do_it	eq
@@ -409,6 +419,7 @@ ARM_FUNC_ALIAS aeabi_l2f floatdisf
 	biceq	r0, r0, ip, lsr #31
 	RET
 
+	CFI_END_FUNCTION
 	FUNC_END floatdisf
 	FUNC_END aeabi_l2f
 	FUNC_END floatundisf
@@ -420,6 +431,7 @@ ARM_FUNC_ALIAS aeabi_l2f floatdisf
 
 ARM_FUNC_START mulsf3
 ARM_FUNC_ALIAS aeabi_fmul mulsf3
+	CFI_START_FUNCTION
 
 	@ Mask out exponents, trap any zero/denormal/INF/NAN.
 	mov	ip, #0xff
@@ -454,7 +466,13 @@ LSYM(Lml_x):
 	and	r3, ip, #0x80000000
 
 	@ Well, no way to make it shorter without the umull instruction.
-	do_push	{r3, r4, r5}
+	do_push	{r3, r4, r5}       @ sp -= 12
+	.cfi_remember_state        @ Save the current CFI state
+	.cfi_adjust_cfa_offset 12  @ CFA is now sp + previousOffset + 12
+	.cfi_rel_offset r3, 0      @ Registers are saved from sp to sp + 8
+	.cfi_rel_offset r4, 4
+	.cfi_rel_offset r5, 8
+
 	mov	r4, r0, lsr #16
 	mov	r5, r1, lsr #16
 	bic	r0, r0, r4, lsl #16
@@ -465,7 +483,8 @@ LSYM(Lml_x):
 	mla	r0, r4, r1, r0
 	adds	r3, r3, r0, lsl #16
 	adc	r1, ip, r0, lsr #16
-	do_pop	{r0, r4, r5}
+	do_pop	{r0, r4, r5}       @ sp += 12
+	.cfi_restore_state         @ Restore the previous CFI state
 
 #else
 
@@ -618,11 +637,13 @@ LSYM(Lml_n):
 	orr	r0, r0, #0x00c00000
 	RET
 
+	CFI_END_FUNCTION
 	FUNC_END aeabi_fmul
 	FUNC_END mulsf3
 
 ARM_FUNC_START divsf3
 ARM_FUNC_ALIAS aeabi_fdiv divsf3
+	CFI_START_FUNCTION
 
 	@ Mask out exponents, trap any zero/denormal/INF/NAN.
 	mov	ip, #0xff
@@ -758,6 +779,7 @@ LSYM(Ldv_s):
 	bne	LSYM(Lml_z)		@ 0 / <non_zero> -> 0
 	b	LSYM(Lml_n)		@ 0 / 0 -> NAN
 
+	CFI_END_FUNCTION
 	FUNC_END aeabi_fdiv
 	FUNC_END divsf3
 
@@ -782,6 +804,7 @@ LSYM(Ldv_s):
 
 ARM_FUNC_START gtsf2
 ARM_FUNC_ALIAS gesf2 gtsf2
+	CFI_START_FUNCTION
 	mov	ip, #-1
 	b	1f
 
@@ -796,6 +819,10 @@ ARM_FUNC_ALIAS eqsf2 cmpsf2
 	mov	ip, #1			@ how should we specify unordered here?
 
 1:	str	ip, [sp, #-4]!
+	.cfi_adjust_cfa_offset 4  @ CFA is now sp + previousOffset + 4.
+	@ We're not adding CFI for ip as it's pushed into the stack only because
+	@ it may be popped off later as a return value (i.e. we're not preserving
+	@ it anyways).
 
 	@ Trap any INF/NAN first.
 	mov	r2, r0, lsl #1
@@ -804,10 +831,18 @@ ARM_FUNC_ALIAS eqsf2 cmpsf2
 	do_it	ne
 	COND(mvn,s,ne)	ip, r3, asr #24
 	beq	3f
+	.cfi_remember_state
+	@ Save the current CFI state. This is done because the branch is conditional,
+	@ and if we don't take it we'll issue a .cfi_adjust_cfa_offset and return.
+	@ If we do take it, however, the .cfi_adjust_cfa_offset from the non-branch
+	@ code will affect the branch code as well. To avoid this we'll restore
+	@ the current state before executing the branch code.
 
 	@ Compare values.
 	@ Note that 0.0 is equal to -0.0.
 2:	add	sp, sp, #4
+	.cfi_adjust_cfa_offset -4       @ CFA is now sp + previousOffset.
+
 	orrs	ip, r2, r3, lsr #1	@ test if both are 0, clear C flag
 	do_it	ne
 	teqne	r0, r1			@ if not 0 compare sign
@@ -823,8 +858,13 @@ ARM_FUNC_ALIAS eqsf2 cmpsf2
 	orrne	r0, r0, #1
 	RET
 
-	@ Look for a NAN. 
-3:	mvns	ip, r2, asr #24
+3:	@ Look for a NAN.
+
+	@ Restore the previous CFI state (i.e. keep the CFI state as it was
+	@ before the branch).
+	.cfi_restore_state
+
+	mvns	ip, r2, asr #24
 	bne	4f
 	movs	ip, r0, lsl #9
 	bne	5f			@ r0 is NAN
@@ -832,9 +872,12 @@ ARM_FUNC_ALIAS eqsf2 cmpsf2
 	bne	2b
 	movs	ip, r1, lsl #9
 	beq	2b			@ r1 is not NAN
+
 5:	ldr	r0, [sp], #4		@ return unordered code.
+	.cfi_adjust_cfa_offset -4       @ CFA is now sp + previousOffset.
 	RET
 
+	CFI_END_FUNCTION
 	FUNC_END gesf2
 	FUNC_END gtsf2
 	FUNC_END lesf2
@@ -844,6 +887,7 @@ ARM_FUNC_ALIAS eqsf2 cmpsf2
 	FUNC_END cmpsf2
 
 ARM_FUNC_START aeabi_cfrcmple
+	CFI_START_FUNCTION
 
 	mov	ip, r0
 	mov	r0, r1
@@ -856,6 +900,13 @@ ARM_FUNC_ALIAS aeabi_cfcmple aeabi_cfcmpeq
 	@ The status-returning routines are required to preserve all
 	@ registers except ip, lr, and cpsr.
 6:	do_push	{r0, r1, r2, r3, lr}
+	.cfi_adjust_cfa_offset 20  @ CFA is at sp + previousOffset + 20
+	.cfi_rel_offset r0, 0      @ Registers are saved from sp to sp + 16
+	.cfi_rel_offset r1, 4
+	.cfi_rel_offset r2, 8
+	.cfi_rel_offset r3, 12
+	.cfi_rel_offset lr, 16
+
 	ARM_CALL cmpsf2
 	@ Set the Z flag correctly, and the C flag unconditionally.
 	cmp	r0, #0
@@ -865,57 +916,82 @@ ARM_FUNC_ALIAS aeabi_cfcmple aeabi_cfcmpeq
 	cmnmi	r0, #0
 	RETLDM	"r0, r1, r2, r3"
 
+	CFI_END_FUNCTION
 	FUNC_END aeabi_cfcmple
 	FUNC_END aeabi_cfcmpeq
 	FUNC_END aeabi_cfrcmple
 
 ARM_FUNC_START	aeabi_fcmpeq
+	CFI_START_FUNCTION
+
+	str	lr, [sp, #-8]!    @ sp -= 8
+	.cfi_adjust_cfa_offset 8  @ CFA is now sp + previousOffset + 8
+	.cfi_rel_offset lr, 0     @ lr is at sp
 
-	str	lr, [sp, #-8]!
 	ARM_CALL aeabi_cfcmple
 	do_it	eq, e
 	moveq	r0, #1	@ Equal to.
 	movne	r0, #0	@ Less than, greater than, or unordered.
 	RETLDM
 
+	CFI_END_FUNCTION
 	FUNC_END aeabi_fcmpeq
 
 ARM_FUNC_START	aeabi_fcmplt
+	CFI_START_FUNCTION
+
+	str	lr, [sp, #-8]!    @ sp -= 8
+	.cfi_adjust_cfa_offset 8  @ CFA is now sp + previousOffset + 8
+	.cfi_rel_offset lr, 0     @ lr is at sp
 
-	str	lr, [sp, #-8]!
 	ARM_CALL aeabi_cfcmple
 	do_it	cc, e
 	movcc	r0, #1	@ Less than.
 	movcs	r0, #0	@ Equal to, greater than, or unordered.
 	RETLDM
 
+	CFI_END_FUNCTION
 	FUNC_END aeabi_fcmplt
 
 ARM_FUNC_START	aeabi_fcmple
+	CFI_START_FUNCTION
+
+	str	lr, [sp, #-8]!    @ sp -= 8
+	.cfi_adjust_cfa_offset 8  @ CFA is now sp + previousOffset + 8
+	.cfi_rel_offset lr, 0     @ lr is at sp
 
-	str	lr, [sp, #-8]!
 	ARM_CALL aeabi_cfcmple
 	do_it	ls, e
 	movls	r0, #1  @ Less than or equal to.
 	movhi	r0, #0	@ Greater than or unordered.
 	RETLDM
 
+	CFI_END_FUNCTION
 	FUNC_END aeabi_fcmple
 
 ARM_FUNC_START	aeabi_fcmpge
+	CFI_START_FUNCTION
+
+	str	lr, [sp, #-8]!    @ sp -= 8
+	.cfi_adjust_cfa_offset 8  @ CFA is now sp + previousOffset + 8
+	.cfi_rel_offset lr, 0     @ lr is at sp
 
-	str	lr, [sp, #-8]!
 	ARM_CALL aeabi_cfrcmple
 	do_it	ls, e
 	movls	r0, #1	@ Operand 2 is less than or equal to operand 1.
 	movhi	r0, #0	@ Operand 2 greater than operand 1, or unordered.
 	RETLDM
 
+	CFI_END_FUNCTION
 	FUNC_END aeabi_fcmpge
 
 ARM_FUNC_START	aeabi_fcmpgt
+	CFI_START_FUNCTION
+
+	str	lr, [sp, #-8]!    @ sp -= 8
+	.cfi_adjust_cfa_offset 8  @ CFA is now sp + previousOffset + 8
+	.cfi_rel_offset lr, 0     @ lr is at sp
 
-	str	lr, [sp, #-8]!
 	ARM_CALL aeabi_cfrcmple
 	do_it	cc, e
 	movcc	r0, #1	@ Operand 2 is less than operand 1.
@@ -923,6 +999,7 @@ ARM_FUNC_START	aeabi_fcmpgt
 			@ or they are unordered.
 	RETLDM
 
+	CFI_END_FUNCTION
 	FUNC_END aeabi_fcmpgt
 
 #endif /* L_cmpsf2 */
@@ -931,6 +1008,7 @@ ARM_FUNC_START	aeabi_fcmpgt
 
 ARM_FUNC_START unordsf2
 ARM_FUNC_ALIAS aeabi_fcmpun unordsf2
+	CFI_START_FUNCTION
 
 	mov	r2, r0, lsl #1
 	mov	r3, r1, lsl #1
@@ -947,6 +1025,7 @@ ARM_FUNC_ALIAS aeabi_fcmpun unordsf2
 3:	mov	r0, #1			@ arguments are unordered.
 	RET
 
+	CFI_END_FUNCTION
 	FUNC_END aeabi_fcmpun
 	FUNC_END unordsf2
 
@@ -956,6 +1035,7 @@ ARM_FUNC_ALIAS aeabi_fcmpun unordsf2
 
 ARM_FUNC_START fixsfsi
 ARM_FUNC_ALIAS aeabi_f2iz fixsfsi
+	CFI_START_FUNCTION
 
 	@ check exponent range.
 	mov	r2, r0, lsl #1
@@ -989,6 +1069,7 @@ ARM_FUNC_ALIAS aeabi_f2iz fixsfsi
 4:	mov	r0, #0			@ What should we convert NAN to?
 	RET
 
+	CFI_END_FUNCTION
 	FUNC_END aeabi_f2iz
 	FUNC_END fixsfsi
 
@@ -998,6 +1079,7 @@ ARM_FUNC_ALIAS aeabi_f2iz fixsfsi
 
 ARM_FUNC_START fixunssfsi
 ARM_FUNC_ALIAS aeabi_f2uiz fixunssfsi
+	CFI_START_FUNCTION
 
 	@ check exponent range.
 	movs	r2, r0, lsl #1
@@ -1027,6 +1109,7 @@ ARM_FUNC_ALIAS aeabi_f2uiz fixunssfsi
 4:	mov	r0, #0			@ What should we convert NAN to?
 	RET
 
+	CFI_END_FUNCTION
 	FUNC_END aeabi_f2uiz
 	FUNC_END fixunssfsi
 
--- a/src/libgcc/config/arm/lib1funcs.S
+++ b/src/libgcc/config/arm/lib1funcs.S
@@ -1965,6 +1965,16 @@ LSYM(Lchange_\register):
 
 #endif /* Arch supports thumb.  */
 
+.macro CFI_START_FUNCTION
+	.cfi_startproc
+	.cfi_remember_state
+.endm
+
+.macro CFI_END_FUNCTION
+	.cfi_restore_state
+	.cfi_endproc
+.endm
+
 #ifndef __symbian__
 #ifndef __ARM_ARCH_6M__
 #include "ieee754-df.S"
--- a/src/libgcc/unwind-dw2-fde-dip.c
+++ b/src/libgcc/unwind-dw2-fde-dip.c
@@ -59,6 +59,12 @@
 
 #if !defined(inhibit_libc) && defined(HAVE_LD_EH_FRAME_HDR) \
     && defined(TARGET_DL_ITERATE_PHDR) \
+    && defined(__linux__)
+# define USE_PT_GNU_EH_FRAME
+#endif
+
+#if !defined(inhibit_libc) && defined(HAVE_LD_EH_FRAME_HDR) \
+    && defined(TARGET_DL_ITERATE_PHDR) \
     && (defined(__DragonFly__) || defined(__FreeBSD__))
 # define ElfW __ElfN
 # define USE_PT_GNU_EH_FRAME
--- a/src/libgfortran/acinclude.m4
+++ b/src/libgfortran/acinclude.m4
@@ -100,7 +100,7 @@ void foo (void);
 	      [Define to 1 if the target supports #pragma weak])
   fi
   case "$host" in
-    *-*-darwin* | *-*-hpux* | *-*-cygwin* | *-*-mingw* )
+    *-*-darwin* | *-*-hpux* | *-*-cygwin* | *-*-mingw* | *-*-musl* )
       AC_DEFINE(GTHREAD_USE_WEAK, 0,
 		[Define to 0 if the target shouldn't use #pragma weak])
       ;;
--- a/src/libgfortran/configure
+++ b/src/libgfortran/configure
@@ -26456,7 +26456,7 @@ $as_echo "#define SUPPORTS_WEAK 1" >>confdefs.h
 
   fi
   case "$host" in
-    *-*-darwin* | *-*-hpux* | *-*-cygwin* | *-*-mingw* )
+    *-*-darwin* | *-*-hpux* | *-*-cygwin* | *-*-mingw* | *-*-musl* )
 
 $as_echo "#define GTHREAD_USE_WEAK 0" >>confdefs.h
 
--- a/src/libgomp/testsuite/libgomp.graphite/bounds.c
+++ b/src/libgomp/testsuite/libgomp.graphite/bounds.c
@@ -8,6 +8,3 @@ int foo(int *a, int n)
 /* Check that Graphite dependency checking notes the dependency.  */
 /* { dg-do compile } */
 /* { dg-final { scan-tree-dump-times "0 loops carried no dependency" 1 "graphite" } } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
-/* { dg-final { cleanup-tree-dump "parloops" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/libgomp/testsuite/libgomp.graphite/force-parallel-1.c
+++ b/src/libgomp/testsuite/libgomp.graphite/force-parallel-1.c
@@ -25,7 +25,4 @@ int main(void)
 
 /* Check that parallel code generation part make the right answer.  */
 /* { dg-final { scan-tree-dump-times "1 loops carried no dependency" 1 "graphite" } } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
 /* { dg-final { scan-tree-dump-times "loopfn" 4 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "parloops" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/libgomp/testsuite/libgomp.graphite/force-parallel-2.c
+++ b/src/libgomp/testsuite/libgomp.graphite/force-parallel-2.c
@@ -24,7 +24,4 @@ int main(void)
 
 /* Check that parallel code generation part make the right answer.  */
 /* { dg-final { scan-tree-dump-times "2 loops carried no dependency" 1 "graphite" } } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
 /* { dg-final { scan-tree-dump-times "loopfn" 4 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "parloops" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/libgomp/testsuite/libgomp.graphite/force-parallel-3.c
+++ b/src/libgomp/testsuite/libgomp.graphite/force-parallel-3.c
@@ -31,8 +31,5 @@ int main(void)
 
 /* Check that parallel code generation part make the right answer.  */
 /* { dg-final { scan-tree-dump-times "4 loops carried no dependency" 1 "graphite" } } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
 /* { dg-final { scan-tree-dump-times "loopfn.0" 4 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "loopfn.1" 4 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "parloops" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/libgomp/testsuite/libgomp.graphite/force-parallel-4.c
+++ b/src/libgomp/testsuite/libgomp.graphite/force-parallel-4.c
@@ -49,8 +49,5 @@ int main(void)
 /* Check that parallel code generation part make the right answer.  */
 /* { dg-final { scan-tree-dump-times "1 loops carried no dependency" 1 "graphite" } } */
 /* { dg-final { scan-tree-dump-times "2 loops carried no dependency" 1 "graphite" } } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
 /* { dg-final { scan-tree-dump-times "loopfn.0" 4 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "loopfn.1" 4 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "parloops" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/libgomp/testsuite/libgomp.graphite/force-parallel-5.c
+++ b/src/libgomp/testsuite/libgomp.graphite/force-parallel-5.c
@@ -32,8 +32,5 @@ int main(void)
 
 /* Check that parallel code generation part make the right answer.  */
 /* { dg-final { scan-tree-dump-times "1 loops carried no dependency" 1 "graphite" } } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
 /* { dg-final { scan-tree-dump-times "loopfn.0" 4 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "loopfn.1" 4 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "parloops" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/libgomp/testsuite/libgomp.graphite/force-parallel-6.c
+++ b/src/libgomp/testsuite/libgomp.graphite/force-parallel-6.c
@@ -80,7 +80,4 @@ int main(void)
 
 /* Check that parallel code generation part make the right answer.  */
 /* { dg-final { scan-tree-dump-times "1 loops carried no dependency" 1 "graphite" } } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
 /* { dg-final { scan-tree-dump-times "loopfn.0" 4 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "parloops" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/libgomp/testsuite/libgomp.graphite/force-parallel-7.c
+++ b/src/libgomp/testsuite/libgomp.graphite/force-parallel-7.c
@@ -32,7 +32,4 @@ int main (void)
 
 /* Check that parallel code generation part make the right answer.  */
 /* { dg-final { scan-tree-dump-times "3 loops carried no dependency" 1 "graphite" } } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
 /* { dg-final { scan-tree-dump-times "loopfn.0" 4 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "parloops" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/libgomp/testsuite/libgomp.graphite/force-parallel-8.c
+++ b/src/libgomp/testsuite/libgomp.graphite/force-parallel-8.c
@@ -46,8 +46,5 @@ int main(void)
 /* { dg-final { scan-tree-dump-times "1 loops carried no dependency" 1 "graphite" } } */
 /* { dg-final { scan-tree-dump-times "3 loops carried no dependency" 1 "graphite" } } */
 /* { dg-final { scan-tree-dump-times "5 loops carried no dependency" 1 "graphite" } } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
 /* { dg-final { scan-tree-dump-times "loopfn.0" 4 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "loopfn.1" 4 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "parloops" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/libgomp/testsuite/libgomp.graphite/force-parallel-9.c
+++ b/src/libgomp/testsuite/libgomp.graphite/force-parallel-9.c
@@ -30,8 +30,5 @@ int main(void)
 
 /* Check that parallel code generation part make the right answer.  */
 /* { dg-final { scan-tree-dump-times "4 loops carried no dependency" 1 "graphite" } } */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
 /* { dg-final { scan-tree-dump-times "loopfn.0" 4 "optimized" } } */
 /* { dg-final { scan-tree-dump-times "loopfn.1" 4 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "parloops" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/libgomp/testsuite/libgomp.graphite/pr41118.c
+++ b/src/libgomp/testsuite/libgomp.graphite/pr41118.c
@@ -13,7 +13,4 @@ int main(void)
 }
 
 /* Check that parallel code generation part make the right answer.  */
-/* { dg-final { cleanup-tree-dump "graphite" } } */
 /* { dg-final { scan-tree-dump-times "loopfn" 0 "optimized" } } */
-/* { dg-final { cleanup-tree-dump "parloops" } } */
-/* { dg-final { cleanup-tree-dump "optimized" } } */
--- a/src/libitm/config/arm/hwcap.cc
+++ b/src/libitm/config/arm/hwcap.cc
@@ -40,7 +40,7 @@ int GTM_hwcap HIDDEN = 0
 
 #ifdef __linux__
 #include <unistd.h>
-#include <sys/fcntl.h>
+#include <fcntl.h>
 #include <elf.h>
 
 static void __attribute__((constructor))
--- a/src/libitm/config/linux/x86/tls.h
+++ b/src/libitm/config/linux/x86/tls.h
@@ -25,16 +25,19 @@
 #ifndef LIBITM_X86_TLS_H
 #define LIBITM_X86_TLS_H 1
 
-#if defined(__GLIBC_PREREQ) && __GLIBC_PREREQ(2, 10)
+#if defined(__GLIBC_PREREQ)
+#if __GLIBC_PREREQ(2, 10)
 /* Use slots in the TCB head rather than __thread lookups.
    GLIBC has reserved words 10 through 13 for TM.  */
 #define HAVE_ARCH_GTM_THREAD 1
 #define HAVE_ARCH_GTM_THREAD_DISP 1
 #endif
+#endif
 
 #include "config/generic/tls.h"
 
-#if defined(__GLIBC_PREREQ) && __GLIBC_PREREQ(2, 10)
+#if defined(__GLIBC_PREREQ)
+#if __GLIBC_PREREQ(2, 10)
 namespace GTM HIDDEN {
 
 #ifdef __x86_64__
@@ -101,5 +104,6 @@ static inline void set_abi_disp(struct abi_dispatch *x)
 
 } // namespace GTM
 #endif /* >= GLIBC 2.10 */
+#endif
 
 #endif // LIBITM_X86_TLS_H
--- /dev/null
+++ b/src/libstdc++-v3/config/cpu/arm/cpu_defines.h
@@ -0,0 +1,40 @@
+// Specific definitions for generic platforms  -*- C++ -*-
+
+// Copyright (C) 2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+/** @file bits/cpu_defines.h
+ *  This is an internal header file, included by other library headers.
+ *  Do not attempt to use it directly. @headername{iosfwd}
+ */
+
+#ifndef _GLIBCXX_CPU_DEFINES
+#define _GLIBCXX_CPU_DEFINES 1
+
+// Integer divide instructions don't trap on ARM.
+#ifdef __ARM_ARCH_EXT_IDIV__
+#define __glibcxx_integral_traps false
+#else
+#define __glibcxx_integral_traps true
+#endif
+
+#endif
--- a/src/libstdc++-v3/config/os/generic/os_defines.h
+++ b/src/libstdc++-v3/config/os/generic/os_defines.h
@@ -33,4 +33,9 @@
 // System-specific #define, typedefs, corrections, etc, go here.  This
 // file will come before all others.
 
+// Disable the weak reference logic in gthr.h for os/generic because it
+// is broken on every platform unless there is implementation specific
+// workaround in gthr-posix.h and at link-time for static linking.
+#define _GLIBCXX_GTHREAD_USE_WEAK 0
+
 #endif
--- a/src/libstdc++-v3/configure.host
+++ b/src/libstdc++-v3/configure.host
@@ -143,6 +143,9 @@ cpu_include_dir=cpu/${try_cpu}
 # Set specific CPU overrides for cpu_defines_dir. Most can just use generic.
 # THIS TABLE IS SORTED.  KEEP IT THAT WAY.
 case "${host_cpu}" in
+  arm*)
+    cpu_defines_dir=cpu/arm
+    ;;
   powerpc* | rs6000)
     cpu_defines_dir=cpu/powerpc
     ;;
@@ -273,6 +276,9 @@ case "${host_os}" in
   freebsd*)
     os_include_dir="os/bsd/freebsd"
     ;;
+  linux-musl*)
+    os_include_dir="os/generic"
+    ;;
   gnu* | linux* | kfreebsd*-gnu | knetbsd*-gnu)
     if [ "$uclibc" = "yes" ]; then
       os_include_dir="os/uclibc"
--- a/src/libstdc++-v3/testsuite/lib/libstdc++.exp
+++ b/src/libstdc++-v3/testsuite/lib/libstdc++.exp
@@ -409,6 +409,11 @@ proc libstdc++-dg-test { prog do_what extra_tool_flags } {
     # and-target file), but the defaults are lacking in goodness.
     set comp_output [$select_compile "$prog" "$output_file" "$compile_type" $options];
 
+    set unsupported_message [libstdc++_check_unsupported_p $comp_output]
+    if { $unsupported_message != "" } {
+	set comp_output "::unsupported::$unsupported_message"
+    }
+
     return [list $comp_output $output_file]
 }
 
