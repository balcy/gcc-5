2012-05-06  Andrew Pinski  <apinski@cavium.com>
  
  * combine.c (simplify_comparison): Use gen_lowpart_or_truncate instead
  of gen_lowpart when we had a truncating and.

  * gcc.c-torture/execute/20110418-1.c: New testcase.

Index: a/src/gcc/combine.c
===================================================================
--- a/src/gcc/combine.c	(revision 187203)
+++ a/src/gcc/combine.c	(working copy)
@@ -11199,8 +11199,8 @@ simplify_comparison (enum rtx_code code,
 		 tmode != GET_MODE (op0); tmode = GET_MODE_WIDER_MODE (tmode))
 	      if ((unsigned HOST_WIDE_INT) c0 == GET_MODE_MASK (tmode))
 		{
-		  op0 = gen_lowpart (tmode, inner_op0);
-		  op1 = gen_lowpart (tmode, inner_op1);
+		  op0 = gen_lowpart_or_truncate (tmode, inner_op0);
+		  op1 = gen_lowpart_or_truncate (tmode, inner_op1);
 		  code = unsigned_condition (code);
 		  changed = 1;
 		  break;
Index: a/src/gcc/testsuite/gcc.c-torture/execute/20110418-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/20110418-1.c	(revision 0)
+++ a/src/gcc/testsuite/gcc.c-torture/execute/20110418-1.c	(revision 0)
@@ -0,0 +1,29 @@
+typedef unsigned long long uint64_t;
+void f(uint64_t *a, uint64_t aa) __attribute__((noinline));
+void f(uint64_t *a, uint64_t aa)
+{
+  uint64_t new_value = aa;
+  uint64_t old_value = *a;
+  int bit_size = 32;
+    uint64_t mask = (uint64_t)(unsigned)(-1);
+    uint64_t tmp = old_value & mask;
+    new_value &= mask;
+    /* On overflow we need to add 1 in the upper bits */
+    if (tmp > new_value)
+        new_value += 1ull<<bit_size;
+    /* Add in the upper bits from the old value */
+    new_value += old_value & ~mask;
+    *a = new_value;
+}
+int main(void)
+{
+  uint64_t value, new_value, old_value;
+  value = 0x100000001;
+  old_value = value;
+  new_value = (value+1)&(uint64_t)(unsigned)(-1);
+  f(&value, new_value);
+  if (value != old_value+1)
+    __builtin_abort ();
+  return 0;
+}
+
