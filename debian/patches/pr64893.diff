# DP: Proposed fix for PR target/64893 (AArch64)

commit 455a54f36a205af281b3fe8dbc97916ede704ca8
Author: Andrew Pinski <apinski@cavium.com>
Date:   Mon Feb 2 18:40:08 2015 +0000

    Fix bug 64893: ICE with vget_lane_u32 with C++ front-end
    
    	PR target/64893
            * config/aarch64/aarch64-builtins.c (aarch64_init_simd_builtins):
            Change the first argument type to size_type_node and add another
            size_type_node.
            (aarch64_simd_expand_builtin): Handle the new argument to
            AARCH64_SIMD_BUILTIN_LANE_CHECK and don't ICE but rather
            print sorry out when the first two arguments are not
            integer constants.
            * config/aarch64/arm_neon.h (__AARCH64_LANE_CHECK):
            Pass the sizeof directly to __builtin_aarch64_im_lane_boundsi.
            * testsuite/c-c++-common/torture/aarch64-vect-lane-1.c: New testcase.

--- a/src/gcc/config/aarch64/aarch64-builtins.c
+++ b/src/gcc/config/aarch64/aarch64-builtins.c
@@ -712,7 +712,8 @@ aarch64_init_simd_builtins (void)
   aarch64_init_simd_builtin_scalar_types ();
  
   tree lane_check_fpr = build_function_type_list (void_type_node,
-						  intSI_type_node,
+						  size_type_node,
+						  size_type_node,
 						  intSI_type_node,
 						  NULL);
   aarch64_builtin_decls[AARCH64_SIMD_BUILTIN_LANE_CHECK] =
@@ -1001,13 +1002,18 @@ aarch64_simd_expand_builtin (int fcode, tree exp, rtx target)
 {
   if (fcode == AARCH64_SIMD_BUILTIN_LANE_CHECK)
     {
-      tree nlanes = CALL_EXPR_ARG (exp, 0);
-      gcc_assert (TREE_CODE (nlanes) == INTEGER_CST);
-      rtx lane_idx = expand_normal (CALL_EXPR_ARG (exp, 1));
-      if (CONST_INT_P (lane_idx))
-	aarch64_simd_lane_bounds (lane_idx, 0, TREE_INT_CST_LOW (nlanes), exp);
+      rtx totalsize = expand_normal (CALL_EXPR_ARG (exp, 0));
+      rtx elementsize = expand_normal (CALL_EXPR_ARG (exp, 1));
+      if (CONST_INT_P (totalsize) && CONST_INT_P (elementsize))
+	{
+	  rtx lane_idx = expand_normal (CALL_EXPR_ARG (exp, 2));
+          if (CONST_INT_P (lane_idx))
+	    aarch64_simd_lane_bounds (lane_idx, 0, UINTVAL (totalsize)/UINTVAL (elementsize), exp);
+          else
+	    error ("%Klane index must be a constant immediate", exp);
+	}
       else
-	error ("%Klane index must be a constant immediate", exp);
+	sorry ("%Ktotal size and element size must be a constant immediate", exp);
       /* Don't generate any RTL.  */
       return const0_rtx;
     }
--- a/src/gcc/config/aarch64/arm_neon.h
+++ b/src/gcc/config/aarch64/arm_neon.h
@@ -541,7 +541,7 @@ typedef struct poly16x8x4_t
 
 #define __AARCH64_NUM_LANES(__v) (sizeof (__v) / sizeof (__v[0]))
 #define __AARCH64_LANE_CHECK(__vec, __idx)	\
-	__builtin_aarch64_im_lane_boundsi (__AARCH64_NUM_LANES (__vec), __idx)
+	__builtin_aarch64_im_lane_boundsi (sizeof(__vec), sizeof(__vec[0]), __idx)
 
 /* For big-endian, GCC's vector indices are the opposite way around
    to the architectural lane indices used by Neon intrinsics.  */
--- /dev/null
+++ b/src/gcc/testsuite/c-c++-common/torture/aarch64-vect-lane-1.c
@@ -0,0 +1,8 @@
+// { dg-do compile { target "aarch64*-*-*" } }
+#include <arm_neon.h>
+int
+search_line_fast (uint32x2_t t)
+{
+  return vget_lane_u32 (t, 0);
+}
+
