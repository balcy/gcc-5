# DP: Fix PR libstdc++/65913, taken from the trunk.

gcc/

2015-09-17  Richard Henderson  <rth@redhat.com>

	PR libstdc++/65913
	* builtins.c (fold_builtin_atomic_always_lock_free): Handle fake
	pointers that encode the alignment of the object.

libstdc++-v3/

2015-09-17  Jonathan Wakely  <jwakely@redhat.com>

	PR libstdc++/65913
	* include/bits/atomic_base.h (__atomic_base<_TTp>::is_lock_free(),
	__atomic_base<_PTp*>::is_lock_free()): Call the built-in with the
	immediate pointer value, not a variable.
	* include/std/atomic (atomic<T>::is_lock_free()): Likewise.
	* testsuite/29_atomics/atomic/65913.cc: New.

--- a/src/libstdc++-v3/include/std/atomic
+++ b/src/libstdc++-v3/include/std/atomic
@@ -208,8 +208,8 @@
       is_lock_free() const noexcept
       {
 	// Produce a fake, minimally aligned pointer.
-	void *__a = reinterpret_cast<void *>(-__alignof(_M_i));
-	return __atomic_is_lock_free(sizeof(_M_i), __a);
+	return __atomic_is_lock_free(sizeof(_M_i),
+	    reinterpret_cast<void *>(-__alignof(_M_i)));
       }
 
       bool
@@ -216,8 +216,8 @@
       is_lock_free() const volatile noexcept
       {
 	// Produce a fake, minimally aligned pointer.
-	void *__a = reinterpret_cast<void *>(-__alignof(_M_i));
-	return __atomic_is_lock_free(sizeof(_M_i), __a);
+	return __atomic_is_lock_free(sizeof(_M_i),
+	    reinterpret_cast<void *>(-__alignof(_M_i)));
       }
 
       void
--- a/src/libstdc++-v3/include/bits/atomic_base.h
+++ b/src/libstdc++-v3/include/bits/atomic_base.h
@@ -350,17 +350,17 @@
       bool
       is_lock_free() const noexcept
       {
-	// Produce a fake, minimally aligned pointer.
-	void *__a = reinterpret_cast<void *>(-__alignof(_M_i));
-	return __atomic_is_lock_free(sizeof(_M_i), __a);
+	// Use a fake, minimally aligned pointer.
+	return __atomic_is_lock_free(sizeof(_M_i),
+	    reinterpret_cast<void *>(-__alignof(_M_i)));
       }
 
       bool
       is_lock_free() const volatile noexcept
       {
-	// Produce a fake, minimally aligned pointer.
-	void *__a = reinterpret_cast<void *>(-__alignof(_M_i));
-	return __atomic_is_lock_free(sizeof(_M_i), __a);
+	// Use a fake, minimally aligned pointer.
+	return __atomic_is_lock_free(sizeof(_M_i),
+	    reinterpret_cast<void *>(-__alignof(_M_i)));
       }
 
       _GLIBCXX_ALWAYS_INLINE void
@@ -666,8 +666,8 @@
       is_lock_free() const noexcept
       {
 	// Produce a fake, minimally aligned pointer.
-	void *__a = reinterpret_cast<void *>(-__alignof(_M_p));
-	return __atomic_is_lock_free(sizeof(_M_p), __a);
+	return __atomic_is_lock_free(sizeof(_M_p),
+	    reinterpret_cast<void *>(-__alignof(_M_p)));
       }
 
       bool
@@ -674,8 +674,8 @@
       is_lock_free() const volatile noexcept
       {
 	// Produce a fake, minimally aligned pointer.
-	void *__a = reinterpret_cast<void *>(-__alignof(_M_p));
-	return __atomic_is_lock_free(sizeof(_M_p), __a);
+	return __atomic_is_lock_free(sizeof(_M_p),
+	    reinterpret_cast<void *>(-__alignof(_M_p)));
       }
 
       _GLIBCXX_ALWAYS_INLINE void
--- a/src/libstdc++-v3/testsuite/29_atomics/atomic/65913.cc
+++ b/src/libstdc++-v3/testsuite/29_atomics/atomic/65913.cc
@@ -0,0 +1,39 @@
+// Copyright (C) 2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target x86_64-*-linux* powerpc*-*-linux* } }
+// { dg-options "-std=gnu++11 -O0" }
+
+#include <atomic>
+#include <testsuite_hooks.h>
+
+// PR libstdc++/65913
+
+void
+test01()
+{
+  struct Int { int i; };
+  VERIFY( std::atomic<Int>{}.is_lock_free() );
+  VERIFY( std::atomic<int>{}.is_lock_free() );
+  VERIFY( std::atomic<int*>{}.is_lock_free() );
+}
+
+int
+main()
+{
+  test01();
+}
--- a/src/gcc/builtins.c
+++ b/src/gcc/builtins.c
@@ -5635,8 +5635,20 @@
   mode = mode_for_size (size, MODE_INT, 0);
   mode_align = GET_MODE_ALIGNMENT (mode);
 
-  if (TREE_CODE (arg1) == INTEGER_CST && INTVAL (expand_normal (arg1)) == 0)
-    type_align = mode_align;
+  if (TREE_CODE (arg1) == INTEGER_CST)
+    {
+      unsigned HOST_WIDE_INT val = UINTVAL (expand_normal (arg1));
+
+      /* Either this argument is null, or it's a fake pointer encoding
+         the alignment of the object.  */
+      val = val & -val;
+      val *= BITS_PER_UNIT;
+
+      if (val == 0 || mode_align < val)
+        type_align = mode_align;
+      else
+        type_align = val;
+    }
   else
     {
       tree ttype = TREE_TYPE (arg1);
